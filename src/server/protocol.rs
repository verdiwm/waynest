#![allow(unused)]
#![allow(async_fn_in_trait)]
pub mod wayland {
    pub mod wl_display {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidObject = 0u32,
            InvalidMethod = 1u32,
            NoMemory = 2u32,
            Implementation = 3u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "The core global object.  This is a special singleton object.  It"]
        #[doc = "is used for internal Wayland protocol features."]
        pub trait WlDisplay: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_display";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_display#{}.sync()", object.id);
                        self.sync(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("wl_display#{}.get_registry()", object.id);
                        self.get_registry(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "The sync request asks the server to emit the 'done' event"]
            #[doc = "on the returned wl_callback object.  Since requests are"]
            #[doc = "handled in-order and events are delivered in-order, this can"]
            #[doc = "be used as a barrier to ensure all previous requests and the"]
            #[doc = "resulting events have been handled."]
            #[doc = ""]
            #[doc = "The object returned by this request will be destroyed by the"]
            #[doc = "compositor after the callback is fired and as such the client must not"]
            #[doc = "attempt to use it after that point."]
            #[doc = ""]
            #[doc = "The callback_data passed in the callback is undefined and should be ignored."]
            async fn sync(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                callback: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This request creates a registry object that allows the client"]
            #[doc = "to list and bind the global objects available from the"]
            #[doc = "compositor."]
            #[doc = ""]
            #[doc = "It should be noted that the server side resources consumed in"]
            #[doc = "response to a get_registry request can only be released when the"]
            #[doc = "client disconnects, not when the client side proxy is destroyed."]
            #[doc = "Therefore, clients should invoke get_registry as infrequently as"]
            #[doc = "possible to avoid wasting memory."]
            async fn get_registry(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                registry: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "The error event is sent out when a fatal (non-recoverable)"]
            #[doc = "error has occurred.  The object_id argument is the object"]
            #[doc = "where the error occurred, most often in response to a request"]
            #[doc = "to that object.  The code identifies the error and is defined"]
            #[doc = "by the object interface.  As such, each interface defines its"]
            #[doc = "own set of error codes.  The message is a brief description"]
            #[doc = "of the error, for (debugging) convenience."]
            async fn error(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is used internally by the object ID management"]
            #[doc = "logic. When a client deletes an object that it had created,"]
            #[doc = "the server will send this event to acknowledge that it has"]
            #[doc = "seen the delete request. When the client receives this event,"]
            #[doc = "it will know that it can safely reuse the object ID."]
            async fn delete_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod wl_registry {
        #[doc = "The singleton global registry object.  The server has a number of"]
        #[doc = "global objects that are available to all clients.  These objects"]
        #[doc = "typically represent an actual object in the server (for example,"]
        #[doc = "an input device) or they are singleton objects that provide"]
        #[doc = "extension functionality."]
        #[doc = ""]
        #[doc = "When a client creates a registry object, the registry object"]
        #[doc = "will emit a global event for each global currently in the"]
        #[doc = "registry.  Globals come and go as a result of device or"]
        #[doc = "monitor hotplugs, reconfiguration or other events, and the"]
        #[doc = "registry will send out global and global_remove events to"]
        #[doc = "keep the client up to date with the changes.  To mark the end"]
        #[doc = "of the initial burst of events, the client can use the"]
        #[doc = "wl_display.sync request immediately after calling"]
        #[doc = "wl_display.get_registry."]
        #[doc = ""]
        #[doc = "A client can bind to a global object by using the bind"]
        #[doc = "request.  This creates a client-side handle that lets the object"]
        #[doc = "emit events to the client and lets the client invoke requests on"]
        #[doc = "the object."]
        pub trait WlRegistry: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_registry";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_registry#{}.bind()", object.id);
                        self.bind(object, client, message.uint()?, message.new_id()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Binds a new, client-created object to the server using the"]
            #[doc = "specified name as the identifier."]
            async fn bind(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: u32,
                id: crate::wire::NewId,
            ) -> crate::server::Result<()>;
            #[doc = "Notify the client of global objects."]
            #[doc = ""]
            #[doc = "The event notifies the client that a global object with"]
            #[doc = "the given name is now available, and it implements the"]
            #[doc = "given version of the given interface."]
            async fn global(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notify the client of removed global objects."]
            #[doc = ""]
            #[doc = "This event notifies the client that the global identified"]
            #[doc = "by name is no longer available.  If the client bound to"]
            #[doc = "the global using the bind request, the client should now"]
            #[doc = "destroy that object."]
            #[doc = ""]
            #[doc = "The object remains valid and requests to the object will be"]
            #[doc = "ignored until the client destroys it, to avoid races between"]
            #[doc = "the global going away and a client sending a request to it."]
            async fn global_remove(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod wl_callback {
        #[doc = "Clients can handle the 'done' event to get notified when"]
        #[doc = "the related request is done."]
        #[doc = ""]
        #[doc = "Note, because wl_callback objects are created from multiple independent"]
        #[doc = "factory interfaces, the wl_callback interface is frozen at version 1."]
        pub trait WlCallback: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_callback";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Notify the client when the related request is done."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod wl_compositor {
        #[doc = "A compositor.  This object is a singleton global.  The"]
        #[doc = "compositor is in charge of combining the contents of multiple"]
        #[doc = "surfaces into one displayable output."]
        pub trait WlCompositor: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_compositor";
            const VERSION: u32 = 6u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_compositor#{}.create_surface()", object.id);
                        self.create_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("wl_compositor#{}.create_region()", object.id);
                        self.create_region(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Ask the compositor to create a new surface."]
            async fn create_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Ask the compositor to create a new region."]
            async fn create_region(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wl_shm_pool {
        #[doc = "The wl_shm_pool object encapsulates a piece of memory shared"]
        #[doc = "between the compositor and client.  Through the wl_shm_pool"]
        #[doc = "object, the client can allocate shared memory wl_buffer objects."]
        #[doc = "All objects created through the same pool share the same"]
        #[doc = "underlying mapped memory. Reusing the mapped memory avoids the"]
        #[doc = "setup/teardown overhead and is useful when interactively resizing"]
        #[doc = "a surface or for many small buffers."]
        pub trait WlShmPool: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_shm_pool";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_shm_pool#{}.create_buffer()", object.id);
                        self.create_buffer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("wl_shm_pool#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    2u16 => {
                        tracing::debug!("wl_shm_pool#{}.resize()", object.id);
                        self.resize(object, client, message.int()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a wl_buffer object from the pool."]
            #[doc = ""]
            #[doc = "The buffer is created offset bytes into the pool and has"]
            #[doc = "width and height as specified.  The stride argument specifies"]
            #[doc = "the number of bytes from the beginning of one row to the beginning"]
            #[doc = "of the next.  The format is the pixel format of the buffer and"]
            #[doc = "must be one of those advertised through the wl_shm.format event."]
            #[doc = ""]
            #[doc = "A buffer will keep a reference to the pool it was created from"]
            #[doc = "so it is valid to destroy the pool immediately after creating"]
            #[doc = "a buffer from it."]
            async fn create_buffer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                offset: i32,
                width: i32,
                height: i32,
                stride: i32,
                format: super::super::wayland::wl_shm::Format,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the shared memory pool."]
            #[doc = ""]
            #[doc = "The mmapped memory will be released when all"]
            #[doc = "buffers that have been created from this pool"]
            #[doc = "are gone."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This request will cause the server to remap the backing memory"]
            #[doc = "for the pool from the file descriptor passed when the pool was"]
            #[doc = "created, but using the new size.  This request can only be"]
            #[doc = "used to make the pool bigger."]
            #[doc = ""]
            #[doc = "This request only changes the amount of bytes that are mmapped"]
            #[doc = "by the server and does not touch the file corresponding to the"]
            #[doc = "file descriptor passed at creation time. It is the client's"]
            #[doc = "responsibility to ensure that the file is at least as big as"]
            #[doc = "the new pool size."]
            async fn resize(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                size: i32,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wl_shm {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidFormat = 0u32,
            InvalidStride = 1u32,
            InvalidFd = 2u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Format {
            Argb8888 = 0u32,
            Xrgb8888 = 1u32,
            C8 = 538982467u32,
            Rgb332 = 943867730u32,
            Bgr233 = 944916290u32,
            Xrgb4444 = 842093144u32,
            Xbgr4444 = 842089048u32,
            Rgbx4444 = 842094674u32,
            Bgrx4444 = 842094658u32,
            Argb4444 = 842093121u32,
            Abgr4444 = 842089025u32,
            Rgba4444 = 842088786u32,
            Bgra4444 = 842088770u32,
            Xrgb1555 = 892424792u32,
            Xbgr1555 = 892420696u32,
            Rgbx5551 = 892426322u32,
            Bgrx5551 = 892426306u32,
            Argb1555 = 892424769u32,
            Abgr1555 = 892420673u32,
            Rgba5551 = 892420434u32,
            Bgra5551 = 892420418u32,
            Rgb565 = 909199186u32,
            Bgr565 = 909199170u32,
            Rgb888 = 875710290u32,
            Bgr888 = 875710274u32,
            Xbgr8888 = 875709016u32,
            Rgbx8888 = 875714642u32,
            Bgrx8888 = 875714626u32,
            Abgr8888 = 875708993u32,
            Rgba8888 = 875708754u32,
            Bgra8888 = 875708738u32,
            Xrgb2101010 = 808669784u32,
            Xbgr2101010 = 808665688u32,
            Rgbx1010102 = 808671314u32,
            Bgrx1010102 = 808671298u32,
            Argb2101010 = 808669761u32,
            Abgr2101010 = 808665665u32,
            Rgba1010102 = 808665426u32,
            Bgra1010102 = 808665410u32,
            Yuyv = 1448695129u32,
            Yvyu = 1431918169u32,
            Uyvy = 1498831189u32,
            Vyuy = 1498765654u32,
            Ayuv = 1448433985u32,
            Nv12 = 842094158u32,
            Nv21 = 825382478u32,
            Nv16 = 909203022u32,
            Nv61 = 825644622u32,
            Yuv410 = 961959257u32,
            Yvu410 = 961893977u32,
            Yuv411 = 825316697u32,
            Yvu411 = 825316953u32,
            Yuv420 = 842093913u32,
            Yvu420 = 842094169u32,
            Yuv422 = 909202777u32,
            Yvu422 = 909203033u32,
            Yuv444 = 875713881u32,
            Yvu444 = 875714137u32,
            R8 = 538982482u32,
            R16 = 540422482u32,
            Rg88 = 943212370u32,
            Gr88 = 943215175u32,
            Rg1616 = 842221394u32,
            Gr1616 = 842224199u32,
            Xrgb16161616f = 1211388504u32,
            Xbgr16161616f = 1211384408u32,
            Argb16161616f = 1211388481u32,
            Abgr16161616f = 1211384385u32,
            Xyuv8888 = 1448434008u32,
            Vuy888 = 875713878u32,
            Vuy101010 = 808670550u32,
            Y210 = 808530521u32,
            Y212 = 842084953u32,
            Y216 = 909193817u32,
            Y410 = 808531033u32,
            Y412 = 842085465u32,
            Y416 = 909194329u32,
            Xvyu2101010 = 808670808u32,
            Xvyu1216161616 = 909334104u32,
            Xvyu16161616 = 942954072u32,
            Y0l0 = 810299481u32,
            X0l0 = 810299480u32,
            Y0l2 = 843853913u32,
            X0l2 = 843853912u32,
            Yuv4208bit = 942691673u32,
            Yuv42010bit = 808539481u32,
            Xrgb8888A8 = 943805016u32,
            Xbgr8888A8 = 943800920u32,
            Rgbx8888A8 = 943806546u32,
            Bgrx8888A8 = 943806530u32,
            Rgb888A8 = 943798354u32,
            Bgr888A8 = 943798338u32,
            Rgb565A8 = 943797586u32,
            Bgr565A8 = 943797570u32,
            Nv24 = 875714126u32,
            Nv42 = 842290766u32,
            P210 = 808530512u32,
            P010 = 808530000u32,
            P012 = 842084432u32,
            P016 = 909193296u32,
            Axbxgxrx106106106106 = 808534593u32,
            Nv15 = 892425806u32,
            Q410 = 808531025u32,
            Q401 = 825242705u32,
            Xrgb16161616 = 942953048u32,
            Xbgr16161616 = 942948952u32,
            Argb16161616 = 942953025u32,
            Abgr16161616 = 942948929u32,
            C1 = 538980675u32,
            C2 = 538980931u32,
            C4 = 538981443u32,
            D1 = 538980676u32,
            D2 = 538980932u32,
            D4 = 538981444u32,
            D8 = 538982468u32,
            R1 = 538980690u32,
            R2 = 538980946u32,
            R4 = 538981458u32,
            R10 = 540029266u32,
            R12 = 540160338u32,
            Avuy8888 = 1498764865u32,
            Xvuy8888 = 1498764888u32,
            P030 = 808661072u32,
        }
        impl TryFrom<u32> for Format {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "A singleton global object that provides support for shared"]
        #[doc = "memory."]
        #[doc = ""]
        #[doc = "Clients can create wl_shm_pool objects using the create_pool"]
        #[doc = "request."]
        #[doc = ""]
        #[doc = "On binding the wl_shm object one or more format events"]
        #[doc = "are emitted to inform clients about the valid pixel formats"]
        #[doc = "that can be used for buffers."]
        pub trait WlShm: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_shm";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_shm#{}.create_pool()", object.id);
                        self.create_pool(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.fd()?,
                            message.int()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("wl_shm#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a new wl_shm_pool object."]
            #[doc = ""]
            #[doc = "The pool can be used to create shared memory based buffer"]
            #[doc = "objects.  The server will mmap size bytes of the passed file"]
            #[doc = "descriptor, to use as backing memory for the pool."]
            async fn create_pool(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                fd: rustix::fd::OwnedFd,
                size: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Using this request a client can tell the server that it is not going to"]
            #[doc = "use the shm object anymore."]
            #[doc = ""]
            #[doc = "Objects created via this interface remain unaffected."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Informs the client about a valid pixel format that"]
            #[doc = "can be used for buffers. Known formats include"]
            #[doc = "argb8888 and xrgb8888."]
            async fn format(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod wl_buffer {
        #[doc = "A buffer provides the content for a wl_surface. Buffers are"]
        #[doc = "created through factory interfaces such as wl_shm, wp_linux_buffer_params"]
        #[doc = "(from the linux-dmabuf protocol extension) or similar. It has a width and"]
        #[doc = "a height and can be attached to a wl_surface, but the mechanism by which a"]
        #[doc = "client provides and updates the contents is defined by the buffer factory"]
        #[doc = "interface."]
        #[doc = ""]
        #[doc = "Color channels are assumed to be electrical rather than optical (in other"]
        #[doc = "words, encoded with a transfer function) unless otherwise specified. If"]
        #[doc = "the buffer uses a format that has an alpha channel, the alpha channel is"]
        #[doc = "assumed to be premultiplied into the electrical color channel values"]
        #[doc = "(after transfer function encoding) unless otherwise specified."]
        #[doc = ""]
        #[doc = "Note, because wl_buffer objects are created from multiple independent"]
        #[doc = "factory interfaces, the wl_buffer interface is frozen at version 1."]
        pub trait WlBuffer: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_buffer";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_buffer#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy a buffer. If and how you need to release the backing"]
            #[doc = "storage is defined by the buffer factory interface."]
            #[doc = ""]
            #[doc = "For possible side-effects to a surface, see wl_surface.attach."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sent when this wl_buffer is no longer used by the compositor."]
            #[doc = "The client is now free to reuse or destroy this buffer and its"]
            #[doc = "backing storage."]
            #[doc = ""]
            #[doc = "If a client receives a release event before the frame callback"]
            #[doc = "requested in the same wl_surface.commit that attaches this"]
            #[doc = "wl_buffer to a surface, then the client is immediately free to"]
            #[doc = "reuse the buffer and its backing storage, and does not need a"]
            #[doc = "second buffer for the next surface content update. Typically"]
            #[doc = "this is possible, when the compositor maintains a copy of the"]
            #[doc = "wl_surface contents, e.g. as a GL texture. This is an important"]
            #[doc = "optimization for GL(ES) compositors with wl_shm clients."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod wl_data_offer {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidFinish = 0u32,
            InvalidActionMask = 1u32,
            InvalidAction = 2u32,
            InvalidOffer = 3u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "A wl_data_offer represents a piece of data offered for transfer"]
        #[doc = "by another client (the source client).  It is used by the"]
        #[doc = "copy-and-paste and drag-and-drop mechanisms.  The offer"]
        #[doc = "describes the different mime types that the data can be"]
        #[doc = "converted to and provides the mechanism for transferring the"]
        #[doc = "data directly from the source client."]
        pub trait WlDataOffer: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_data_offer";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_data_offer#{}.accept()", object.id);
                        self.accept(object, client, message.uint()?, message.string()?)
                            .await
                    }
                    1u16 => {
                        tracing::debug!("wl_data_offer#{}.receive()", object.id);
                        self.receive(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.fd()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("wl_data_offer#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    3u16 => {
                        tracing::debug!("wl_data_offer#{}.finish()", object.id);
                        self.finish(object, client).await
                    }
                    4u16 => {
                        tracing::debug!("wl_data_offer#{}.set_actions()", object.id);
                        self.set_actions(
                            object,
                            client,
                            message.uint()?.try_into()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Indicate that the client can accept the given mime type, or"]
            #[doc = "NULL for not accepted."]
            #[doc = ""]
            #[doc = "For objects of version 2 or older, this request is used by the"]
            #[doc = "client to give feedback whether the client can receive the given"]
            #[doc = "mime type, or NULL if none is accepted; the feedback does not"]
            #[doc = "determine whether the drag-and-drop operation succeeds or not."]
            #[doc = ""]
            #[doc = "For objects of version 3 or newer, this request determines the"]
            #[doc = "final result of the drag-and-drop operation. If the end result"]
            #[doc = "is that no mime types were accepted, the drag-and-drop operation"]
            #[doc = "will be cancelled and the corresponding drag source will receive"]
            #[doc = "wl_data_source.cancelled. Clients may still use this event in"]
            #[doc = "conjunction with wl_data_source.action for feedback."]
            async fn accept(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                mime_type: Option<String>,
            ) -> crate::server::Result<()>;
            #[doc = "To transfer the offered data, the client issues this request"]
            #[doc = "and indicates the mime type it wants to receive.  The transfer"]
            #[doc = "happens through the passed file descriptor (typically created"]
            #[doc = "with the pipe system call).  The source client writes the data"]
            #[doc = "in the mime type representation requested and then closes the"]
            #[doc = "file descriptor."]
            #[doc = ""]
            #[doc = "The receiving client reads from the read end of the pipe until"]
            #[doc = "EOF and then closes its end, at which point the transfer is"]
            #[doc = "complete."]
            #[doc = ""]
            #[doc = "This request may happen multiple times for different mime types,"]
            #[doc = "both before and after wl_data_device.drop. Drag-and-drop destination"]
            #[doc = "clients may preemptively fetch data or examine it more closely to"]
            #[doc = "determine acceptance."]
            async fn receive(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
                fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the data offer."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Notifies the compositor that the drag destination successfully"]
            #[doc = "finished the drag-and-drop operation."]
            #[doc = ""]
            #[doc = "Upon receiving this request, the compositor will emit"]
            #[doc = "wl_data_source.dnd_finished on the drag source client."]
            #[doc = ""]
            #[doc = "It is a client error to perform other requests than"]
            #[doc = "wl_data_offer.destroy after this one. It is also an error to perform"]
            #[doc = "this request after a NULL mime type has been set in"]
            #[doc = "wl_data_offer.accept or no action was received through"]
            #[doc = "wl_data_offer.action."]
            #[doc = ""]
            #[doc = "If wl_data_offer.finish request is received for a non drag and drop"]
            #[doc = "operation, the invalid_finish protocol error is raised."]
            async fn finish(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the actions that the destination side client supports for"]
            #[doc = "this operation. This request may trigger the emission of"]
            #[doc = "wl_data_source.action and wl_data_offer.action events if the compositor"]
            #[doc = "needs to change the selected action."]
            #[doc = ""]
            #[doc = "This request can be called multiple times throughout the"]
            #[doc = "drag-and-drop operation, typically in response to wl_data_device.enter"]
            #[doc = "or wl_data_device.motion events."]
            #[doc = ""]
            #[doc = "This request determines the final result of the drag-and-drop"]
            #[doc = "operation. If the end result is that no action is accepted,"]
            #[doc = "the drag source will receive wl_data_source.cancelled."]
            #[doc = ""]
            #[doc = "The dnd_actions argument must contain only values expressed in the"]
            #[doc = "wl_data_device_manager.dnd_actions enum, and the preferred_action"]
            #[doc = "argument must only contain one of those values set, otherwise it"]
            #[doc = "will result in a protocol error."]
            #[doc = ""]
            #[doc = "While managing an \"ask\" action, the destination drag-and-drop client"]
            #[doc = "may perform further wl_data_offer.receive requests, and is expected"]
            #[doc = "to perform one last wl_data_offer.set_actions request with a preferred"]
            #[doc = "action other than \"ask\" (and optionally wl_data_offer.accept) before"]
            #[doc = "requesting wl_data_offer.finish, in order to convey the action selected"]
            #[doc = "by the user. If the preferred action is not in the"]
            #[doc = "wl_data_offer.source_actions mask, an error will be raised."]
            #[doc = ""]
            #[doc = "If the \"ask\" action is dismissed (e.g. user cancellation), the client"]
            #[doc = "is expected to perform wl_data_offer.destroy right away."]
            #[doc = ""]
            #[doc = "This request can only be made on drag-and-drop offers, a protocol error"]
            #[doc = "will be raised otherwise."]
            async fn set_actions(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                dnd_actions: super::super::wayland::wl_data_device_manager::DndAction,
                preferred_action: super::super::wayland::wl_data_device_manager::DndAction,
            ) -> crate::server::Result<()>;
            #[doc = "Sent immediately after creating the wl_data_offer object.  One"]
            #[doc = "event per offered mime type."]
            async fn offer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event indicates the actions offered by the data source. It"]
            #[doc = "will be sent immediately after creating the wl_data_offer object,"]
            #[doc = "or anytime the source side changes its offered actions through"]
            #[doc = "wl_data_source.set_actions."]
            async fn source_actions(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event indicates the action selected by the compositor after"]
            #[doc = "matching the source/destination side actions. Only one action (or"]
            #[doc = "none) will be offered here."]
            #[doc = ""]
            #[doc = "This event can be emitted multiple times during the drag-and-drop"]
            #[doc = "operation in response to destination side action changes through"]
            #[doc = "wl_data_offer.set_actions."]
            #[doc = ""]
            #[doc = "This event will no longer be emitted after wl_data_device.drop"]
            #[doc = "happened on the drag-and-drop destination, the client must"]
            #[doc = "honor the last action received, or the last preferred one set"]
            #[doc = "through wl_data_offer.set_actions when handling an \"ask\" action."]
            #[doc = ""]
            #[doc = "Compositors may also change the selected action on the fly, mainly"]
            #[doc = "in response to keyboard modifier changes during the drag-and-drop"]
            #[doc = "operation."]
            #[doc = ""]
            #[doc = "The most recent action received is always the valid one. Prior to"]
            #[doc = "receiving wl_data_device.drop, the chosen action may change (e.g."]
            #[doc = "due to keyboard modifiers being pressed). At the time of receiving"]
            #[doc = "wl_data_device.drop the drag-and-drop destination must honor the"]
            #[doc = "last action received."]
            #[doc = ""]
            #[doc = "Action changes may still happen after wl_data_device.drop,"]
            #[doc = "especially on \"ask\" actions, where the drag-and-drop destination"]
            #[doc = "may choose another action afterwards. Action changes happening"]
            #[doc = "at this stage are always the result of inter-client negotiation, the"]
            #[doc = "compositor shall no longer be able to induce a different action."]
            #[doc = ""]
            #[doc = "Upon \"ask\" actions, it is expected that the drag-and-drop destination"]
            #[doc = "may potentially choose a different action and/or mime type,"]
            #[doc = "based on wl_data_offer.source_actions and finally chosen by the"]
            #[doc = "user (e.g. popping up a menu with the available options). The"]
            #[doc = "final wl_data_offer.set_actions and wl_data_offer.accept requests"]
            #[doc = "must happen before the call to wl_data_offer.finish."]
            async fn action(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod wl_data_source {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidActionMask = 0u32,
            InvalidSource = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "The wl_data_source object is the source side of a wl_data_offer."]
        #[doc = "It is created by the source client in a data transfer and"]
        #[doc = "provides a way to describe the offered data and a way to respond"]
        #[doc = "to requests to transfer the data."]
        pub trait WlDataSource: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_data_source";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_data_source#{}.offer()", object.id);
                        self.offer(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("wl_data_source#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    2u16 => {
                        tracing::debug!("wl_data_source#{}.set_actions()", object.id);
                        self.set_actions(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request adds a mime type to the set of mime types"]
            #[doc = "advertised to targets.  Can be called several times to offer"]
            #[doc = "multiple types."]
            async fn offer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the data source."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the actions that the source side client supports for this"]
            #[doc = "operation. This request may trigger wl_data_source.action and"]
            #[doc = "wl_data_offer.action events if the compositor needs to change the"]
            #[doc = "selected action."]
            #[doc = ""]
            #[doc = "The dnd_actions argument must contain only values expressed in the"]
            #[doc = "wl_data_device_manager.dnd_actions enum, otherwise it will result"]
            #[doc = "in a protocol error."]
            #[doc = ""]
            #[doc = "This request must be made once only, and can only be made on sources"]
            #[doc = "used in drag-and-drop, so it must be performed before"]
            #[doc = "wl_data_device.start_drag. Attempting to use the source other than"]
            #[doc = "for drag-and-drop will raise a protocol error."]
            async fn set_actions(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                dnd_actions: super::super::wayland::wl_data_device_manager::DndAction,
            ) -> crate::server::Result<()>;
            #[doc = "Sent when a target accepts pointer_focus or motion events.  If"]
            #[doc = "a target does not accept any of the offered types, type is NULL."]
            #[doc = ""]
            #[doc = "Used for feedback during drag-and-drop."]
            async fn target(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Request for data from the client.  Send the data as the"]
            #[doc = "specified mime type over the passed file descriptor, then"]
            #[doc = "close it."]
            async fn send(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This data source is no longer valid. There are several reasons why"]
            #[doc = "this could happen:"]
            #[doc = ""]
            #[doc = "- The data source has been replaced by another data source."]
            #[doc = "- The drag-and-drop operation was performed, but the drop destination"]
            #[doc = "did not accept any of the mime types offered through"]
            #[doc = "wl_data_source.target."]
            #[doc = "- The drag-and-drop operation was performed, but the drop destination"]
            #[doc = "did not select any of the actions present in the mask offered through"]
            #[doc = "wl_data_source.action."]
            #[doc = "- The drag-and-drop operation was performed but didn't happen over a"]
            #[doc = "surface."]
            #[doc = "- The compositor cancelled the drag-and-drop operation (e.g. compositor"]
            #[doc = "dependent timeouts to avoid stale drag-and-drop transfers)."]
            #[doc = ""]
            #[doc = "The client should clean up and destroy this data source."]
            #[doc = ""]
            #[doc = "For objects of version 2 or older, wl_data_source.cancelled will"]
            #[doc = "only be emitted if the data source was replaced by another data"]
            #[doc = "source."]
            async fn cancelled(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The user performed the drop action. This event does not indicate"]
            #[doc = "acceptance, wl_data_source.cancelled may still be emitted afterwards"]
            #[doc = "if the drop destination does not accept any mime type."]
            #[doc = ""]
            #[doc = "However, this event might however not be received if the compositor"]
            #[doc = "cancelled the drag-and-drop operation before this event could happen."]
            #[doc = ""]
            #[doc = "Note that the data_source may still be used in the future and should"]
            #[doc = "not be destroyed here."]
            async fn dnd_drop_performed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The drop destination finished interoperating with this data"]
            #[doc = "source, so the client is now free to destroy this data source and"]
            #[doc = "free all associated data."]
            #[doc = ""]
            #[doc = "If the action used to perform the operation was \"move\", the"]
            #[doc = "source can now delete the transferred data."]
            async fn dnd_finished(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event indicates the action selected by the compositor after"]
            #[doc = "matching the source/destination side actions. Only one action (or"]
            #[doc = "none) will be offered here."]
            #[doc = ""]
            #[doc = "This event can be emitted multiple times during the drag-and-drop"]
            #[doc = "operation, mainly in response to destination side changes through"]
            #[doc = "wl_data_offer.set_actions, and as the data device enters/leaves"]
            #[doc = "surfaces."]
            #[doc = ""]
            #[doc = "It is only possible to receive this event after"]
            #[doc = "wl_data_source.dnd_drop_performed if the drag-and-drop operation"]
            #[doc = "ended in an \"ask\" action, in which case the final wl_data_source.action"]
            #[doc = "event will happen immediately before wl_data_source.dnd_finished."]
            #[doc = ""]
            #[doc = "Compositors may also change the selected action on the fly, mainly"]
            #[doc = "in response to keyboard modifier changes during the drag-and-drop"]
            #[doc = "operation."]
            #[doc = ""]
            #[doc = "The most recent action received is always the valid one. The chosen"]
            #[doc = "action may change alongside negotiation (e.g. an \"ask\" action can turn"]
            #[doc = "into a \"move\" operation), so the effects of the final action must"]
            #[doc = "always be applied in wl_data_offer.dnd_finished."]
            #[doc = ""]
            #[doc = "Clients can trigger cursor surface changes from this point, so"]
            #[doc = "they reflect the current action."]
            async fn action(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod wl_data_device {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            Role = 0u32,
            UsedSource = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "There is one wl_data_device per seat which can be obtained"]
        #[doc = "from the global wl_data_device_manager singleton."]
        #[doc = ""]
        #[doc = "A wl_data_device provides access to inter-client data transfer"]
        #[doc = "mechanisms such as copy-and-paste and drag-and-drop."]
        pub trait WlDataDevice: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_data_device";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_data_device#{}.start_drag()", object.id);
                        self.start_drag(
                            object,
                            client,
                            message.object()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.object()?,
                            message.uint()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("wl_data_device#{}.set_selection()", object.id);
                        self.set_selection(object, client, message.object()?, message.uint()?)
                            .await
                    }
                    2u16 => {
                        tracing::debug!("wl_data_device#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request asks the compositor to start a drag-and-drop"]
            #[doc = "operation on behalf of the client."]
            #[doc = ""]
            #[doc = "The source argument is the data source that provides the data"]
            #[doc = "for the eventual data transfer. If source is NULL, enter, leave"]
            #[doc = "and motion events are sent only to the client that initiated the"]
            #[doc = "drag and the client is expected to handle the data passing"]
            #[doc = "internally. If source is destroyed, the drag-and-drop session will be"]
            #[doc = "cancelled."]
            #[doc = ""]
            #[doc = "The origin surface is the surface where the drag originates and"]
            #[doc = "the client must have an active implicit grab that matches the"]
            #[doc = "serial."]
            #[doc = ""]
            #[doc = "The icon surface is an optional (can be NULL) surface that"]
            #[doc = "provides an icon to be moved around with the cursor.  Initially,"]
            #[doc = "the top-left corner of the icon surface is placed at the cursor"]
            #[doc = "hotspot, but subsequent wl_surface.offset requests can move the"]
            #[doc = "relative position. Attach requests must be confirmed with"]
            #[doc = "wl_surface.commit as usual. The icon surface is given the role of"]
            #[doc = "a drag-and-drop icon. If the icon surface already has another role,"]
            #[doc = "it raises a protocol error."]
            #[doc = ""]
            #[doc = "The input region is ignored for wl_surfaces with the role of a"]
            #[doc = "drag-and-drop icon."]
            #[doc = ""]
            #[doc = "The given source may not be used in any further set_selection or"]
            #[doc = "start_drag requests. Attempting to reuse a previously-used source"]
            #[doc = "may send a used_source error."]
            async fn start_drag(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: Option<crate::wire::ObjectId>,
                origin: crate::wire::ObjectId,
                icon: Option<crate::wire::ObjectId>,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This request asks the compositor to set the selection"]
            #[doc = "to the data from the source on behalf of the client."]
            #[doc = ""]
            #[doc = "To unset the selection, set the source to NULL."]
            #[doc = ""]
            #[doc = "The given source may not be used in any further set_selection or"]
            #[doc = "start_drag requests. Attempting to reuse a previously-used source"]
            #[doc = "may send a used_source error."]
            async fn set_selection(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: Option<crate::wire::ObjectId>,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This request destroys the data device."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The data_offer event introduces a new wl_data_offer object,"]
            #[doc = "which will subsequently be used in either the"]
            #[doc = "data_device.enter event (for drag-and-drop) or the"]
            #[doc = "data_device.selection event (for selections).  Immediately"]
            #[doc = "following the data_device.data_offer event, the new data_offer"]
            #[doc = "object will send out data_offer.offer events to describe the"]
            #[doc = "mime types it offers."]
            async fn data_offer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent when an active drag-and-drop pointer enters"]
            #[doc = "a surface owned by the client.  The position of the pointer at"]
            #[doc = "enter time is provided by the x and y arguments, in surface-local"]
            #[doc = "coordinates."]
            async fn enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent when the drag-and-drop pointer leaves the"]
            #[doc = "surface and the session ends.  The client must destroy the"]
            #[doc = "wl_data_offer introduced at enter time at this point."]
            async fn leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent when the drag-and-drop pointer moves within"]
            #[doc = "the currently focused surface. The new position of the pointer"]
            #[doc = "is provided by the x and y arguments, in surface-local"]
            #[doc = "coordinates."]
            async fn motion(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The event is sent when a drag-and-drop operation is ended"]
            #[doc = "because the implicit grab is removed."]
            #[doc = ""]
            #[doc = "The drag-and-drop destination is expected to honor the last action"]
            #[doc = "received through wl_data_offer.action, if the resulting action is"]
            #[doc = "\"copy\" or \"move\", the destination can still perform"]
            #[doc = "wl_data_offer.receive requests, and is expected to end all"]
            #[doc = "transfers with a wl_data_offer.finish request."]
            #[doc = ""]
            #[doc = "If the resulting action is \"ask\", the action will not be considered"]
            #[doc = "final. The drag-and-drop destination is expected to perform one last"]
            #[doc = "wl_data_offer.set_actions request, or wl_data_offer.destroy in order"]
            #[doc = "to cancel the operation."]
            async fn drop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The selection event is sent out to notify the client of a new"]
            #[doc = "wl_data_offer for the selection for this device.  The"]
            #[doc = "data_device.data_offer and the data_offer.offer events are"]
            #[doc = "sent out immediately before this event to introduce the data"]
            #[doc = "offer object.  The selection event is sent to a client"]
            #[doc = "immediately before receiving keyboard focus and when a new"]
            #[doc = "selection is set while the client has keyboard focus.  The"]
            #[doc = "data_offer is valid until a new data_offer or NULL is received"]
            #[doc = "or until the client loses keyboard focus.  Switching surface with"]
            #[doc = "keyboard focus within the same client doesn't mean a new selection"]
            #[doc = "will be sent.  The client must destroy the previous selection"]
            #[doc = "data_offer, if any, upon receiving this event."]
            async fn selection(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod wl_data_device_manager {
        bitflags::bitflags! { # [doc = "This is a bitmask of the available/preferred actions in a"] # [doc = "drag-and-drop operation."] # [doc = ""] # [doc = "In the compositor, the selected action is a result of matching the"] # [doc = "actions offered by the source and destination sides.  \"action\" events"] # [doc = "with a \"none\" action will be sent to both source and destination if"] # [doc = "there is no match. All further checks will effectively happen on"] # [doc = "(source actions ∩ destination actions)."] # [doc = ""] # [doc = "In addition, compositors may also pick different actions in"] # [doc = "reaction to key modifiers being pressed. One common design that"] # [doc = "is used in major toolkits (and the behavior recommended for"] # [doc = "compositors) is:"] # [doc = ""] # [doc = "- If no modifiers are pressed, the first match (in bit order)"] # [doc = "will be used."] # [doc = "- Pressing Shift selects \"move\", if enabled in the mask."] # [doc = "- Pressing Control selects \"copy\", if enabled in the mask."] # [doc = ""] # [doc = "Behavior beyond that is considered implementation-dependent."] # [doc = "Compositors may for example bind other modifiers (like Alt/Meta)"] # [doc = "or drags initiated with other buttons than BTN_LEFT to specific"] # [doc = "actions (e.g. \"ask\")."] # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct DndAction : u32 { # [doc = "no action"] const None = 0u32 ; # [doc = "copy action"] const Copy = 1u32 ; # [doc = "move action"] const Move = 2u32 ; # [doc = "ask action"] const Ask = 4u32 ; } }
        impl TryFrom<u32> for DndAction {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "The wl_data_device_manager is a singleton global object that"]
        #[doc = "provides access to inter-client data transfer mechanisms such as"]
        #[doc = "copy-and-paste and drag-and-drop.  These mechanisms are tied to"]
        #[doc = "a wl_seat and this interface lets a client get a wl_data_device"]
        #[doc = "corresponding to a wl_seat."]
        #[doc = ""]
        #[doc = "Depending on the version bound, the objects created from the bound"]
        #[doc = "wl_data_device_manager object will have different requirements for"]
        #[doc = "functioning properly. See wl_data_source.set_actions,"]
        #[doc = "wl_data_offer.accept and wl_data_offer.finish for details."]
        pub trait WlDataDeviceManager: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_data_device_manager";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "wl_data_device_manager#{}.create_data_source()",
                            object.id
                        );
                        self.create_data_source(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("wl_data_device_manager#{}.get_data_device()", object.id);
                        self.get_data_device(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a new data source."]
            async fn create_data_source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Create a new data device for a given seat."]
            async fn get_data_device(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wl_shell {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            Role = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This interface is implemented by servers that provide"]
        #[doc = "desktop-style user interfaces."]
        #[doc = ""]
        #[doc = "It allows clients to associate a wl_shell_surface with"]
        #[doc = "a basic surface."]
        #[doc = ""]
        #[doc = "Note! This protocol is deprecated and not intended for production use."]
        #[doc = "For desktop-style user interfaces, use xdg_shell. Compositors and clients"]
        #[doc = "should not implement this interface."]
        pub trait WlShell: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_shell";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_shell#{}.get_shell_surface()", object.id);
                        self.get_shell_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a shell surface for an existing surface. This gives"]
            #[doc = "the wl_surface the role of a shell surface. If the wl_surface"]
            #[doc = "already has another role, it raises a protocol error."]
            #[doc = ""]
            #[doc = "Only one shell surface can be associated with a given surface."]
            async fn get_shell_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wl_shell_surface {
        bitflags::bitflags! { # [doc = "These values are used to indicate which edge of a surface"] # [doc = "is being dragged in a resize operation. The server may"] # [doc = "use this information to adapt its behavior, e.g. choose"] # [doc = "an appropriate cursor image."] # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Resize : u32 { # [doc = "no edge"] const None = 0u32 ; # [doc = "top edge"] const Top = 1u32 ; # [doc = "bottom edge"] const Bottom = 2u32 ; # [doc = "left edge"] const Left = 4u32 ; # [doc = "top and left edges"] const TopLeft = 5u32 ; # [doc = "bottom and left edges"] const BottomLeft = 6u32 ; # [doc = "right edge"] const Right = 8u32 ; # [doc = "top and right edges"] const TopRight = 9u32 ; # [doc = "bottom and right edges"] const BottomRight = 10u32 ; } }
        impl TryFrom<u32> for Resize {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        bitflags::bitflags! { # [doc = "These flags specify details of the expected behaviour"] # [doc = "of transient surfaces. Used in the set_transient request."] # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Transient : u32 { # [doc = "do not set keyboard focus"] const Inactive = 1u32 ; } }
        impl TryFrom<u32> for Transient {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum FullscreenMethod {
            Default = 0u32,
            Scale = 1u32,
            Driver = 2u32,
            Fill = 3u32,
        }
        impl TryFrom<u32> for FullscreenMethod {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "An interface that may be implemented by a wl_surface, for"]
        #[doc = "implementations that provide a desktop-style user interface."]
        #[doc = ""]
        #[doc = "It provides requests to treat surfaces like toplevel, fullscreen"]
        #[doc = "or popup windows, move, resize or maximize them, associate"]
        #[doc = "metadata like title and class, etc."]
        #[doc = ""]
        #[doc = "On the server side the object is automatically destroyed when"]
        #[doc = "the related wl_surface is destroyed. On the client side,"]
        #[doc = "wl_shell_surface_destroy() must be called before destroying"]
        #[doc = "the wl_surface object."]
        pub trait WlShellSurface: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_shell_surface";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_shell_surface#{}.pong()", object.id);
                        self.pong(object, client, message.uint()?).await
                    }
                    1u16 => {
                        tracing::debug!("wl_shell_surface#{}.move()", object.id);
                        self.r#move(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("wl_shell_surface#{}.resize()", object.id);
                        self.resize(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("wl_shell_surface#{}.set_toplevel()", object.id);
                        self.set_toplevel(object, client).await
                    }
                    4u16 => {
                        tracing::debug!("wl_shell_surface#{}.set_transient()", object.id);
                        self.set_transient(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    5u16 => {
                        tracing::debug!("wl_shell_surface#{}.set_fullscreen()", object.id);
                        self.set_fullscreen(
                            object,
                            client,
                            message.uint()?.try_into()?,
                            message.uint()?,
                            message.object()?,
                        )
                        .await
                    }
                    6u16 => {
                        tracing::debug!("wl_shell_surface#{}.set_popup()", object.id);
                        self.set_popup(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    7u16 => {
                        tracing::debug!("wl_shell_surface#{}.set_maximized()", object.id);
                        self.set_maximized(object, client, message.object()?).await
                    }
                    8u16 => {
                        tracing::debug!("wl_shell_surface#{}.set_title()", object.id);
                        self.set_title(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    9u16 => {
                        tracing::debug!("wl_shell_surface#{}.set_class()", object.id);
                        self.set_class(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "A client must respond to a ping event with a pong request or"]
            #[doc = "the client may be deemed unresponsive."]
            async fn pong(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Start a pointer-driven move of the surface."]
            #[doc = ""]
            #[doc = "This request must be used in response to a button press event."]
            #[doc = "The server may ignore move requests depending on the state of"]
            #[doc = "the surface (e.g. fullscreen or maximized)."]
            async fn r#move(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Start a pointer-driven resizing of the surface."]
            #[doc = ""]
            #[doc = "This request must be used in response to a button press event."]
            #[doc = "The server may ignore resize requests depending on the state of"]
            #[doc = "the surface (e.g. fullscreen or maximized)."]
            async fn resize(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
                edges: Resize,
            ) -> crate::server::Result<()>;
            #[doc = "Map the surface as a toplevel surface."]
            #[doc = ""]
            #[doc = "A toplevel surface is not fullscreen, maximized or transient."]
            async fn set_toplevel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Map the surface relative to an existing surface."]
            #[doc = ""]
            #[doc = "The x and y arguments specify the location of the upper left"]
            #[doc = "corner of the surface relative to the upper left corner of the"]
            #[doc = "parent surface, in surface-local coordinates."]
            #[doc = ""]
            #[doc = "The flags argument controls details of the transient behaviour."]
            async fn set_transient(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                parent: crate::wire::ObjectId,
                x: i32,
                y: i32,
                flags: Transient,
            ) -> crate::server::Result<()>;
            #[doc = "Map the surface as a fullscreen surface."]
            #[doc = ""]
            #[doc = "If an output parameter is given then the surface will be made"]
            #[doc = "fullscreen on that output. If the client does not specify the"]
            #[doc = "output then the compositor will apply its policy - usually"]
            #[doc = "choosing the output on which the surface has the biggest surface"]
            #[doc = "area."]
            #[doc = ""]
            #[doc = "The client may specify a method to resolve a size conflict"]
            #[doc = "between the output size and the surface size - this is provided"]
            #[doc = "through the method parameter."]
            #[doc = ""]
            #[doc = "The framerate parameter is used only when the method is set"]
            #[doc = "to \"driver\", to indicate the preferred framerate. A value of 0"]
            #[doc = "indicates that the client does not care about framerate.  The"]
            #[doc = "framerate is specified in mHz, that is framerate of 60000 is 60Hz."]
            #[doc = ""]
            #[doc = "A method of \"scale\" or \"driver\" implies a scaling operation of"]
            #[doc = "the surface, either via a direct scaling operation or a change of"]
            #[doc = "the output mode. This will override any kind of output scaling, so"]
            #[doc = "that mapping a surface with a buffer size equal to the mode can"]
            #[doc = "fill the screen independent of buffer_scale."]
            #[doc = ""]
            #[doc = "A method of \"fill\" means we don't scale up the buffer, however"]
            #[doc = "any output scale is applied. This means that you may run into"]
            #[doc = "an edge case where the application maps a buffer with the same"]
            #[doc = "size of the output mode but buffer_scale 1 (thus making a"]
            #[doc = "surface larger than the output). In this case it is allowed to"]
            #[doc = "downscale the results to fit the screen."]
            #[doc = ""]
            #[doc = "The compositor must reply to this request with a configure event"]
            #[doc = "with the dimensions for the output on which the surface will"]
            #[doc = "be made fullscreen."]
            async fn set_fullscreen(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                method: FullscreenMethod,
                framerate: u32,
                output: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Map the surface as a popup."]
            #[doc = ""]
            #[doc = "A popup surface is a transient surface with an added pointer"]
            #[doc = "grab."]
            #[doc = ""]
            #[doc = "An existing implicit grab will be changed to owner-events mode,"]
            #[doc = "and the popup grab will continue after the implicit grab ends"]
            #[doc = "(i.e. releasing the mouse button does not cause the popup to"]
            #[doc = "be unmapped)."]
            #[doc = ""]
            #[doc = "The popup grab continues until the window is destroyed or a"]
            #[doc = "mouse button is pressed in any other client's window. A click"]
            #[doc = "in any of the client's surfaces is reported as normal, however,"]
            #[doc = "clicks in other clients' surfaces will be discarded and trigger"]
            #[doc = "the callback."]
            #[doc = ""]
            #[doc = "The x and y arguments specify the location of the upper left"]
            #[doc = "corner of the surface relative to the upper left corner of the"]
            #[doc = "parent surface, in surface-local coordinates."]
            async fn set_popup(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
                parent: crate::wire::ObjectId,
                x: i32,
                y: i32,
                flags: Transient,
            ) -> crate::server::Result<()>;
            #[doc = "Map the surface as a maximized surface."]
            #[doc = ""]
            #[doc = "If an output parameter is given then the surface will be"]
            #[doc = "maximized on that output. If the client does not specify the"]
            #[doc = "output then the compositor will apply its policy - usually"]
            #[doc = "choosing the output on which the surface has the biggest surface"]
            #[doc = "area."]
            #[doc = ""]
            #[doc = "The compositor will reply with a configure event telling"]
            #[doc = "the expected new surface size. The operation is completed"]
            #[doc = "on the next buffer attach to this surface."]
            #[doc = ""]
            #[doc = "A maximized surface typically fills the entire output it is"]
            #[doc = "bound to, except for desktop elements such as panels. This is"]
            #[doc = "the main difference between a maximized shell surface and a"]
            #[doc = "fullscreen shell surface."]
            #[doc = ""]
            #[doc = "The details depend on the compositor implementation."]
            async fn set_maximized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Set a short title for the surface."]
            #[doc = ""]
            #[doc = "This string may be used to identify the surface in a task bar,"]
            #[doc = "window list, or other user interface elements provided by the"]
            #[doc = "compositor."]
            #[doc = ""]
            #[doc = "The string must be encoded in UTF-8."]
            async fn set_title(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                title: String,
            ) -> crate::server::Result<()>;
            #[doc = "Set a class for the surface."]
            #[doc = ""]
            #[doc = "The surface class identifies the general class of applications"]
            #[doc = "to which the surface belongs. A common convention is to use the"]
            #[doc = "file name (or the full path if it is a non-standard location) of"]
            #[doc = "the application's .desktop file as the class."]
            async fn set_class(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                class: String,
            ) -> crate::server::Result<()>;
            #[doc = "Ping a client to check if it is receiving events and sending"]
            #[doc = "requests. A client is expected to reply with a pong request."]
            async fn ping(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The configure event asks the client to resize its surface."]
            #[doc = ""]
            #[doc = "The size is a hint, in the sense that the client is free to"]
            #[doc = "ignore it if it doesn't resize, pick a smaller size (to"]
            #[doc = "satisfy aspect ratio or resize in steps of NxM pixels)."]
            #[doc = ""]
            #[doc = "The edges parameter provides a hint about how the surface"]
            #[doc = "was resized. The client may use this information to decide"]
            #[doc = "how to adjust its content to the new size (e.g. a scrolling"]
            #[doc = "area might adjust its content position to leave the viewable"]
            #[doc = "content unmoved)."]
            #[doc = ""]
            #[doc = "The client is free to dismiss all but the last configure"]
            #[doc = "event it received."]
            #[doc = ""]
            #[doc = "The width and height arguments specify the size of the window"]
            #[doc = "in surface-local coordinates."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The popup_done event is sent out when a popup grab is broken,"]
            #[doc = "that is, when the user clicks a surface that doesn't belong"]
            #[doc = "to the client owning the popup surface."]
            async fn popup_done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod wl_surface {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidScale = 0u32,
            InvalidTransform = 1u32,
            InvalidSize = 2u32,
            InvalidOffset = 3u32,
            DefunctRoleObject = 4u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "A surface is a rectangular area that may be displayed on zero"]
        #[doc = "or more outputs, and shown any number of times at the compositor's"]
        #[doc = "discretion. They can present wl_buffers, receive user input, and"]
        #[doc = "define a local coordinate system."]
        #[doc = ""]
        #[doc = "The size of a surface (and relative positions on it) is described"]
        #[doc = "in surface-local coordinates, which may differ from the buffer"]
        #[doc = "coordinates of the pixel content, in case a buffer_transform"]
        #[doc = "or a buffer_scale is used."]
        #[doc = ""]
        #[doc = "A surface without a \"role\" is fairly useless: a compositor does"]
        #[doc = "not know where, when or how to present it. The role is the"]
        #[doc = "purpose of a wl_surface. Examples of roles are a cursor for a"]
        #[doc = "pointer (as set by wl_pointer.set_cursor), a drag icon"]
        #[doc = "(wl_data_device.start_drag), a sub-surface"]
        #[doc = "(wl_subcompositor.get_subsurface), and a window as defined by a"]
        #[doc = "shell protocol (e.g. wl_shell.get_shell_surface)."]
        #[doc = ""]
        #[doc = "A surface can have only one role at a time. Initially a"]
        #[doc = "wl_surface does not have a role. Once a wl_surface is given a"]
        #[doc = "role, it is set permanently for the whole lifetime of the"]
        #[doc = "wl_surface object. Giving the current role again is allowed,"]
        #[doc = "unless explicitly forbidden by the relevant interface"]
        #[doc = "specification."]
        #[doc = ""]
        #[doc = "Surface roles are given by requests in other interfaces such as"]
        #[doc = "wl_pointer.set_cursor. The request should explicitly mention"]
        #[doc = "that this request gives a role to a wl_surface. Often, this"]
        #[doc = "request also creates a new protocol object that represents the"]
        #[doc = "role and adds additional functionality to wl_surface. When a"]
        #[doc = "client wants to destroy a wl_surface, they must destroy this role"]
        #[doc = "object before the wl_surface, otherwise a defunct_role_object error is"]
        #[doc = "sent."]
        #[doc = ""]
        #[doc = "Destroying the role object does not remove the role from the"]
        #[doc = "wl_surface, but it may stop the wl_surface from \"playing the role\"."]
        #[doc = "For instance, if a wl_subsurface object is destroyed, the wl_surface"]
        #[doc = "it was created for will be unmapped and forget its position and"]
        #[doc = "z-order. It is allowed to create a wl_subsurface for the same"]
        #[doc = "wl_surface again, but it is not allowed to use the wl_surface as"]
        #[doc = "a cursor (cursor is a different role than sub-surface, and role"]
        #[doc = "switching is not allowed)."]
        pub trait WlSurface: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_surface";
            const VERSION: u32 = 6u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_surface#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("wl_surface#{}.attach()", object.id);
                        self.attach(
                            object,
                            client,
                            message.object()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("wl_surface#{}.damage()", object.id);
                        self.damage(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("wl_surface#{}.frame()", object.id);
                        self.frame(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("wl_surface#{}.set_opaque_region()", object.id);
                        self.set_opaque_region(object, client, message.object()?)
                            .await
                    }
                    5u16 => {
                        tracing::debug!("wl_surface#{}.set_input_region()", object.id);
                        self.set_input_region(object, client, message.object()?)
                            .await
                    }
                    6u16 => {
                        tracing::debug!("wl_surface#{}.commit()", object.id);
                        self.commit(object, client).await
                    }
                    7u16 => {
                        tracing::debug!("wl_surface#{}.set_buffer_transform()", object.id);
                        self.set_buffer_transform(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    8u16 => {
                        tracing::debug!("wl_surface#{}.set_buffer_scale()", object.id);
                        self.set_buffer_scale(object, client, message.int()?).await
                    }
                    9u16 => {
                        tracing::debug!("wl_surface#{}.damage_buffer()", object.id);
                        self.damage_buffer(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    10u16 => {
                        tracing::debug!("wl_surface#{}.offset()", object.id);
                        self.offset(object, client, message.int()?, message.int()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Deletes the surface and invalidates its object ID."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set a buffer as the content of this surface."]
            #[doc = ""]
            #[doc = "The new size of the surface is calculated based on the buffer"]
            #[doc = "size transformed by the inverse buffer_transform and the"]
            #[doc = "inverse buffer_scale. This means that at commit time the supplied"]
            #[doc = "buffer size must be an integer multiple of the buffer_scale. If"]
            #[doc = "that's not the case, an invalid_size error is sent."]
            #[doc = ""]
            #[doc = "The x and y arguments specify the location of the new pending"]
            #[doc = "buffer's upper left corner, relative to the current buffer's upper"]
            #[doc = "left corner, in surface-local coordinates. In other words, the"]
            #[doc = "x and y, combined with the new surface size define in which"]
            #[doc = "directions the surface's size changes. Setting anything other than 0"]
            #[doc = "as x and y arguments is discouraged, and should instead be replaced"]
            #[doc = "with using the separate wl_surface.offset request."]
            #[doc = ""]
            #[doc = "When the bound wl_surface version is 5 or higher, passing any"]
            #[doc = "non-zero x or y is a protocol violation, and will result in an"]
            #[doc = "'invalid_offset' error being raised. The x and y arguments are ignored"]
            #[doc = "and do not change the pending state. To achieve equivalent semantics,"]
            #[doc = "use wl_surface.offset."]
            #[doc = ""]
            #[doc = "Surface contents are double-buffered state, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "The initial surface contents are void; there is no content."]
            #[doc = "wl_surface.attach assigns the given wl_buffer as the pending"]
            #[doc = "wl_buffer. wl_surface.commit makes the pending wl_buffer the new"]
            #[doc = "surface contents, and the size of the surface becomes the size"]
            #[doc = "calculated from the wl_buffer, as described above. After commit,"]
            #[doc = "there is no pending buffer until the next attach."]
            #[doc = ""]
            #[doc = "Committing a pending wl_buffer allows the compositor to read the"]
            #[doc = "pixels in the wl_buffer. The compositor may access the pixels at"]
            #[doc = "any time after the wl_surface.commit request. When the compositor"]
            #[doc = "will not access the pixels anymore, it will send the"]
            #[doc = "wl_buffer.release event. Only after receiving wl_buffer.release,"]
            #[doc = "the client may reuse the wl_buffer. A wl_buffer that has been"]
            #[doc = "attached and then replaced by another attach instead of committed"]
            #[doc = "will not receive a release event, and is not used by the"]
            #[doc = "compositor."]
            #[doc = ""]
            #[doc = "If a pending wl_buffer has been committed to more than one wl_surface,"]
            #[doc = "the delivery of wl_buffer.release events becomes undefined. A well"]
            #[doc = "behaved client should not rely on wl_buffer.release events in this"]
            #[doc = "case. Alternatively, a client could create multiple wl_buffer objects"]
            #[doc = "from the same backing storage or use wp_linux_buffer_release."]
            #[doc = ""]
            #[doc = "Destroying the wl_buffer after wl_buffer.release does not change"]
            #[doc = "the surface contents. Destroying the wl_buffer before wl_buffer.release"]
            #[doc = "is allowed as long as the underlying buffer storage isn't re-used (this"]
            #[doc = "can happen e.g. on client process termination). However, if the client"]
            #[doc = "destroys the wl_buffer before receiving the wl_buffer.release event and"]
            #[doc = "mutates the underlying buffer storage, the surface contents become"]
            #[doc = "undefined immediately."]
            #[doc = ""]
            #[doc = "If wl_surface.attach is sent with a NULL wl_buffer, the"]
            #[doc = "following wl_surface.commit will remove the surface content."]
            #[doc = ""]
            #[doc = "If a pending wl_buffer has been destroyed, the result is not specified."]
            #[doc = "Many compositors are known to remove the surface content on the following"]
            #[doc = "wl_surface.commit, but this behaviour is not universal. Clients seeking to"]
            #[doc = "maximise compatibility should not destroy pending buffers and should"]
            #[doc = "ensure that they explicitly remove content from surfaces, even after"]
            #[doc = "destroying buffers."]
            async fn attach(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer: Option<crate::wire::ObjectId>,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "This request is used to describe the regions where the pending"]
            #[doc = "buffer is different from the current surface contents, and where"]
            #[doc = "the surface therefore needs to be repainted. The compositor"]
            #[doc = "ignores the parts of the damage that fall outside of the surface."]
            #[doc = ""]
            #[doc = "Damage is double-buffered state, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "The damage rectangle is specified in surface-local coordinates,"]
            #[doc = "where x and y specify the upper left corner of the damage rectangle."]
            #[doc = ""]
            #[doc = "The initial value for pending damage is empty: no damage."]
            #[doc = "wl_surface.damage adds pending damage: the new pending damage"]
            #[doc = "is the union of old pending damage and the given rectangle."]
            #[doc = ""]
            #[doc = "wl_surface.commit assigns pending damage as the current damage,"]
            #[doc = "and clears pending damage. The server will clear the current"]
            #[doc = "damage as it repaints the surface."]
            #[doc = ""]
            #[doc = "Note! New clients should not use this request. Instead damage can be"]
            #[doc = "posted with wl_surface.damage_buffer which uses buffer coordinates"]
            #[doc = "instead of surface coordinates."]
            async fn damage(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Request a notification when it is a good time to start drawing a new"]
            #[doc = "frame, by creating a frame callback. This is useful for throttling"]
            #[doc = "redrawing operations, and driving animations."]
            #[doc = ""]
            #[doc = "When a client is animating on a wl_surface, it can use the 'frame'"]
            #[doc = "request to get notified when it is a good time to draw and commit the"]
            #[doc = "next frame of animation. If the client commits an update earlier than"]
            #[doc = "that, it is likely that some updates will not make it to the display,"]
            #[doc = "and the client is wasting resources by drawing too often."]
            #[doc = ""]
            #[doc = "The frame request will take effect on the next wl_surface.commit."]
            #[doc = "The notification will only be posted for one frame unless"]
            #[doc = "requested again. For a wl_surface, the notifications are posted in"]
            #[doc = "the order the frame requests were committed."]
            #[doc = ""]
            #[doc = "The server must send the notifications so that a client"]
            #[doc = "will not send excessive updates, while still allowing"]
            #[doc = "the highest possible update rate for clients that wait for the reply"]
            #[doc = "before drawing again. The server should give some time for the client"]
            #[doc = "to draw and commit after sending the frame callback events to let it"]
            #[doc = "hit the next output refresh."]
            #[doc = ""]
            #[doc = "A server should avoid signaling the frame callbacks if the"]
            #[doc = "surface is not visible in any way, e.g. the surface is off-screen,"]
            #[doc = "or completely obscured by other opaque surfaces."]
            #[doc = ""]
            #[doc = "The object returned by this request will be destroyed by the"]
            #[doc = "compositor after the callback is fired and as such the client must not"]
            #[doc = "attempt to use it after that point."]
            #[doc = ""]
            #[doc = "The callback_data passed in the callback is the current time, in"]
            #[doc = "milliseconds, with an undefined base."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                callback: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This request sets the region of the surface that contains"]
            #[doc = "opaque content."]
            #[doc = ""]
            #[doc = "The opaque region is an optimization hint for the compositor"]
            #[doc = "that lets it optimize the redrawing of content behind opaque"]
            #[doc = "regions.  Setting an opaque region is not required for correct"]
            #[doc = "behaviour, but marking transparent content as opaque will result"]
            #[doc = "in repaint artifacts."]
            #[doc = ""]
            #[doc = "The opaque region is specified in surface-local coordinates."]
            #[doc = ""]
            #[doc = "The compositor ignores the parts of the opaque region that fall"]
            #[doc = "outside of the surface."]
            #[doc = ""]
            #[doc = "Opaque region is double-buffered state, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "wl_surface.set_opaque_region changes the pending opaque region."]
            #[doc = "wl_surface.commit copies the pending region to the current region."]
            #[doc = "Otherwise, the pending and current regions are never changed."]
            #[doc = ""]
            #[doc = "The initial value for an opaque region is empty. Setting the pending"]
            #[doc = "opaque region has copy semantics, and the wl_region object can be"]
            #[doc = "destroyed immediately. A NULL wl_region causes the pending opaque"]
            #[doc = "region to be set to empty."]
            async fn set_opaque_region(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                region: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "This request sets the region of the surface that can receive"]
            #[doc = "pointer and touch events."]
            #[doc = ""]
            #[doc = "Input events happening outside of this region will try the next"]
            #[doc = "surface in the server surface stack. The compositor ignores the"]
            #[doc = "parts of the input region that fall outside of the surface."]
            #[doc = ""]
            #[doc = "The input region is specified in surface-local coordinates."]
            #[doc = ""]
            #[doc = "Input region is double-buffered state, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "wl_surface.set_input_region changes the pending input region."]
            #[doc = "wl_surface.commit copies the pending region to the current region."]
            #[doc = "Otherwise the pending and current regions are never changed,"]
            #[doc = "except cursor and icon surfaces are special cases, see"]
            #[doc = "wl_pointer.set_cursor and wl_data_device.start_drag."]
            #[doc = ""]
            #[doc = "The initial value for an input region is infinite. That means the"]
            #[doc = "whole surface will accept input. Setting the pending input region"]
            #[doc = "has copy semantics, and the wl_region object can be destroyed"]
            #[doc = "immediately. A NULL wl_region causes the input region to be set"]
            #[doc = "to infinite."]
            async fn set_input_region(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                region: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Surface state (input, opaque, and damage regions, attached buffers,"]
            #[doc = "etc.) is double-buffered. Protocol requests modify the pending state,"]
            #[doc = "as opposed to the active state in use by the compositor."]
            #[doc = ""]
            #[doc = "A commit request atomically creates a content update from the pending"]
            #[doc = "state, even if the pending state has not been touched. The content"]
            #[doc = "update is placed in a queue until it becomes active. After commit, the"]
            #[doc = "new pending state is as documented for each related request."]
            #[doc = ""]
            #[doc = "When the content update is applied, the wl_buffer is applied before all"]
            #[doc = "other state. This means that all coordinates in double-buffered state"]
            #[doc = "are relative to the newly attached wl_buffers, except for"]
            #[doc = "wl_surface.attach itself. If there is no newly attached wl_buffer, the"]
            #[doc = "coordinates are relative to the previous content update."]
            #[doc = ""]
            #[doc = "All requests that need a commit to become effective are documented"]
            #[doc = "to affect double-buffered state."]
            #[doc = ""]
            #[doc = "Other interfaces may add further double-buffered surface state."]
            async fn commit(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This request sets the transformation that the client has already applied"]
            #[doc = "to the content of the buffer. The accepted values for the transform"]
            #[doc = "parameter are the values for wl_output.transform."]
            #[doc = ""]
            #[doc = "The compositor applies the inverse of this transformation whenever it"]
            #[doc = "uses the buffer contents."]
            #[doc = ""]
            #[doc = "Buffer transform is double-buffered state, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "A newly created surface has its buffer transformation set to normal."]
            #[doc = ""]
            #[doc = "wl_surface.set_buffer_transform changes the pending buffer"]
            #[doc = "transformation. wl_surface.commit copies the pending buffer"]
            #[doc = "transformation to the current one. Otherwise, the pending and current"]
            #[doc = "values are never changed."]
            #[doc = ""]
            #[doc = "The purpose of this request is to allow clients to render content"]
            #[doc = "according to the output transform, thus permitting the compositor to"]
            #[doc = "use certain optimizations even if the display is rotated. Using"]
            #[doc = "hardware overlays and scanning out a client buffer for fullscreen"]
            #[doc = "surfaces are examples of such optimizations. Those optimizations are"]
            #[doc = "highly dependent on the compositor implementation, so the use of this"]
            #[doc = "request should be considered on a case-by-case basis."]
            #[doc = ""]
            #[doc = "Note that if the transform value includes 90 or 270 degree rotation,"]
            #[doc = "the width of the buffer will become the surface height and the height"]
            #[doc = "of the buffer will become the surface width."]
            #[doc = ""]
            #[doc = "If transform is not one of the values from the"]
            #[doc = "wl_output.transform enum the invalid_transform protocol error"]
            #[doc = "is raised."]
            async fn set_buffer_transform(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                transform: super::super::wayland::wl_output::Transform,
            ) -> crate::server::Result<()>;
            #[doc = "This request sets an optional scaling factor on how the compositor"]
            #[doc = "interprets the contents of the buffer attached to the window."]
            #[doc = ""]
            #[doc = "Buffer scale is double-buffered state, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "A newly created surface has its buffer scale set to 1."]
            #[doc = ""]
            #[doc = "wl_surface.set_buffer_scale changes the pending buffer scale."]
            #[doc = "wl_surface.commit copies the pending buffer scale to the current one."]
            #[doc = "Otherwise, the pending and current values are never changed."]
            #[doc = ""]
            #[doc = "The purpose of this request is to allow clients to supply higher"]
            #[doc = "resolution buffer data for use on high resolution outputs. It is"]
            #[doc = "intended that you pick the same buffer scale as the scale of the"]
            #[doc = "output that the surface is displayed on. This means the compositor"]
            #[doc = "can avoid scaling when rendering the surface on that output."]
            #[doc = ""]
            #[doc = "Note that if the scale is larger than 1, then you have to attach"]
            #[doc = "a buffer that is larger (by a factor of scale in each dimension)"]
            #[doc = "than the desired surface size."]
            #[doc = ""]
            #[doc = "If scale is not greater than 0 the invalid_scale protocol error is"]
            #[doc = "raised."]
            async fn set_buffer_scale(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                scale: i32,
            ) -> crate::server::Result<()>;
            #[doc = "This request is used to describe the regions where the pending"]
            #[doc = "buffer is different from the current surface contents, and where"]
            #[doc = "the surface therefore needs to be repainted. The compositor"]
            #[doc = "ignores the parts of the damage that fall outside of the surface."]
            #[doc = ""]
            #[doc = "Damage is double-buffered state, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "The damage rectangle is specified in buffer coordinates,"]
            #[doc = "where x and y specify the upper left corner of the damage rectangle."]
            #[doc = ""]
            #[doc = "The initial value for pending damage is empty: no damage."]
            #[doc = "wl_surface.damage_buffer adds pending damage: the new pending"]
            #[doc = "damage is the union of old pending damage and the given rectangle."]
            #[doc = ""]
            #[doc = "wl_surface.commit assigns pending damage as the current damage,"]
            #[doc = "and clears pending damage. The server will clear the current"]
            #[doc = "damage as it repaints the surface."]
            #[doc = ""]
            #[doc = "This request differs from wl_surface.damage in only one way - it"]
            #[doc = "takes damage in buffer coordinates instead of surface-local"]
            #[doc = "coordinates. While this generally is more intuitive than surface"]
            #[doc = "coordinates, it is especially desirable when using wp_viewport"]
            #[doc = "or when a drawing library (like EGL) is unaware of buffer scale"]
            #[doc = "and buffer transform."]
            #[doc = ""]
            #[doc = "Note: Because buffer transformation changes and damage requests may"]
            #[doc = "be interleaved in the protocol stream, it is impossible to determine"]
            #[doc = "the actual mapping between surface and buffer damage until"]
            #[doc = "wl_surface.commit time. Therefore, compositors wishing to take both"]
            #[doc = "kinds of damage into account will have to accumulate damage from the"]
            #[doc = "two requests separately and only transform from one to the other"]
            #[doc = "after receiving the wl_surface.commit."]
            async fn damage_buffer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "The x and y arguments specify the location of the new pending"]
            #[doc = "buffer's upper left corner, relative to the current buffer's upper"]
            #[doc = "left corner, in surface-local coordinates. In other words, the"]
            #[doc = "x and y, combined with the new surface size define in which"]
            #[doc = "directions the surface's size changes."]
            #[doc = ""]
            #[doc = "Surface location offset is double-buffered state, see"]
            #[doc = "wl_surface.commit."]
            #[doc = ""]
            #[doc = "This request is semantically equivalent to and the replaces the x and y"]
            #[doc = "arguments in the wl_surface.attach request in wl_surface versions prior"]
            #[doc = "to 5. See wl_surface.attach for details."]
            async fn offset(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "This is emitted whenever a surface's creation, movement, or resizing"]
            #[doc = "results in some part of it being within the scanout region of an"]
            #[doc = "output."]
            #[doc = ""]
            #[doc = "Note that a surface may be overlapping with zero or more outputs."]
            async fn enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This is emitted whenever a surface's creation, movement, or resizing"]
            #[doc = "results in it no longer having any part of it within the scanout region"]
            #[doc = "of an output."]
            #[doc = ""]
            #[doc = "Clients should not use the number of outputs the surface is on for frame"]
            #[doc = "throttling purposes. The surface might be hidden even if no leave event"]
            #[doc = "has been sent, and the compositor might expect new surface content"]
            #[doc = "updates even if no enter event has been sent. The frame event should be"]
            #[doc = "used instead."]
            async fn leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event indicates the preferred buffer scale for this surface. It is"]
            #[doc = "sent whenever the compositor's preference changes."]
            #[doc = ""]
            #[doc = "Before receiving this event the preferred buffer scale for this surface"]
            #[doc = "is 1."]
            #[doc = ""]
            #[doc = "It is intended that scaling aware clients use this event to scale their"]
            #[doc = "content and use wl_surface.set_buffer_scale to indicate the scale they"]
            #[doc = "have rendered with. This allows clients to supply a higher detail"]
            #[doc = "buffer."]
            #[doc = ""]
            #[doc = "The compositor shall emit a scale value greater than 0."]
            async fn preferred_buffer_scale(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event indicates the preferred buffer transform for this surface."]
            #[doc = "It is sent whenever the compositor's preference changes."]
            #[doc = ""]
            #[doc = "Before receiving this event the preferred buffer transform for this"]
            #[doc = "surface is normal."]
            #[doc = ""]
            #[doc = "Applying this transformation to the surface buffer contents and using"]
            #[doc = "wl_surface.set_buffer_transform might allow the compositor to use the"]
            #[doc = "surface buffer more efficiently."]
            async fn preferred_buffer_transform(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod wl_seat {
        bitflags::bitflags! { # [doc = "This is a bitmask of capabilities this seat has; if a member is"] # [doc = "set, then it is present on the seat."] # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Capability : u32 { # [doc = "the seat has pointer devices"] const Pointer = 1u32 ; # [doc = "the seat has one or more keyboards"] const Keyboard = 2u32 ; # [doc = "the seat has touch devices"] const Touch = 4u32 ; } }
        impl TryFrom<u32> for Capability {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            MissingCapability = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "A seat is a group of keyboards, pointer and touch devices. This"]
        #[doc = "object is published as a global during start up, or when such a"]
        #[doc = "device is hot plugged.  A seat typically has a pointer and"]
        #[doc = "maintains a keyboard focus and a pointer focus."]
        pub trait WlSeat: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_seat";
            const VERSION: u32 = 9u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_seat#{}.get_pointer()", object.id);
                        self.get_pointer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("wl_seat#{}.get_keyboard()", object.id);
                        self.get_keyboard(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("wl_seat#{}.get_touch()", object.id);
                        self.get_touch(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("wl_seat#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "The ID provided will be initialized to the wl_pointer interface"]
            #[doc = "for this seat."]
            #[doc = ""]
            #[doc = "This request only takes effect if the seat has the pointer"]
            #[doc = "capability, or has had the pointer capability in the past."]
            #[doc = "It is a protocol violation to issue this request on a seat that has"]
            #[doc = "never had the pointer capability. The missing_capability error will"]
            #[doc = "be sent in this case."]
            async fn get_pointer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "The ID provided will be initialized to the wl_keyboard interface"]
            #[doc = "for this seat."]
            #[doc = ""]
            #[doc = "This request only takes effect if the seat has the keyboard"]
            #[doc = "capability, or has had the keyboard capability in the past."]
            #[doc = "It is a protocol violation to issue this request on a seat that has"]
            #[doc = "never had the keyboard capability. The missing_capability error will"]
            #[doc = "be sent in this case."]
            async fn get_keyboard(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "The ID provided will be initialized to the wl_touch interface"]
            #[doc = "for this seat."]
            #[doc = ""]
            #[doc = "This request only takes effect if the seat has the touch"]
            #[doc = "capability, or has had the touch capability in the past."]
            #[doc = "It is a protocol violation to issue this request on a seat that has"]
            #[doc = "never had the touch capability. The missing_capability error will"]
            #[doc = "be sent in this case."]
            async fn get_touch(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Using this request a client can tell the server that it is not going to"]
            #[doc = "use the seat object anymore."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This is emitted whenever a seat gains or loses the pointer,"]
            #[doc = "keyboard or touch capabilities.  The argument is a capability"]
            #[doc = "enum containing the complete set of capabilities this seat has."]
            #[doc = ""]
            #[doc = "When the pointer capability is added, a client may create a"]
            #[doc = "wl_pointer object using the wl_seat.get_pointer request. This object"]
            #[doc = "will receive pointer events until the capability is removed in the"]
            #[doc = "future."]
            #[doc = ""]
            #[doc = "When the pointer capability is removed, a client should destroy the"]
            #[doc = "wl_pointer objects associated with the seat where the capability was"]
            #[doc = "removed, using the wl_pointer.release request. No further pointer"]
            #[doc = "events will be received on these objects."]
            #[doc = ""]
            #[doc = "In some compositors, if a seat regains the pointer capability and a"]
            #[doc = "client has a previously obtained wl_pointer object of version 4 or"]
            #[doc = "less, that object may start sending pointer events again. This"]
            #[doc = "behavior is considered a misinterpretation of the intended behavior"]
            #[doc = "and must not be relied upon by the client. wl_pointer objects of"]
            #[doc = "version 5 or later must not send events if created before the most"]
            #[doc = "recent event notifying the client of an added pointer capability."]
            #[doc = ""]
            #[doc = "The above behavior also applies to wl_keyboard and wl_touch with the"]
            #[doc = "keyboard and touch capabilities, respectively."]
            async fn capabilities(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "In a multi-seat configuration the seat name can be used by clients to"]
            #[doc = "help identify which physical devices the seat represents."]
            #[doc = ""]
            #[doc = "The seat name is a UTF-8 string with no convention defined for its"]
            #[doc = "contents. Each name is unique among all wl_seat globals. The name is"]
            #[doc = "only guaranteed to be unique for the current compositor instance."]
            #[doc = ""]
            #[doc = "The same seat names are used for all clients. Thus, the name can be"]
            #[doc = "shared across processes to refer to a specific wl_seat global."]
            #[doc = ""]
            #[doc = "The name event is sent after binding to the seat global. This event is"]
            #[doc = "only sent once per seat object, and the name does not change over the"]
            #[doc = "lifetime of the wl_seat global."]
            #[doc = ""]
            #[doc = "Compositors may re-use the same seat name if the wl_seat global is"]
            #[doc = "destroyed and re-created later."]
            async fn name(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod wl_pointer {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            Role = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ButtonState {
            Released = 0u32,
            Pressed = 1u32,
        }
        impl TryFrom<u32> for ButtonState {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Axis {
            VerticalScroll = 0u32,
            HorizontalScroll = 1u32,
        }
        impl TryFrom<u32> for Axis {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum AxisSource {
            Wheel = 0u32,
            Finger = 1u32,
            Continuous = 2u32,
            WheelTilt = 3u32,
        }
        impl TryFrom<u32> for AxisSource {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum AxisRelativeDirection {
            Identical = 0u32,
            Inverted = 1u32,
        }
        impl TryFrom<u32> for AxisRelativeDirection {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "The wl_pointer interface represents one or more input devices,"]
        #[doc = "such as mice, which control the pointer location and pointer_focus"]
        #[doc = "of a seat."]
        #[doc = ""]
        #[doc = "The wl_pointer interface generates motion, enter and leave"]
        #[doc = "events for the surfaces that the pointer is located over,"]
        #[doc = "and button and axis events for button presses, button releases"]
        #[doc = "and scrolling."]
        pub trait WlPointer: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_pointer";
            const VERSION: u32 = 9u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_pointer#{}.set_cursor()", object.id);
                        self.set_cursor(
                            object,
                            client,
                            message.uint()?,
                            message.object()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("wl_pointer#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Set the pointer surface, i.e., the surface that contains the"]
            #[doc = "pointer image (cursor). This request gives the surface the role"]
            #[doc = "of a cursor. If the surface already has another role, it raises"]
            #[doc = "a protocol error."]
            #[doc = ""]
            #[doc = "The cursor actually changes only if the pointer"]
            #[doc = "focus for this device is one of the requesting client's surfaces"]
            #[doc = "or the surface parameter is the current pointer surface. If"]
            #[doc = "there was a previous surface set with this request it is"]
            #[doc = "replaced. If surface is NULL, the pointer image is hidden."]
            #[doc = ""]
            #[doc = "The parameters hotspot_x and hotspot_y define the position of"]
            #[doc = "the pointer surface relative to the pointer location. Its"]
            #[doc = "top-left corner is always at (x, y) - (hotspot_x, hotspot_y),"]
            #[doc = "where (x, y) are the coordinates of the pointer location, in"]
            #[doc = "surface-local coordinates."]
            #[doc = ""]
            #[doc = "On wl_surface.offset requests to the pointer surface, hotspot_x"]
            #[doc = "and hotspot_y are decremented by the x and y parameters"]
            #[doc = "passed to the request. The offset must be applied by"]
            #[doc = "wl_surface.commit as usual."]
            #[doc = ""]
            #[doc = "The hotspot can also be updated by passing the currently set"]
            #[doc = "pointer surface to this request with new values for hotspot_x"]
            #[doc = "and hotspot_y."]
            #[doc = ""]
            #[doc = "The input region is ignored for wl_surfaces with the role of"]
            #[doc = "a cursor. When the use as a cursor ends, the wl_surface is"]
            #[doc = "unmapped."]
            #[doc = ""]
            #[doc = "The serial parameter must match the latest wl_pointer.enter"]
            #[doc = "serial number sent to the client. Otherwise the request will be"]
            #[doc = "ignored."]
            async fn set_cursor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: Option<crate::wire::ObjectId>,
                hotspot_x: i32,
                hotspot_y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Using this request a client can tell the server that it is not going to"]
            #[doc = "use the pointer object anymore."]
            #[doc = ""]
            #[doc = "This request destroys the pointer proxy object, so clients must not call"]
            #[doc = "wl_pointer_destroy() after using this request."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Notification that this seat's pointer is focused on a certain"]
            #[doc = "surface."]
            #[doc = ""]
            #[doc = "When a seat's focus enters a surface, the pointer image"]
            #[doc = "is undefined and a client should respond to this event by setting"]
            #[doc = "an appropriate pointer image with the set_cursor request."]
            async fn enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notification that this seat's pointer is no longer focused on"]
            #[doc = "a certain surface."]
            #[doc = ""]
            #[doc = "The leave notification is sent before the enter notification"]
            #[doc = "for the new focus."]
            async fn leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notification of pointer location change. The arguments"]
            #[doc = "surface_x and surface_y are the location relative to the"]
            #[doc = "focused surface."]
            async fn motion(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Mouse button click and release notifications."]
            #[doc = ""]
            #[doc = "The location of the click is given by the last motion or"]
            #[doc = "enter event."]
            #[doc = "The time argument is a timestamp with millisecond"]
            #[doc = "granularity, with an undefined base."]
            #[doc = ""]
            #[doc = "The button is a button code as defined in the Linux kernel's"]
            #[doc = "linux/input-event-codes.h header file, e.g. BTN_LEFT."]
            #[doc = ""]
            #[doc = "Any 16-bit button code value is reserved for future additions to the"]
            #[doc = "kernel's event code list. All other button codes above 0xFFFF are"]
            #[doc = "currently undefined but may be used in future versions of this"]
            #[doc = "protocol."]
            async fn button(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Scroll and other axis notifications."]
            #[doc = ""]
            #[doc = "For scroll events (vertical and horizontal scroll axes), the"]
            #[doc = "value parameter is the length of a vector along the specified"]
            #[doc = "axis in a coordinate space identical to those of motion events,"]
            #[doc = "representing a relative movement along the specified axis."]
            #[doc = ""]
            #[doc = "For devices that support movements non-parallel to axes multiple"]
            #[doc = "axis events will be emitted."]
            #[doc = ""]
            #[doc = "When applicable, for example for touch pads, the server can"]
            #[doc = "choose to emit scroll events where the motion vector is"]
            #[doc = "equivalent to a motion event vector."]
            #[doc = ""]
            #[doc = "When applicable, a client can transform its content relative to the"]
            #[doc = "scroll distance."]
            async fn axis(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Indicates the end of a set of events that logically belong together."]
            #[doc = "A client is expected to accumulate the data in all events within the"]
            #[doc = "frame before proceeding."]
            #[doc = ""]
            #[doc = "All wl_pointer events before a wl_pointer.frame event belong"]
            #[doc = "logically together. For example, in a diagonal scroll motion the"]
            #[doc = "compositor will send an optional wl_pointer.axis_source event, two"]
            #[doc = "wl_pointer.axis events (horizontal and vertical) and finally a"]
            #[doc = "wl_pointer.frame event. The client may use this information to"]
            #[doc = "calculate a diagonal vector for scrolling."]
            #[doc = ""]
            #[doc = "When multiple wl_pointer.axis events occur within the same frame,"]
            #[doc = "the motion vector is the combined motion of all events."]
            #[doc = "When a wl_pointer.axis and a wl_pointer.axis_stop event occur within"]
            #[doc = "the same frame, this indicates that axis movement in one axis has"]
            #[doc = "stopped but continues in the other axis."]
            #[doc = "When multiple wl_pointer.axis_stop events occur within the same"]
            #[doc = "frame, this indicates that these axes stopped in the same instance."]
            #[doc = ""]
            #[doc = "A wl_pointer.frame event is sent for every logical event group,"]
            #[doc = "even if the group only contains a single wl_pointer event."]
            #[doc = "Specifically, a client may get a sequence: motion, frame, button,"]
            #[doc = "frame, axis, frame, axis_stop, frame."]
            #[doc = ""]
            #[doc = "The wl_pointer.enter and wl_pointer.leave events are logical events"]
            #[doc = "generated by the compositor and not the hardware. These events are"]
            #[doc = "also grouped by a wl_pointer.frame. When a pointer moves from one"]
            #[doc = "surface to another, a compositor should group the"]
            #[doc = "wl_pointer.leave event within the same wl_pointer.frame."]
            #[doc = "However, a client must not rely on wl_pointer.leave and"]
            #[doc = "wl_pointer.enter being in the same wl_pointer.frame."]
            #[doc = "Compositor-specific policies may require the wl_pointer.leave and"]
            #[doc = "wl_pointer.enter event being split across multiple wl_pointer.frame"]
            #[doc = "groups."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Source information for scroll and other axes."]
            #[doc = ""]
            #[doc = "This event does not occur on its own. It is sent before a"]
            #[doc = "wl_pointer.frame event and carries the source information for"]
            #[doc = "all events within that frame."]
            #[doc = ""]
            #[doc = "The source specifies how this event was generated. If the source is"]
            #[doc = "wl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be"]
            #[doc = "sent when the user lifts the finger off the device."]
            #[doc = ""]
            #[doc = "If the source is wl_pointer.axis_source.wheel,"]
            #[doc = "wl_pointer.axis_source.wheel_tilt or"]
            #[doc = "wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may"]
            #[doc = "or may not be sent. Whether a compositor sends an axis_stop event"]
            #[doc = "for these sources is hardware-specific and implementation-dependent;"]
            #[doc = "clients must not rely on receiving an axis_stop event for these"]
            #[doc = "scroll sources and should treat scroll sequences from these scroll"]
            #[doc = "sources as unterminated by default."]
            #[doc = ""]
            #[doc = "This event is optional. If the source is unknown for a particular"]
            #[doc = "axis event sequence, no event is sent."]
            #[doc = "Only one wl_pointer.axis_source event is permitted per frame."]
            #[doc = ""]
            #[doc = "The order of wl_pointer.axis_discrete and wl_pointer.axis_source is"]
            #[doc = "not guaranteed."]
            async fn axis_source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Stop notification for scroll and other axes."]
            #[doc = ""]
            #[doc = "For some wl_pointer.axis_source types, a wl_pointer.axis_stop event"]
            #[doc = "is sent to notify a client that the axis sequence has terminated."]
            #[doc = "This enables the client to implement kinetic scrolling."]
            #[doc = "See the wl_pointer.axis_source documentation for information on when"]
            #[doc = "this event may be generated."]
            #[doc = ""]
            #[doc = "Any wl_pointer.axis events with the same axis_source after this"]
            #[doc = "event should be considered as the start of a new axis motion."]
            #[doc = ""]
            #[doc = "The timestamp is to be interpreted identical to the timestamp in the"]
            #[doc = "wl_pointer.axis event. The timestamp value may be the same as a"]
            #[doc = "preceding wl_pointer.axis event."]
            async fn axis_stop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Discrete step information for scroll and other axes."]
            #[doc = ""]
            #[doc = "This event carries the axis value of the wl_pointer.axis event in"]
            #[doc = "discrete steps (e.g. mouse wheel clicks)."]
            #[doc = ""]
            #[doc = "This event is deprecated with wl_pointer version 8 - this event is not"]
            #[doc = "sent to clients supporting version 8 or later."]
            #[doc = ""]
            #[doc = "This event does not occur on its own, it is coupled with a"]
            #[doc = "wl_pointer.axis event that represents this axis value on a"]
            #[doc = "continuous scale. The protocol guarantees that each axis_discrete"]
            #[doc = "event is always followed by exactly one axis event with the same"]
            #[doc = "axis number within the same wl_pointer.frame. Note that the protocol"]
            #[doc = "allows for other events to occur between the axis_discrete and"]
            #[doc = "its coupled axis event, including other axis_discrete or axis"]
            #[doc = "events. A wl_pointer.frame must not contain more than one axis_discrete"]
            #[doc = "event per axis type."]
            #[doc = ""]
            #[doc = "This event is optional; continuous scrolling devices"]
            #[doc = "like two-finger scrolling on touchpads do not have discrete"]
            #[doc = "steps and do not generate this event."]
            #[doc = ""]
            #[doc = "The discrete value carries the directional information. e.g. a value"]
            #[doc = "of -2 is two steps towards the negative direction of this axis."]
            #[doc = ""]
            #[doc = "The axis number is identical to the axis number in the associated"]
            #[doc = "axis event."]
            #[doc = ""]
            #[doc = "The order of wl_pointer.axis_discrete and wl_pointer.axis_source is"]
            #[doc = "not guaranteed."]
            async fn axis_discrete(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Discrete high-resolution scroll information."]
            #[doc = ""]
            #[doc = "This event carries high-resolution wheel scroll information,"]
            #[doc = "with each multiple of 120 representing one logical scroll step"]
            #[doc = "(a wheel detent). For example, an axis_value120 of 30 is one quarter of"]
            #[doc = "a logical scroll step in the positive direction, a value120 of"]
            #[doc = "-240 are two logical scroll steps in the negative direction within the"]
            #[doc = "same hardware event."]
            #[doc = "Clients that rely on discrete scrolling should accumulate the"]
            #[doc = "value120 to multiples of 120 before processing the event."]
            #[doc = ""]
            #[doc = "The value120 must not be zero."]
            #[doc = ""]
            #[doc = "This event replaces the wl_pointer.axis_discrete event in clients"]
            #[doc = "supporting wl_pointer version 8 or later."]
            #[doc = ""]
            #[doc = "Where a wl_pointer.axis_source event occurs in the same"]
            #[doc = "wl_pointer.frame, the axis source applies to this event."]
            #[doc = ""]
            #[doc = "The order of wl_pointer.axis_value120 and wl_pointer.axis_source is"]
            #[doc = "not guaranteed."]
            async fn axis_value120(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Relative directional information of the entity causing the axis"]
            #[doc = "motion."]
            #[doc = ""]
            #[doc = "For a wl_pointer.axis event, the wl_pointer.axis_relative_direction"]
            #[doc = "event specifies the movement direction of the entity causing the"]
            #[doc = "wl_pointer.axis event. For example:"]
            #[doc = "- if a user's fingers on a touchpad move down and this"]
            #[doc = "causes a wl_pointer.axis vertical_scroll down event, the physical"]
            #[doc = "direction is 'identical'"]
            #[doc = "- if a user's fingers on a touchpad move down and this causes a"]
            #[doc = "wl_pointer.axis vertical_scroll up scroll up event ('natural"]
            #[doc = "scrolling'), the physical direction is 'inverted'."]
            #[doc = ""]
            #[doc = "A client may use this information to adjust scroll motion of"]
            #[doc = "components. Specifically, enabling natural scrolling causes the"]
            #[doc = "content to change direction compared to traditional scrolling."]
            #[doc = "Some widgets like volume control sliders should usually match the"]
            #[doc = "physical direction regardless of whether natural scrolling is"]
            #[doc = "active. This event enables clients to match the scroll direction of"]
            #[doc = "a widget to the physical direction."]
            #[doc = ""]
            #[doc = "This event does not occur on its own, it is coupled with a"]
            #[doc = "wl_pointer.axis event that represents this axis value."]
            #[doc = "The protocol guarantees that each axis_relative_direction event is"]
            #[doc = "always followed by exactly one axis event with the same"]
            #[doc = "axis number within the same wl_pointer.frame. Note that the protocol"]
            #[doc = "allows for other events to occur between the axis_relative_direction"]
            #[doc = "and its coupled axis event."]
            #[doc = ""]
            #[doc = "The axis number is identical to the axis number in the associated"]
            #[doc = "axis event."]
            #[doc = ""]
            #[doc = "The order of wl_pointer.axis_relative_direction,"]
            #[doc = "wl_pointer.axis_discrete and wl_pointer.axis_source is not"]
            #[doc = "guaranteed."]
            async fn axis_relative_direction(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod wl_keyboard {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum KeymapFormat {
            NoKeymap = 0u32,
            XkbV1 = 1u32,
        }
        impl TryFrom<u32> for KeymapFormat {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum KeyState {
            Released = 0u32,
            Pressed = 1u32,
        }
        impl TryFrom<u32> for KeyState {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "The wl_keyboard interface represents one or more keyboards"]
        #[doc = "associated with a seat."]
        #[doc = ""]
        #[doc = "Each wl_keyboard has the following logical state:"]
        #[doc = ""]
        #[doc = "- an active surface (possibly null),"]
        #[doc = "- the keys currently logically down,"]
        #[doc = "- the active modifiers,"]
        #[doc = "- the active group."]
        #[doc = ""]
        #[doc = "By default, the active surface is null, the keys currently logically down"]
        #[doc = "are empty, the active modifiers and the active group are 0."]
        pub trait WlKeyboard: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_keyboard";
            const VERSION: u32 = 9u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_keyboard#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event provides a file descriptor to the client which can be"]
            #[doc = "memory-mapped in read-only mode to provide a keyboard mapping"]
            #[doc = "description."]
            #[doc = ""]
            #[doc = "From version 7 onwards, the fd must be mapped with MAP_PRIVATE by"]
            #[doc = "the recipient, as MAP_SHARED may fail."]
            async fn keymap(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notification that this seat's keyboard focus is on a certain"]
            #[doc = "surface."]
            #[doc = ""]
            #[doc = "The compositor must send the wl_keyboard.modifiers event after this"]
            #[doc = "event."]
            #[doc = ""]
            #[doc = "In the wl_keyboard logical state, this event sets the active surface to"]
            #[doc = "the surface argument and the keys currently logically down to the keys"]
            #[doc = "in the keys argument. The compositor must not send this event if the"]
            #[doc = "wl_keyboard already had an active surface immediately before this event."]
            async fn enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notification that this seat's keyboard focus is no longer on"]
            #[doc = "a certain surface."]
            #[doc = ""]
            #[doc = "The leave notification is sent before the enter notification"]
            #[doc = "for the new focus."]
            #[doc = ""]
            #[doc = "In the wl_keyboard logical state, this event resets all values to their"]
            #[doc = "defaults. The compositor must not send this event if the active surface"]
            #[doc = "of the wl_keyboard was not equal to the surface argument immediately"]
            #[doc = "before this event."]
            async fn leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "A key was pressed or released."]
            #[doc = "The time argument is a timestamp with millisecond"]
            #[doc = "granularity, with an undefined base."]
            #[doc = ""]
            #[doc = "The key is a platform-specific key code that can be interpreted"]
            #[doc = "by feeding it to the keyboard mapping (see the keymap event)."]
            #[doc = ""]
            #[doc = "If this event produces a change in modifiers, then the resulting"]
            #[doc = "wl_keyboard.modifiers event must be sent after this event."]
            #[doc = ""]
            #[doc = "In the wl_keyboard logical state, this event adds the key to the keys"]
            #[doc = "currently logically down (if the state argument is pressed) or removes"]
            #[doc = "the key from the keys currently logically down (if the state argument is"]
            #[doc = "released). The compositor must not send this event if the wl_keyboard"]
            #[doc = "did not have an active surface immediately before this event. The"]
            #[doc = "compositor must not send this event if state is pressed (resp. released)"]
            #[doc = "and the key was already logically down (resp. was not logically down)"]
            #[doc = "immediately before this event."]
            async fn key(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notifies clients that the modifier and/or group state has"]
            #[doc = "changed, and it should update its local state."]
            #[doc = ""]
            #[doc = "The compositor may send this event without a surface of the client"]
            #[doc = "having keyboard focus, for example to tie modifier information to"]
            #[doc = "pointer focus instead. If a modifier event with pressed modifiers is sent"]
            #[doc = "without a prior enter event, the client can assume the modifier state is"]
            #[doc = "valid until it receives the next wl_keyboard.modifiers event. In order to"]
            #[doc = "reset the modifier state again, the compositor can send a"]
            #[doc = "wl_keyboard.modifiers event with no pressed modifiers."]
            #[doc = ""]
            #[doc = "In the wl_keyboard logical state, this event updates the modifiers and"]
            #[doc = "group."]
            async fn modifiers(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Informs the client about the keyboard's repeat rate and delay."]
            #[doc = ""]
            #[doc = "This event is sent as soon as the wl_keyboard object has been created,"]
            #[doc = "and is guaranteed to be received by the client before any key press"]
            #[doc = "event."]
            #[doc = ""]
            #[doc = "Negative values for either rate or delay are illegal. A rate of zero"]
            #[doc = "will disable any repeating (regardless of the value of delay)."]
            #[doc = ""]
            #[doc = "This event can be sent later on as well with a new value if necessary,"]
            #[doc = "so clients should continue listening for the event past the creation"]
            #[doc = "of wl_keyboard."]
            async fn repeat_info(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod wl_touch {
        #[doc = "The wl_touch interface represents a touchscreen"]
        #[doc = "associated with a seat."]
        #[doc = ""]
        #[doc = "Touch interactions can consist of one or more contacts."]
        #[doc = "For each contact, a series of events is generated, starting"]
        #[doc = "with a down event, followed by zero or more motion events,"]
        #[doc = "and ending with an up event. Events relating to the same"]
        #[doc = "contact point can be identified by the ID of the sequence."]
        pub trait WlTouch: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_touch";
            const VERSION: u32 = 9u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_touch#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "A new touch point has appeared on the surface. This touch point is"]
            #[doc = "assigned a unique ID. Future events from this touch point reference"]
            #[doc = "this ID. The ID ceases to be valid after a touch up event and may be"]
            #[doc = "reused in the future."]
            async fn down(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The touch point has disappeared. No further events will be sent for"]
            #[doc = "this touch point and the touch point's ID is released and may be"]
            #[doc = "reused in a future touch down event."]
            async fn up(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "A touch point has changed coordinates."]
            async fn motion(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Indicates the end of a set of events that logically belong together."]
            #[doc = "A client is expected to accumulate the data in all events within the"]
            #[doc = "frame before proceeding."]
            #[doc = ""]
            #[doc = "A wl_touch.frame terminates at least one event but otherwise no"]
            #[doc = "guarantee is provided about the set of events within a frame. A client"]
            #[doc = "must assume that any state not updated in a frame is unchanged from the"]
            #[doc = "previously known state."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent if the compositor decides the touch stream is a global"]
            #[doc = "gesture. No further events are sent to the clients from that"]
            #[doc = "particular gesture. Touch cancellation applies to all touch points"]
            #[doc = "currently active on this client's surface. The client is"]
            #[doc = "responsible for finalizing the touch points, future touch points on"]
            #[doc = "this surface may reuse the touch point ID."]
            #[doc = ""]
            #[doc = "No frame event is required after the cancel event."]
            async fn cancel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent when a touchpoint has changed its shape."]
            #[doc = ""]
            #[doc = "This event does not occur on its own. It is sent before a"]
            #[doc = "wl_touch.frame event and carries the new shape information for"]
            #[doc = "any previously reported, or new touch points of that frame."]
            #[doc = ""]
            #[doc = "Other events describing the touch point such as wl_touch.down,"]
            #[doc = "wl_touch.motion or wl_touch.orientation may be sent within the"]
            #[doc = "same wl_touch.frame. A client should treat these events as a single"]
            #[doc = "logical touch point update. The order of wl_touch.shape,"]
            #[doc = "wl_touch.orientation and wl_touch.motion is not guaranteed."]
            #[doc = "A wl_touch.down event is guaranteed to occur before the first"]
            #[doc = "wl_touch.shape event for this touch ID but both events may occur within"]
            #[doc = "the same wl_touch.frame."]
            #[doc = ""]
            #[doc = "A touchpoint shape is approximated by an ellipse through the major and"]
            #[doc = "minor axis length. The major axis length describes the longer diameter"]
            #[doc = "of the ellipse, while the minor axis length describes the shorter"]
            #[doc = "diameter. Major and minor are orthogonal and both are specified in"]
            #[doc = "surface-local coordinates. The center of the ellipse is always at the"]
            #[doc = "touchpoint location as reported by wl_touch.down or wl_touch.move."]
            #[doc = ""]
            #[doc = "This event is only sent by the compositor if the touch device supports"]
            #[doc = "shape reports. The client has to make reasonable assumptions about the"]
            #[doc = "shape if it did not receive this event."]
            async fn shape(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent when a touchpoint has changed its orientation."]
            #[doc = ""]
            #[doc = "This event does not occur on its own. It is sent before a"]
            #[doc = "wl_touch.frame event and carries the new shape information for"]
            #[doc = "any previously reported, or new touch points of that frame."]
            #[doc = ""]
            #[doc = "Other events describing the touch point such as wl_touch.down,"]
            #[doc = "wl_touch.motion or wl_touch.shape may be sent within the"]
            #[doc = "same wl_touch.frame. A client should treat these events as a single"]
            #[doc = "logical touch point update. The order of wl_touch.shape,"]
            #[doc = "wl_touch.orientation and wl_touch.motion is not guaranteed."]
            #[doc = "A wl_touch.down event is guaranteed to occur before the first"]
            #[doc = "wl_touch.orientation event for this touch ID but both events may occur"]
            #[doc = "within the same wl_touch.frame."]
            #[doc = ""]
            #[doc = "The orientation describes the clockwise angle of a touchpoint's major"]
            #[doc = "axis to the positive surface y-axis and is normalized to the -180 to"]
            #[doc = "+180 degree range. The granularity of orientation depends on the touch"]
            #[doc = "device, some devices only support binary rotation values between 0 and"]
            #[doc = "90 degrees."]
            #[doc = ""]
            #[doc = "This event is only sent by the compositor if the touch device supports"]
            #[doc = "orientation reports."]
            async fn orientation(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod wl_output {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Subpixel {
            Unknown = 0u32,
            None = 1u32,
            HorizontalRgb = 2u32,
            HorizontalBgr = 3u32,
            VerticalRgb = 4u32,
            VerticalBgr = 5u32,
        }
        impl TryFrom<u32> for Subpixel {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Transform {
            Normal = 0u32,
            _90 = 1u32,
            _180 = 2u32,
            _270 = 3u32,
            Flipped = 4u32,
            Flipped90 = 5u32,
            Flipped180 = 6u32,
            Flipped270 = 7u32,
        }
        impl TryFrom<u32> for Transform {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! { # [doc = "These flags describe properties of an output mode."] # [doc = "They are used in the flags bitfield of the mode event."] # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Mode : u32 { # [doc = "indicates this is the current mode"] const Current = 1u32 ; # [doc = "indicates this is the preferred mode"] const Preferred = 2u32 ; } }
        impl TryFrom<u32> for Mode {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "An output describes part of the compositor geometry.  The"]
        #[doc = "compositor works in the 'compositor coordinate system' and an"]
        #[doc = "output corresponds to a rectangular area in that space that is"]
        #[doc = "actually visible.  This typically corresponds to a monitor that"]
        #[doc = "displays part of the compositor space.  This object is published"]
        #[doc = "as global during start up, or when a monitor is hotplugged."]
        pub trait WlOutput: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_output";
            const VERSION: u32 = 4u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_output#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Using this request a client can tell the server that it is not going to"]
            #[doc = "use the output object anymore."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The geometry event describes geometric properties of the output."]
            #[doc = "The event is sent when binding to the output object and whenever"]
            #[doc = "any of the properties change."]
            #[doc = ""]
            #[doc = "The physical size can be set to zero if it doesn't make sense for this"]
            #[doc = "output (e.g. for projectors or virtual outputs)."]
            #[doc = ""]
            #[doc = "The geometry event will be followed by a done event (starting from"]
            #[doc = "version 2)."]
            #[doc = ""]
            #[doc = "Clients should use wl_surface.preferred_buffer_transform instead of the"]
            #[doc = "transform advertised by this event to find the preferred buffer"]
            #[doc = "transform to use for a surface."]
            #[doc = ""]
            #[doc = "Note: wl_output only advertises partial information about the output"]
            #[doc = "position and identification. Some compositors, for instance those not"]
            #[doc = "implementing a desktop-style output layout or those exposing virtual"]
            #[doc = "outputs, might fake this information. Instead of using x and y, clients"]
            #[doc = "should use xdg_output.logical_position. Instead of using make and model,"]
            #[doc = "clients should use name and description."]
            async fn geometry(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The mode event describes an available mode for the output."]
            #[doc = ""]
            #[doc = "The event is sent when binding to the output object and there"]
            #[doc = "will always be one mode, the current mode.  The event is sent"]
            #[doc = "again if an output changes mode, for the mode that is now"]
            #[doc = "current.  In other words, the current mode is always the last"]
            #[doc = "mode that was received with the current flag set."]
            #[doc = ""]
            #[doc = "Non-current modes are deprecated. A compositor can decide to only"]
            #[doc = "advertise the current mode and never send other modes. Clients"]
            #[doc = "should not rely on non-current modes."]
            #[doc = ""]
            #[doc = "The size of a mode is given in physical hardware units of"]
            #[doc = "the output device. This is not necessarily the same as"]
            #[doc = "the output size in the global compositor space. For instance,"]
            #[doc = "the output may be scaled, as described in wl_output.scale,"]
            #[doc = "or transformed, as described in wl_output.transform. Clients"]
            #[doc = "willing to retrieve the output size in the global compositor"]
            #[doc = "space should use xdg_output.logical_size instead."]
            #[doc = ""]
            #[doc = "The vertical refresh rate can be set to zero if it doesn't make"]
            #[doc = "sense for this output (e.g. for virtual outputs)."]
            #[doc = ""]
            #[doc = "The mode event will be followed by a done event (starting from"]
            #[doc = "version 2)."]
            #[doc = ""]
            #[doc = "Clients should not use the refresh rate to schedule frames. Instead,"]
            #[doc = "they should use the wl_surface.frame event or the presentation-time"]
            #[doc = "protocol."]
            #[doc = ""]
            #[doc = "Note: this information is not always meaningful for all outputs. Some"]
            #[doc = "compositors, such as those exposing virtual outputs, might fake the"]
            #[doc = "refresh rate or the size."]
            async fn mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent after all other properties have been"]
            #[doc = "sent after binding to the output object and after any"]
            #[doc = "other property changes done after that. This allows"]
            #[doc = "changes to the output properties to be seen as"]
            #[doc = "atomic, even if they happen via multiple events."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event contains scaling geometry information"]
            #[doc = "that is not in the geometry event. It may be sent after"]
            #[doc = "binding the output object or if the output scale changes"]
            #[doc = "later. The compositor will emit a non-zero, positive"]
            #[doc = "value for scale. If it is not sent, the client should"]
            #[doc = "assume a scale of 1."]
            #[doc = ""]
            #[doc = "A scale larger than 1 means that the compositor will"]
            #[doc = "automatically scale surface buffers by this amount"]
            #[doc = "when rendering. This is used for very high resolution"]
            #[doc = "displays where applications rendering at the native"]
            #[doc = "resolution would be too small to be legible."]
            #[doc = ""]
            #[doc = "Clients should use wl_surface.preferred_buffer_scale"]
            #[doc = "instead of this event to find the preferred buffer"]
            #[doc = "scale to use for a surface."]
            #[doc = ""]
            #[doc = "The scale event will be followed by a done event."]
            async fn scale(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Many compositors will assign user-friendly names to their outputs, show"]
            #[doc = "them to the user, allow the user to refer to an output, etc. The client"]
            #[doc = "may wish to know this name as well to offer the user similar behaviors."]
            #[doc = ""]
            #[doc = "The name is a UTF-8 string with no convention defined for its contents."]
            #[doc = "Each name is unique among all wl_output globals. The name is only"]
            #[doc = "guaranteed to be unique for the compositor instance."]
            #[doc = ""]
            #[doc = "The same output name is used for all clients for a given wl_output"]
            #[doc = "global. Thus, the name can be shared across processes to refer to a"]
            #[doc = "specific wl_output global."]
            #[doc = ""]
            #[doc = "The name is not guaranteed to be persistent across sessions, thus cannot"]
            #[doc = "be used to reliably identify an output in e.g. configuration files."]
            #[doc = ""]
            #[doc = "Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do"]
            #[doc = "not assume that the name is a reflection of an underlying DRM connector,"]
            #[doc = "X11 connection, etc."]
            #[doc = ""]
            #[doc = "The name event is sent after binding the output object. This event is"]
            #[doc = "only sent once per output object, and the name does not change over the"]
            #[doc = "lifetime of the wl_output global."]
            #[doc = ""]
            #[doc = "Compositors may re-use the same output name if the wl_output global is"]
            #[doc = "destroyed and re-created later. Compositors should avoid re-using the"]
            #[doc = "same name if possible."]
            #[doc = ""]
            #[doc = "The name event will be followed by a done event."]
            async fn name(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Many compositors can produce human-readable descriptions of their"]
            #[doc = "outputs. The client may wish to know this description as well, e.g. for"]
            #[doc = "output selection purposes."]
            #[doc = ""]
            #[doc = "The description is a UTF-8 string with no convention defined for its"]
            #[doc = "contents. The description is not guaranteed to be unique among all"]
            #[doc = "wl_output globals. Examples might include 'Foocorp 11\" Display' or"]
            #[doc = "'Virtual X11 output via :1'."]
            #[doc = ""]
            #[doc = "The description event is sent after binding the output object and"]
            #[doc = "whenever the description changes. The description is optional, and may"]
            #[doc = "not be sent at all."]
            #[doc = ""]
            #[doc = "The description event will be followed by a done event."]
            async fn description(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod wl_region {
        #[doc = "A region object describes an area."]
        #[doc = ""]
        #[doc = "Region objects are used to describe the opaque and input"]
        #[doc = "regions of a surface."]
        pub trait WlRegion: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_region";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_region#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("wl_region#{}.add()", object.id);
                        self.add(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("wl_region#{}.subtract()", object.id);
                        self.subtract(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the region.  This will invalidate the object ID."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Add the specified rectangle to the region."]
            async fn add(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Subtract the specified rectangle from the region."]
            async fn subtract(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wl_subcompositor {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            BadSurface = 0u32,
            BadParent = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "The global interface exposing sub-surface compositing capabilities."]
        #[doc = "A wl_surface, that has sub-surfaces associated, is called the"]
        #[doc = "parent surface. Sub-surfaces can be arbitrarily nested and create"]
        #[doc = "a tree of sub-surfaces."]
        #[doc = ""]
        #[doc = "The root surface in a tree of sub-surfaces is the main"]
        #[doc = "surface. The main surface cannot be a sub-surface, because"]
        #[doc = "sub-surfaces must always have a parent."]
        #[doc = ""]
        #[doc = "A main surface with its sub-surfaces forms a (compound) window."]
        #[doc = "For window management purposes, this set of wl_surface objects is"]
        #[doc = "to be considered as a single window, and it should also behave as"]
        #[doc = "such."]
        #[doc = ""]
        #[doc = "The aim of sub-surfaces is to offload some of the compositing work"]
        #[doc = "within a window from clients to the compositor. A prime example is"]
        #[doc = "a video player with decorations and video in separate wl_surface"]
        #[doc = "objects. This should allow the compositor to pass YUV video buffer"]
        #[doc = "processing to dedicated overlay hardware when possible."]
        pub trait WlSubcompositor: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_subcompositor";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_subcompositor#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("wl_subcompositor#{}.get_subsurface()", object.id);
                        self.get_subsurface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Informs the server that the client will not be using this"]
            #[doc = "protocol object anymore. This does not affect any other"]
            #[doc = "objects, wl_subsurface objects included."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a sub-surface interface for the given surface, and"]
            #[doc = "associate it with the given parent surface. This turns a"]
            #[doc = "plain wl_surface into a sub-surface."]
            #[doc = ""]
            #[doc = "The to-be sub-surface must not already have another role, and it"]
            #[doc = "must not have an existing wl_subsurface object. Otherwise the"]
            #[doc = "bad_surface protocol error is raised."]
            #[doc = ""]
            #[doc = "Adding sub-surfaces to a parent is a double-buffered operation on the"]
            #[doc = "parent (see wl_surface.commit). The effect of adding a sub-surface"]
            #[doc = "becomes visible on the next time the state of the parent surface is"]
            #[doc = "applied."]
            #[doc = ""]
            #[doc = "The parent surface must not be one of the child surface's descendants,"]
            #[doc = "and the parent must be different from the child surface, otherwise the"]
            #[doc = "bad_parent protocol error is raised."]
            #[doc = ""]
            #[doc = "This request modifies the behaviour of wl_surface.commit request on"]
            #[doc = "the sub-surface, see the documentation on wl_subsurface interface."]
            async fn get_subsurface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
                parent: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wl_subsurface {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            BadSurface = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "An additional interface to a wl_surface object, which has been"]
        #[doc = "made a sub-surface. A sub-surface has one parent surface. A"]
        #[doc = "sub-surface's size and position are not limited to that of the parent."]
        #[doc = "Particularly, a sub-surface is not automatically clipped to its"]
        #[doc = "parent's area."]
        #[doc = ""]
        #[doc = "A sub-surface becomes mapped, when a non-NULL wl_buffer is applied"]
        #[doc = "and the parent surface is mapped. The order of which one happens"]
        #[doc = "first is irrelevant. A sub-surface is hidden if the parent becomes"]
        #[doc = "hidden, or if a NULL wl_buffer is applied. These rules apply"]
        #[doc = "recursively through the tree of surfaces."]
        #[doc = ""]
        #[doc = "The behaviour of a wl_surface.commit request on a sub-surface"]
        #[doc = "depends on the sub-surface's mode. The possible modes are"]
        #[doc = "synchronized and desynchronized, see methods"]
        #[doc = "wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized"]
        #[doc = "mode caches the wl_surface state to be applied when the parent's"]
        #[doc = "state gets applied, and desynchronized mode applies the pending"]
        #[doc = "wl_surface state directly. A sub-surface is initially in the"]
        #[doc = "synchronized mode."]
        #[doc = ""]
        #[doc = "Sub-surfaces also have another kind of state, which is managed by"]
        #[doc = "wl_subsurface requests, as opposed to wl_surface requests. This"]
        #[doc = "state includes the sub-surface position relative to the parent"]
        #[doc = "surface (wl_subsurface.set_position), and the stacking order of"]
        #[doc = "the parent and its sub-surfaces (wl_subsurface.place_above and"]
        #[doc = ".place_below). This state is applied when the parent surface's"]
        #[doc = "wl_surface state is applied, regardless of the sub-surface's mode."]
        #[doc = "As the exception, set_sync and set_desync are effective immediately."]
        #[doc = ""]
        #[doc = "The main surface can be thought to be always in desynchronized mode,"]
        #[doc = "since it does not have a parent in the sub-surfaces sense."]
        #[doc = ""]
        #[doc = "Even if a sub-surface is in desynchronized mode, it will behave as"]
        #[doc = "in synchronized mode, if its parent surface behaves as in"]
        #[doc = "synchronized mode. This rule is applied recursively throughout the"]
        #[doc = "tree of surfaces. This means, that one can set a sub-surface into"]
        #[doc = "synchronized mode, and then assume that all its child and grand-child"]
        #[doc = "sub-surfaces are synchronized, too, without explicitly setting them."]
        #[doc = ""]
        #[doc = "Destroying a sub-surface takes effect immediately. If you need to"]
        #[doc = "synchronize the removal of a sub-surface to the parent surface update,"]
        #[doc = "unmap the sub-surface first by attaching a NULL wl_buffer, update parent,"]
        #[doc = "and then destroy the sub-surface."]
        #[doc = ""]
        #[doc = "If the parent wl_surface object is destroyed, the sub-surface is"]
        #[doc = "unmapped."]
        #[doc = ""]
        #[doc = "A sub-surface never has the keyboard focus of any seat."]
        #[doc = ""]
        #[doc = "The wl_surface.offset request is ignored: clients must use set_position"]
        #[doc = "instead to move the sub-surface."]
        pub trait WlSubsurface: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_subsurface";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_subsurface#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("wl_subsurface#{}.set_position()", object.id);
                        self.set_position(object, client, message.int()?, message.int()?)
                            .await
                    }
                    2u16 => {
                        tracing::debug!("wl_subsurface#{}.place_above()", object.id);
                        self.place_above(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("wl_subsurface#{}.place_below()", object.id);
                        self.place_below(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("wl_subsurface#{}.set_sync()", object.id);
                        self.set_sync(object, client).await
                    }
                    5u16 => {
                        tracing::debug!("wl_subsurface#{}.set_desync()", object.id);
                        self.set_desync(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "The sub-surface interface is removed from the wl_surface object"]
            #[doc = "that was turned into a sub-surface with a"]
            #[doc = "wl_subcompositor.get_subsurface request. The wl_surface's association"]
            #[doc = "to the parent is deleted. The wl_surface is unmapped immediately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This schedules a sub-surface position change."]
            #[doc = "The sub-surface will be moved so that its origin (top left"]
            #[doc = "corner pixel) will be at the location x, y of the parent surface"]
            #[doc = "coordinate system. The coordinates are not restricted to the parent"]
            #[doc = "surface area. Negative values are allowed."]
            #[doc = ""]
            #[doc = "The scheduled coordinates will take effect whenever the state of the"]
            #[doc = "parent surface is applied."]
            #[doc = ""]
            #[doc = "If more than one set_position request is invoked by the client before"]
            #[doc = "the commit of the parent surface, the position of a new request always"]
            #[doc = "replaces the scheduled position from any previous request."]
            #[doc = ""]
            #[doc = "The initial position is 0, 0."]
            async fn set_position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "This sub-surface is taken from the stack, and put back just"]
            #[doc = "above the reference surface, changing the z-order of the sub-surfaces."]
            #[doc = "The reference surface must be one of the sibling surfaces, or the"]
            #[doc = "parent surface. Using any other surface, including this sub-surface,"]
            #[doc = "will cause a protocol error."]
            #[doc = ""]
            #[doc = "The z-order is double-buffered. Requests are handled in order and"]
            #[doc = "applied immediately to a pending state. The final pending state is"]
            #[doc = "copied to the active state the next time the state of the parent"]
            #[doc = "surface is applied."]
            #[doc = ""]
            #[doc = "A new sub-surface is initially added as the top-most in the stack"]
            #[doc = "of its siblings and parent."]
            async fn place_above(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                sibling: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "The sub-surface is placed just below the reference surface."]
            #[doc = "See wl_subsurface.place_above."]
            async fn place_below(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                sibling: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Change the commit behaviour of the sub-surface to synchronized"]
            #[doc = "mode, also described as the parent dependent mode."]
            #[doc = ""]
            #[doc = "In synchronized mode, wl_surface.commit on a sub-surface will"]
            #[doc = "accumulate the committed state in a cache, but the state will"]
            #[doc = "not be applied and hence will not change the compositor output."]
            #[doc = "The cached state is applied to the sub-surface immediately after"]
            #[doc = "the parent surface's state is applied. This ensures atomic"]
            #[doc = "updates of the parent and all its synchronized sub-surfaces."]
            #[doc = "Applying the cached state will invalidate the cache, so further"]
            #[doc = "parent surface commits do not (re-)apply old state."]
            #[doc = ""]
            #[doc = "See wl_subsurface for the recursive effect of this mode."]
            async fn set_sync(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Change the commit behaviour of the sub-surface to desynchronized"]
            #[doc = "mode, also described as independent or freely running mode."]
            #[doc = ""]
            #[doc = "In desynchronized mode, wl_surface.commit on a sub-surface will"]
            #[doc = "apply the pending state directly, without caching, as happens"]
            #[doc = "normally with a wl_surface. Calling wl_surface.commit on the"]
            #[doc = "parent surface has no effect on the sub-surface's wl_surface"]
            #[doc = "state. This mode allows a sub-surface to be updated on its own."]
            #[doc = ""]
            #[doc = "If cached state exists when wl_surface.commit is called in"]
            #[doc = "desynchronized mode, the pending state is added to the cached"]
            #[doc = "state, and applied as a whole. This invalidates the cache."]
            #[doc = ""]
            #[doc = "Note: even if a sub-surface is set to desynchronized, a parent"]
            #[doc = "sub-surface may override it to behave as synchronized. For details,"]
            #[doc = "see wl_subsurface."]
            #[doc = ""]
            #[doc = "If a surface's parent surface behaves as desynchronized, then"]
            #[doc = "the cached state is applied on set_desync."]
            async fn set_desync(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod linux_dmabuf_v1 {
    pub mod zwp_linux_dmabuf_v1 {
        #[doc = "Following the interfaces from:"]
        #[doc = "https://www.khronos.org/registry/egl/extensions/EXT/EGL_EXT_image_dma_buf_import.txt"]
        #[doc = "https://www.khronos.org/registry/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import_modifiers.txt"]
        #[doc = "and the Linux DRM sub-system's AddFb2 ioctl."]
        #[doc = ""]
        #[doc = "This interface offers ways to create generic dmabuf-based wl_buffers."]
        #[doc = ""]
        #[doc = "Clients can use the get_surface_feedback request to get dmabuf feedback"]
        #[doc = "for a particular surface. If the client wants to retrieve feedback not"]
        #[doc = "tied to a surface, they can use the get_default_feedback request."]
        #[doc = ""]
        #[doc = "The following are required from clients:"]
        #[doc = ""]
        #[doc = "- Clients must ensure that either all data in the dma-buf is"]
        #[doc = "coherent for all subsequent read access or that coherency is"]
        #[doc = "correctly handled by the underlying kernel-side dma-buf"]
        #[doc = "implementation."]
        #[doc = ""]
        #[doc = "- Don't make any more attachments after sending the buffer to the"]
        #[doc = "compositor. Making more attachments later increases the risk of"]
        #[doc = "the compositor not being able to use (re-import) an existing"]
        #[doc = "dmabuf-based wl_buffer."]
        #[doc = ""]
        #[doc = "The underlying graphics stack must ensure the following:"]
        #[doc = ""]
        #[doc = "- The dmabuf file descriptors relayed to the server will stay valid"]
        #[doc = "for the whole lifetime of the wl_buffer. This means the server may"]
        #[doc = "at any time use those fds to import the dmabuf into any kernel"]
        #[doc = "sub-system that might accept it."]
        #[doc = ""]
        #[doc = "However, when the underlying graphics stack fails to deliver the"]
        #[doc = "promise, because of e.g. a device hot-unplug which raises internal"]
        #[doc = "errors, after the wl_buffer has been successfully created the"]
        #[doc = "compositor must not raise protocol errors to the client when dmabuf"]
        #[doc = "import later fails."]
        #[doc = ""]
        #[doc = "To create a wl_buffer from one or more dmabufs, a client creates a"]
        #[doc = "zwp_linux_dmabuf_params_v1 object with a zwp_linux_dmabuf_v1.create_params"]
        #[doc = "request. All planes required by the intended format are added with"]
        #[doc = "the 'add' request. Finally, a 'create' or 'create_immed' request is"]
        #[doc = "issued, which has the following outcome depending on the import success."]
        #[doc = ""]
        #[doc = "The 'create' request,"]
        #[doc = "- on success, triggers a 'created' event which provides the final"]
        #[doc = "wl_buffer to the client."]
        #[doc = "- on failure, triggers a 'failed' event to convey that the server"]
        #[doc = "cannot use the dmabufs received from the client."]
        #[doc = ""]
        #[doc = "For the 'create_immed' request,"]
        #[doc = "- on success, the server immediately imports the added dmabufs to"]
        #[doc = "create a wl_buffer. No event is sent from the server in this case."]
        #[doc = "- on failure, the server can choose to either:"]
        #[doc = "- terminate the client by raising a fatal error."]
        #[doc = "- mark the wl_buffer as failed, and send a 'failed' event to the"]
        #[doc = "client. If the client uses a failed wl_buffer as an argument to any"]
        #[doc = "request, the behaviour is compositor implementation-defined."]
        #[doc = ""]
        #[doc = "For all DRM formats and unless specified in another protocol extension,"]
        #[doc = "pre-multiplied alpha is used for pixel values."]
        #[doc = ""]
        #[doc = "Unless specified otherwise in another protocol extension, implicit"]
        #[doc = "synchronization is used. In other words, compositors and clients must"]
        #[doc = "wait and signal fences implicitly passed via the DMA-BUF's reservation"]
        #[doc = "mechanism."]
        pub trait ZwpLinuxDmabufV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_dmabuf_v1";
            const VERSION: u32 = 5u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.create_params()", object.id);
                        self.create_params(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.get_default_feedback()", object.id);
                        self.get_default_feedback(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.get_surface_feedback()", object.id);
                        self.get_surface_feedback(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Objects created through this interface, especially wl_buffers, will"]
            #[doc = "remain valid."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This temporary object is used to collect multiple dmabuf handles into"]
            #[doc = "a single batch to create a wl_buffer. It can only be used once and"]
            #[doc = "should be destroyed after a 'created' or 'failed' event has been"]
            #[doc = "received."]
            async fn create_params(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                params_id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This request creates a new wp_linux_dmabuf_feedback object not bound"]
            #[doc = "to a particular surface. This object will deliver feedback about dmabuf"]
            #[doc = "parameters to use if the client doesn't support per-surface feedback"]
            #[doc = "(see get_surface_feedback)."]
            async fn get_default_feedback(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This request creates a new wp_linux_dmabuf_feedback object for the"]
            #[doc = "specified wl_surface. This object will deliver feedback about dmabuf"]
            #[doc = "parameters to use for buffers attached to this surface."]
            #[doc = ""]
            #[doc = "If the surface is destroyed before the wp_linux_dmabuf_feedback object,"]
            #[doc = "the feedback object becomes inert."]
            async fn get_surface_feedback(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This event advertises one buffer format that the server supports."]
            #[doc = "All the supported formats are advertised once when the client"]
            #[doc = "binds to this interface. A roundtrip after binding guarantees"]
            #[doc = "that the client has received all supported formats."]
            #[doc = ""]
            #[doc = "For the definition of the format codes, see the"]
            #[doc = "zwp_linux_buffer_params_v1::create request."]
            #[doc = ""]
            #[doc = "Starting version 4, the format event is deprecated and must not be"]
            #[doc = "sent by compositors. Instead, use get_default_feedback or"]
            #[doc = "get_surface_feedback."]
            async fn format(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event advertises the formats that the server supports, along with"]
            #[doc = "the modifiers supported for each format. All the supported modifiers"]
            #[doc = "for all the supported formats are advertised once when the client"]
            #[doc = "binds to this interface. A roundtrip after binding guarantees that"]
            #[doc = "the client has received all supported format-modifier pairs."]
            #[doc = ""]
            #[doc = "For legacy support, DRM_FORMAT_MOD_INVALID (that is, modifier_hi =="]
            #[doc = "0x00ffffff and modifier_lo == 0xffffffff) is allowed in this event."]
            #[doc = "It indicates that the server can support the format with an implicit"]
            #[doc = "modifier. When a plane has DRM_FORMAT_MOD_INVALID as its modifier, it"]
            #[doc = "is as if no explicit modifier is specified. The effective modifier"]
            #[doc = "will be derived from the dmabuf."]
            #[doc = ""]
            #[doc = "A compositor that sends valid modifiers and DRM_FORMAT_MOD_INVALID for"]
            #[doc = "a given format supports both explicit modifiers and implicit modifiers."]
            #[doc = ""]
            #[doc = "For the definition of the format and modifier codes, see the"]
            #[doc = "zwp_linux_buffer_params_v1::create and zwp_linux_buffer_params_v1::add"]
            #[doc = "requests."]
            #[doc = ""]
            #[doc = "Starting version 4, the modifier event is deprecated and must not be"]
            #[doc = "sent by compositors. Instead, use get_default_feedback or"]
            #[doc = "get_surface_feedback."]
            async fn modifier(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_linux_buffer_params_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            AlreadyUsed = 0u32,
            PlaneIdx = 1u32,
            PlaneSet = 2u32,
            Incomplete = 3u32,
            InvalidFormat = 4u32,
            InvalidDimensions = 5u32,
            OutOfBounds = 6u32,
            InvalidWlBuffer = 7u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! { # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Flags : u32 { # [doc = "contents are y-inverted"] const YInvert = 1u32 ; # [doc = "content is interlaced"] const Interlaced = 2u32 ; # [doc = "bottom field first"] const BottomFirst = 4u32 ; } }
        impl TryFrom<u32> for Flags {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "This temporary object is a collection of dmabufs and other"]
        #[doc = "parameters that together form a single logical buffer. The temporary"]
        #[doc = "object may eventually create one wl_buffer unless cancelled by"]
        #[doc = "destroying it before requesting 'create'."]
        #[doc = ""]
        #[doc = "Single-planar formats only require one dmabuf, however"]
        #[doc = "multi-planar formats may require more than one dmabuf. For all"]
        #[doc = "formats, an 'add' request must be called once per plane (even if the"]
        #[doc = "underlying dmabuf fd is identical)."]
        #[doc = ""]
        #[doc = "You must use consecutive plane indices ('plane_idx' argument for 'add')"]
        #[doc = "from zero to the number of planes used by the drm_fourcc format code."]
        #[doc = "All planes required by the format must be given exactly once, but can"]
        #[doc = "be given in any order. Each plane index can be set only once."]
        pub trait ZwpLinuxBufferParamsV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_buffer_params_v1";
            const VERSION: u32 = 5u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.add()", object.id);
                        self.add(
                            object,
                            client,
                            message.fd()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.create()", object.id);
                        self.create(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.uint()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.create_immed()", object.id);
                        self.create_immed(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.uint()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Cleans up the temporary data sent to the server for dmabuf-based"]
            #[doc = "wl_buffer creation."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This request adds one dmabuf to the set in this"]
            #[doc = "zwp_linux_buffer_params_v1."]
            #[doc = ""]
            #[doc = "The 64-bit unsigned value combined from modifier_hi and modifier_lo"]
            #[doc = "is the dmabuf layout modifier. DRM AddFB2 ioctl calls this the"]
            #[doc = "fb modifier, which is defined in drm_mode.h of Linux UAPI."]
            #[doc = "This is an opaque token. Drivers use this token to express tiling,"]
            #[doc = "compression, etc. driver-specific modifications to the base format"]
            #[doc = "defined by the DRM fourcc code."]
            #[doc = ""]
            #[doc = "Starting from version 4, the invalid_format protocol error is sent if"]
            #[doc = "the format + modifier pair was not advertised as supported."]
            #[doc = ""]
            #[doc = "Starting from version 5, the invalid_format protocol error is sent if"]
            #[doc = "all planes don't use the same modifier."]
            #[doc = ""]
            #[doc = "This request raises the PLANE_IDX error if plane_idx is too large."]
            #[doc = "The error PLANE_SET is raised if attempting to set a plane that"]
            #[doc = "was already set."]
            async fn add(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                fd: rustix::fd::OwnedFd,
                plane_idx: u32,
                offset: u32,
                stride: u32,
                modifier_hi: u32,
                modifier_lo: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This asks for creation of a wl_buffer from the added dmabuf"]
            #[doc = "buffers. The wl_buffer is not created immediately but returned via"]
            #[doc = "the 'created' event if the dmabuf sharing succeeds. The sharing"]
            #[doc = "may fail at runtime for reasons a client cannot predict, in"]
            #[doc = "which case the 'failed' event is triggered."]
            #[doc = ""]
            #[doc = "The 'format' argument is a DRM_FORMAT code, as defined by the"]
            #[doc = "libdrm's drm_fourcc.h. The Linux kernel's DRM sub-system is the"]
            #[doc = "authoritative source on how the format codes should work."]
            #[doc = ""]
            #[doc = "The 'flags' is a bitfield of the flags defined in enum \"flags\"."]
            #[doc = "'y_invert' means the that the image needs to be y-flipped."]
            #[doc = ""]
            #[doc = "Flag 'interlaced' means that the frame in the buffer is not"]
            #[doc = "progressive as usual, but interlaced. An interlaced buffer as"]
            #[doc = "supported here must always contain both top and bottom fields."]
            #[doc = "The top field always begins on the first pixel row. The temporal"]
            #[doc = "ordering between the two fields is top field first, unless"]
            #[doc = "'bottom_first' is specified. It is undefined whether 'bottom_first'"]
            #[doc = "is ignored if 'interlaced' is not set."]
            #[doc = ""]
            #[doc = "This protocol does not convey any information about field rate,"]
            #[doc = "duration, or timing, other than the relative ordering between the"]
            #[doc = "two fields in one buffer. A compositor may have to estimate the"]
            #[doc = "intended field rate from the incoming buffer rate. It is undefined"]
            #[doc = "whether the time of receiving wl_surface.commit with a new buffer"]
            #[doc = "attached, applying the wl_surface state, wl_surface.frame callback"]
            #[doc = "trigger, presentation, or any other point in the compositor cycle"]
            #[doc = "is used to measure the frame or field times. There is no support"]
            #[doc = "for detecting missed or late frames/fields/buffers either, and"]
            #[doc = "there is no support whatsoever for cooperating with interlaced"]
            #[doc = "compositor output."]
            #[doc = ""]
            #[doc = "The composited image quality resulting from the use of interlaced"]
            #[doc = "buffers is explicitly undefined. A compositor may use elaborate"]
            #[doc = "hardware features or software to deinterlace and create progressive"]
            #[doc = "output frames from a sequence of interlaced input buffers, or it"]
            #[doc = "may produce substandard image quality. However, compositors that"]
            #[doc = "cannot guarantee reasonable image quality in all cases are recommended"]
            #[doc = "to just reject all interlaced buffers."]
            #[doc = ""]
            #[doc = "Any argument errors, including non-positive width or height,"]
            #[doc = "mismatch between the number of planes and the format, bad"]
            #[doc = "format, bad offset or stride, may be indicated by fatal protocol"]
            #[doc = "errors: INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS,"]
            #[doc = "OUT_OF_BOUNDS."]
            #[doc = ""]
            #[doc = "Dmabuf import errors in the server that are not obvious client"]
            #[doc = "bugs are returned via the 'failed' event as non-fatal. This"]
            #[doc = "allows attempting dmabuf sharing and falling back in the client"]
            #[doc = "if it fails."]
            #[doc = ""]
            #[doc = "This request can be sent only once in the object's lifetime, after"]
            #[doc = "which the only legal request is destroy. This object should be"]
            #[doc = "destroyed after issuing a 'create' request. Attempting to use this"]
            #[doc = "object after issuing 'create' raises ALREADY_USED protocol error."]
            #[doc = ""]
            #[doc = "It is not mandatory to issue 'create'. If a client wants to"]
            #[doc = "cancel the buffer creation, it can just destroy this object."]
            async fn create(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
                format: u32,
                flags: Flags,
            ) -> crate::server::Result<()>;
            #[doc = "This asks for immediate creation of a wl_buffer by importing the"]
            #[doc = "added dmabufs."]
            #[doc = ""]
            #[doc = "In case of import success, no event is sent from the server, and the"]
            #[doc = "wl_buffer is ready to be used by the client."]
            #[doc = ""]
            #[doc = "Upon import failure, either of the following may happen, as seen fit"]
            #[doc = "by the implementation:"]
            #[doc = "- the client is terminated with one of the following fatal protocol"]
            #[doc = "errors:"]
            #[doc = "- INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS, OUT_OF_BOUNDS,"]
            #[doc = "in case of argument errors such as mismatch between the number"]
            #[doc = "of planes and the format, bad format, non-positive width or"]
            #[doc = "height, or bad offset or stride."]
            #[doc = "- INVALID_WL_BUFFER, in case the cause for failure is unknown or"]
            #[doc = "plaform specific."]
            #[doc = "- the server creates an invalid wl_buffer, marks it as failed and"]
            #[doc = "sends a 'failed' event to the client. The result of using this"]
            #[doc = "invalid wl_buffer as an argument in any request by the client is"]
            #[doc = "defined by the compositor implementation."]
            #[doc = ""]
            #[doc = "This takes the same arguments as a 'create' request, and obeys the"]
            #[doc = "same restrictions."]
            async fn create_immed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer_id: crate::wire::ObjectId,
                width: i32,
                height: i32,
                format: u32,
                flags: Flags,
            ) -> crate::server::Result<()>;
            #[doc = "This event indicates that the attempted buffer creation was"]
            #[doc = "successful. It provides the new wl_buffer referencing the dmabuf(s)."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy the"]
            #[doc = "zwp_linux_buffer_params_v1 object."]
            async fn created(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event indicates that the attempted buffer creation has"]
            #[doc = "failed. It usually means that one of the dmabuf constraints"]
            #[doc = "has not been fulfilled."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy the"]
            #[doc = "zwp_linux_buffer_params_v1 object."]
            async fn failed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_linux_dmabuf_feedback_v1 {
        bitflags::bitflags! { # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct TrancheFlags : u32 { # [doc = "direct scan-out tranche"] const Scanout = 1u32 ; } }
        impl TryFrom<u32> for TrancheFlags {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "This object advertises dmabuf parameters feedback. This includes the"]
        #[doc = "preferred devices and the supported formats/modifiers."]
        #[doc = ""]
        #[doc = "The parameters are sent once when this object is created and whenever they"]
        #[doc = "change. The done event is always sent once after all parameters have been"]
        #[doc = "sent. When a single parameter changes, all parameters are re-sent by the"]
        #[doc = "compositor."]
        #[doc = ""]
        #[doc = "Compositors can re-send the parameters when the current client buffer"]
        #[doc = "allocations are sub-optimal. Compositors should not re-send the"]
        #[doc = "parameters if re-allocating the buffers would not result in a more optimal"]
        #[doc = "configuration. In particular, compositors should avoid sending the exact"]
        #[doc = "same parameters multiple times in a row."]
        #[doc = ""]
        #[doc = "The tranche_target_device and tranche_formats events are grouped by"]
        #[doc = "tranches of preference. For each tranche, a tranche_target_device, one"]
        #[doc = "tranche_flags and one or more tranche_formats events are sent, followed"]
        #[doc = "by a tranche_done event finishing the list. The tranches are sent in"]
        #[doc = "descending order of preference. All formats and modifiers in the same"]
        #[doc = "tranche have the same preference."]
        #[doc = ""]
        #[doc = "To send parameters, the compositor sends one main_device event, tranches"]
        #[doc = "(each consisting of one tranche_target_device event, one tranche_flags"]
        #[doc = "event, tranche_formats events and then a tranche_done event), then one"]
        #[doc = "done event."]
        pub trait ZwpLinuxDmabufFeedbackV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_dmabuf_feedback_v1";
            const VERSION: u32 = 5u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_linux_dmabuf_feedback_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Using this request a client can tell the server that it is not going to"]
            #[doc = "use the wp_linux_dmabuf_feedback object anymore."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent after all parameters of a wp_linux_dmabuf_feedback"]
            #[doc = "object have been sent."]
            #[doc = ""]
            #[doc = "This allows changes to the wp_linux_dmabuf_feedback parameters to be"]
            #[doc = "seen as atomic, even if they happen via multiple events."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event provides a file descriptor which can be memory-mapped to"]
            #[doc = "access the format and modifier table."]
            #[doc = ""]
            #[doc = "The table contains a tightly packed array of consecutive format +"]
            #[doc = "modifier pairs. Each pair is 16 bytes wide. It contains a format as a"]
            #[doc = "32-bit unsigned integer, followed by 4 bytes of unused padding, and a"]
            #[doc = "modifier as a 64-bit unsigned integer. The native endianness is used."]
            #[doc = ""]
            #[doc = "The client must map the file descriptor in read-only private mode."]
            #[doc = ""]
            #[doc = "Compositors are not allowed to mutate the table file contents once this"]
            #[doc = "event has been sent. Instead, compositors must create a new, separate"]
            #[doc = "table file and re-send feedback parameters. Compositors are allowed to"]
            #[doc = "store duplicate format + modifier pairs in the table."]
            async fn format_table(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event advertises the main device that the server prefers to use"]
            #[doc = "when direct scan-out to the target device isn't possible. The"]
            #[doc = "advertised main device may be different for each"]
            #[doc = "wp_linux_dmabuf_feedback object, and may change over time."]
            #[doc = ""]
            #[doc = "There is exactly one main device. The compositor must send at least"]
            #[doc = "one preference tranche with tranche_target_device equal to main_device."]
            #[doc = ""]
            #[doc = "Clients need to create buffers that the main device can import and"]
            #[doc = "read from, otherwise creating the dmabuf wl_buffer will fail (see the"]
            #[doc = "wp_linux_buffer_params.create and create_immed requests for details)."]
            #[doc = "The main device will also likely be kept active by the compositor,"]
            #[doc = "so clients can use it instead of waking up another device for power"]
            #[doc = "savings."]
            #[doc = ""]
            #[doc = "In general the device is a DRM node. The DRM node type (primary vs."]
            #[doc = "render) is unspecified. Clients must not rely on the compositor sending"]
            #[doc = "a particular node type. Clients cannot check two devices for equality"]
            #[doc = "by comparing the dev_t value."]
            #[doc = ""]
            #[doc = "If explicit modifiers are not supported and the client performs buffer"]
            #[doc = "allocations on a different device than the main device, then the client"]
            #[doc = "must force the buffer to have a linear layout."]
            async fn main_device(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event splits tranche_target_device and tranche_formats events in"]
            #[doc = "preference tranches. It is sent after a set of tranche_target_device"]
            #[doc = "and tranche_formats events; it represents the end of a tranche. The"]
            #[doc = "next tranche will have a lower preference."]
            async fn tranche_done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event advertises the target device that the server prefers to use"]
            #[doc = "for a buffer created given this tranche. The advertised target device"]
            #[doc = "may be different for each preference tranche, and may change over time."]
            #[doc = ""]
            #[doc = "There is exactly one target device per tranche."]
            #[doc = ""]
            #[doc = "The target device may be a scan-out device, for example if the"]
            #[doc = "compositor prefers to directly scan-out a buffer created given this"]
            #[doc = "tranche. The target device may be a rendering device, for example if"]
            #[doc = "the compositor prefers to texture from said buffer."]
            #[doc = ""]
            #[doc = "The client can use this hint to allocate the buffer in a way that makes"]
            #[doc = "it accessible from the target device, ideally directly. The buffer must"]
            #[doc = "still be accessible from the main device, either through direct import"]
            #[doc = "or through a potentially more expensive fallback path. If the buffer"]
            #[doc = "can't be directly imported from the main device then clients must be"]
            #[doc = "prepared for the compositor changing the tranche priority or making"]
            #[doc = "wl_buffer creation fail (see the wp_linux_buffer_params.create and"]
            #[doc = "create_immed requests for details)."]
            #[doc = ""]
            #[doc = "If the device is a DRM node, the DRM node type (primary vs. render) is"]
            #[doc = "unspecified. Clients must not rely on the compositor sending a"]
            #[doc = "particular node type. Clients cannot check two devices for equality by"]
            #[doc = "comparing the dev_t value."]
            #[doc = ""]
            #[doc = "This event is tied to a preference tranche, see the tranche_done event."]
            async fn tranche_target_device(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event advertises the format + modifier combinations that the"]
            #[doc = "compositor supports."]
            #[doc = ""]
            #[doc = "It carries an array of indices, each referring to a format + modifier"]
            #[doc = "pair in the last received format table (see the format_table event)."]
            #[doc = "Each index is a 16-bit unsigned integer in native endianness."]
            #[doc = ""]
            #[doc = "For legacy support, DRM_FORMAT_MOD_INVALID is an allowed modifier."]
            #[doc = "It indicates that the server can support the format with an implicit"]
            #[doc = "modifier. When a buffer has DRM_FORMAT_MOD_INVALID as its modifier, it"]
            #[doc = "is as if no explicit modifier is specified. The effective modifier"]
            #[doc = "will be derived from the dmabuf."]
            #[doc = ""]
            #[doc = "A compositor that sends valid modifiers and DRM_FORMAT_MOD_INVALID for"]
            #[doc = "a given format supports both explicit modifiers and implicit modifiers."]
            #[doc = ""]
            #[doc = "Compositors must not send duplicate format + modifier pairs within the"]
            #[doc = "same tranche or across two different tranches with the same target"]
            #[doc = "device and flags."]
            #[doc = ""]
            #[doc = "This event is tied to a preference tranche, see the tranche_done event."]
            #[doc = ""]
            #[doc = "For the definition of the format and modifier codes, see the"]
            #[doc = "wp_linux_buffer_params.create request."]
            async fn tranche_formats(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event sets tranche-specific flags."]
            #[doc = ""]
            #[doc = "The scanout flag is a hint that direct scan-out may be attempted by the"]
            #[doc = "compositor on the target device if the client appropriately allocates a"]
            #[doc = "buffer. How to allocate a buffer that can be scanned out on the target"]
            #[doc = "device is implementation-defined."]
            #[doc = ""]
            #[doc = "This event is tied to a preference tranche, see the tranche_done event."]
            async fn tranche_flags(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
pub mod presentation_time {
    pub mod wp_presentation {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidTimestamp = 0u32,
            InvalidFlag = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "The main feature of this interface is accurate presentation"]
        #[doc = "timing feedback to ensure smooth video playback while maintaining"]
        #[doc = "audio/video synchronization. Some features use the concept of a"]
        #[doc = "presentation clock, which is defined in the"]
        #[doc = "presentation.clock_id event."]
        #[doc = ""]
        #[doc = "A content update for a wl_surface is submitted by a"]
        #[doc = "wl_surface.commit request. Request 'feedback' associates with"]
        #[doc = "the wl_surface.commit and provides feedback on the content"]
        #[doc = "update, particularly the final realized presentation time."]
        #[doc = ""]
        #[doc = ""]
        #[doc = ""]
        #[doc = "When the final realized presentation time is available, e.g."]
        #[doc = "after a framebuffer flip completes, the requested"]
        #[doc = "presentation_feedback.presented events are sent. The final"]
        #[doc = "presentation time can differ from the compositor's predicted"]
        #[doc = "display update time and the update's target time, especially"]
        #[doc = "when the compositor misses its target vertical blanking period."]
        pub trait WpPresentation: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_presentation";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_presentation#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("wp_presentation#{}.feedback()", object.id);
                        self.feedback(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Informs the server that the client will no longer be using"]
            #[doc = "this protocol object. Existing objects created by this object"]
            #[doc = "are not affected."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Request presentation feedback for the current content submission"]
            #[doc = "on the given surface. This creates a new presentation_feedback"]
            #[doc = "object, which will deliver the feedback information once. If"]
            #[doc = "multiple presentation_feedback objects are created for the same"]
            #[doc = "submission, they will all deliver the same information."]
            #[doc = ""]
            #[doc = "For details on what information is returned, see the"]
            #[doc = "presentation_feedback interface."]
            async fn feedback(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
                callback: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This event tells the client in which clock domain the"]
            #[doc = "compositor interprets the timestamps used by the presentation"]
            #[doc = "extension. This clock is called the presentation clock."]
            #[doc = ""]
            #[doc = "The compositor sends this event when the client binds to the"]
            #[doc = "presentation interface. The presentation clock does not change"]
            #[doc = "during the lifetime of the client connection."]
            #[doc = ""]
            #[doc = "The clock identifier is platform dependent. On POSIX platforms, the"]
            #[doc = "identifier value is one of the clockid_t values accepted by"]
            #[doc = "clock_gettime(). clock_gettime() is defined by POSIX.1-2001."]
            #[doc = ""]
            #[doc = "Timestamps in this clock domain are expressed as tv_sec_hi,"]
            #[doc = "tv_sec_lo, tv_nsec triples, each component being an unsigned"]
            #[doc = "32-bit value. Whole seconds are in tv_sec which is a 64-bit"]
            #[doc = "value combined from tv_sec_hi and tv_sec_lo, and the"]
            #[doc = "additional fractional part in tv_nsec as nanoseconds. Hence,"]
            #[doc = "for valid timestamps tv_nsec must be in [0, 999999999]."]
            #[doc = ""]
            #[doc = "Note that clock_id applies only to the presentation clock,"]
            #[doc = "and implies nothing about e.g. the timestamps used in the"]
            #[doc = "Wayland core protocol input events."]
            #[doc = ""]
            #[doc = "Compositors should prefer a clock which does not jump and is"]
            #[doc = "not slewed e.g. by NTP. The absolute value of the clock is"]
            #[doc = "irrelevant. Precision of one millisecond or better is"]
            #[doc = "recommended. Clients must be able to query the current clock"]
            #[doc = "value directly, not by asking the compositor."]
            async fn clock_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod wp_presentation_feedback {
        bitflags::bitflags! { # [doc = "These flags provide information about how the presentation of"] # [doc = "the related content update was done. The intent is to help"] # [doc = "clients assess the reliability of the feedback and the visual"] # [doc = "quality with respect to possible tearing and timings."] # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Kind : u32 { const Vsync = 1u32 ; const HwClock = 2u32 ; const HwCompletion = 4u32 ; const ZeroCopy = 8u32 ; } }
        impl TryFrom<u32> for Kind {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "A presentation_feedback object returns an indication that a"]
        #[doc = "wl_surface content update has become visible to the user."]
        #[doc = "One object corresponds to one content update submission"]
        #[doc = "(wl_surface.commit). There are two possible outcomes: the"]
        #[doc = "content update is presented to the user, and a presentation"]
        #[doc = "timestamp delivered; or, the user did not see the content"]
        #[doc = "update because it was superseded or its surface destroyed,"]
        #[doc = "and the content update is discarded."]
        #[doc = ""]
        #[doc = "Once a presentation_feedback object has delivered a 'presented'"]
        #[doc = "or 'discarded' event it is automatically destroyed."]
        pub trait WpPresentationFeedback: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_presentation_feedback";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "As presentation can be synchronized to only one output at a"]
            #[doc = "time, this event tells which output it was. This event is only"]
            #[doc = "sent prior to the presented event."]
            #[doc = ""]
            #[doc = "As clients may bind to the same global wl_output multiple"]
            #[doc = "times, this event is sent for each bound instance that matches"]
            #[doc = "the synchronized output. If a client has not bound to the"]
            #[doc = "right wl_output global at all, this event is not sent."]
            async fn sync_output(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The associated content update was displayed to the user at the"]
            #[doc = "indicated time (tv_sec_hi/lo, tv_nsec). For the interpretation of"]
            #[doc = "the timestamp, see presentation.clock_id event."]
            #[doc = ""]
            #[doc = "The timestamp corresponds to the time when the content update"]
            #[doc = "turned into light the first time on the surface's main output."]
            #[doc = "Compositors may approximate this from the framebuffer flip"]
            #[doc = "completion events from the system, and the latency of the"]
            #[doc = "physical display path if known."]
            #[doc = ""]
            #[doc = "This event is preceded by all related sync_output events"]
            #[doc = "telling which output's refresh cycle the feedback corresponds"]
            #[doc = "to, i.e. the main output for the surface. Compositors are"]
            #[doc = "recommended to choose the output containing the largest part"]
            #[doc = "of the wl_surface, or keeping the output they previously"]
            #[doc = "chose. Having a stable presentation output association helps"]
            #[doc = "clients predict future output refreshes (vblank)."]
            #[doc = ""]
            #[doc = "The 'refresh' argument gives the compositor's prediction of how"]
            #[doc = "many nanoseconds after tv_sec, tv_nsec the very next output"]
            #[doc = "refresh may occur. This is to further aid clients in"]
            #[doc = "predicting future refreshes, i.e., estimating the timestamps"]
            #[doc = "targeting the next few vblanks. If such prediction cannot"]
            #[doc = "usefully be done, the argument is zero."]
            #[doc = ""]
            #[doc = "If the output does not have a constant refresh rate, explicit"]
            #[doc = "video mode switches excluded, then the refresh argument must"]
            #[doc = "be zero."]
            #[doc = ""]
            #[doc = "The 64-bit value combined from seq_hi and seq_lo is the value"]
            #[doc = "of the output's vertical retrace counter when the content"]
            #[doc = "update was first scanned out to the display. This value must"]
            #[doc = "be compatible with the definition of MSC in"]
            #[doc = "GLX_OML_sync_control specification. Note, that if the display"]
            #[doc = "path has a non-zero latency, the time instant specified by"]
            #[doc = "this counter may differ from the timestamp's."]
            #[doc = ""]
            #[doc = "If the output does not have a concept of vertical retrace or a"]
            #[doc = "refresh cycle, or the output device is self-refreshing without"]
            #[doc = "a way to query the refresh count, then the arguments seq_hi"]
            #[doc = "and seq_lo must be zero."]
            async fn presented(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The content update was never displayed to the user."]
            async fn discarded(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
#[doc = "This description provides a high-level overview of the interplay between"]
#[doc = "the interfaces defined this protocol. For details, see the protocol"]
#[doc = "specification."]
#[doc = ""]
#[doc = "More than one tablet may exist, and device-specifics matter. Tablets are"]
#[doc = "not represented by a single virtual device like wl_pointer. A client"]
#[doc = "binds to the tablet manager object which is just a proxy object. From"]
#[doc = "that, the client requests wp_tablet_manager.get_tablet_seat(wl_seat)"]
#[doc = "and that returns the actual interface that has all the tablets. With"]
#[doc = "this indirection, we can avoid merging wp_tablet into the actual Wayland"]
#[doc = "protocol, a long-term benefit."]
#[doc = ""]
#[doc = "The wp_tablet_seat sends a \"tablet added\" event for each tablet"]
#[doc = "connected. That event is followed by descriptive events about the"]
#[doc = "hardware; currently that includes events for name, vid/pid and"]
#[doc = "a wp_tablet.path event that describes a local path. This path can be"]
#[doc = "used to uniquely identify a tablet or get more information through"]
#[doc = "libwacom. Emulated or nested tablets can skip any of those, e.g. a"]
#[doc = "virtual tablet may not have a vid/pid. The sequence of descriptive"]
#[doc = "events is terminated by a wp_tablet.done event to signal that a client"]
#[doc = "may now finalize any initialization for that tablet."]
#[doc = ""]
#[doc = "Events from tablets require a tool in proximity. Tools are also managed"]
#[doc = "by the tablet seat; a \"tool added\" event is sent whenever a tool is new"]
#[doc = "to the compositor. That event is followed by a number of descriptive"]
#[doc = "events about the hardware; currently that includes capabilities,"]
#[doc = "hardware id and serial number, and tool type. Similar to the tablet"]
#[doc = "interface, a wp_tablet_tool.done event is sent to terminate that initial"]
#[doc = "sequence."]
#[doc = ""]
#[doc = "Any event from a tool happens on the wp_tablet_tool interface. When the"]
#[doc = "tool gets into proximity of the tablet, a proximity_in event is sent on"]
#[doc = "the wp_tablet_tool interface, listing the tablet and the surface. That"]
#[doc = "event is followed by a motion event with the coordinates. After that,"]
#[doc = "it's the usual motion, axis, button, etc. events. The protocol's"]
#[doc = "serialisation means events are grouped by wp_tablet_tool.frame events."]
#[doc = ""]
#[doc = "Two special events (that don't exist in X) are down and up. They signal"]
#[doc = "\"tip touching the surface\". For tablets without real proximity"]
#[doc = "detection, the sequence is: proximity_in, motion, down, frame."]
#[doc = ""]
#[doc = "When the tool leaves proximity, a proximity_out event is sent. If any"]
#[doc = "button is still down, a button release event is sent before this"]
#[doc = "proximity event. These button events are sent in the same frame as the"]
#[doc = "proximity event to signal to the client that the buttons were held when"]
#[doc = "the tool left proximity."]
#[doc = ""]
#[doc = "If the tool moves out of the surface but stays in proximity (i.e."]
#[doc = "between windows), compositor-specific grab policies apply. This usually"]
#[doc = "means that the proximity-out is delayed until all buttons are released."]
#[doc = ""]
#[doc = "Moving a tool physically from one tablet to the other has no real effect"]
#[doc = "on the protocol, since we already have the tool object from the \"tool"]
#[doc = "added\" event. All the information is already there and the proximity"]
#[doc = "events on both tablets are all a client needs to reconstruct what"]
#[doc = "happened."]
#[doc = ""]
#[doc = "Some extra axes are normalized, i.e. the client knows the range as"]
#[doc = "specified in the protocol (e.g. [0, 65535]), the granularity however is"]
#[doc = "unknown. The current normalized axes are pressure, distance, and slider."]
#[doc = ""]
#[doc = "Other extra axes are in physical units as specified in the protocol."]
#[doc = "The current extra axes with physical units are tilt, rotation and"]
#[doc = "wheel rotation."]
#[doc = ""]
#[doc = "Since tablets work independently of the pointer controlled by the mouse,"]
#[doc = "the focus handling is independent too and controlled by proximity."]
#[doc = "The wp_tablet_tool.set_cursor request sets a tool-specific cursor."]
#[doc = "This cursor surface may be the same as the mouse cursor, and it may be"]
#[doc = "the same across tools but it is possible to be more fine-grained. For"]
#[doc = "example, a client may set different cursors for the pen and eraser."]
#[doc = ""]
#[doc = "Tools are generally independent of tablets and it is"]
#[doc = "compositor-specific policy when a tool can be removed. Common approaches"]
#[doc = "will likely include some form of removing a tool when all tablets the"]
#[doc = "tool was used on are removed."]
pub mod tablet_v2 {
    pub mod zwp_tablet_manager_v2 {
        #[doc = "An object that provides access to the graphics tablets available on this"]
        #[doc = "system. All tablets are associated with a seat, to get access to the"]
        #[doc = "actual tablets, use wp_tablet_manager.get_tablet_seat."]
        pub trait ZwpTabletManagerV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_manager_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_manager_v2#{}.get_tablet_seat()", object.id);
                        self.get_tablet_seat(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_manager_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Get the wp_tablet_seat object for the given seat. This object"]
            #[doc = "provides access to all graphics tablets in this seat."]
            async fn get_tablet_seat(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tablet_seat: crate::wire::ObjectId,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the wp_tablet_manager object. Objects created from this"]
            #[doc = "object are unaffected and should be destroyed separately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_tablet_seat_v2 {
        #[doc = "An object that provides access to the graphics tablets available on this"]
        #[doc = "seat. After binding to this interface, the compositor sends a set of"]
        #[doc = "wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events."]
        pub trait ZwpTabletSeatV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_seat_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_seat_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the wp_tablet_seat object. Objects created from this"]
            #[doc = "object are unaffected and should be destroyed separately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent whenever a new tablet becomes available on this"]
            #[doc = "seat. This event only provides the object id of the tablet, any"]
            #[doc = "static information about the tablet (device name, vid/pid, etc.) is"]
            #[doc = "sent through the wp_tablet interface."]
            async fn tablet_added(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent whenever a tool that has not previously been used"]
            #[doc = "with a tablet comes into use. This event only provides the object id"]
            #[doc = "of the tool; any static information about the tool (capabilities,"]
            #[doc = "type, etc.) is sent through the wp_tablet_tool interface."]
            async fn tool_added(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent whenever a new pad is known to the system. Typically,"]
            #[doc = "pads are physically attached to tablets and a pad_added event is"]
            #[doc = "sent immediately after the wp_tablet_seat.tablet_added."]
            #[doc = "However, some standalone pad devices logically attach to tablets at"]
            #[doc = "runtime, and the client must wait for wp_tablet_pad.enter to know"]
            #[doc = "the tablet a pad is attached to."]
            #[doc = ""]
            #[doc = "This event only provides the object id of the pad. All further"]
            #[doc = "features (buttons, strips, rings) are sent through the wp_tablet_pad"]
            #[doc = "interface."]
            async fn pad_added(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_tablet_tool_v2 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Type {
            Pen = 320u32,
            Eraser = 321u32,
            Brush = 322u32,
            Pencil = 323u32,
            Airbrush = 324u32,
            Finger = 325u32,
            Mouse = 326u32,
            Lens = 327u32,
        }
        impl TryFrom<u32> for Type {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Capability {
            Tilt = 1u32,
            Pressure = 2u32,
            Distance = 3u32,
            Rotation = 4u32,
            Slider = 5u32,
            Wheel = 6u32,
        }
        impl TryFrom<u32> for Capability {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ButtonState {
            Released = 0u32,
            Pressed = 1u32,
        }
        impl TryFrom<u32> for ButtonState {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            Role = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "An object that represents a physical tool that has been, or is"]
        #[doc = "currently in use with a tablet in this seat. Each wp_tablet_tool"]
        #[doc = "object stays valid until the client destroys it; the compositor"]
        #[doc = "reuses the wp_tablet_tool object to indicate that the object's"]
        #[doc = "respective physical tool has come into proximity of a tablet again."]
        #[doc = ""]
        #[doc = "A wp_tablet_tool object's relation to a physical tool depends on the"]
        #[doc = "tablet's ability to report serial numbers. If the tablet supports"]
        #[doc = "this capability, then the object represents a specific physical tool"]
        #[doc = "and can be identified even when used on multiple tablets."]
        #[doc = ""]
        #[doc = "A tablet tool has a number of static characteristics, e.g. tool type,"]
        #[doc = "hardware_serial and capabilities. These capabilities are sent in an"]
        #[doc = "event sequence after the wp_tablet_seat.tool_added event before any"]
        #[doc = "actual events from this tool. This initial event sequence is"]
        #[doc = "terminated by a wp_tablet_tool.done event."]
        #[doc = ""]
        #[doc = "Tablet tool events are grouped by wp_tablet_tool.frame events."]
        #[doc = "Any events received before a wp_tablet_tool.frame event should be"]
        #[doc = "considered part of the same hardware state change."]
        pub trait ZwpTabletToolV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_tool_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_tool_v2#{}.set_cursor()", object.id);
                        self.set_cursor(
                            object,
                            client,
                            message.uint()?,
                            message.object()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_tool_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Sets the surface of the cursor used for this tool on the given"]
            #[doc = "tablet. This request only takes effect if the tool is in proximity"]
            #[doc = "of one of the requesting client's surfaces or the surface parameter"]
            #[doc = "is the current pointer surface. If there was a previous surface set"]
            #[doc = "with this request it is replaced. If surface is NULL, the cursor"]
            #[doc = "image is hidden."]
            #[doc = ""]
            #[doc = "The parameters hotspot_x and hotspot_y define the position of the"]
            #[doc = "pointer surface relative to the pointer location. Its top-left corner"]
            #[doc = "is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the"]
            #[doc = "coordinates of the pointer location, in surface-local coordinates."]
            #[doc = ""]
            #[doc = "On surface.attach requests to the pointer surface, hotspot_x and"]
            #[doc = "hotspot_y are decremented by the x and y parameters passed to the"]
            #[doc = "request. Attach must be confirmed by wl_surface.commit as usual."]
            #[doc = ""]
            #[doc = "The hotspot can also be updated by passing the currently set pointer"]
            #[doc = "surface to this request with new values for hotspot_x and hotspot_y."]
            #[doc = ""]
            #[doc = "The current and pending input regions of the wl_surface are cleared,"]
            #[doc = "and wl_surface.set_input_region is ignored until the wl_surface is no"]
            #[doc = "longer used as the cursor. When the use as a cursor ends, the current"]
            #[doc = "and pending input regions become undefined, and the wl_surface is"]
            #[doc = "unmapped."]
            #[doc = ""]
            #[doc = "This request gives the surface the role of a wp_tablet_tool cursor. A"]
            #[doc = "surface may only ever be used as the cursor surface for one"]
            #[doc = "wp_tablet_tool. If the surface already has another role or has"]
            #[doc = "previously been used as cursor surface for a different tool, a"]
            #[doc = "protocol error is raised."]
            async fn set_cursor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: Option<crate::wire::ObjectId>,
                hotspot_x: i32,
                hotspot_y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "This destroys the client's resource for this tool object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The tool type is the high-level type of the tool and usually decides"]
            #[doc = "the interaction expected from this tool."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn r#type(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "If the physical tool can be identified by a unique 64-bit serial"]
            #[doc = "number, this event notifies the client of this serial number."]
            #[doc = ""]
            #[doc = "If multiple tablets are available in the same seat and the tool is"]
            #[doc = "uniquely identifiable by the serial number, that tool may move"]
            #[doc = "between tablets."]
            #[doc = ""]
            #[doc = "Otherwise, if the tool has no serial number and this event is"]
            #[doc = "missing, the tool is tied to the tablet it first comes into"]
            #[doc = "proximity with. Even if the physical tool is used on multiple"]
            #[doc = "tablets, separate wp_tablet_tool objects will be created, one per"]
            #[doc = "tablet."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn hardware_serial(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event notifies the client of a hardware id available on this tool."]
            #[doc = ""]
            #[doc = "The hardware id is a device-specific 64-bit id that provides extra"]
            #[doc = "information about the tool in use, beyond the wl_tool.type"]
            #[doc = "enumeration. The format of the id is specific to tablets made by"]
            #[doc = "Wacom Inc. For example, the hardware id of a Wacom Grip"]
            #[doc = "Pen (a stylus) is 0x802."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn hardware_id_wacom(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event notifies the client of any capabilities of this tool,"]
            #[doc = "beyond the main set of x/y axes and tip up/down detection."]
            #[doc = ""]
            #[doc = "One event is sent for each extra capability available on this tool."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn capability(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event signals the end of the initial burst of descriptive"]
            #[doc = "events. A client may consider the static description of the tool to"]
            #[doc = "be complete and finalize initialization of the tool."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent when the tool is removed from the system and will"]
            #[doc = "send no further events. Should the physical tool come back into"]
            #[doc = "proximity later, a new wp_tablet_tool object will be created."]
            #[doc = ""]
            #[doc = "It is compositor-dependent when a tool is removed. A compositor may"]
            #[doc = "remove a tool on proximity out, tablet removal or any other reason."]
            #[doc = "A compositor may also keep a tool alive until shutdown."]
            #[doc = ""]
            #[doc = "If the tool is currently in proximity, a proximity_out event will be"]
            #[doc = "sent before the removed event. See wp_tablet_tool.proximity_out for"]
            #[doc = "the handling of any buttons logically down."]
            #[doc = ""]
            #[doc = "When this event is received, the client must wp_tablet_tool.destroy"]
            #[doc = "the object."]
            async fn removed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notification that this tool is focused on a certain surface."]
            #[doc = ""]
            #[doc = "This event can be received when the tool has moved from one surface to"]
            #[doc = "another, or when the tool has come back into proximity above the"]
            #[doc = "surface."]
            #[doc = ""]
            #[doc = "If any button is logically down when the tool comes into proximity,"]
            #[doc = "the respective button event is sent after the proximity_in event but"]
            #[doc = "within the same frame as the proximity_in event."]
            async fn proximity_in(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notification that this tool has either left proximity, or is no"]
            #[doc = "longer focused on a certain surface."]
            #[doc = ""]
            #[doc = "When the tablet tool leaves proximity of the tablet, button release"]
            #[doc = "events are sent for each button that was held down at the time of"]
            #[doc = "leaving proximity. These events are sent before the proximity_out"]
            #[doc = "event but within the same wp_tablet.frame."]
            #[doc = ""]
            #[doc = "If the tool stays within proximity of the tablet, but the focus"]
            #[doc = "changes from one surface to another, a button release event may not"]
            #[doc = "be sent until the button is actually released or the tool leaves the"]
            #[doc = "proximity of the tablet."]
            async fn proximity_out(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the tablet tool comes in contact with the surface of the"]
            #[doc = "tablet."]
            #[doc = ""]
            #[doc = "If the tool is already in contact with the tablet when entering the"]
            #[doc = "input region, the client owning said region will receive a"]
            #[doc = "wp_tablet.proximity_in event, followed by a wp_tablet.down"]
            #[doc = "event and a wp_tablet.frame event."]
            #[doc = ""]
            #[doc = "Note that this event describes logical contact, not physical"]
            #[doc = "contact. On some devices, a compositor may not consider a tool in"]
            #[doc = "logical contact until a minimum physical pressure threshold is"]
            #[doc = "exceeded."]
            async fn down(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the tablet tool stops making contact with the surface of"]
            #[doc = "the tablet, or when the tablet tool moves out of the input region"]
            #[doc = "and the compositor grab (if any) is dismissed."]
            #[doc = ""]
            #[doc = "If the tablet tool moves out of the input region while in contact"]
            #[doc = "with the surface of the tablet and the compositor does not have an"]
            #[doc = "ongoing grab on the surface, the client owning said region will"]
            #[doc = "receive a wp_tablet.up event, followed by a wp_tablet.proximity_out"]
            #[doc = "event and a wp_tablet.frame event. If the compositor has an ongoing"]
            #[doc = "grab on this device, this event sequence is sent whenever the grab"]
            #[doc = "is dismissed in the future."]
            #[doc = ""]
            #[doc = "Note that this event describes logical contact, not physical"]
            #[doc = "contact. On some devices, a compositor may not consider a tool out"]
            #[doc = "of logical contact until physical pressure falls below a specific"]
            #[doc = "threshold."]
            async fn up(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever a tablet tool moves."]
            async fn motion(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the pressure axis on a tool changes. The value of this"]
            #[doc = "event is normalized to a value between 0 and 65535."]
            #[doc = ""]
            #[doc = "Note that pressure may be nonzero even when a tool is not in logical"]
            #[doc = "contact. See the down and up events for more details."]
            async fn pressure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the distance axis on a tool changes. The value of this"]
            #[doc = "event is normalized to a value between 0 and 65535."]
            #[doc = ""]
            #[doc = "Note that distance may be nonzero even when a tool is not in logical"]
            #[doc = "contact. See the down and up events for more details."]
            async fn distance(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever one or both of the tilt axes on a tool change. Each tilt"]
            #[doc = "value is in degrees, relative to the z-axis of the tablet."]
            #[doc = "The angle is positive when the top of a tool tilts along the"]
            #[doc = "positive x or y axis."]
            async fn tilt(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the z-rotation axis on the tool changes. The"]
            #[doc = "rotation value is in degrees clockwise from the tool's"]
            #[doc = "logical neutral position."]
            async fn rotation(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the slider position on the tool changes. The"]
            #[doc = "value is normalized between -65535 and 65535, with 0 as the logical"]
            #[doc = "neutral position of the slider."]
            #[doc = ""]
            #[doc = "The slider is available on e.g. the Wacom Airbrush tool."]
            async fn slider(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the wheel on the tool emits an event. This event"]
            #[doc = "contains two values for the same axis change. The degrees value is"]
            #[doc = "in the same orientation as the wl_pointer.vertical_scroll axis. The"]
            #[doc = "clicks value is in discrete logical clicks of the mouse wheel. This"]
            #[doc = "value may be zero if the movement of the wheel was less"]
            #[doc = "than one logical click."]
            #[doc = ""]
            #[doc = "Clients should choose either value and avoid mixing degrees and"]
            #[doc = "clicks. The compositor may accumulate values smaller than a logical"]
            #[doc = "click and emulate click events when a certain threshold is met."]
            #[doc = "Thus, wl_tablet_tool.wheel events with non-zero clicks values may"]
            #[doc = "have different degrees values."]
            async fn wheel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever a button on the tool is pressed or released."]
            #[doc = ""]
            #[doc = "If a button is held down when the tool moves in or out of proximity,"]
            #[doc = "button events are generated by the compositor. See"]
            #[doc = "wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for"]
            #[doc = "details."]
            async fn button(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Marks the end of a series of axis and/or button updates from the"]
            #[doc = "tablet. The Wayland protocol requires axis updates to be sent"]
            #[doc = "sequentially, however all events within a frame should be considered"]
            #[doc = "one hardware event."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_tablet_v2 {
        #[doc = "The wp_tablet interface represents one graphics tablet device. The"]
        #[doc = "tablet interface itself does not generate events; all events are"]
        #[doc = "generated by wp_tablet_tool objects when in proximity above a tablet."]
        #[doc = ""]
        #[doc = "A tablet has a number of static characteristics, e.g. device name and"]
        #[doc = "pid/vid. These capabilities are sent in an event sequence after the"]
        #[doc = "wp_tablet_seat.tablet_added event. This initial event sequence is"]
        #[doc = "terminated by a wp_tablet.done event."]
        pub trait ZwpTabletV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This destroys the client's resource for this tablet object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "A descriptive name for the tablet device."]
            #[doc = ""]
            #[doc = "If the device has no descriptive name, this event is not sent."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet.done event."]
            async fn name(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The USB vendor and product IDs for the tablet device."]
            #[doc = ""]
            #[doc = "If the device has no USB vendor/product ID, this event is not sent."]
            #[doc = "This can happen for virtual devices or non-USB devices, for instance."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet.done event."]
            async fn id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "A system-specific device path that indicates which device is behind"]
            #[doc = "this wp_tablet. This information may be used to gather additional"]
            #[doc = "information about the device, e.g. through libwacom."]
            #[doc = ""]
            #[doc = "A device may have more than one device path. If so, multiple"]
            #[doc = "wp_tablet.path events are sent. A device may be emulated and not"]
            #[doc = "have a device path, and in that case this event will not be sent."]
            #[doc = ""]
            #[doc = "The format of the path is unspecified, it may be a device node, a"]
            #[doc = "sysfs path, or some other identifier. It is up to the client to"]
            #[doc = "identify the string provided."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet.done event."]
            async fn path(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent immediately to signal the end of the initial"]
            #[doc = "burst of descriptive events. A client may consider the static"]
            #[doc = "description of the tablet to be complete and finalize initialization"]
            #[doc = "of the tablet."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent when the tablet has been removed from the system. When a tablet"]
            #[doc = "is removed, some tools may be removed."]
            #[doc = ""]
            #[doc = "When this event is received, the client must wp_tablet.destroy"]
            #[doc = "the object."]
            async fn removed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_tablet_pad_ring_v2 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Source {
            Finger = 1u32,
        }
        impl TryFrom<u32> for Source {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "A circular interaction area, such as the touch ring on the Wacom Intuos"]
        #[doc = "Pro series tablets."]
        #[doc = ""]
        #[doc = "Events on a ring are logically grouped by the wl_tablet_pad_ring.frame"]
        #[doc = "event."]
        pub trait ZwpTabletPadRingV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_ring_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_pad_ring_v2#{}.set_feedback()", object.id);
                        self.set_feedback(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_pad_ring_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Request that the compositor use the provided feedback string"]
            #[doc = "associated with this ring. This request should be issued immediately"]
            #[doc = "after a wp_tablet_pad_group.mode_switch event from the corresponding"]
            #[doc = "group is received, or whenever the ring is mapped to a different"]
            #[doc = "action. See wp_tablet_pad_group.mode_switch for more details."]
            #[doc = ""]
            #[doc = "Clients are encouraged to provide context-aware descriptions for"]
            #[doc = "the actions associated with the ring; compositors may use this"]
            #[doc = "information to offer visual feedback about the button layout"]
            #[doc = "(eg. on-screen displays)."]
            #[doc = ""]
            #[doc = "The provided string 'description' is a UTF-8 encoded string to be"]
            #[doc = "associated with this ring, and is considered user-visible; general"]
            #[doc = "internationalization rules apply."]
            #[doc = ""]
            #[doc = "The serial argument will be that of the last"]
            #[doc = "wp_tablet_pad_group.mode_switch event received for the group of this"]
            #[doc = "ring. Requests providing other serials than the most recent one will be"]
            #[doc = "ignored."]
            async fn set_feedback(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                description: String,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This destroys the client's resource for this ring object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Source information for ring events."]
            #[doc = ""]
            #[doc = "This event does not occur on its own. It is sent before a"]
            #[doc = "wp_tablet_pad_ring.frame event and carries the source information"]
            #[doc = "for all events within that frame."]
            #[doc = ""]
            #[doc = "The source specifies how this event was generated. If the source is"]
            #[doc = "wp_tablet_pad_ring.source.finger, a wp_tablet_pad_ring.stop event"]
            #[doc = "will be sent when the user lifts the finger off the device."]
            #[doc = ""]
            #[doc = "This event is optional. If the source is unknown for an interaction,"]
            #[doc = "no event is sent."]
            async fn source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the angle on a ring changes."]
            #[doc = ""]
            #[doc = "The angle is provided in degrees clockwise from the logical"]
            #[doc = "north of the ring in the pad's current rotation."]
            async fn angle(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Stop notification for ring events."]
            #[doc = ""]
            #[doc = "For some wp_tablet_pad_ring.source types, a wp_tablet_pad_ring.stop"]
            #[doc = "event is sent to notify a client that the interaction with the ring"]
            #[doc = "has terminated. This enables the client to implement kinetic scrolling."]
            #[doc = "See the wp_tablet_pad_ring.source documentation for information on"]
            #[doc = "when this event may be generated."]
            #[doc = ""]
            #[doc = "Any wp_tablet_pad_ring.angle events with the same source after this"]
            #[doc = "event should be considered as the start of a new interaction."]
            async fn stop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Indicates the end of a set of ring events that logically belong"]
            #[doc = "together. A client is expected to accumulate the data in all events"]
            #[doc = "within the frame before proceeding."]
            #[doc = ""]
            #[doc = "All wp_tablet_pad_ring events before a wp_tablet_pad_ring.frame event belong"]
            #[doc = "logically together. For example, on termination of a finger interaction"]
            #[doc = "on a ring the compositor will send a wp_tablet_pad_ring.source event,"]
            #[doc = "a wp_tablet_pad_ring.stop event and a wp_tablet_pad_ring.frame event."]
            #[doc = ""]
            #[doc = "A wp_tablet_pad_ring.frame event is sent for every logical event"]
            #[doc = "group, even if the group only contains a single wp_tablet_pad_ring"]
            #[doc = "event. Specifically, a client may get a sequence: angle, frame,"]
            #[doc = "angle, frame, etc."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_tablet_pad_strip_v2 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Source {
            Finger = 1u32,
        }
        impl TryFrom<u32> for Source {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "A linear interaction area, such as the strips found in Wacom Cintiq"]
        #[doc = "models."]
        #[doc = ""]
        #[doc = "Events on a strip are logically grouped by the wl_tablet_pad_strip.frame"]
        #[doc = "event."]
        pub trait ZwpTabletPadStripV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_strip_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_pad_strip_v2#{}.set_feedback()", object.id);
                        self.set_feedback(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_pad_strip_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Requests the compositor to use the provided feedback string"]
            #[doc = "associated with this strip. This request should be issued immediately"]
            #[doc = "after a wp_tablet_pad_group.mode_switch event from the corresponding"]
            #[doc = "group is received, or whenever the strip is mapped to a different"]
            #[doc = "action. See wp_tablet_pad_group.mode_switch for more details."]
            #[doc = ""]
            #[doc = "Clients are encouraged to provide context-aware descriptions for"]
            #[doc = "the actions associated with the strip, and compositors may use this"]
            #[doc = "information to offer visual feedback about the button layout"]
            #[doc = "(eg. on-screen displays)."]
            #[doc = ""]
            #[doc = "The provided string 'description' is a UTF-8 encoded string to be"]
            #[doc = "associated with this ring, and is considered user-visible; general"]
            #[doc = "internationalization rules apply."]
            #[doc = ""]
            #[doc = "The serial argument will be that of the last"]
            #[doc = "wp_tablet_pad_group.mode_switch event received for the group of this"]
            #[doc = "strip. Requests providing other serials than the most recent one will be"]
            #[doc = "ignored."]
            async fn set_feedback(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                description: String,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This destroys the client's resource for this strip object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Source information for strip events."]
            #[doc = ""]
            #[doc = "This event does not occur on its own. It is sent before a"]
            #[doc = "wp_tablet_pad_strip.frame event and carries the source information"]
            #[doc = "for all events within that frame."]
            #[doc = ""]
            #[doc = "The source specifies how this event was generated. If the source is"]
            #[doc = "wp_tablet_pad_strip.source.finger, a wp_tablet_pad_strip.stop event"]
            #[doc = "will be sent when the user lifts their finger off the device."]
            #[doc = ""]
            #[doc = "This event is optional. If the source is unknown for an interaction,"]
            #[doc = "no event is sent."]
            async fn source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the position on a strip changes."]
            #[doc = ""]
            #[doc = "The position is normalized to a range of [0, 65535], the 0-value"]
            #[doc = "represents the top-most and/or left-most position of the strip in"]
            #[doc = "the pad's current rotation."]
            async fn position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Stop notification for strip events."]
            #[doc = ""]
            #[doc = "For some wp_tablet_pad_strip.source types, a wp_tablet_pad_strip.stop"]
            #[doc = "event is sent to notify a client that the interaction with the strip"]
            #[doc = "has terminated. This enables the client to implement kinetic"]
            #[doc = "scrolling. See the wp_tablet_pad_strip.source documentation for"]
            #[doc = "information on when this event may be generated."]
            #[doc = ""]
            #[doc = "Any wp_tablet_pad_strip.position events with the same source after this"]
            #[doc = "event should be considered as the start of a new interaction."]
            async fn stop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Indicates the end of a set of events that represent one logical"]
            #[doc = "hardware strip event. A client is expected to accumulate the data"]
            #[doc = "in all events within the frame before proceeding."]
            #[doc = ""]
            #[doc = "All wp_tablet_pad_strip events before a wp_tablet_pad_strip.frame event belong"]
            #[doc = "logically together. For example, on termination of a finger interaction"]
            #[doc = "on a strip the compositor will send a wp_tablet_pad_strip.source event,"]
            #[doc = "a wp_tablet_pad_strip.stop event and a wp_tablet_pad_strip.frame"]
            #[doc = "event."]
            #[doc = ""]
            #[doc = "A wp_tablet_pad_strip.frame event is sent for every logical event"]
            #[doc = "group, even if the group only contains a single wp_tablet_pad_strip"]
            #[doc = "event. Specifically, a client may get a sequence: position, frame,"]
            #[doc = "position, frame, etc."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_tablet_pad_group_v2 {
        #[doc = "A pad group describes a distinct (sub)set of buttons, rings and strips"]
        #[doc = "present in the tablet. The criteria of this grouping is usually positional,"]
        #[doc = "eg. if a tablet has buttons on the left and right side, 2 groups will be"]
        #[doc = "presented. The physical arrangement of groups is undisclosed and may"]
        #[doc = "change on the fly."]
        #[doc = ""]
        #[doc = "Pad groups will announce their features during pad initialization. Between"]
        #[doc = "the corresponding wp_tablet_pad.group event and wp_tablet_pad_group.done, the"]
        #[doc = "pad group will announce the buttons, rings and strips contained in it,"]
        #[doc = "plus the number of supported modes."]
        #[doc = ""]
        #[doc = "Modes are a mechanism to allow multiple groups of actions for every element"]
        #[doc = "in the pad group. The number of groups and available modes in each is"]
        #[doc = "persistent across device plugs. The current mode is user-switchable, it"]
        #[doc = "will be announced through the wp_tablet_pad_group.mode_switch event both"]
        #[doc = "whenever it is switched, and after wp_tablet_pad.enter."]
        #[doc = ""]
        #[doc = "The current mode logically applies to all elements in the pad group,"]
        #[doc = "although it is at clients' discretion whether to actually perform different"]
        #[doc = "actions, and/or issue the respective .set_feedback requests to notify the"]
        #[doc = "compositor. See the wp_tablet_pad_group.mode_switch event for more details."]
        pub trait ZwpTabletPadGroupV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_group_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_pad_group_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the wp_tablet_pad_group object. Objects created from this object"]
            #[doc = "are unaffected and should be destroyed separately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sent on wp_tablet_pad_group initialization to announce the available"]
            #[doc = "buttons in the group. Button indices start at 0, a button may only be"]
            #[doc = "in one group at a time."]
            #[doc = ""]
            #[doc = "This event is first sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad_group.done event."]
            #[doc = ""]
            #[doc = "Some buttons are reserved by the compositor. These buttons may not be"]
            #[doc = "assigned to any wp_tablet_pad_group. Compositors may broadcast this"]
            #[doc = "event in the case of changes to the mapping of these reserved buttons."]
            #[doc = "If the compositor happens to reserve all buttons in a group, this event"]
            #[doc = "will be sent with an empty array."]
            async fn buttons(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent on wp_tablet_pad_group initialization to announce available rings."]
            #[doc = "One event is sent for each ring available on this pad group."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad_group.done event."]
            async fn ring(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent on wp_tablet_pad initialization to announce available strips."]
            #[doc = "One event is sent for each strip available on this pad group."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad_group.done event."]
            async fn strip(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent on wp_tablet_pad_group initialization to announce that the pad"]
            #[doc = "group may switch between modes. A client may use a mode to store a"]
            #[doc = "specific configuration for buttons, rings and strips and use the"]
            #[doc = "wl_tablet_pad_group.mode_switch event to toggle between these"]
            #[doc = "configurations. Mode indices start at 0."]
            #[doc = ""]
            #[doc = "Switching modes is compositor-dependent. See the"]
            #[doc = "wp_tablet_pad_group.mode_switch event for more details."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad_group.done event. This event is only sent when more than"]
            #[doc = "more than one mode is available."]
            async fn modes(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent immediately to signal the end of the initial"]
            #[doc = "burst of descriptive events. A client may consider the static"]
            #[doc = "description of the tablet to be complete and finalize initialization"]
            #[doc = "of the tablet group."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notification that the mode was switched."]
            #[doc = ""]
            #[doc = "A mode applies to all buttons, rings and strips in a group"]
            #[doc = "simultaneously, but a client is not required to assign different actions"]
            #[doc = "for each mode. For example, a client may have mode-specific button"]
            #[doc = "mappings but map the ring to vertical scrolling in all modes. Mode"]
            #[doc = "indices start at 0."]
            #[doc = ""]
            #[doc = "Switching modes is compositor-dependent. The compositor may provide"]
            #[doc = "visual cues to the client about the mode, e.g. by toggling LEDs on"]
            #[doc = "the tablet device. Mode-switching may be software-controlled or"]
            #[doc = "controlled by one or more physical buttons. For example, on a Wacom"]
            #[doc = "Intuos Pro, the button inside the ring may be assigned to switch"]
            #[doc = "between modes."]
            #[doc = ""]
            #[doc = "The compositor will also send this event after wp_tablet_pad.enter on"]
            #[doc = "each group in order to notify of the current mode. Groups that only"]
            #[doc = "feature one mode will use mode=0 when emitting this event."]
            #[doc = ""]
            #[doc = "If a button action in the new mode differs from the action in the"]
            #[doc = "previous mode, the client should immediately issue a"]
            #[doc = "wp_tablet_pad.set_feedback request for each changed button."]
            #[doc = ""]
            #[doc = "If a ring or strip action in the new mode differs from the action"]
            #[doc = "in the previous mode, the client should immediately issue a"]
            #[doc = "wp_tablet_ring.set_feedback or wp_tablet_strip.set_feedback request"]
            #[doc = "for each changed ring or strip."]
            async fn mode_switch(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_tablet_pad_v2 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ButtonState {
            Released = 0u32,
            Pressed = 1u32,
        }
        impl TryFrom<u32> for ButtonState {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "A pad device is a set of buttons, rings and strips"]
        #[doc = "usually physically present on the tablet device itself. Some"]
        #[doc = "exceptions exist where the pad device is physically detached, e.g. the"]
        #[doc = "Wacom ExpressKey Remote."]
        #[doc = ""]
        #[doc = "Pad devices have no axes that control the cursor and are generally"]
        #[doc = "auxiliary devices to the tool devices used on the tablet surface."]
        #[doc = ""]
        #[doc = "A pad device has a number of static characteristics, e.g. the number"]
        #[doc = "of rings. These capabilities are sent in an event sequence after the"]
        #[doc = "wp_tablet_seat.pad_added event before any actual events from this pad."]
        #[doc = "This initial event sequence is terminated by a wp_tablet_pad.done"]
        #[doc = "event."]
        #[doc = ""]
        #[doc = "All pad features (buttons, rings and strips) are logically divided into"]
        #[doc = "groups and all pads have at least one group. The available groups are"]
        #[doc = "notified through the wp_tablet_pad.group event; the compositor will"]
        #[doc = "emit one event per group before emitting wp_tablet_pad.done."]
        #[doc = ""]
        #[doc = "Groups may have multiple modes. Modes allow clients to map multiple"]
        #[doc = "actions to a single pad feature. Only one mode can be active per group,"]
        #[doc = "although different groups may have different active modes."]
        pub trait ZwpTabletPadV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_pad_v2#{}.set_feedback()", object.id);
                        self.set_feedback(
                            object,
                            client,
                            message.uint()?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_pad_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Requests the compositor to use the provided feedback string"]
            #[doc = "associated with this button. This request should be issued immediately"]
            #[doc = "after a wp_tablet_pad_group.mode_switch event from the corresponding"]
            #[doc = "group is received, or whenever a button is mapped to a different"]
            #[doc = "action. See wp_tablet_pad_group.mode_switch for more details."]
            #[doc = ""]
            #[doc = "Clients are encouraged to provide context-aware descriptions for"]
            #[doc = "the actions associated with each button, and compositors may use"]
            #[doc = "this information to offer visual feedback on the button layout"]
            #[doc = "(e.g. on-screen displays)."]
            #[doc = ""]
            #[doc = "Button indices start at 0. Setting the feedback string on a button"]
            #[doc = "that is reserved by the compositor (i.e. not belonging to any"]
            #[doc = "wp_tablet_pad_group) does not generate an error but the compositor"]
            #[doc = "is free to ignore the request."]
            #[doc = ""]
            #[doc = "The provided string 'description' is a UTF-8 encoded string to be"]
            #[doc = "associated with this ring, and is considered user-visible; general"]
            #[doc = "internationalization rules apply."]
            #[doc = ""]
            #[doc = "The serial argument will be that of the last"]
            #[doc = "wp_tablet_pad_group.mode_switch event received for the group of this"]
            #[doc = "button. Requests providing other serials than the most recent one will"]
            #[doc = "be ignored."]
            async fn set_feedback(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                button: u32,
                description: String,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the wp_tablet_pad object. Objects created from this object"]
            #[doc = "are unaffected and should be destroyed separately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sent on wp_tablet_pad initialization to announce available groups."]
            #[doc = "One event is sent for each pad group available."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad.done event. At least one group will be announced."]
            async fn group(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "A system-specific device path that indicates which device is behind"]
            #[doc = "this wp_tablet_pad. This information may be used to gather additional"]
            #[doc = "information about the device, e.g. through libwacom."]
            #[doc = ""]
            #[doc = "The format of the path is unspecified, it may be a device node, a"]
            #[doc = "sysfs path, or some other identifier. It is up to the client to"]
            #[doc = "identify the string provided."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad.done event."]
            async fn path(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent on wp_tablet_pad initialization to announce the available"]
            #[doc = "buttons."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad.done event. This event is only sent when at least one"]
            #[doc = "button is available."]
            async fn buttons(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event signals the end of the initial burst of descriptive"]
            #[doc = "events. A client may consider the static description of the pad to"]
            #[doc = "be complete and finalize initialization of the pad."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the physical state of a button changes."]
            async fn button(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notification that this pad is focused on the specified surface."]
            async fn enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notification that this pad is no longer focused on the specified"]
            #[doc = "surface."]
            async fn leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent when the pad has been removed from the system. When a tablet"]
            #[doc = "is removed its pad(s) will be removed too."]
            #[doc = ""]
            #[doc = "When this event is received, the client must destroy all rings, strips"]
            #[doc = "and groups that were offered by this pad, and issue wp_tablet_pad.destroy"]
            #[doc = "the pad itself."]
            async fn removed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
pub mod viewporter {
    pub mod wp_viewporter {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            ViewportExists = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "The global interface exposing surface cropping and scaling"]
        #[doc = "capabilities is used to instantiate an interface extension for a"]
        #[doc = "wl_surface object. This extended interface will then allow"]
        #[doc = "cropping and scaling the surface contents, effectively"]
        #[doc = "disconnecting the direct relationship between the buffer and the"]
        #[doc = "surface size."]
        pub trait WpViewporter: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_viewporter";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_viewporter#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("wp_viewporter#{}.get_viewport()", object.id);
                        self.get_viewport(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Informs the server that the client will not be using this"]
            #[doc = "protocol object anymore. This does not affect any other objects,"]
            #[doc = "wp_viewport objects included."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Instantiate an interface extension for the given wl_surface to"]
            #[doc = "crop and scale its content. If the given wl_surface already has"]
            #[doc = "a wp_viewport object associated, the viewport_exists"]
            #[doc = "protocol error is raised."]
            async fn get_viewport(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wp_viewport {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            BadValue = 0u32,
            BadSize = 1u32,
            OutOfBuffer = 2u32,
            NoSurface = 3u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "An additional interface to a wl_surface object, which allows the"]
        #[doc = "client to specify the cropping and scaling of the surface"]
        #[doc = "contents."]
        #[doc = ""]
        #[doc = "This interface works with two concepts: the source rectangle (src_x,"]
        #[doc = "src_y, src_width, src_height), and the destination size (dst_width,"]
        #[doc = "dst_height). The contents of the source rectangle are scaled to the"]
        #[doc = "destination size, and content outside the source rectangle is ignored."]
        #[doc = "This state is double-buffered, and is applied on the next"]
        #[doc = "wl_surface.commit."]
        #[doc = ""]
        #[doc = "The two parts of crop and scale state are independent: the source"]
        #[doc = "rectangle, and the destination size. Initially both are unset, that"]
        #[doc = "is, no scaling is applied. The whole of the current wl_buffer is"]
        #[doc = "used as the source, and the surface size is as defined in"]
        #[doc = "wl_surface.attach."]
        #[doc = ""]
        #[doc = "If the destination size is set, it causes the surface size to become"]
        #[doc = "dst_width, dst_height. The source (rectangle) is scaled to exactly"]
        #[doc = "this size. This overrides whatever the attached wl_buffer size is,"]
        #[doc = "unless the wl_buffer is NULL. If the wl_buffer is NULL, the surface"]
        #[doc = "has no content and therefore no size. Otherwise, the size is always"]
        #[doc = "at least 1x1 in surface local coordinates."]
        #[doc = ""]
        #[doc = "If the source rectangle is set, it defines what area of the wl_buffer is"]
        #[doc = "taken as the source. If the source rectangle is set and the destination"]
        #[doc = "size is not set, then src_width and src_height must be integers, and the"]
        #[doc = "surface size becomes the source rectangle size. This results in cropping"]
        #[doc = "without scaling. If src_width or src_height are not integers and"]
        #[doc = "destination size is not set, the bad_size protocol error is raised when"]
        #[doc = "the surface state is applied."]
        #[doc = ""]
        #[doc = "The coordinate transformations from buffer pixel coordinates up to"]
        #[doc = "the surface-local coordinates happen in the following order:"]
        #[doc = "1. buffer_transform (wl_surface.set_buffer_transform)"]
        #[doc = "2. buffer_scale (wl_surface.set_buffer_scale)"]
        #[doc = "3. crop and scale (wp_viewport.set*)"]
        #[doc = "This means, that the source rectangle coordinates of crop and scale"]
        #[doc = "are given in the coordinates after the buffer transform and scale,"]
        #[doc = "i.e. in the coordinates that would be the surface-local coordinates"]
        #[doc = "if the crop and scale was not applied."]
        #[doc = ""]
        #[doc = "If src_x or src_y are negative, the bad_value protocol error is raised."]
        #[doc = "Otherwise, if the source rectangle is partially or completely outside of"]
        #[doc = "the non-NULL wl_buffer, then the out_of_buffer protocol error is raised"]
        #[doc = "when the surface state is applied. A NULL wl_buffer does not raise the"]
        #[doc = "out_of_buffer error."]
        #[doc = ""]
        #[doc = "If the wl_surface associated with the wp_viewport is destroyed,"]
        #[doc = "all wp_viewport requests except 'destroy' raise the protocol error"]
        #[doc = "no_surface."]
        #[doc = ""]
        #[doc = "If the wp_viewport object is destroyed, the crop and scale"]
        #[doc = "state is removed from the wl_surface. The change will be applied"]
        #[doc = "on the next wl_surface.commit."]
        pub trait WpViewport: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_viewport";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_viewport#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("wp_viewport#{}.set_source()", object.id);
                        self.set_source(
                            object,
                            client,
                            message.fixed()?,
                            message.fixed()?,
                            message.fixed()?,
                            message.fixed()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("wp_viewport#{}.set_destination()", object.id);
                        self.set_destination(object, client, message.int()?, message.int()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "The associated wl_surface's crop and scale state is removed."]
            #[doc = "The change is applied on the next wl_surface.commit."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the source rectangle of the associated wl_surface. See"]
            #[doc = "wp_viewport for the description, and relation to the wl_buffer"]
            #[doc = "size."]
            #[doc = ""]
            #[doc = "If all of x, y, width and height are -1.0, the source rectangle is"]
            #[doc = "unset instead. Any other set of values where width or height are zero"]
            #[doc = "or negative, or x or y are negative, raise the bad_value protocol"]
            #[doc = "error."]
            #[doc = ""]
            #[doc = "The crop and scale state is double-buffered state, and will be"]
            #[doc = "applied on the next wl_surface.commit."]
            async fn set_source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: crate::wire::Fixed,
                y: crate::wire::Fixed,
                width: crate::wire::Fixed,
                height: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            #[doc = "Set the destination size of the associated wl_surface. See"]
            #[doc = "wp_viewport for the description, and relation to the wl_buffer"]
            #[doc = "size."]
            #[doc = ""]
            #[doc = "If width is -1 and height is -1, the destination size is unset"]
            #[doc = "instead. Any other pair of values for width and height that"]
            #[doc = "contains zero or negative values raises the bad_value protocol"]
            #[doc = "error."]
            #[doc = ""]
            #[doc = "The crop and scale state is double-buffered state, and will be"]
            #[doc = "applied on the next wl_surface.commit."]
            async fn set_destination(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod xdg_shell {
    pub mod xdg_wm_base {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            Role = 0u32,
            DefunctSurfaces = 1u32,
            NotTheTopmostPopup = 2u32,
            InvalidPopupParent = 3u32,
            InvalidSurfaceState = 4u32,
            InvalidPositioner = 5u32,
            Unresponsive = 6u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "The xdg_wm_base interface is exposed as a global object enabling clients"]
        #[doc = "to turn their wl_surfaces into windows in a desktop environment. It"]
        #[doc = "defines the basic functionality needed for clients and the compositor to"]
        #[doc = "create windows that can be dragged, resized, maximized, etc, as well as"]
        #[doc = "creating transient windows such as popup menus."]
        pub trait XdgWmBase: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_wm_base";
            const VERSION: u32 = 6u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_wm_base#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_wm_base#{}.create_positioner()", object.id);
                        self.create_positioner(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("xdg_wm_base#{}.get_xdg_surface()", object.id);
                        self.get_xdg_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("xdg_wm_base#{}.pong()", object.id);
                        self.pong(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy this xdg_wm_base object."]
            #[doc = ""]
            #[doc = "Destroying a bound xdg_wm_base object while there are surfaces"]
            #[doc = "still alive created by this xdg_wm_base object instance is illegal"]
            #[doc = "and will result in a defunct_surfaces error."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a positioner object. A positioner object is used to position"]
            #[doc = "surfaces relative to some parent surface. See the interface description"]
            #[doc = "and xdg_surface.get_popup for details."]
            async fn create_positioner(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This creates an xdg_surface for the given surface. While xdg_surface"]
            #[doc = "itself is not a role, the corresponding surface may only be assigned"]
            #[doc = "a role extending xdg_surface, such as xdg_toplevel or xdg_popup. It is"]
            #[doc = "illegal to create an xdg_surface for a wl_surface which already has an"]
            #[doc = "assigned role and this will result in a role error."]
            #[doc = ""]
            #[doc = "This creates an xdg_surface for the given surface. An xdg_surface is"]
            #[doc = "used as basis to define a role to a given surface, such as xdg_toplevel"]
            #[doc = "or xdg_popup. It also manages functionality shared between xdg_surface"]
            #[doc = "based surface roles."]
            #[doc = ""]
            #[doc = "See the documentation of xdg_surface for more details about what an"]
            #[doc = "xdg_surface is and how it is used."]
            async fn get_xdg_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "A client must respond to a ping event with a pong request or"]
            #[doc = "the client may be deemed unresponsive. See xdg_wm_base.ping"]
            #[doc = "and xdg_wm_base.error.unresponsive."]
            async fn pong(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "The ping event asks the client if it's still alive. Pass the"]
            #[doc = "serial specified in the event back to the compositor by sending"]
            #[doc = "a \"pong\" request back with the specified serial. See xdg_wm_base.pong."]
            #[doc = ""]
            #[doc = "Compositors can use this to determine if the client is still"]
            #[doc = "alive. It's unspecified what will happen if the client doesn't"]
            #[doc = "respond to the ping request, or in what timeframe. Clients should"]
            #[doc = "try to respond in a reasonable amount of time. The “unresponsive”"]
            #[doc = "error is provided for compositors that wish to disconnect unresponsive"]
            #[doc = "clients."]
            #[doc = ""]
            #[doc = "A compositor is free to ping in any way it wants, but a client must"]
            #[doc = "always respond to any xdg_wm_base object it created."]
            async fn ping(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod xdg_positioner {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidInput = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Anchor {
            None = 0u32,
            Top = 1u32,
            Bottom = 2u32,
            Left = 3u32,
            Right = 4u32,
            TopLeft = 5u32,
            BottomLeft = 6u32,
            TopRight = 7u32,
            BottomRight = 8u32,
        }
        impl TryFrom<u32> for Anchor {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Gravity {
            None = 0u32,
            Top = 1u32,
            Bottom = 2u32,
            Left = 3u32,
            Right = 4u32,
            TopLeft = 5u32,
            BottomLeft = 6u32,
            TopRight = 7u32,
            BottomRight = 8u32,
        }
        impl TryFrom<u32> for Gravity {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! { # [doc = "The constraint adjustment value define ways the compositor will adjust"] # [doc = "the position of the surface, if the unadjusted position would result"] # [doc = "in the surface being partly constrained."] # [doc = ""] # [doc = "Whether a surface is considered 'constrained' is left to the compositor"] # [doc = "to determine. For example, the surface may be partly outside the"] # [doc = "compositor's defined 'work area', thus necessitating the child surface's"] # [doc = "position be adjusted until it is entirely inside the work area."] # [doc = ""] # [doc = "The adjustments can be combined, according to a defined precedence: 1)"] # [doc = "Flip, 2) Slide, 3) Resize."] # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct ConstraintAdjustment : u32 { const None = 0u32 ; const SlideX = 1u32 ; const SlideY = 2u32 ; const FlipX = 4u32 ; const FlipY = 8u32 ; const ResizeX = 16u32 ; const ResizeY = 32u32 ; } }
        impl TryFrom<u32> for ConstraintAdjustment {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "The xdg_positioner provides a collection of rules for the placement of a"]
        #[doc = "child surface relative to a parent surface. Rules can be defined to ensure"]
        #[doc = "the child surface remains within the visible area's borders, and to"]
        #[doc = "specify how the child surface changes its position, such as sliding along"]
        #[doc = "an axis, or flipping around a rectangle. These positioner-created rules are"]
        #[doc = "constrained by the requirement that a child surface must intersect with or"]
        #[doc = "be at least partially adjacent to its parent surface."]
        #[doc = ""]
        #[doc = "See the various requests for details about possible rules."]
        #[doc = ""]
        #[doc = "At the time of the request, the compositor makes a copy of the rules"]
        #[doc = "specified by the xdg_positioner. Thus, after the request is complete the"]
        #[doc = "xdg_positioner object can be destroyed or reused; further changes to the"]
        #[doc = "object will have no effect on previous usages."]
        #[doc = ""]
        #[doc = "For an xdg_positioner object to be considered complete, it must have a"]
        #[doc = "non-zero size set by set_size, and a non-zero anchor rectangle set by"]
        #[doc = "set_anchor_rect. Passing an incomplete xdg_positioner object when"]
        #[doc = "positioning a surface raises an invalid_positioner error."]
        pub trait XdgPositioner: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_positioner";
            const VERSION: u32 = 6u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_positioner#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_positioner#{}.set_size()", object.id);
                        self.set_size(object, client, message.int()?, message.int()?)
                            .await
                    }
                    2u16 => {
                        tracing::debug!("xdg_positioner#{}.set_anchor_rect()", object.id);
                        self.set_anchor_rect(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("xdg_positioner#{}.set_anchor()", object.id);
                        self.set_anchor(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    4u16 => {
                        tracing::debug!("xdg_positioner#{}.set_gravity()", object.id);
                        self.set_gravity(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    5u16 => {
                        tracing::debug!("xdg_positioner#{}.set_constraint_adjustment()", object.id);
                        self.set_constraint_adjustment(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    6u16 => {
                        tracing::debug!("xdg_positioner#{}.set_offset()", object.id);
                        self.set_offset(object, client, message.int()?, message.int()?)
                            .await
                    }
                    7u16 => {
                        tracing::debug!("xdg_positioner#{}.set_reactive()", object.id);
                        self.set_reactive(object, client).await
                    }
                    8u16 => {
                        tracing::debug!("xdg_positioner#{}.set_parent_size()", object.id);
                        self.set_parent_size(object, client, message.int()?, message.int()?)
                            .await
                    }
                    9u16 => {
                        tracing::debug!("xdg_positioner#{}.set_parent_configure()", object.id);
                        self.set_parent_configure(object, client, message.uint()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Notify the compositor that the xdg_positioner will no longer be used."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the size of the surface that is to be positioned with the positioner"]
            #[doc = "object. The size is in surface-local coordinates and corresponds to the"]
            #[doc = "window geometry. See xdg_surface.set_window_geometry."]
            #[doc = ""]
            #[doc = "If a zero or negative size is set the invalid_input error is raised."]
            async fn set_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Specify the anchor rectangle within the parent surface that the child"]
            #[doc = "surface will be placed relative to. The rectangle is relative to the"]
            #[doc = "window geometry as defined by xdg_surface.set_window_geometry of the"]
            #[doc = "parent surface."]
            #[doc = ""]
            #[doc = "When the xdg_positioner object is used to position a child surface, the"]
            #[doc = "anchor rectangle may not extend outside the window geometry of the"]
            #[doc = "positioned child's parent surface."]
            #[doc = ""]
            #[doc = "If a negative size is set the invalid_input error is raised."]
            async fn set_anchor_rect(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Defines the anchor point for the anchor rectangle. The specified anchor"]
            #[doc = "is used derive an anchor point that the child surface will be"]
            #[doc = "positioned relative to. If a corner anchor is set (e.g. 'top_left' or"]
            #[doc = "'bottom_right'), the anchor point will be at the specified corner;"]
            #[doc = "otherwise, the derived anchor point will be centered on the specified"]
            #[doc = "edge, or in the center of the anchor rectangle if no edge is specified."]
            async fn set_anchor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                anchor: Anchor,
            ) -> crate::server::Result<()>;
            #[doc = "Defines in what direction a surface should be positioned, relative to"]
            #[doc = "the anchor point of the parent surface. If a corner gravity is"]
            #[doc = "specified (e.g. 'bottom_right' or 'top_left'), then the child surface"]
            #[doc = "will be placed towards the specified gravity; otherwise, the child"]
            #[doc = "surface will be centered over the anchor point on any axis that had no"]
            #[doc = "gravity specified. If the gravity is not in the ‘gravity’ enum, an"]
            #[doc = "invalid_input error is raised."]
            async fn set_gravity(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                gravity: Gravity,
            ) -> crate::server::Result<()>;
            #[doc = "Specify how the window should be positioned if the originally intended"]
            #[doc = "position caused the surface to be constrained, meaning at least"]
            #[doc = "partially outside positioning boundaries set by the compositor. The"]
            #[doc = "adjustment is set by constructing a bitmask describing the adjustment to"]
            #[doc = "be made when the surface is constrained on that axis."]
            #[doc = ""]
            #[doc = "If no bit for one axis is set, the compositor will assume that the child"]
            #[doc = "surface should not change its position on that axis when constrained."]
            #[doc = ""]
            #[doc = "If more than one bit for one axis is set, the order of how adjustments"]
            #[doc = "are applied is specified in the corresponding adjustment descriptions."]
            #[doc = ""]
            #[doc = "The default adjustment is none."]
            async fn set_constraint_adjustment(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                constraint_adjustment: ConstraintAdjustment,
            ) -> crate::server::Result<()>;
            #[doc = "Specify the surface position offset relative to the position of the"]
            #[doc = "anchor on the anchor rectangle and the anchor on the surface. For"]
            #[doc = "example if the anchor of the anchor rectangle is at (x, y), the surface"]
            #[doc = "has the gravity bottom|right, and the offset is (ox, oy), the calculated"]
            #[doc = "surface position will be (x + ox, y + oy). The offset position of the"]
            #[doc = "surface is the one used for constraint testing. See"]
            #[doc = "set_constraint_adjustment."]
            #[doc = ""]
            #[doc = "An example use case is placing a popup menu on top of a user interface"]
            #[doc = "element, while aligning the user interface element of the parent surface"]
            #[doc = "with some user interface element placed somewhere in the popup surface."]
            async fn set_offset(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "When set reactive, the surface is reconstrained if the conditions used"]
            #[doc = "for constraining changed, e.g. the parent window moved."]
            #[doc = ""]
            #[doc = "If the conditions changed and the popup was reconstrained, an"]
            #[doc = "xdg_popup.configure event is sent with updated geometry, followed by an"]
            #[doc = "xdg_surface.configure event."]
            async fn set_reactive(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the parent window geometry the compositor should use when"]
            #[doc = "positioning the popup. The compositor may use this information to"]
            #[doc = "determine the future state the popup should be constrained using. If"]
            #[doc = "this doesn't match the dimension of the parent the popup is eventually"]
            #[doc = "positioned against, the behavior is undefined."]
            #[doc = ""]
            #[doc = "The arguments are given in the surface-local coordinate space."]
            async fn set_parent_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                parent_width: i32,
                parent_height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Set the serial of an xdg_surface.configure event this positioner will be"]
            #[doc = "used in response to. The compositor may use this information together"]
            #[doc = "with set_parent_size to determine what future state the popup should be"]
            #[doc = "constrained using."]
            async fn set_parent_configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod xdg_surface {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            NotConstructed = 1u32,
            AlreadyConstructed = 2u32,
            UnconfiguredBuffer = 3u32,
            InvalidSerial = 4u32,
            InvalidSize = 5u32,
            DefunctRoleObject = 6u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "An interface that may be implemented by a wl_surface, for"]
        #[doc = "implementations that provide a desktop-style user interface."]
        #[doc = ""]
        #[doc = "It provides a base set of functionality required to construct user"]
        #[doc = "interface elements requiring management by the compositor, such as"]
        #[doc = "toplevel windows, menus, etc. The types of functionality are split into"]
        #[doc = "xdg_surface roles."]
        #[doc = ""]
        #[doc = "Creating an xdg_surface does not set the role for a wl_surface. In order"]
        #[doc = "to map an xdg_surface, the client must create a role-specific object"]
        #[doc = "using, e.g., get_toplevel, get_popup. The wl_surface for any given"]
        #[doc = "xdg_surface can have at most one role, and may not be assigned any role"]
        #[doc = "not based on xdg_surface."]
        #[doc = ""]
        #[doc = "A role must be assigned before any other requests are made to the"]
        #[doc = "xdg_surface object."]
        #[doc = ""]
        #[doc = "The client must call wl_surface.commit on the corresponding wl_surface"]
        #[doc = "for the xdg_surface state to take effect."]
        #[doc = ""]
        #[doc = "Creating an xdg_surface from a wl_surface which has a buffer attached or"]
        #[doc = "committed is a client error, and any attempts by a client to attach or"]
        #[doc = "manipulate a buffer prior to the first xdg_surface.configure call must"]
        #[doc = "also be treated as errors."]
        #[doc = ""]
        #[doc = "After creating a role-specific object and setting it up, the client must"]
        #[doc = "perform an initial commit without any buffer attached. The compositor"]
        #[doc = "will reply with initial wl_surface state such as"]
        #[doc = "wl_surface.preferred_buffer_scale followed by an xdg_surface.configure"]
        #[doc = "event. The client must acknowledge it and is then allowed to attach a"]
        #[doc = "buffer to map the surface."]
        #[doc = ""]
        #[doc = "Mapping an xdg_surface-based role surface is defined as making it"]
        #[doc = "possible for the surface to be shown by the compositor. Note that"]
        #[doc = "a mapped surface is not guaranteed to be visible once it is mapped."]
        #[doc = ""]
        #[doc = "For an xdg_surface to be mapped by the compositor, the following"]
        #[doc = "conditions must be met:"]
        #[doc = "(1) the client has assigned an xdg_surface-based role to the surface"]
        #[doc = "(2) the client has set and committed the xdg_surface state and the"]
        #[doc = "role-dependent state to the surface"]
        #[doc = "(3) the client has committed a buffer to the surface"]
        #[doc = ""]
        #[doc = "A newly-unmapped surface is considered to have met condition (1) out"]
        #[doc = "of the 3 required conditions for mapping a surface if its role surface"]
        #[doc = "has not been destroyed, i.e. the client must perform the initial commit"]
        #[doc = "again before attaching a buffer."]
        pub trait XdgSurface: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_surface";
            const VERSION: u32 = 6u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_surface#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_surface#{}.get_toplevel()", object.id);
                        self.get_toplevel(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("xdg_surface#{}.get_popup()", object.id);
                        self.get_popup(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.object()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("xdg_surface#{}.set_window_geometry()", object.id);
                        self.set_window_geometry(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("xdg_surface#{}.ack_configure()", object.id);
                        self.ack_configure(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the xdg_surface object. An xdg_surface must only be destroyed"]
            #[doc = "after its role object has been destroyed, otherwise"]
            #[doc = "a defunct_role_object error is raised."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This creates an xdg_toplevel object for the given xdg_surface and gives"]
            #[doc = "the associated wl_surface the xdg_toplevel role."]
            #[doc = ""]
            #[doc = "See the documentation of xdg_toplevel for more details about what an"]
            #[doc = "xdg_toplevel is and how it is used."]
            async fn get_toplevel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This creates an xdg_popup object for the given xdg_surface and gives"]
            #[doc = "the associated wl_surface the xdg_popup role."]
            #[doc = ""]
            #[doc = "If null is passed as a parent, a parent surface must be specified using"]
            #[doc = "some other protocol, before committing the initial state."]
            #[doc = ""]
            #[doc = "See the documentation of xdg_popup for more details about what an"]
            #[doc = "xdg_popup is and how it is used."]
            async fn get_popup(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                parent: Option<crate::wire::ObjectId>,
                positioner: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "The window geometry of a surface is its \"visible bounds\" from the"]
            #[doc = "user's perspective. Client-side decorations often have invisible"]
            #[doc = "portions like drop-shadows which should be ignored for the"]
            #[doc = "purposes of aligning, placing and constraining windows."]
            #[doc = ""]
            #[doc = "The window geometry is double buffered, and will be applied at the"]
            #[doc = "time wl_surface.commit of the corresponding wl_surface is called."]
            #[doc = ""]
            #[doc = "When maintaining a position, the compositor should treat the (x, y)"]
            #[doc = "coordinate of the window geometry as the top left corner of the window."]
            #[doc = "A client changing the (x, y) window geometry coordinate should in"]
            #[doc = "general not alter the position of the window."]
            #[doc = ""]
            #[doc = "Once the window geometry of the surface is set, it is not possible to"]
            #[doc = "unset it, and it will remain the same until set_window_geometry is"]
            #[doc = "called again, even if a new subsurface or buffer is attached."]
            #[doc = ""]
            #[doc = "If never set, the value is the full bounds of the surface,"]
            #[doc = "including any subsurfaces. This updates dynamically on every"]
            #[doc = "commit. This unset is meant for extremely simple clients."]
            #[doc = ""]
            #[doc = "The arguments are given in the surface-local coordinate space of"]
            #[doc = "the wl_surface associated with this xdg_surface, and may extend outside"]
            #[doc = "of the wl_surface itself to mark parts of the subsurface tree as part of"]
            #[doc = "the window geometry."]
            #[doc = ""]
            #[doc = "When applied, the effective window geometry will be the set window"]
            #[doc = "geometry clamped to the bounding rectangle of the combined"]
            #[doc = "geometry of the surface of the xdg_surface and the associated"]
            #[doc = "subsurfaces."]
            #[doc = ""]
            #[doc = "The effective geometry will not be recalculated unless a new call to"]
            #[doc = "set_window_geometry is done and the new pending surface state is"]
            #[doc = "subsequently applied."]
            #[doc = ""]
            #[doc = "The width and height of the effective window geometry must be"]
            #[doc = "greater than zero. Setting an invalid size will raise an"]
            #[doc = "invalid_size error."]
            async fn set_window_geometry(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "When a configure event is received, if a client commits the"]
            #[doc = "surface in response to the configure event, then the client"]
            #[doc = "must make an ack_configure request sometime before the commit"]
            #[doc = "request, passing along the serial of the configure event."]
            #[doc = ""]
            #[doc = "For instance, for toplevel surfaces the compositor might use this"]
            #[doc = "information to move a surface to the top left only when the client has"]
            #[doc = "drawn itself for the maximized or fullscreen state."]
            #[doc = ""]
            #[doc = "If the client receives multiple configure events before it"]
            #[doc = "can respond to one, it only has to ack the last configure event."]
            #[doc = "Acking a configure event that was never sent raises an invalid_serial"]
            #[doc = "error."]
            #[doc = ""]
            #[doc = "A client is not required to commit immediately after sending"]
            #[doc = "an ack_configure request - it may even ack_configure several times"]
            #[doc = "before its next surface commit."]
            #[doc = ""]
            #[doc = "A client may send multiple ack_configure requests before committing, but"]
            #[doc = "only the last request sent before a commit indicates which configure"]
            #[doc = "event the client really is responding to."]
            #[doc = ""]
            #[doc = "Sending an ack_configure request consumes the serial number sent with"]
            #[doc = "the request, as well as serial numbers sent by all configure events"]
            #[doc = "sent on this xdg_surface prior to the configure event referenced by"]
            #[doc = "the committed serial."]
            #[doc = ""]
            #[doc = "It is an error to issue multiple ack_configure requests referencing a"]
            #[doc = "serial from the same configure event, or to issue an ack_configure"]
            #[doc = "request referencing a serial from a configure event issued before the"]
            #[doc = "event identified by the last ack_configure request for the same"]
            #[doc = "xdg_surface. Doing so will raise an invalid_serial error."]
            async fn ack_configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "The configure event marks the end of a configure sequence. A configure"]
            #[doc = "sequence is a set of one or more events configuring the state of the"]
            #[doc = "xdg_surface, including the final xdg_surface.configure event."]
            #[doc = ""]
            #[doc = "Where applicable, xdg_surface surface roles will during a configure"]
            #[doc = "sequence extend this event as a latched state sent as events before the"]
            #[doc = "xdg_surface.configure event. Such events should be considered to make up"]
            #[doc = "a set of atomically applied configuration states, where the"]
            #[doc = "xdg_surface.configure commits the accumulated state."]
            #[doc = ""]
            #[doc = "Clients should arrange their surface for the new states, and then send"]
            #[doc = "an ack_configure request with the serial sent in this configure event at"]
            #[doc = "some point before committing the new surface."]
            #[doc = ""]
            #[doc = "If the client receives multiple configure events before it can respond"]
            #[doc = "to one, it is free to discard all but the last event it received."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod xdg_toplevel {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidResizeEdge = 0u32,
            InvalidParent = 1u32,
            InvalidSize = 2u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ResizeEdge {
            None = 0u32,
            Top = 1u32,
            Bottom = 2u32,
            Left = 4u32,
            TopLeft = 5u32,
            BottomLeft = 6u32,
            Right = 8u32,
            TopRight = 9u32,
            BottomRight = 10u32,
        }
        impl TryFrom<u32> for ResizeEdge {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum State {
            #[doc = "The surface is maximized. The window geometry specified in the configure"]
            #[doc = "event must be obeyed by the client, or the xdg_wm_base.invalid_surface_state"]
            #[doc = "error is raised."]
            #[doc = ""]
            #[doc = "The client should draw without shadow or other"]
            #[doc = "decoration outside of the window geometry."]
            Maximized = 1u32,
            #[doc = "The surface is fullscreen. The window geometry specified in the"]
            #[doc = "configure event is a maximum; the client cannot resize beyond it. For"]
            #[doc = "a surface to cover the whole fullscreened area, the geometry"]
            #[doc = "dimensions must be obeyed by the client. For more details, see"]
            #[doc = "xdg_toplevel.set_fullscreen."]
            Fullscreen = 2u32,
            #[doc = "The surface is being resized. The window geometry specified in the"]
            #[doc = "configure event is a maximum; the client cannot resize beyond it."]
            #[doc = "Clients that have aspect ratio or cell sizing configuration can use"]
            #[doc = "a smaller size, however."]
            Resizing = 3u32,
            #[doc = "Client window decorations should be painted as if the window is"]
            #[doc = "active. Do not assume this means that the window actually has"]
            #[doc = "keyboard or pointer focus."]
            Activated = 4u32,
            #[doc = "The window is currently in a tiled layout and the left edge is"]
            #[doc = "considered to be adjacent to another part of the tiling grid."]
            #[doc = ""]
            #[doc = "The client should draw without shadow or other decoration outside of"]
            #[doc = "the window geometry on the left edge."]
            TiledLeft = 5u32,
            #[doc = "The window is currently in a tiled layout and the right edge is"]
            #[doc = "considered to be adjacent to another part of the tiling grid."]
            #[doc = ""]
            #[doc = "The client should draw without shadow or other decoration outside of"]
            #[doc = "the window geometry on the right edge."]
            TiledRight = 6u32,
            #[doc = "The window is currently in a tiled layout and the top edge is"]
            #[doc = "considered to be adjacent to another part of the tiling grid."]
            #[doc = ""]
            #[doc = "The client should draw without shadow or other decoration outside of"]
            #[doc = "the window geometry on the top edge."]
            TiledTop = 7u32,
            #[doc = "The window is currently in a tiled layout and the bottom edge is"]
            #[doc = "considered to be adjacent to another part of the tiling grid."]
            #[doc = ""]
            #[doc = "The client should draw without shadow or other decoration outside of"]
            #[doc = "the window geometry on the bottom edge."]
            TiledBottom = 8u32,
            #[doc = "The surface is currently not ordinarily being repainted; for"]
            #[doc = "example because its content is occluded by another window, or its"]
            #[doc = "outputs are switched off due to screen locking."]
            Suspended = 9u32,
        }
        impl TryFrom<u32> for State {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum WmCapabilities {
            WindowMenu = 1u32,
            Maximize = 2u32,
            Fullscreen = 3u32,
            Minimize = 4u32,
        }
        impl TryFrom<u32> for WmCapabilities {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This interface defines an xdg_surface role which allows a surface to,"]
        #[doc = "among other things, set window-like properties such as maximize,"]
        #[doc = "fullscreen, and minimize, set application-specific metadata like title and"]
        #[doc = "id, and well as trigger user interactive operations such as interactive"]
        #[doc = "resize and move."]
        #[doc = ""]
        #[doc = "A xdg_toplevel by default is responsible for providing the full intended"]
        #[doc = "visual representation of the toplevel, which depending on the window"]
        #[doc = "state, may mean things like a title bar, window controls and drop shadow."]
        #[doc = ""]
        #[doc = "Unmapping an xdg_toplevel means that the surface cannot be shown"]
        #[doc = "by the compositor until it is explicitly mapped again."]
        #[doc = "All active operations (e.g., move, resize) are canceled and all"]
        #[doc = "attributes (e.g. title, state, stacking, ...) are discarded for"]
        #[doc = "an xdg_toplevel surface when it is unmapped. The xdg_toplevel returns to"]
        #[doc = "the state it had right after xdg_surface.get_toplevel. The client"]
        #[doc = "can re-map the toplevel by perfoming a commit without any buffer"]
        #[doc = "attached, waiting for a configure event and handling it as usual (see"]
        #[doc = "xdg_surface description)."]
        #[doc = ""]
        #[doc = "Attaching a null buffer to a toplevel unmaps the surface."]
        pub trait XdgToplevel: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_toplevel";
            const VERSION: u32 = 6u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_toplevel#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_toplevel#{}.set_parent()", object.id);
                        self.set_parent(object, client, message.object()?).await
                    }
                    2u16 => {
                        tracing::debug!("xdg_toplevel#{}.set_title()", object.id);
                        self.set_title(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("xdg_toplevel#{}.set_app_id()", object.id);
                        self.set_app_id(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("xdg_toplevel#{}.show_window_menu()", object.id);
                        self.show_window_menu(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    5u16 => {
                        tracing::debug!("xdg_toplevel#{}.move()", object.id);
                        self.r#move(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    6u16 => {
                        tracing::debug!("xdg_toplevel#{}.resize()", object.id);
                        self.resize(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    7u16 => {
                        tracing::debug!("xdg_toplevel#{}.set_max_size()", object.id);
                        self.set_max_size(object, client, message.int()?, message.int()?)
                            .await
                    }
                    8u16 => {
                        tracing::debug!("xdg_toplevel#{}.set_min_size()", object.id);
                        self.set_min_size(object, client, message.int()?, message.int()?)
                            .await
                    }
                    9u16 => {
                        tracing::debug!("xdg_toplevel#{}.set_maximized()", object.id);
                        self.set_maximized(object, client).await
                    }
                    10u16 => {
                        tracing::debug!("xdg_toplevel#{}.unset_maximized()", object.id);
                        self.unset_maximized(object, client).await
                    }
                    11u16 => {
                        tracing::debug!("xdg_toplevel#{}.set_fullscreen()", object.id);
                        self.set_fullscreen(object, client, message.object()?).await
                    }
                    12u16 => {
                        tracing::debug!("xdg_toplevel#{}.unset_fullscreen()", object.id);
                        self.unset_fullscreen(object, client).await
                    }
                    13u16 => {
                        tracing::debug!("xdg_toplevel#{}.set_minimized()", object.id);
                        self.set_minimized(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request destroys the role surface and unmaps the surface;"]
            #[doc = "see \"Unmapping\" behavior in interface section for details."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the \"parent\" of this surface. This surface should be stacked"]
            #[doc = "above the parent surface and all other ancestor surfaces."]
            #[doc = ""]
            #[doc = "Parent surfaces should be set on dialogs, toolboxes, or other"]
            #[doc = "\"auxiliary\" surfaces, so that the parent is raised when the dialog"]
            #[doc = "is raised."]
            #[doc = ""]
            #[doc = "Setting a null parent for a child surface unsets its parent. Setting"]
            #[doc = "a null parent for a surface which currently has no parent is a no-op."]
            #[doc = ""]
            #[doc = "Only mapped surfaces can have child surfaces. Setting a parent which"]
            #[doc = "is not mapped is equivalent to setting a null parent. If a surface"]
            #[doc = "becomes unmapped, its children's parent is set to the parent of"]
            #[doc = "the now-unmapped surface. If the now-unmapped surface has no parent,"]
            #[doc = "its children's parent is unset. If the now-unmapped surface becomes"]
            #[doc = "mapped again, its parent-child relationship is not restored."]
            #[doc = ""]
            #[doc = "The parent toplevel must not be one of the child toplevel's"]
            #[doc = "descendants, and the parent must be different from the child toplevel,"]
            #[doc = "otherwise the invalid_parent protocol error is raised."]
            async fn set_parent(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                parent: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Set a short title for the surface."]
            #[doc = ""]
            #[doc = "This string may be used to identify the surface in a task bar,"]
            #[doc = "window list, or other user interface elements provided by the"]
            #[doc = "compositor."]
            #[doc = ""]
            #[doc = "The string must be encoded in UTF-8."]
            async fn set_title(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                title: String,
            ) -> crate::server::Result<()>;
            #[doc = "Set an application identifier for the surface."]
            #[doc = ""]
            #[doc = "The app ID identifies the general class of applications to which"]
            #[doc = "the surface belongs. The compositor can use this to group multiple"]
            #[doc = "surfaces together, or to determine how to launch a new application."]
            #[doc = ""]
            #[doc = "For D-Bus activatable applications, the app ID is used as the D-Bus"]
            #[doc = "service name."]
            #[doc = ""]
            #[doc = "The compositor shell will try to group application surfaces together"]
            #[doc = "by their app ID. As a best practice, it is suggested to select app"]
            #[doc = "ID's that match the basename of the application's .desktop file."]
            #[doc = "For example, \"org.freedesktop.FooViewer\" where the .desktop file is"]
            #[doc = "\"org.freedesktop.FooViewer.desktop\"."]
            #[doc = ""]
            #[doc = "Like other properties, a set_app_id request can be sent after the"]
            #[doc = "xdg_toplevel has been mapped to update the property."]
            #[doc = ""]
            #[doc = "See the desktop-entry specification [0] for more details on"]
            #[doc = "application identifiers and how they relate to well-known D-Bus"]
            #[doc = "names and .desktop files."]
            #[doc = ""]
            #[doc = "[0] https://standards.freedesktop.org/desktop-entry-spec/"]
            async fn set_app_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                app_id: String,
            ) -> crate::server::Result<()>;
            #[doc = "Clients implementing client-side decorations might want to show"]
            #[doc = "a context menu when right-clicking on the decorations, giving the"]
            #[doc = "user a menu that they can use to maximize or minimize the window."]
            #[doc = ""]
            #[doc = "This request asks the compositor to pop up such a window menu at"]
            #[doc = "the given position, relative to the local surface coordinates of"]
            #[doc = "the parent surface. There are no guarantees as to what menu items"]
            #[doc = "the window menu contains, or even if a window menu will be drawn"]
            #[doc = "at all."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action"]
            #[doc = "like a button press, key press, or touch down event."]
            async fn show_window_menu(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Start an interactive, user-driven move of the surface."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action"]
            #[doc = "like a button press, key press, or touch down event. The passed"]
            #[doc = "serial is used to determine the type of interactive move (touch,"]
            #[doc = "pointer, etc)."]
            #[doc = ""]
            #[doc = "The server may ignore move requests depending on the state of"]
            #[doc = "the surface (e.g. fullscreen or maximized), or if the passed serial"]
            #[doc = "is no longer valid."]
            #[doc = ""]
            #[doc = "If triggered, the surface will lose the focus of the device"]
            #[doc = "(wl_pointer, wl_touch, etc) used for the move. It is up to the"]
            #[doc = "compositor to visually indicate that the move is taking place, such as"]
            #[doc = "updating a pointer cursor, during the move. There is no guarantee"]
            #[doc = "that the device focus will return when the move is completed."]
            async fn r#move(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Start a user-driven, interactive resize of the surface."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action"]
            #[doc = "like a button press, key press, or touch down event. The passed"]
            #[doc = "serial is used to determine the type of interactive resize (touch,"]
            #[doc = "pointer, etc)."]
            #[doc = ""]
            #[doc = "The server may ignore resize requests depending on the state of"]
            #[doc = "the surface (e.g. fullscreen or maximized)."]
            #[doc = ""]
            #[doc = "If triggered, the client will receive configure events with the"]
            #[doc = "\"resize\" state enum value and the expected sizes. See the \"resize\""]
            #[doc = "enum value for more details about what is required. The client"]
            #[doc = "must also acknowledge configure events using \"ack_configure\". After"]
            #[doc = "the resize is completed, the client will receive another \"configure\""]
            #[doc = "event without the resize state."]
            #[doc = ""]
            #[doc = "If triggered, the surface also will lose the focus of the device"]
            #[doc = "(wl_pointer, wl_touch, etc) used for the resize. It is up to the"]
            #[doc = "compositor to visually indicate that the resize is taking place,"]
            #[doc = "such as updating a pointer cursor, during the resize. There is no"]
            #[doc = "guarantee that the device focus will return when the resize is"]
            #[doc = "completed."]
            #[doc = ""]
            #[doc = "The edges parameter specifies how the surface should be resized, and"]
            #[doc = "is one of the values of the resize_edge enum. Values not matching"]
            #[doc = "a variant of the enum will cause the invalid_resize_edge protocol error."]
            #[doc = "The compositor may use this information to update the surface position"]
            #[doc = "for example when dragging the top left corner. The compositor may also"]
            #[doc = "use this information to adapt its behavior, e.g. choose an appropriate"]
            #[doc = "cursor image."]
            async fn resize(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
                edges: ResizeEdge,
            ) -> crate::server::Result<()>;
            #[doc = "Set a maximum size for the window."]
            #[doc = ""]
            #[doc = "The client can specify a maximum size so that the compositor does"]
            #[doc = "not try to configure the window beyond this size."]
            #[doc = ""]
            #[doc = "The width and height arguments are in window geometry coordinates."]
            #[doc = "See xdg_surface.set_window_geometry."]
            #[doc = ""]
            #[doc = "Values set in this way are double-buffered. They will get applied"]
            #[doc = "on the next commit."]
            #[doc = ""]
            #[doc = "The compositor can use this information to allow or disallow"]
            #[doc = "different states like maximize or fullscreen and draw accurate"]
            #[doc = "animations."]
            #[doc = ""]
            #[doc = "Similarly, a tiling window manager may use this information to"]
            #[doc = "place and resize client windows in a more effective way."]
            #[doc = ""]
            #[doc = "The client should not rely on the compositor to obey the maximum"]
            #[doc = "size. The compositor may decide to ignore the values set by the"]
            #[doc = "client and request a larger size."]
            #[doc = ""]
            #[doc = "If never set, or a value of zero in the request, means that the"]
            #[doc = "client has no expected maximum size in the given dimension."]
            #[doc = "As a result, a client wishing to reset the maximum size"]
            #[doc = "to an unspecified state can use zero for width and height in the"]
            #[doc = "request."]
            #[doc = ""]
            #[doc = "Requesting a maximum size to be smaller than the minimum size of"]
            #[doc = "a surface is illegal and will result in an invalid_size error."]
            #[doc = ""]
            #[doc = "The width and height must be greater than or equal to zero. Using"]
            #[doc = "strictly negative values for width or height will result in a"]
            #[doc = "invalid_size error."]
            async fn set_max_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Set a minimum size for the window."]
            #[doc = ""]
            #[doc = "The client can specify a minimum size so that the compositor does"]
            #[doc = "not try to configure the window below this size."]
            #[doc = ""]
            #[doc = "The width and height arguments are in window geometry coordinates."]
            #[doc = "See xdg_surface.set_window_geometry."]
            #[doc = ""]
            #[doc = "Values set in this way are double-buffered. They will get applied"]
            #[doc = "on the next commit."]
            #[doc = ""]
            #[doc = "The compositor can use this information to allow or disallow"]
            #[doc = "different states like maximize or fullscreen and draw accurate"]
            #[doc = "animations."]
            #[doc = ""]
            #[doc = "Similarly, a tiling window manager may use this information to"]
            #[doc = "place and resize client windows in a more effective way."]
            #[doc = ""]
            #[doc = "The client should not rely on the compositor to obey the minimum"]
            #[doc = "size. The compositor may decide to ignore the values set by the"]
            #[doc = "client and request a smaller size."]
            #[doc = ""]
            #[doc = "If never set, or a value of zero in the request, means that the"]
            #[doc = "client has no expected minimum size in the given dimension."]
            #[doc = "As a result, a client wishing to reset the minimum size"]
            #[doc = "to an unspecified state can use zero for width and height in the"]
            #[doc = "request."]
            #[doc = ""]
            #[doc = "Requesting a minimum size to be larger than the maximum size of"]
            #[doc = "a surface is illegal and will result in an invalid_size error."]
            #[doc = ""]
            #[doc = "The width and height must be greater than or equal to zero. Using"]
            #[doc = "strictly negative values for width and height will result in a"]
            #[doc = "invalid_size error."]
            async fn set_min_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Maximize the surface."]
            #[doc = ""]
            #[doc = "After requesting that the surface should be maximized, the compositor"]
            #[doc = "will respond by emitting a configure event. Whether this configure"]
            #[doc = "actually sets the window maximized is subject to compositor policies."]
            #[doc = "The client must then update its content, drawing in the configured"]
            #[doc = "state. The client must also acknowledge the configure when committing"]
            #[doc = "the new content (see ack_configure)."]
            #[doc = ""]
            #[doc = "It is up to the compositor to decide how and where to maximize the"]
            #[doc = "surface, for example which output and what region of the screen should"]
            #[doc = "be used."]
            #[doc = ""]
            #[doc = "If the surface was already maximized, the compositor will still emit"]
            #[doc = "a configure event with the \"maximized\" state."]
            #[doc = ""]
            #[doc = "If the surface is in a fullscreen state, this request has no direct"]
            #[doc = "effect. It may alter the state the surface is returned to when"]
            #[doc = "unmaximized unless overridden by the compositor."]
            async fn set_maximized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Unmaximize the surface."]
            #[doc = ""]
            #[doc = "After requesting that the surface should be unmaximized, the compositor"]
            #[doc = "will respond by emitting a configure event. Whether this actually"]
            #[doc = "un-maximizes the window is subject to compositor policies."]
            #[doc = "If available and applicable, the compositor will include the window"]
            #[doc = "geometry dimensions the window had prior to being maximized in the"]
            #[doc = "configure event. The client must then update its content, drawing it in"]
            #[doc = "the configured state. The client must also acknowledge the configure"]
            #[doc = "when committing the new content (see ack_configure)."]
            #[doc = ""]
            #[doc = "It is up to the compositor to position the surface after it was"]
            #[doc = "unmaximized; usually the position the surface had before maximizing, if"]
            #[doc = "applicable."]
            #[doc = ""]
            #[doc = "If the surface was already not maximized, the compositor will still"]
            #[doc = "emit a configure event without the \"maximized\" state."]
            #[doc = ""]
            #[doc = "If the surface is in a fullscreen state, this request has no direct"]
            #[doc = "effect. It may alter the state the surface is returned to when"]
            #[doc = "unmaximized unless overridden by the compositor."]
            async fn unset_maximized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Make the surface fullscreen."]
            #[doc = ""]
            #[doc = "After requesting that the surface should be fullscreened, the"]
            #[doc = "compositor will respond by emitting a configure event. Whether the"]
            #[doc = "client is actually put into a fullscreen state is subject to compositor"]
            #[doc = "policies. The client must also acknowledge the configure when"]
            #[doc = "committing the new content (see ack_configure)."]
            #[doc = ""]
            #[doc = "The output passed by the request indicates the client's preference as"]
            #[doc = "to which display it should be set fullscreen on. If this value is NULL,"]
            #[doc = "it's up to the compositor to choose which display will be used to map"]
            #[doc = "this surface."]
            #[doc = ""]
            #[doc = "If the surface doesn't cover the whole output, the compositor will"]
            #[doc = "position the surface in the center of the output and compensate with"]
            #[doc = "with border fill covering the rest of the output. The content of the"]
            #[doc = "border fill is undefined, but should be assumed to be in some way that"]
            #[doc = "attempts to blend into the surrounding area (e.g. solid black)."]
            #[doc = ""]
            #[doc = "If the fullscreened surface is not opaque, the compositor must make"]
            #[doc = "sure that other screen content not part of the same surface tree (made"]
            #[doc = "up of subsurfaces, popups or similarly coupled surfaces) are not"]
            #[doc = "visible below the fullscreened surface."]
            async fn set_fullscreen(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Make the surface no longer fullscreen."]
            #[doc = ""]
            #[doc = "After requesting that the surface should be unfullscreened, the"]
            #[doc = "compositor will respond by emitting a configure event."]
            #[doc = "Whether this actually removes the fullscreen state of the client is"]
            #[doc = "subject to compositor policies."]
            #[doc = ""]
            #[doc = "Making a surface unfullscreen sets states for the surface based on the following:"]
            #[doc = "* the state(s) it may have had before becoming fullscreen"]
            #[doc = "* any state(s) decided by the compositor"]
            #[doc = "* any state(s) requested by the client while the surface was fullscreen"]
            #[doc = ""]
            #[doc = "The compositor may include the previous window geometry dimensions in"]
            #[doc = "the configure event, if applicable."]
            #[doc = ""]
            #[doc = "The client must also acknowledge the configure when committing the new"]
            #[doc = "content (see ack_configure)."]
            async fn unset_fullscreen(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Request that the compositor minimize your surface. There is no"]
            #[doc = "way to know if the surface is currently minimized, nor is there"]
            #[doc = "any way to unset minimization on this surface."]
            #[doc = ""]
            #[doc = "If you are looking to throttle redrawing when minimized, please"]
            #[doc = "instead use the wl_surface.frame event for this, as this will"]
            #[doc = "also work with live previews on windows in Alt-Tab, Expose or"]
            #[doc = "similar compositor features."]
            async fn set_minimized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This configure event asks the client to resize its toplevel surface or"]
            #[doc = "to change its state. The configured state should not be applied"]
            #[doc = "immediately. See xdg_surface.configure for details."]
            #[doc = ""]
            #[doc = "The width and height arguments specify a hint to the window"]
            #[doc = "about how its surface should be resized in window geometry"]
            #[doc = "coordinates. See set_window_geometry."]
            #[doc = ""]
            #[doc = "If the width or height arguments are zero, it means the client"]
            #[doc = "should decide its own window dimension. This may happen when the"]
            #[doc = "compositor needs to configure the state of the surface but doesn't"]
            #[doc = "have any information about any previous or expected dimension."]
            #[doc = ""]
            #[doc = "The states listed in the event specify how the width/height"]
            #[doc = "arguments should be interpreted, and possibly how it should be"]
            #[doc = "drawn."]
            #[doc = ""]
            #[doc = "Clients must send an ack_configure in response to this event. See"]
            #[doc = "xdg_surface.configure and xdg_surface.ack_configure for details."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The close event is sent by the compositor when the user"]
            #[doc = "wants the surface to be closed. This should be equivalent to"]
            #[doc = "the user clicking the close button in client-side decorations,"]
            #[doc = "if your application has any."]
            #[doc = ""]
            #[doc = "This is only a request that the user intends to close the"]
            #[doc = "window. The client may choose to ignore this request, or show"]
            #[doc = "a dialog to ask the user to save their data, etc."]
            async fn close(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The configure_bounds event may be sent prior to a xdg_toplevel.configure"]
            #[doc = "event to communicate the bounds a window geometry size is recommended"]
            #[doc = "to constrain to."]
            #[doc = ""]
            #[doc = "The passed width and height are in surface coordinate space. If width"]
            #[doc = "and height are 0, it means bounds is unknown and equivalent to as if no"]
            #[doc = "configure_bounds event was ever sent for this surface."]
            #[doc = ""]
            #[doc = "The bounds can for example correspond to the size of a monitor excluding"]
            #[doc = "any panels or other shell components, so that a surface isn't created in"]
            #[doc = "a way that it cannot fit."]
            #[doc = ""]
            #[doc = "The bounds may change at any point, and in such a case, a new"]
            #[doc = "xdg_toplevel.configure_bounds will be sent, followed by"]
            #[doc = "xdg_toplevel.configure and xdg_surface.configure."]
            async fn configure_bounds(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event advertises the capabilities supported by the compositor. If"]
            #[doc = "a capability isn't supported, clients should hide or disable the UI"]
            #[doc = "elements that expose this functionality. For instance, if the"]
            #[doc = "compositor doesn't advertise support for minimized toplevels, a button"]
            #[doc = "triggering the set_minimized request should not be displayed."]
            #[doc = ""]
            #[doc = "The compositor will ignore requests it doesn't support. For instance,"]
            #[doc = "a compositor which doesn't advertise support for minimized will ignore"]
            #[doc = "set_minimized requests."]
            #[doc = ""]
            #[doc = "Compositors must send this event once before the first"]
            #[doc = "xdg_surface.configure event. When the capabilities change, compositors"]
            #[doc = "must send this event again and then send an xdg_surface.configure"]
            #[doc = "event."]
            #[doc = ""]
            #[doc = "The configured state should not be applied immediately. See"]
            #[doc = "xdg_surface.configure for details."]
            #[doc = ""]
            #[doc = "The capabilities are sent as an array of 32-bit unsigned integers in"]
            #[doc = "native endianness."]
            async fn wm_capabilities(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod xdg_popup {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidGrab = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "A popup surface is a short-lived, temporary surface. It can be used to"]
        #[doc = "implement for example menus, popovers, tooltips and other similar user"]
        #[doc = "interface concepts."]
        #[doc = ""]
        #[doc = "A popup can be made to take an explicit grab. See xdg_popup.grab for"]
        #[doc = "details."]
        #[doc = ""]
        #[doc = "When the popup is dismissed, a popup_done event will be sent out, and at"]
        #[doc = "the same time the surface will be unmapped. See the xdg_popup.popup_done"]
        #[doc = "event for details."]
        #[doc = ""]
        #[doc = "Explicitly destroying the xdg_popup object will also dismiss the popup and"]
        #[doc = "unmap the surface. Clients that want to dismiss the popup when another"]
        #[doc = "surface of their own is clicked should dismiss the popup using the destroy"]
        #[doc = "request."]
        #[doc = ""]
        #[doc = "A newly created xdg_popup will be stacked on top of all previously created"]
        #[doc = "xdg_popup surfaces associated with the same xdg_toplevel."]
        #[doc = ""]
        #[doc = "The parent of an xdg_popup must be mapped (see the xdg_surface"]
        #[doc = "description) before the xdg_popup itself."]
        #[doc = ""]
        #[doc = "The client must call wl_surface.commit on the corresponding wl_surface"]
        #[doc = "for the xdg_popup state to take effect."]
        pub trait XdgPopup: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_popup";
            const VERSION: u32 = 6u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_popup#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_popup#{}.grab()", object.id);
                        self.grab(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("xdg_popup#{}.reposition()", object.id);
                        self.reposition(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This destroys the popup. Explicitly destroying the xdg_popup"]
            #[doc = "object will also dismiss the popup, and unmap the surface."]
            #[doc = ""]
            #[doc = "If this xdg_popup is not the \"topmost\" popup, the"]
            #[doc = "xdg_wm_base.not_the_topmost_popup protocol error will be sent."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This request makes the created popup take an explicit grab. An explicit"]
            #[doc = "grab will be dismissed when the user dismisses the popup, or when the"]
            #[doc = "client destroys the xdg_popup. This can be done by the user clicking"]
            #[doc = "outside the surface, using the keyboard, or even locking the screen"]
            #[doc = "through closing the lid or a timeout."]
            #[doc = ""]
            #[doc = "If the compositor denies the grab, the popup will be immediately"]
            #[doc = "dismissed."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action like a"]
            #[doc = "button press, key press, or touch down event. The serial number of the"]
            #[doc = "event should be passed as 'serial'."]
            #[doc = ""]
            #[doc = "The parent of a grabbing popup must either be an xdg_toplevel surface or"]
            #[doc = "another xdg_popup with an explicit grab. If the parent is another"]
            #[doc = "xdg_popup it means that the popups are nested, with this popup now being"]
            #[doc = "the topmost popup."]
            #[doc = ""]
            #[doc = "Nested popups must be destroyed in the reverse order they were created"]
            #[doc = "in, e.g. the only popup you are allowed to destroy at all times is the"]
            #[doc = "topmost one."]
            #[doc = ""]
            #[doc = "When compositors choose to dismiss a popup, they may dismiss every"]
            #[doc = "nested grabbing popup as well. When a compositor dismisses popups, it"]
            #[doc = "will follow the same dismissing order as required from the client."]
            #[doc = ""]
            #[doc = "If the topmost grabbing popup is destroyed, the grab will be returned to"]
            #[doc = "the parent of the popup, if that parent previously had an explicit grab."]
            #[doc = ""]
            #[doc = "If the parent is a grabbing popup which has already been dismissed, this"]
            #[doc = "popup will be immediately dismissed. If the parent is a popup that did"]
            #[doc = "not take an explicit grab, an error will be raised."]
            #[doc = ""]
            #[doc = "During a popup grab, the client owning the grab will receive pointer"]
            #[doc = "and touch events for all their surfaces as normal (similar to an"]
            #[doc = "\"owner-events\" grab in X11 parlance), while the top most grabbing popup"]
            #[doc = "will always have keyboard focus."]
            async fn grab(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Reposition an already-mapped popup. The popup will be placed given the"]
            #[doc = "details in the passed xdg_positioner object, and a"]
            #[doc = "xdg_popup.repositioned followed by xdg_popup.configure and"]
            #[doc = "xdg_surface.configure will be emitted in response. Any parameters set"]
            #[doc = "by the previous positioner will be discarded."]
            #[doc = ""]
            #[doc = "The passed token will be sent in the corresponding"]
            #[doc = "xdg_popup.repositioned event. The new popup position will not take"]
            #[doc = "effect until the corresponding configure event is acknowledged by the"]
            #[doc = "client. See xdg_popup.repositioned for details. The token itself is"]
            #[doc = "opaque, and has no other special meaning."]
            #[doc = ""]
            #[doc = "If multiple reposition requests are sent, the compositor may skip all"]
            #[doc = "but the last one."]
            #[doc = ""]
            #[doc = "If the popup is repositioned in response to a configure event for its"]
            #[doc = "parent, the client should send an xdg_positioner.set_parent_configure"]
            #[doc = "and possibly an xdg_positioner.set_parent_size request to allow the"]
            #[doc = "compositor to properly constrain the popup."]
            #[doc = ""]
            #[doc = "If the popup is repositioned together with a parent that is being"]
            #[doc = "resized, but not in response to a configure event, the client should"]
            #[doc = "send an xdg_positioner.set_parent_size request."]
            async fn reposition(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                positioner: crate::wire::ObjectId,
                token: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This event asks the popup surface to configure itself given the"]
            #[doc = "configuration. The configured state should not be applied immediately."]
            #[doc = "See xdg_surface.configure for details."]
            #[doc = ""]
            #[doc = "The x and y arguments represent the position the popup was placed at"]
            #[doc = "given the xdg_positioner rule, relative to the upper left corner of the"]
            #[doc = "window geometry of the parent surface."]
            #[doc = ""]
            #[doc = "For version 2 or older, the configure event for an xdg_popup is only"]
            #[doc = "ever sent once for the initial configuration. Starting with version 3,"]
            #[doc = "it may be sent again if the popup is setup with an xdg_positioner with"]
            #[doc = "set_reactive requested, or in response to xdg_popup.reposition requests."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The popup_done event is sent out when a popup is dismissed by the"]
            #[doc = "compositor. The client should destroy the xdg_popup object at this"]
            #[doc = "point."]
            async fn popup_done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The repositioned event is sent as part of a popup configuration"]
            #[doc = "sequence, together with xdg_popup.configure and lastly"]
            #[doc = "xdg_surface.configure to notify the completion of a reposition request."]
            #[doc = ""]
            #[doc = "The repositioned event is to notify about the completion of a"]
            #[doc = "xdg_popup.reposition request. The token argument is the token passed"]
            #[doc = "in the xdg_popup.reposition request."]
            #[doc = ""]
            #[doc = "Immediately after this event is emitted, xdg_popup.configure and"]
            #[doc = "xdg_surface.configure will be sent with the updated size and position,"]
            #[doc = "as well as a new configure serial."]
            #[doc = ""]
            #[doc = "The client should optionally update the content of the popup, but must"]
            #[doc = "acknowledge the new popup configuration for the new position to take"]
            #[doc = "effect. See xdg_surface.ack_configure for details."]
            async fn repositioned(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
pub mod alpha_modifier_v1 {
    pub mod wp_alpha_modifier_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            AlreadyConstructed = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This interface allows a client to set a factor for the alpha values on a"]
        #[doc = "surface, which can be used to offload such operations to the compositor,"]
        #[doc = "which can in turn for example offload them to KMS."]
        #[doc = ""]
        #[doc = "Warning! The protocol described in this file is currently in the testing"]
        #[doc = "phase. Backward compatible changes may be added together with the"]
        #[doc = "corresponding interface version bump. Backward incompatible changes can"]
        #[doc = "only be done by creating a new major version of the extension."]
        pub trait WpAlphaModifierV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_alpha_modifier_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_alpha_modifier_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("wp_alpha_modifier_v1#{}.get_surface()", object.id);
                        self.get_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the alpha modifier manager. This doesn't destroy objects"]
            #[doc = "created with the manager."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a new alpha modifier surface object associated with the"]
            #[doc = "given wl_surface. If there is already such an object associated with"]
            #[doc = "the wl_surface, the already_constructed error will be raised."]
            async fn get_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wp_alpha_modifier_surface_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            NoSurface = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This interface allows the client to set a factor for the alpha values on"]
        #[doc = "a surface, which can be used to offload such operations to the compositor."]
        #[doc = "The default factor is UINT32_MAX."]
        #[doc = ""]
        #[doc = "This object has to be destroyed before the associated wl_surface. Once the"]
        #[doc = "wl_surface is destroyed, all request on this object will raise the"]
        #[doc = "no_surface error."]
        pub trait WpAlphaModifierSurfaceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_alpha_modifier_surface_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_alpha_modifier_surface_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "wp_alpha_modifier_surface_v1#{}.set_multiplier()",
                            object.id
                        );
                        self.set_multiplier(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This destroys the object, and is equivalent to set_multiplier with"]
            #[doc = "a value of UINT32_MAX, with the same double-buffered semantics as"]
            #[doc = "set_multiplier."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the alpha multiplier for the surface. The alpha multiplier is"]
            #[doc = "double-buffered state, see wl_surface.commit for details."]
            #[doc = ""]
            #[doc = "This factor is applied in the compositor's blending space, as an"]
            #[doc = "additional step after the processing of per-pixel alpha values for the"]
            #[doc = "wl_surface. The exact meaning of the factor is thus undefined, unless"]
            #[doc = "the blending space is specified in a different extension."]
            #[doc = ""]
            #[doc = "This multiplier is applied even if the buffer attached to the"]
            #[doc = "wl_surface doesn't have an alpha channel; in that case an alpha value"]
            #[doc = "of one is used instead."]
            #[doc = ""]
            #[doc = "Zero means completely transparent, UINT32_MAX means completely opaque."]
            async fn set_multiplier(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                factor: u32,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod content_type_v1 {
    pub mod wp_content_type_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            AlreadyConstructed = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This interface allows a client to describe the kind of content a surface"]
        #[doc = "will display, to allow the compositor to optimize its behavior for it."]
        #[doc = ""]
        #[doc = "Warning! The protocol described in this file is currently in the testing"]
        #[doc = "phase. Backward compatible changes may be added together with the"]
        #[doc = "corresponding interface version bump. Backward incompatible changes can"]
        #[doc = "only be done by creating a new major version of the extension."]
        pub trait WpContentTypeManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_content_type_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_content_type_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "wp_content_type_manager_v1#{}.get_surface_content_type()",
                            object.id
                        );
                        self.get_surface_content_type(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the content type manager. This doesn't destroy objects created"]
            #[doc = "with the manager."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a new content type object associated with the given surface."]
            #[doc = ""]
            #[doc = "Creating a wp_content_type_v1 from a wl_surface which already has one"]
            #[doc = "attached is a client error: already_constructed."]
            async fn get_surface_content_type(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wp_content_type_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Type {
            #[doc = "The content type none means that either the application has no data"]
            #[doc = "about the content type, or that the content doesn't fit into one of"]
            #[doc = "the other categories."]
            None = 0u32,
            #[doc = "The content type photo describes content derived from digital still"]
            #[doc = "pictures and may be presented with minimal processing."]
            Photo = 1u32,
            #[doc = "The content type video describes a video or animation and may be"]
            #[doc = "presented with more accurate timing to avoid stutter. Where scaling"]
            #[doc = "is needed, scaling methods more appropriate for video may be used."]
            Video = 2u32,
            #[doc = "The content type game describes a running game. Its content may be"]
            #[doc = "presented with reduced latency."]
            Game = 3u32,
        }
        impl TryFrom<u32> for Type {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "The content type object allows the compositor to optimize for the kind"]
        #[doc = "of content shown on the surface. A compositor may for example use it to"]
        #[doc = "set relevant drm properties like \"content type\"."]
        #[doc = ""]
        #[doc = "The client may request to switch to another content type at any time."]
        #[doc = "When the associated surface gets destroyed, this object becomes inert and"]
        #[doc = "the client should destroy it."]
        pub trait WpContentTypeV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_content_type_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_content_type_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("wp_content_type_v1#{}.set_content_type()", object.id);
                        self.set_content_type(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Switch back to not specifying the content type of this surface. This is"]
            #[doc = "equivalent to setting the content type to none, including double"]
            #[doc = "buffering semantics. See set_content_type for details."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the surface content type. This informs the compositor that the"]
            #[doc = "client believes it is displaying buffers matching this content type."]
            #[doc = ""]
            #[doc = "This is purely a hint for the compositor, which can be used to adjust"]
            #[doc = "its behavior or hardware settings to fit the presented content best."]
            #[doc = ""]
            #[doc = "The content type is double-buffered state, see wl_surface.commit for"]
            #[doc = "details."]
            async fn set_content_type(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                content_type: Type,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod cursor_shape_v1 {
    pub mod wp_cursor_shape_manager_v1 {
        #[doc = "This global offers an alternative, optional way to set cursor images. This"]
        #[doc = "new way uses enumerated cursors instead of a wl_surface like"]
        #[doc = "wl_pointer.set_cursor does."]
        #[doc = ""]
        #[doc = "Warning! The protocol described in this file is currently in the testing"]
        #[doc = "phase. Backward compatible changes may be added together with the"]
        #[doc = "corresponding interface version bump. Backward incompatible changes can"]
        #[doc = "only be done by creating a new major version of the extension."]
        pub trait WpCursorShapeManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_cursor_shape_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_cursor_shape_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("wp_cursor_shape_manager_v1#{}.get_pointer()", object.id);
                        self.get_pointer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "wp_cursor_shape_manager_v1#{}.get_tablet_tool_v2()",
                            object.id
                        );
                        self.get_tablet_tool_v2(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the cursor shape manager."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Obtain a wp_cursor_shape_device_v1 for a wl_pointer object."]
            async fn get_pointer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                cursor_shape_device: crate::wire::ObjectId,
                pointer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Obtain a wp_cursor_shape_device_v1 for a zwp_tablet_tool_v2 object."]
            async fn get_tablet_tool_v2(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                cursor_shape_device: crate::wire::ObjectId,
                tablet_tool: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wp_cursor_shape_device_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Shape {
            Default = 1u32,
            ContextMenu = 2u32,
            Help = 3u32,
            Pointer = 4u32,
            Progress = 5u32,
            Wait = 6u32,
            Cell = 7u32,
            Crosshair = 8u32,
            Text = 9u32,
            VerticalText = 10u32,
            Alias = 11u32,
            Copy = 12u32,
            Move = 13u32,
            NoDrop = 14u32,
            NotAllowed = 15u32,
            Grab = 16u32,
            Grabbing = 17u32,
            EResize = 18u32,
            NResize = 19u32,
            NeResize = 20u32,
            NwResize = 21u32,
            SResize = 22u32,
            SeResize = 23u32,
            SwResize = 24u32,
            WResize = 25u32,
            EwResize = 26u32,
            NsResize = 27u32,
            NeswResize = 28u32,
            NwseResize = 29u32,
            ColResize = 30u32,
            RowResize = 31u32,
            AllScroll = 32u32,
            ZoomIn = 33u32,
            ZoomOut = 34u32,
        }
        impl TryFrom<u32> for Shape {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidShape = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This interface allows clients to set the cursor shape."]
        pub trait WpCursorShapeDeviceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_cursor_shape_device_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_cursor_shape_device_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("wp_cursor_shape_device_v1#{}.set_shape()", object.id);
                        self.set_shape(object, client, message.uint()?, message.uint()?.try_into()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the cursor shape device."]
            #[doc = ""]
            #[doc = "The device cursor shape remains unchanged."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the device cursor to the specified shape. The compositor will"]
            #[doc = "change the cursor image based on the specified shape."]
            #[doc = ""]
            #[doc = "The cursor actually changes only if the input device focus is one of"]
            #[doc = "the requesting client's surfaces. If any, the previous cursor image"]
            #[doc = "(surface or shape) is replaced."]
            #[doc = ""]
            #[doc = "The \"shape\" argument must be a valid enum entry, otherwise the"]
            #[doc = "invalid_shape protocol error is raised."]
            #[doc = ""]
            #[doc = "This is similar to the wl_pointer.set_cursor and"]
            #[doc = "zwp_tablet_tool_v2.set_cursor requests, but this request accepts a"]
            #[doc = "shape instead of contents in the form of a surface. Clients can mix"]
            #[doc = "set_cursor and set_shape requests."]
            #[doc = ""]
            #[doc = "The serial parameter must match the latest wl_pointer.enter or"]
            #[doc = "zwp_tablet_tool_v2.proximity_in serial number sent to the client."]
            #[doc = "Otherwise the request will be ignored."]
            async fn set_shape(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                shape: Shape,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod drm_lease_v1 {
    pub mod wp_drm_lease_device_v1 {
        #[doc = "This protocol is used by Wayland compositors which act as Direct"]
        #[doc = "Rendering Manager (DRM) masters to lease DRM resources to Wayland"]
        #[doc = "clients."]
        #[doc = ""]
        #[doc = "The compositor will advertise one wp_drm_lease_device_v1 global for each"]
        #[doc = "DRM node. Some time after a client binds to the wp_drm_lease_device_v1"]
        #[doc = "global, the compositor will send a drm_fd event followed by zero, one or"]
        #[doc = "more connector events. After all currently available connectors have been"]
        #[doc = "sent, the compositor will send a wp_drm_lease_device_v1.done event."]
        #[doc = ""]
        #[doc = "When the list of connectors available for lease changes the compositor"]
        #[doc = "will send wp_drm_lease_device_v1.connector events for added connectors and"]
        #[doc = "wp_drm_lease_connector_v1.withdrawn events for removed connectors,"]
        #[doc = "followed by a wp_drm_lease_device_v1.done event."]
        #[doc = ""]
        #[doc = "The compositor will indicate when a device is gone by removing the global"]
        #[doc = "via a wl_registry.global_remove event. Upon receiving this event, the"]
        #[doc = "client should destroy any matching wp_drm_lease_device_v1 object."]
        #[doc = ""]
        #[doc = "To destroy a wp_drm_lease_device_v1 object, the client must first issue"]
        #[doc = "a release request. Upon receiving this request, the compositor will"]
        #[doc = "immediately send a released event and destroy the object. The client must"]
        #[doc = "continue to process and discard drm_fd and connector events until it"]
        #[doc = "receives the released event. Upon receiving the released event, the"]
        #[doc = "client can safely cleanup any client-side resources."]
        #[doc = ""]
        #[doc = "Warning! The protocol described in this file is currently in the testing"]
        #[doc = "phase. Backward compatible changes may be added together with the"]
        #[doc = "corresponding interface version bump. Backward incompatible changes can"]
        #[doc = "only be done by creating a new major version of the extension."]
        pub trait WpDrmLeaseDeviceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_drm_lease_device_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "wp_drm_lease_device_v1#{}.create_lease_request()",
                            object.id
                        );
                        self.create_lease_request(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("wp_drm_lease_device_v1#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Creates a lease request object."]
            #[doc = ""]
            #[doc = "See the documentation for wp_drm_lease_request_v1 for details."]
            async fn create_lease_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Indicates the client no longer wishes to use this object. In response"]
            #[doc = "the compositor will immediately send the released event and destroy"]
            #[doc = "this object. It can however not guarantee that the client won't receive"]
            #[doc = "connector events before the released event. The client must not send any"]
            #[doc = "requests after this one, doing so will raise a wl_display error."]
            #[doc = "Existing connectors, lease request and leases will not be affected."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The compositor will send this event when the wp_drm_lease_device_v1"]
            #[doc = "global is bound, although there are no guarantees as to how long this"]
            #[doc = "takes - the compositor might need to wait until regaining DRM master."]
            #[doc = "The included fd is a non-master DRM file descriptor opened for this"]
            #[doc = "device and the compositor must not authenticate it."]
            #[doc = "The purpose of this event is to give the client the ability to"]
            #[doc = "query DRM and discover information which may help them pick the"]
            #[doc = "appropriate DRM device or select the appropriate connectors therein."]
            async fn drm_fd(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The compositor will use this event to advertise connectors available for"]
            #[doc = "lease by clients. This object may be passed into a lease request to"]
            #[doc = "indicate the client would like to lease that connector, see"]
            #[doc = "wp_drm_lease_request_v1.request_connector for details. While the"]
            #[doc = "compositor will make a best effort to not send disconnected connectors,"]
            #[doc = "no guarantees can be made."]
            #[doc = ""]
            #[doc = "The compositor must send the drm_fd event before sending connectors."]
            #[doc = "After the drm_fd event it will send all available connectors but may"]
            #[doc = "send additional connectors at any time."]
            async fn connector(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The compositor will send this event to indicate that it has sent all"]
            #[doc = "currently available connectors after the client binds to the global or"]
            #[doc = "when it updates the connector list, for example on hotplug, drm master"]
            #[doc = "change or when a leased connector becomes available again. It will"]
            #[doc = "similarly send this event to group wp_drm_lease_connector_v1.withdrawn"]
            #[doc = "events of connectors of this device."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent in response to the release request and indicates"]
            #[doc = "that the compositor is done sending connector events."]
            #[doc = "The compositor will destroy this object immediately after sending the"]
            #[doc = "event and it will become invalid. The client should release any"]
            #[doc = "resources associated with this device after receiving this event."]
            async fn released(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod wp_drm_lease_connector_v1 {
        #[doc = "Represents a DRM connector which is available for lease. These objects are"]
        #[doc = "created via wp_drm_lease_device_v1.connector events, and should be passed"]
        #[doc = "to lease requests via wp_drm_lease_request_v1.request_connector."]
        #[doc = "Immediately after the wp_drm_lease_connector_v1 object is created the"]
        #[doc = "compositor will send a name, a description, a connector_id and a done"]
        #[doc = "event. When the description is updated the compositor will send a"]
        #[doc = "description event followed by a done event."]
        pub trait WpDrmLeaseConnectorV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_drm_lease_connector_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_drm_lease_connector_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "The client may send this request to indicate that it will not use this"]
            #[doc = "connector. Clients are encouraged to send this after receiving the"]
            #[doc = "\"withdrawn\" event so that the server can release the resources"]
            #[doc = "associated with this connector offer. Neither existing lease requests"]
            #[doc = "nor leases will be affected."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The compositor sends this event once the connector is created to"]
            #[doc = "indicate the name of this connector. This will not change for the"]
            #[doc = "duration of the Wayland session, but is not guaranteed to be consistent"]
            #[doc = "between sessions."]
            #[doc = ""]
            #[doc = "If the compositor supports wl_output version 4 and this connector"]
            #[doc = "corresponds to a wl_output, the compositor should use the same name as"]
            #[doc = "for the wl_output."]
            async fn name(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The compositor sends this event once the connector is created to provide"]
            #[doc = "a human-readable description for this connector, which may be presented"]
            #[doc = "to the user. The compositor may send this event multiple times over the"]
            #[doc = "lifetime of this object to reflect changes in the description."]
            async fn description(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The compositor sends this event once the connector is created to"]
            #[doc = "indicate the DRM object ID which represents the underlying connector"]
            #[doc = "that is being offered. Note that the final lease may include additional"]
            #[doc = "object IDs, such as CRTCs and planes."]
            async fn connector_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent after all properties of a connector have been sent."]
            #[doc = "This allows changes to the properties to be seen as atomic even if they"]
            #[doc = "happen via multiple events."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent to indicate that the compositor will no longer honor requests for"]
            #[doc = "DRM leases which include this connector. The client may still issue a"]
            #[doc = "lease request including this connector, but the compositor will send"]
            #[doc = "wp_drm_lease_v1.finished without issuing a lease fd. Compositors are"]
            #[doc = "encouraged to send this event when they lose access to connector, for"]
            #[doc = "example when the connector is hot-unplugged, when the connector gets"]
            #[doc = "leased to a client or when the compositor loses DRM master."]
            async fn withdrawn(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod wp_drm_lease_request_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            WrongDevice = 0u32,
            DuplicateConnector = 1u32,
            EmptyLease = 2u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "A client that wishes to lease DRM resources will attach the list of"]
        #[doc = "connectors advertised with wp_drm_lease_device_v1.connector that they"]
        #[doc = "wish to lease, then use wp_drm_lease_request_v1.submit to submit the"]
        #[doc = "request."]
        pub trait WpDrmLeaseRequestV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_drm_lease_request_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "wp_drm_lease_request_v1#{}.request_connector()",
                            object.id
                        );
                        self.request_connector(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("wp_drm_lease_request_v1#{}.submit()", object.id);
                        self.submit(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Indicates that the client would like to lease the given connector."]
            #[doc = "This is only used as a suggestion, the compositor may choose to"]
            #[doc = "include any resources in the lease it issues, or change the set of"]
            #[doc = "leased resources at any time. Compositors are however encouraged to"]
            #[doc = "include the requested connector and other resources necessary"]
            #[doc = "to drive the connected output in the lease."]
            #[doc = ""]
            #[doc = "Requesting a connector that was created from a different lease device"]
            #[doc = "than this lease request raises the wrong_device error. Requesting a"]
            #[doc = "connector twice will raise the duplicate_connector error."]
            async fn request_connector(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                connector: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Submits the lease request and creates a new wp_drm_lease_v1 object."]
            #[doc = "After calling submit the compositor will immediately destroy this"]
            #[doc = "object, issuing any more requests will cause a wl_diplay error."]
            #[doc = "The compositor doesn't make any guarantees about the events of the"]
            #[doc = "lease object, clients cannot expect an immediate response."]
            #[doc = "Not requesting any connectors before submitting the lease request"]
            #[doc = "will raise the empty_lease error."]
            async fn submit(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wp_drm_lease_v1 {
        #[doc = "A DRM lease object is used to transfer the DRM file descriptor to the"]
        #[doc = "client and manage the lifetime of the lease."]
        #[doc = ""]
        #[doc = "Some time after the wp_drm_lease_v1 object is created, the compositor"]
        #[doc = "will reply with the lease request's result. If the lease request is"]
        #[doc = "granted, the compositor will send a lease_fd event. If the lease request"]
        #[doc = "is denied, the compositor will send a finished event without a lease_fd"]
        #[doc = "event."]
        pub trait WpDrmLeaseV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_drm_lease_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_drm_lease_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "The client should send this to indicate that it no longer wishes to use"]
            #[doc = "this lease. The compositor should use drmModeRevokeLease on the"]
            #[doc = "appropriate file descriptor, if necessary."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event returns a file descriptor suitable for use with DRM-related"]
            #[doc = "ioctls. The client should use drmModeGetLease to enumerate the DRM"]
            #[doc = "objects which have been leased to them. The compositor guarantees it"]
            #[doc = "will not use the leased DRM objects itself until it sends the finished"]
            #[doc = "event. If the compositor cannot or will not grant a lease for the"]
            #[doc = "requested connectors, it will not send this event, instead sending the"]
            #[doc = "finished event."]
            #[doc = ""]
            #[doc = "The compositor will send this event at most once during this objects"]
            #[doc = "lifetime."]
            async fn lease_fd(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The compositor uses this event to either reject a lease request, or if"]
            #[doc = "it previously sent a lease_fd, to notify the client that the lease has"]
            #[doc = "been revoked. If the client requires a new lease, they should destroy"]
            #[doc = "this object and submit a new lease request. The compositor will send"]
            #[doc = "no further events for this object after sending the finish event."]
            #[doc = "Compositors should revoke the lease when any of the leased resources"]
            #[doc = "become unavailable, namely when a hot-unplug occurs or when the"]
            #[doc = "compositor loses DRM master."]
            async fn finished(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
#[doc = "The purpose of this protocol is to provide protocol object handles for"]
#[doc = "toplevels, possibly originating from another client."]
#[doc = ""]
#[doc = "This protocol is intentionally minimalistic and expects additional"]
#[doc = "functionality (e.g. creating a screencopy source from a toplevel handle,"]
#[doc = "getting information about the state of the toplevel) to be implemented"]
#[doc = "in extension protocols."]
#[doc = ""]
#[doc = "The compositor may choose to restrict this protocol to a special client"]
#[doc = "launched by the compositor itself or expose it to all clients,"]
#[doc = "this is compositor policy."]
#[doc = ""]
#[doc = "The key words \"must\", \"must not\", \"required\", \"shall\", \"shall not\","]
#[doc = "\"should\", \"should not\", \"recommended\",  \"may\", and \"optional\" in this"]
#[doc = "document are to be interpreted as described in IETF RFC 2119."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is currently in the testing"]
#[doc = "phase. Backward compatible changes may be added together with the"]
#[doc = "corresponding interface version bump. Backward incompatible changes can"]
#[doc = "only be done by creating a new major version of the extension."]
pub mod ext_foreign_toplevel_list_v1 {
    pub mod ext_foreign_toplevel_list_v1 {
        #[doc = "A toplevel is defined as a surface with a role similar to xdg_toplevel."]
        #[doc = "XWayland surfaces may be treated like toplevels in this protocol."]
        #[doc = ""]
        #[doc = "After a client binds the ext_foreign_toplevel_list_v1, each mapped"]
        #[doc = "toplevel window will be sent using the ext_foreign_toplevel_list_v1.toplevel"]
        #[doc = "event."]
        #[doc = ""]
        #[doc = "Clients which only care about the current state can perform a roundtrip after"]
        #[doc = "binding this global."]
        #[doc = ""]
        #[doc = "For each instance of ext_foreign_toplevel_list_v1, the compositor must"]
        #[doc = "create a new ext_foreign_toplevel_handle_v1 object for each mapped toplevel."]
        #[doc = ""]
        #[doc = "If a compositor implementation sends the ext_foreign_toplevel_list_v1.finished"]
        #[doc = "event after the global is bound, the compositor must not send any"]
        #[doc = "ext_foreign_toplevel_list_v1.toplevel events."]
        pub trait ExtForeignToplevelListV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_foreign_toplevel_list_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("ext_foreign_toplevel_list_v1#{}.stop()", object.id);
                        self.stop(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("ext_foreign_toplevel_list_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request indicates that the client no longer wishes to receive"]
            #[doc = "events for new toplevels."]
            #[doc = ""]
            #[doc = "The Wayland protocol is asynchronous, meaning the compositor may send"]
            #[doc = "further toplevel events until the stop request is processed."]
            #[doc = "The client should wait for a ext_foreign_toplevel_list_v1.finished"]
            #[doc = "event before destroying this object."]
            async fn stop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This request should be called either when the client will no longer"]
            #[doc = "use the ext_foreign_toplevel_list_v1 or after the finished event"]
            #[doc = "has been received to allow destruction of the object."]
            #[doc = ""]
            #[doc = "If a client wishes to destroy this object it should send a"]
            #[doc = "ext_foreign_toplevel_list_v1.stop request and wait for a ext_foreign_toplevel_list_v1.finished"]
            #[doc = "event, then destroy the handles and then this object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is emitted whenever a new toplevel window is created. It is"]
            #[doc = "emitted for all toplevels, regardless of the app that has created them."]
            #[doc = ""]
            #[doc = "All initial properties of the toplevel (identifier, title, app_id) will be sent"]
            #[doc = "immediately after this event using the corresponding events for"]
            #[doc = "ext_foreign_toplevel_handle_v1. The compositor will use the"]
            #[doc = "ext_foreign_toplevel_handle_v1.done event to indicate when all data has"]
            #[doc = "been sent."]
            async fn toplevel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event indicates that the compositor is done sending events"]
            #[doc = "to this object. The client should destroy the object."]
            #[doc = "See ext_foreign_toplevel_list_v1.destroy for more information."]
            #[doc = ""]
            #[doc = "The compositor must not send any more toplevel events after this event."]
            async fn finished(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod ext_foreign_toplevel_handle_v1 {
        #[doc = "A ext_foreign_toplevel_handle_v1 object represents a mapped toplevel"]
        #[doc = "window. A single app may have multiple mapped toplevels."]
        pub trait ExtForeignToplevelHandleV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_foreign_toplevel_handle_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("ext_foreign_toplevel_handle_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request should be used when the client will no longer use the handle"]
            #[doc = "or after the closed event has been received to allow destruction of the"]
            #[doc = "object."]
            #[doc = ""]
            #[doc = "When a handle is destroyed, a new handle may not be created by the server"]
            #[doc = "until the toplevel is unmapped and then remapped. Destroying a toplevel handle"]
            #[doc = "is not recommended unless the client is cleaning up child objects"]
            #[doc = "before destroying the ext_foreign_toplevel_list_v1 object, the toplevel"]
            #[doc = "was closed or the toplevel handle will not be used in the future."]
            #[doc = ""]
            #[doc = "Other protocols which extend the ext_foreign_toplevel_handle_v1"]
            #[doc = "interface should require destructors for extension interfaces be"]
            #[doc = "called before allowing the toplevel handle to be destroyed."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The server will emit no further events on the ext_foreign_toplevel_handle_v1"]
            #[doc = "after this event. Any requests received aside from the destroy request must"]
            #[doc = "be ignored. Upon receiving this event, the client should destroy the handle."]
            #[doc = ""]
            #[doc = "Other protocols which extend the ext_foreign_toplevel_handle_v1"]
            #[doc = "interface must also ignore requests other than destructors."]
            async fn closed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent after all changes in the toplevel state have"]
            #[doc = "been sent."]
            #[doc = ""]
            #[doc = "This allows changes to the ext_foreign_toplevel_handle_v1 properties"]
            #[doc = "to be atomically applied. Other protocols which extend the"]
            #[doc = "ext_foreign_toplevel_handle_v1 interface may use this event to also"]
            #[doc = "atomically apply any pending state."]
            #[doc = ""]
            #[doc = "This event must not be sent after the ext_foreign_toplevel_handle_v1.closed"]
            #[doc = "event."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The title of the toplevel has changed."]
            #[doc = ""]
            #[doc = "The configured state must not be applied immediately. See"]
            #[doc = "ext_foreign_toplevel_handle_v1.done for details."]
            async fn title(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The app id of the toplevel has changed."]
            #[doc = ""]
            #[doc = "The configured state must not be applied immediately. See"]
            #[doc = "ext_foreign_toplevel_handle_v1.done for details."]
            async fn app_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This identifier is used to check if two or more toplevel handles belong"]
            #[doc = "to the same toplevel."]
            #[doc = ""]
            #[doc = "The identifier is useful for command line tools or privileged clients"]
            #[doc = "which may need to reference an exact toplevel across processes or"]
            #[doc = "instances of the ext_foreign_toplevel_list_v1 global."]
            #[doc = ""]
            #[doc = "The compositor must only send this event when the handle is created."]
            #[doc = ""]
            #[doc = "The identifier must be unique per toplevel and it's handles. Two different"]
            #[doc = "toplevels must not have the same identifier. The identifier is only valid"]
            #[doc = "as long as the toplevel is mapped. If the toplevel is unmapped the identifier"]
            #[doc = "must not be reused. An identifier must not be reused by the compositor to"]
            #[doc = "ensure there are no races when sharing identifiers between processes."]
            #[doc = ""]
            #[doc = "An identifier is a string that contains up to 32 printable ASCII bytes."]
            #[doc = "An identifier must not be an empty string. It is recommended that a"]
            #[doc = "compositor includes an opaque generation value in identifiers. How the"]
            #[doc = "generation value is used when generating the identifier is implementation"]
            #[doc = "dependent."]
            async fn identifier(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
pub mod ext_idle_notify_v1 {
    pub mod ext_idle_notifier_v1 {
        #[doc = "This interface allows clients to monitor user idle status."]
        #[doc = ""]
        #[doc = "After binding to this global, clients can create ext_idle_notification_v1"]
        #[doc = "objects to get notified when the user is idle for a given amount of time."]
        pub trait ExtIdleNotifierV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_idle_notifier_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("ext_idle_notifier_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "ext_idle_notifier_v1#{}.get_idle_notification()",
                            object.id
                        );
                        self.get_idle_notification(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the manager object. All objects created via this interface"]
            #[doc = "remain valid."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a new idle notification object."]
            #[doc = ""]
            #[doc = "The notification object has a minimum timeout duration and is tied to a"]
            #[doc = "seat. The client will be notified if the seat is inactive for at least"]
            #[doc = "the provided timeout. See ext_idle_notification_v1 for more details."]
            #[doc = ""]
            #[doc = "A zero timeout is valid and means the client wants to be notified as"]
            #[doc = "soon as possible when the seat is inactive."]
            async fn get_idle_notification(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                timeout: u32,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod ext_idle_notification_v1 {
        #[doc = "This interface is used by the compositor to send idle notification events"]
        #[doc = "to clients."]
        #[doc = ""]
        #[doc = "Initially the notification object is not idle. The notification object"]
        #[doc = "becomes idle when no user activity has happened for at least the timeout"]
        #[doc = "duration, starting from the creation of the notification object. User"]
        #[doc = "activity may include input events or a presence sensor, but is"]
        #[doc = "compositor-specific. If an idle inhibitor is active (e.g. another client"]
        #[doc = "has created a zwp_idle_inhibitor_v1 on a visible surface), the compositor"]
        #[doc = "must not make the notification object idle."]
        #[doc = ""]
        #[doc = "When the notification object becomes idle, an idled event is sent. When"]
        #[doc = "user activity starts again, the notification object stops being idle,"]
        #[doc = "a resumed event is sent and the timeout is restarted."]
        pub trait ExtIdleNotificationV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_idle_notification_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("ext_idle_notification_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the notification object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent when the notification object becomes idle."]
            #[doc = ""]
            #[doc = "It's a compositor protocol error to send this event twice without a"]
            #[doc = "resumed event in-between."]
            async fn idled(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent when the notification object stops being idle."]
            #[doc = ""]
            #[doc = "It's a compositor protocol error to send this event twice without an"]
            #[doc = "idled event in-between. It's a compositor protocol error to send this"]
            #[doc = "event prior to any idled event."]
            async fn resumed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
#[doc = "This protocol allows for a privileged Wayland client to lock the session"]
#[doc = "and display arbitrary graphics while the session is locked."]
#[doc = ""]
#[doc = "The compositor may choose to restrict this protocol to a special client"]
#[doc = "launched by the compositor itself or expose it to all privileged clients,"]
#[doc = "this is compositor policy."]
#[doc = ""]
#[doc = "The client is responsible for performing authentication and informing the"]
#[doc = "compositor when the session should be unlocked. If the client dies while"]
#[doc = "the session is locked the session remains locked, possibly permanently"]
#[doc = "depending on compositor policy."]
#[doc = ""]
#[doc = "The key words \"must\", \"must not\", \"required\", \"shall\", \"shall not\","]
#[doc = "\"should\", \"should not\", \"recommended\",  \"may\", and \"optional\" in this"]
#[doc = "document are to be interpreted as described in IETF RFC 2119."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is currently in the"]
#[doc = "testing phase. Backward compatible changes may be added together with"]
#[doc = "the corresponding interface version bump. Backward incompatible changes"]
#[doc = "can only be done by creating a new major version of the extension."]
pub mod ext_session_lock_v1 {
    pub mod ext_session_lock_manager_v1 {
        #[doc = "This interface is used to request that the session be locked."]
        pub trait ExtSessionLockManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_session_lock_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("ext_session_lock_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("ext_session_lock_manager_v1#{}.lock()", object.id);
                        self.lock(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This informs the compositor that the session lock manager object will"]
            #[doc = "no longer be used. Existing objects created through this interface"]
            #[doc = "remain valid."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This request creates a session lock and asks the compositor to lock the"]
            #[doc = "session. The compositor will send either the ext_session_lock_v1.locked"]
            #[doc = "or ext_session_lock_v1.finished event on the created object in"]
            #[doc = "response to this request."]
            async fn lock(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod ext_session_lock_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidDestroy = 0u32,
            InvalidUnlock = 1u32,
            Role = 2u32,
            DuplicateOutput = 3u32,
            AlreadyConstructed = 4u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "In response to the creation of this object the compositor must send"]
        #[doc = "either the locked or finished event."]
        #[doc = ""]
        #[doc = "The locked event indicates that the session is locked. This means"]
        #[doc = "that the compositor must stop rendering and providing input to normal"]
        #[doc = "clients. Instead the compositor must blank all outputs with an opaque"]
        #[doc = "color such that their normal content is fully hidden."]
        #[doc = ""]
        #[doc = "The only surfaces that should be rendered while the session is locked"]
        #[doc = "are the lock surfaces created through this interface and optionally,"]
        #[doc = "at the compositor's discretion, special privileged surfaces such as"]
        #[doc = "input methods or portions of desktop shell UIs."]
        #[doc = ""]
        #[doc = "The locked event must not be sent until a new \"locked\" frame (either"]
        #[doc = "from a session lock surface or the compositor blanking the output) has"]
        #[doc = "been presented on all outputs and no security sensitive normal/unlocked"]
        #[doc = "content is possibly visible."]
        #[doc = ""]
        #[doc = "The finished event should be sent immediately on creation of this"]
        #[doc = "object if the compositor decides that the locked event will not be sent."]
        #[doc = ""]
        #[doc = "The compositor may wait for the client to create and render session lock"]
        #[doc = "surfaces before sending the locked event to avoid displaying intermediate"]
        #[doc = "blank frames. However, it must impose a reasonable time limit if"]
        #[doc = "waiting and send the locked event as soon as the hard requirements"]
        #[doc = "described above can be met if the time limit expires. Clients should"]
        #[doc = "immediately create lock surfaces for all outputs on creation of this"]
        #[doc = "object to make this possible."]
        #[doc = ""]
        #[doc = "This behavior of the locked event is required in order to prevent"]
        #[doc = "possible race conditions with clients that wish to suspend the system"]
        #[doc = "or similar after locking the session. Without these semantics, clients"]
        #[doc = "triggering a suspend after receiving the locked event would race with"]
        #[doc = "the first \"locked\" frame being presented and normal/unlocked frames"]
        #[doc = "might be briefly visible as the system is resumed if the suspend"]
        #[doc = "operation wins the race."]
        #[doc = ""]
        #[doc = "If the client dies while the session is locked, the compositor must not"]
        #[doc = "unlock the session in response. It is acceptable for the session to be"]
        #[doc = "permanently locked if this happens. The compositor may choose to continue"]
        #[doc = "to display the lock surfaces the client had mapped before it died or"]
        #[doc = "alternatively fall back to a solid color, this is compositor policy."]
        #[doc = ""]
        #[doc = "Compositors may also allow a secure way to recover the session, the"]
        #[doc = "details of this are compositor policy. Compositors may allow a new"]
        #[doc = "client to create a ext_session_lock_v1 object and take responsibility"]
        #[doc = "for unlocking the session, they may even start a new lock client"]
        #[doc = "instance automatically."]
        pub trait ExtSessionLockV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_session_lock_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("ext_session_lock_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("ext_session_lock_v1#{}.get_lock_surface()", object.id);
                        self.get_lock_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("ext_session_lock_v1#{}.unlock_and_destroy()", object.id);
                        self.unlock_and_destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This informs the compositor that the lock object will no longer be"]
            #[doc = "used. Existing objects created through this interface remain valid."]
            #[doc = ""]
            #[doc = "After this request is made, lock surfaces created through this object"]
            #[doc = "should be destroyed by the client as they will no longer be used by"]
            #[doc = "the compositor."]
            #[doc = ""]
            #[doc = "It is a protocol error to make this request if the locked event was"]
            #[doc = "sent, the unlock_and_destroy request must be used instead."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The client is expected to create lock surfaces for all outputs"]
            #[doc = "currently present and any new outputs as they are advertised. These"]
            #[doc = "won't be displayed by the compositor unless the lock is successful"]
            #[doc = "and the locked event is sent."]
            #[doc = ""]
            #[doc = "Providing a wl_surface which already has a role or already has a buffer"]
            #[doc = "attached or committed is a protocol error, as is attaching/committing"]
            #[doc = "a buffer before the first ext_session_lock_surface_v1.configure event."]
            #[doc = ""]
            #[doc = "Attempting to create more than one lock surface for a given output"]
            #[doc = "is a duplicate_output protocol error."]
            async fn get_lock_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This request indicates that the session should be unlocked, for"]
            #[doc = "example because the user has entered their password and it has been"]
            #[doc = "verified by the client."]
            #[doc = ""]
            #[doc = "This request also informs the compositor that the lock object will"]
            #[doc = "no longer be used and should be destroyed. Existing objects created"]
            #[doc = "through this interface remain valid."]
            #[doc = ""]
            #[doc = "After this request is made, lock surfaces created through this object"]
            #[doc = "should be destroyed by the client as they will no longer be used by"]
            #[doc = "the compositor."]
            #[doc = ""]
            #[doc = "It is a protocol error to make this request if the locked event has"]
            #[doc = "not been sent. In that case, the lock object must be destroyed using"]
            #[doc = "the destroy request."]
            #[doc = ""]
            #[doc = "Note that a correct client that wishes to exit directly after unlocking"]
            #[doc = "the session must use the wl_display.sync request to ensure the server"]
            #[doc = "receives and processes the unlock_and_destroy request. Otherwise"]
            #[doc = "there is no guarantee that the server has unlocked the session due"]
            #[doc = "to the asynchronous nature of the Wayland protocol. For example,"]
            #[doc = "the server might terminate the client with a protocol error before"]
            #[doc = "it processes the unlock_and_destroy request."]
            async fn unlock_and_destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This client is now responsible for displaying graphics while the"]
            #[doc = "session is locked and deciding when to unlock the session."]
            #[doc = ""]
            #[doc = "The locked event must not be sent until a new \"locked\" frame has been"]
            #[doc = "presented on all outputs and no security sensitive normal/unlocked"]
            #[doc = "content is possibly visible."]
            #[doc = ""]
            #[doc = "If this event is sent, making the destroy request is a protocol error,"]
            #[doc = "the lock object must be destroyed using the unlock_and_destroy request."]
            async fn locked(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The compositor has decided that the session lock should be destroyed"]
            #[doc = "as it will no longer be used by the compositor. Exactly when this"]
            #[doc = "event is sent is compositor policy, but it must never be sent more"]
            #[doc = "than once for a given session lock object."]
            #[doc = ""]
            #[doc = "This might be sent because there is already another ext_session_lock_v1"]
            #[doc = "object held by a client, or the compositor has decided to deny the"]
            #[doc = "request to lock the session for some other reason. This might also"]
            #[doc = "be sent because the compositor implements some alternative, secure"]
            #[doc = "way to authenticate and unlock the session."]
            #[doc = ""]
            #[doc = "The finished event should be sent immediately on creation of this"]
            #[doc = "object if the compositor decides that the locked event will not"]
            #[doc = "be sent."]
            #[doc = ""]
            #[doc = "If the locked event is sent on creation of this object the finished"]
            #[doc = "event may still be sent at some later time in this object's"]
            #[doc = "lifetime. This is compositor policy."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should make either the destroy"]
            #[doc = "request or the unlock_and_destroy request, depending on whether or"]
            #[doc = "not the locked event was received on this object."]
            async fn finished(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod ext_session_lock_surface_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            CommitBeforeFirstAck = 0u32,
            NullBuffer = 1u32,
            DimensionsMismatch = 2u32,
            InvalidSerial = 3u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "The client may use lock surfaces to display a screensaver, render a"]
        #[doc = "dialog to enter a password and unlock the session, or however else it"]
        #[doc = "sees fit."]
        #[doc = ""]
        #[doc = "On binding this interface the compositor will immediately send the"]
        #[doc = "first configure event. After making the ack_configure request in"]
        #[doc = "response to this event the client should attach and commit the first"]
        #[doc = "buffer. Committing the surface before acking the first configure is a"]
        #[doc = "protocol error. Committing the surface with a null buffer at any time"]
        #[doc = "is a protocol error."]
        #[doc = ""]
        #[doc = "The compositor is free to handle keyboard/pointer focus for lock"]
        #[doc = "surfaces however it chooses. A reasonable way to do this would be to"]
        #[doc = "give the first lock surface created keyboard focus and change keyboard"]
        #[doc = "focus if the user clicks on other surfaces."]
        pub trait ExtSessionLockSurfaceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_session_lock_surface_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("ext_session_lock_surface_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "ext_session_lock_surface_v1#{}.ack_configure()",
                            object.id
                        );
                        self.ack_configure(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This informs the compositor that the lock surface object will no"]
            #[doc = "longer be used."]
            #[doc = ""]
            #[doc = "It is recommended for a lock client to destroy lock surfaces if"]
            #[doc = "their corresponding wl_output global is removed."]
            #[doc = ""]
            #[doc = "If a lock surface on an active output is destroyed before the"]
            #[doc = "ext_session_lock_v1.unlock_and_destroy event is sent, the compositor"]
            #[doc = "must fall back to rendering a solid color."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "When a configure event is received, if a client commits the surface"]
            #[doc = "in response to the configure event, then the client must make an"]
            #[doc = "ack_configure request sometime before the commit request, passing"]
            #[doc = "along the serial of the configure event."]
            #[doc = ""]
            #[doc = "If the client receives multiple configure events before it can"]
            #[doc = "respond to one, it only has to ack the last configure event."]
            #[doc = ""]
            #[doc = "A client is not required to commit immediately after sending an"]
            #[doc = "ack_configure request - it may even ack_configure several times"]
            #[doc = "before its next surface commit."]
            #[doc = ""]
            #[doc = "A client may send multiple ack_configure requests before committing,"]
            #[doc = "but only the last request sent before a commit indicates which"]
            #[doc = "configure event the client really is responding to."]
            #[doc = ""]
            #[doc = "Sending an ack_configure request consumes the configure event"]
            #[doc = "referenced by the given serial, as well as all older configure events"]
            #[doc = "sent on this object."]
            #[doc = ""]
            #[doc = "It is a protocol error to issue multiple ack_configure requests"]
            #[doc = "referencing the same configure event or to issue an ack_configure"]
            #[doc = "request referencing a configure event older than the last configure"]
            #[doc = "event acked for a given lock surface."]
            async fn ack_configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent once on binding the interface and may be sent again"]
            #[doc = "at the compositor's discretion, for example if output geometry changes."]
            #[doc = ""]
            #[doc = "The width and height are in surface-local coordinates and are exact"]
            #[doc = "requirements. Failing to match these surface dimensions in the next"]
            #[doc = "commit after acking a configure is a protocol error."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
#[doc = "The transient seat protocol can be used by privileged clients to create"]
#[doc = "independent seats that will be removed from the compositor when the client"]
#[doc = "destroys its transient seat."]
#[doc = ""]
#[doc = "This protocol is intended for use with virtual input protocols such as"]
#[doc = "\"virtual_keyboard_unstable_v1\" or \"wlr_virtual_pointer_unstable_v1\", both"]
#[doc = "of which allow the user to select a seat."]
#[doc = ""]
#[doc = "The \"wl_seat\" global created by this protocol does not generate input events"]
#[doc = "on its own, or have any capabilities except those assigned to it by other"]
#[doc = "protocol extensions, such as the ones mentioned above."]
#[doc = ""]
#[doc = "For example, a remote desktop server can create a seat with virtual inputs"]
#[doc = "for each remote user by following these steps for each new connection:"]
#[doc = "* Create a transient seat"]
#[doc = "* Wait for the transient seat to be created"]
#[doc = "* Locate a \"wl_seat\" global with a matching name"]
#[doc = "* Create virtual inputs using the resulting \"wl_seat\" global"]
pub mod ext_transient_seat_v1 {
    pub mod ext_transient_seat_manager_v1 {
        #[doc = "The transient seat manager creates short-lived seats."]
        pub trait ExtTransientSeatManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_transient_seat_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("ext_transient_seat_manager_v1#{}.create()", object.id);
                        self.create(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("ext_transient_seat_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a new seat that is removed when the client side transient seat"]
            #[doc = "object is destroyed."]
            #[doc = ""]
            #[doc = "The actual seat may be removed sooner, in which case the transient seat"]
            #[doc = "object shall become inert."]
            async fn create(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the manager."]
            #[doc = ""]
            #[doc = "All objects created by the manager will remain valid until they are"]
            #[doc = "destroyed themselves."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod ext_transient_seat_v1 {
        #[doc = "When the transient seat handle is destroyed, the seat itself will also be"]
        #[doc = "destroyed."]
        pub trait ExtTransientSeatV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_transient_seat_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("ext_transient_seat_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "When the transient seat object is destroyed by the client, the"]
            #[doc = "associated seat created by the compositor is also destroyed."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event advertises the global name for the wl_seat to be used with"]
            #[doc = "wl_registry_bind."]
            #[doc = ""]
            #[doc = "It is sent exactly once, immediately after the transient seat is created"]
            #[doc = "and the new \"wl_seat\" global is advertised, if and only if the creation"]
            #[doc = "of the transient seat was allowed."]
            async fn ready(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The event informs the client that the compositor denied its request to"]
            #[doc = "create a transient seat."]
            #[doc = ""]
            #[doc = "It is sent exactly once, immediately after the transient seat object is"]
            #[doc = "created, if and only if the creation of the transient seat was denied."]
            #[doc = ""]
            #[doc = "After receiving this event, the client should destroy the object."]
            async fn denied(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
#[doc = "This protocol allows a compositor to suggest for surfaces to render at"]
#[doc = "fractional scales."]
#[doc = ""]
#[doc = "A client can submit scaled content by utilizing wp_viewport. This is done by"]
#[doc = "creating a wp_viewport object for the surface and setting the destination"]
#[doc = "rectangle to the surface size before the scale factor is applied."]
#[doc = ""]
#[doc = "The buffer size is calculated by multiplying the surface size by the"]
#[doc = "intended scale."]
#[doc = ""]
#[doc = "The wl_surface buffer scale should remain set to 1."]
#[doc = ""]
#[doc = "If a surface has a surface-local size of 100 px by 50 px and wishes to"]
#[doc = "submit buffers with a scale of 1.5, then a buffer of 150px by 75 px should"]
#[doc = "be used and the wp_viewport destination rectangle should be 100 px by 50 px."]
#[doc = ""]
#[doc = "For toplevel surfaces, the size is rounded halfway away from zero. The"]
#[doc = "rounding algorithm for subsurface position and size is not defined."]
pub mod fractional_scale_v1 {
    pub mod wp_fractional_scale_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            FractionalScaleExists = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "A global interface for requesting surfaces to use fractional scales."]
        pub trait WpFractionalScaleManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_fractional_scale_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_fractional_scale_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "wp_fractional_scale_manager_v1#{}.get_fractional_scale()",
                            object.id
                        );
                        self.get_fractional_scale(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Informs the server that the client will not be using this protocol"]
            #[doc = "object anymore. This does not affect any other objects,"]
            #[doc = "wp_fractional_scale_v1 objects included."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create an add-on object for the the wl_surface to let the compositor"]
            #[doc = "request fractional scales. If the given wl_surface already has a"]
            #[doc = "wp_fractional_scale_v1 object associated, the fractional_scale_exists"]
            #[doc = "protocol error is raised."]
            async fn get_fractional_scale(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wp_fractional_scale_v1 {
        #[doc = "An additional interface to a wl_surface object which allows the compositor"]
        #[doc = "to inform the client of the preferred scale."]
        pub trait WpFractionalScaleV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_fractional_scale_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_fractional_scale_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the fractional scale object. When this object is destroyed,"]
            #[doc = "preferred_scale events will no longer be sent."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Notification of a new preferred scale for this surface that the"]
            #[doc = "compositor suggests that the client should use."]
            #[doc = ""]
            #[doc = "The sent scale is the numerator of a fraction with a denominator of 120."]
            async fn preferred_scale(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
#[doc = "This protocol allows clients to request explicit synchronization for"]
#[doc = "buffers. It is tied to the Linux DRM synchronization object framework."]
#[doc = ""]
#[doc = "Synchronization refers to co-ordination of pipelined operations performed"]
#[doc = "on buffers. Most GPU clients will schedule an asynchronous operation to"]
#[doc = "render to the buffer, then immediately send the buffer to the compositor"]
#[doc = "to be attached to a surface."]
#[doc = ""]
#[doc = "With implicit synchronization, ensuring that the rendering operation is"]
#[doc = "complete before the compositor displays the buffer is an implementation"]
#[doc = "detail handled by either the kernel or userspace graphics driver."]
#[doc = ""]
#[doc = "By contrast, with explicit synchronization, DRM synchronization object"]
#[doc = "timeline points mark when the asynchronous operations are complete. When"]
#[doc = "submitting a buffer, the client provides a timeline point which will be"]
#[doc = "waited on before the compositor accesses the buffer, and another timeline"]
#[doc = "point that the compositor will signal when it no longer needs to access the"]
#[doc = "buffer contents for the purposes of the surface commit."]
#[doc = ""]
#[doc = "Linux DRM synchronization objects are documented at:"]
#[doc = "https://dri.freedesktop.org/docs/drm/gpu/drm-mm.html#drm-sync-objects"]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is currently in the testing"]
#[doc = "phase. Backward compatible changes may be added together with the"]
#[doc = "corresponding interface version bump. Backward incompatible changes can"]
#[doc = "only be done by creating a new major version of the extension."]
pub mod linux_drm_syncobj_v1 {
    pub mod wp_linux_drm_syncobj_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            SurfaceExists = 0u32,
            InvalidTimeline = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This global is a factory interface, allowing clients to request"]
        #[doc = "explicit synchronization for buffers on a per-surface basis."]
        #[doc = ""]
        #[doc = "See wp_linux_drm_syncobj_surface_v1 for more information."]
        pub trait WpLinuxDrmSyncobjManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_linux_drm_syncobj_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_linux_drm_syncobj_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "wp_linux_drm_syncobj_manager_v1#{}.get_surface()",
                            object.id
                        );
                        self.get_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "wp_linux_drm_syncobj_manager_v1#{}.import_timeline()",
                            object.id
                        );
                        self.import_timeline(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.fd()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy this explicit synchronization factory object. Other objects"]
            #[doc = "shall not be affected by this request."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Instantiate an interface extension for the given wl_surface to provide"]
            #[doc = "explicit synchronization."]
            #[doc = ""]
            #[doc = "If the given wl_surface already has an explicit synchronization object"]
            #[doc = "associated, the surface_exists protocol error is raised."]
            #[doc = ""]
            #[doc = "Graphics APIs, like EGL or Vulkan, that manage the buffer queue and"]
            #[doc = "commits of a wl_surface themselves, are likely to be using this"]
            #[doc = "extension internally. If a client is using such an API for a"]
            #[doc = "wl_surface, it should not directly use this extension on that surface,"]
            #[doc = "to avoid raising a surface_exists protocol error."]
            async fn get_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Import a DRM synchronization object timeline."]
            #[doc = ""]
            #[doc = "If the FD cannot be imported, the invalid_timeline error is raised."]
            async fn import_timeline(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wp_linux_drm_syncobj_timeline_v1 {
        #[doc = "This object represents an explicit synchronization object timeline"]
        #[doc = "imported by the client to the compositor."]
        pub trait WpLinuxDrmSyncobjTimelineV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_linux_drm_syncobj_timeline_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_linux_drm_syncobj_timeline_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the synchronization object timeline. Other objects are not"]
            #[doc = "affected by this request, in particular timeline points set by"]
            #[doc = "set_acquire_point and set_release_point are not unset."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wp_linux_drm_syncobj_surface_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            NoSurface = 1u32,
            UnsupportedBuffer = 2u32,
            NoBuffer = 3u32,
            NoAcquirePoint = 4u32,
            NoReleasePoint = 5u32,
            ConflictingPoints = 6u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This object is an add-on interface for wl_surface to enable explicit"]
        #[doc = "synchronization."]
        #[doc = ""]
        #[doc = "Each surface can be associated with only one object of this interface at"]
        #[doc = "any time."]
        #[doc = ""]
        #[doc = "Explicit synchronization is guaranteed to be supported for buffers"]
        #[doc = "created with any version of the linux-dmabuf protocol. Compositors are"]
        #[doc = "free to support explicit synchronization for additional buffer types."]
        #[doc = "If at surface commit time the attached buffer does not support explicit"]
        #[doc = "synchronization, an unsupported_buffer error is raised."]
        #[doc = ""]
        #[doc = "As long as the wp_linux_drm_syncobj_surface_v1 object is alive, the"]
        #[doc = "compositor may ignore implicit synchronization for buffers attached and"]
        #[doc = "committed to the wl_surface. The delivery of wl_buffer.release events"]
        #[doc = "for buffers attached to the surface becomes undefined."]
        #[doc = ""]
        #[doc = "Clients must set both acquire and release points if and only if a"]
        #[doc = "non-null buffer is attached in the same surface commit. See the"]
        #[doc = "no_buffer, no_acquire_point and no_release_point protocol errors."]
        #[doc = ""]
        #[doc = "If at surface commit time the acquire and release DRM syncobj timelines"]
        #[doc = "are identical, the acquire point value must be strictly less than the"]
        #[doc = "release point value, or else the conflicting_points protocol error is"]
        #[doc = "raised."]
        pub trait WpLinuxDrmSyncobjSurfaceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_linux_drm_syncobj_surface_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_linux_drm_syncobj_surface_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "wp_linux_drm_syncobj_surface_v1#{}.set_acquire_point()",
                            object.id
                        );
                        self.set_acquire_point(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "wp_linux_drm_syncobj_surface_v1#{}.set_release_point()",
                            object.id
                        );
                        self.set_release_point(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy this surface synchronization object."]
            #[doc = ""]
            #[doc = "Any timeline point set by this object with set_acquire_point or"]
            #[doc = "set_release_point since the last commit may be discarded by the"]
            #[doc = "compositor. Any timeline point set by this object before the last"]
            #[doc = "commit will not be affected."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the timeline point that must be signalled before the compositor may"]
            #[doc = "sample from the buffer attached with wl_surface.attach."]
            #[doc = ""]
            #[doc = "The 64-bit unsigned value combined from point_hi and point_lo is the"]
            #[doc = "point value."]
            #[doc = ""]
            #[doc = "The acquire point is double-buffered state, and will be applied on the"]
            #[doc = "next wl_surface.commit request for the associated surface. Thus, it"]
            #[doc = "applies only to the buffer that is attached to the surface at commit"]
            #[doc = "time."]
            #[doc = ""]
            #[doc = "If an acquire point has already been attached during the same commit"]
            #[doc = "cycle, the new point replaces the old one."]
            #[doc = ""]
            #[doc = "If the associated wl_surface was destroyed, a no_surface error is"]
            #[doc = "raised."]
            #[doc = ""]
            #[doc = "If at surface commit time there is a pending acquire timeline point set"]
            #[doc = "but no pending buffer attached, a no_buffer error is raised. If at"]
            #[doc = "surface commit time there is a pending buffer attached but no pending"]
            #[doc = "acquire timeline point set, the no_acquire_point protocol error is"]
            #[doc = "raised."]
            async fn set_acquire_point(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                timeline: crate::wire::ObjectId,
                point_hi: u32,
                point_lo: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Set the timeline point that must be signalled by the compositor when it"]
            #[doc = "has finished its usage of the buffer attached with wl_surface.attach"]
            #[doc = "for the relevant commit."]
            #[doc = ""]
            #[doc = "Once the timeline point is signaled, and assuming the associated buffer"]
            #[doc = "is not pending release from other wl_surface.commit requests, no"]
            #[doc = "additional explicit or implicit synchronization with the compositor is"]
            #[doc = "required to safely re-use the buffer."]
            #[doc = ""]
            #[doc = "Note that clients cannot rely on the release point being always"]
            #[doc = "signaled after the acquire point: compositors may release buffers"]
            #[doc = "without ever reading from them. In addition, the compositor may use"]
            #[doc = "different presentation paths for different commits, which may have"]
            #[doc = "different release behavior. As a result, the compositor may signal the"]
            #[doc = "release points in a different order than the client committed them."]
            #[doc = ""]
            #[doc = "Because signaling a timeline point also signals every previous point,"]
            #[doc = "it is generally not safe to use the same timeline object for the"]
            #[doc = "release points of multiple buffers. The out-of-order signaling"]
            #[doc = "described above may lead to a release point being signaled before the"]
            #[doc = "compositor has finished reading. To avoid this, it is strongly"]
            #[doc = "recommended that each buffer should use a separate timeline for its"]
            #[doc = "release points."]
            #[doc = ""]
            #[doc = "The 64-bit unsigned value combined from point_hi and point_lo is the"]
            #[doc = "point value."]
            #[doc = ""]
            #[doc = "The release point is double-buffered state, and will be applied on the"]
            #[doc = "next wl_surface.commit request for the associated surface. Thus, it"]
            #[doc = "applies only to the buffer that is attached to the surface at commit"]
            #[doc = "time."]
            #[doc = ""]
            #[doc = "If a release point has already been attached during the same commit"]
            #[doc = "cycle, the new point replaces the old one."]
            #[doc = ""]
            #[doc = "If the associated wl_surface was destroyed, a no_surface error is"]
            #[doc = "raised."]
            #[doc = ""]
            #[doc = "If at surface commit time there is a pending release timeline point set"]
            #[doc = "but no pending buffer attached, a no_buffer error is raised. If at"]
            #[doc = "surface commit time there is a pending buffer attached but no pending"]
            #[doc = "release timeline point set, the no_release_point protocol error is"]
            #[doc = "raised."]
            async fn set_release_point(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                timeline: crate::wire::ObjectId,
                point_hi: u32,
                point_lo: u32,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod security_context_v1 {
    pub mod wp_security_context_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidListenFd = 1u32,
            Nested = 2u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This interface allows a client to register a new Wayland connection to"]
        #[doc = "the compositor and attach a security context to it."]
        #[doc = ""]
        #[doc = "This is intended to be used by sandboxes. Sandbox engines attach a"]
        #[doc = "security context to all connections coming from inside the sandbox. The"]
        #[doc = "compositor can then restrict the features that the sandboxed connections"]
        #[doc = "can use."]
        #[doc = ""]
        #[doc = "Compositors should forbid nesting multiple security contexts by not"]
        #[doc = "exposing wp_security_context_manager_v1 global to clients with a security"]
        #[doc = "context attached, or by sending the nested protocol error. Nested"]
        #[doc = "security contexts are dangerous because they can potentially allow"]
        #[doc = "privilege escalation of a sandboxed client."]
        #[doc = ""]
        #[doc = "Warning! The protocol described in this file is currently in the testing"]
        #[doc = "phase. Backward compatible changes may be added together with the"]
        #[doc = "corresponding interface version bump. Backward incompatible changes can"]
        #[doc = "only be done by creating a new major version of the extension."]
        pub trait WpSecurityContextManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_security_context_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_security_context_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "wp_security_context_manager_v1#{}.create_listener()",
                            object.id
                        );
                        self.create_listener(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.fd()?,
                            message.fd()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the manager. This doesn't destroy objects created with the"]
            #[doc = "manager."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Creates a new security context with a socket listening FD."]
            #[doc = ""]
            #[doc = "The compositor will accept new client connections on listen_fd."]
            #[doc = "listen_fd must be ready to accept new connections when this request is"]
            #[doc = "sent by the client. In other words, the client must call bind(2) and"]
            #[doc = "listen(2) before sending the FD."]
            #[doc = ""]
            #[doc = "close_fd is a FD closed by the client when the compositor should stop"]
            #[doc = "accepting new connections on listen_fd."]
            #[doc = ""]
            #[doc = "The compositor must continue to accept connections on listen_fd when"]
            #[doc = "the Wayland client which created the security context disconnects."]
            #[doc = ""]
            #[doc = "After sending this request, closing listen_fd and close_fd remains the"]
            #[doc = "only valid operation on them."]
            async fn create_listener(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                listen_fd: rustix::fd::OwnedFd,
                close_fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wp_security_context_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            AlreadyUsed = 1u32,
            AlreadySet = 2u32,
            InvalidMetadata = 3u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "The security context allows a client to register a new client and attach"]
        #[doc = "security context metadata to the connections."]
        #[doc = ""]
        #[doc = "When both are set, the combination of the application ID and the sandbox"]
        #[doc = "engine must uniquely identify an application. The same application ID"]
        #[doc = "will be used across instances (e.g. if the application is restarted, or"]
        #[doc = "if the application is started multiple times)."]
        #[doc = ""]
        #[doc = "When both are set, the combination of the instance ID and the sandbox"]
        #[doc = "engine must uniquely identify a running instance of an application."]
        pub trait WpSecurityContextV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_security_context_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_security_context_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "wp_security_context_v1#{}.set_sandbox_engine()",
                            object.id
                        );
                        self.set_sandbox_engine(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("wp_security_context_v1#{}.set_app_id()", object.id);
                        self.set_app_id(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("wp_security_context_v1#{}.set_instance_id()", object.id);
                        self.set_instance_id(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("wp_security_context_v1#{}.commit()", object.id);
                        self.commit(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the security context object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Attach a unique sandbox engine name to the security context. The name"]
            #[doc = "should follow the reverse-DNS style (e.g. \"org.flatpak\")."]
            #[doc = ""]
            #[doc = "A list of well-known engines is maintained at:"]
            #[doc = "https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/security-context/engines.md"]
            #[doc = ""]
            #[doc = "It is a protocol error to call this request twice. The already_set"]
            #[doc = "error is sent in this case."]
            async fn set_sandbox_engine(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
            ) -> crate::server::Result<()>;
            #[doc = "Attach an application ID to the security context."]
            #[doc = ""]
            #[doc = "The application ID is an opaque, sandbox-specific identifier for an"]
            #[doc = "application. See the well-known engines document for more details:"]
            #[doc = "https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/security-context/engines.md"]
            #[doc = ""]
            #[doc = "The compositor may use the application ID to group clients belonging to"]
            #[doc = "the same security context application."]
            #[doc = ""]
            #[doc = "Whether this request is optional or not depends on the sandbox engine used."]
            #[doc = ""]
            #[doc = "It is a protocol error to call this request twice. The already_set"]
            #[doc = "error is sent in this case."]
            async fn set_app_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                app_id: String,
            ) -> crate::server::Result<()>;
            #[doc = "Attach an instance ID to the security context."]
            #[doc = ""]
            #[doc = "The instance ID is an opaque, sandbox-specific identifier for a running"]
            #[doc = "instance of an application. See the well-known engines document for"]
            #[doc = "more details:"]
            #[doc = "https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/security-context/engines.md"]
            #[doc = ""]
            #[doc = "Whether this request is optional or not depends on the sandbox engine used."]
            #[doc = ""]
            #[doc = "It is a protocol error to call this request twice. The already_set"]
            #[doc = "error is sent in this case."]
            async fn set_instance_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                instance_id: String,
            ) -> crate::server::Result<()>;
            #[doc = "Atomically register the new client and attach the security context"]
            #[doc = "metadata."]
            #[doc = ""]
            #[doc = "If the provided metadata is inconsistent or does not match with out of"]
            #[doc = "band metadata (see"]
            #[doc = "https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/security-context/engines.md),"]
            #[doc = "the invalid_metadata error may be sent eventually."]
            #[doc = ""]
            #[doc = "It's a protocol error to send any request other than \"destroy\" after"]
            #[doc = "this request. In this case, the already_used error is sent."]
            async fn commit(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
#[doc = "This protocol extension allows clients to create single-pixel buffers."]
#[doc = ""]
#[doc = "Compositors supporting this protocol extension should also support the"]
#[doc = "viewporter protocol extension. Clients may use viewporter to scale a"]
#[doc = "single-pixel buffer to a desired size."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is currently in the testing"]
#[doc = "phase. Backward compatible changes may be added together with the"]
#[doc = "corresponding interface version bump. Backward incompatible changes can"]
#[doc = "only be done by creating a new major version of the extension."]
pub mod single_pixel_buffer_v1 {
    pub mod wp_single_pixel_buffer_manager_v1 {
        #[doc = "The wp_single_pixel_buffer_manager_v1 interface is a factory for"]
        #[doc = "single-pixel buffers."]
        pub trait WpSinglePixelBufferManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_single_pixel_buffer_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "wp_single_pixel_buffer_manager_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "wp_single_pixel_buffer_manager_v1#{}.create_u32_rgba_buffer()",
                            object.id
                        );
                        self.create_u32_rgba_buffer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the wp_single_pixel_buffer_manager_v1 object."]
            #[doc = ""]
            #[doc = "The child objects created via this interface are unaffected."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a single-pixel buffer from four 32-bit RGBA values."]
            #[doc = ""]
            #[doc = "Unless specified in another protocol extension, the RGBA values use"]
            #[doc = "pre-multiplied alpha."]
            #[doc = ""]
            #[doc = "The width and height of the buffer are 1."]
            async fn create_u32_rgba_buffer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                r: u32,
                g: u32,
                b: u32,
                a: u32,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod tearing_control_v1 {
    pub mod wp_tearing_control_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            TearingControlExists = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "For some use cases like games or drawing tablets it can make sense to"]
        #[doc = "reduce latency by accepting tearing with the use of asynchronous page"]
        #[doc = "flips. This global is a factory interface, allowing clients to inform"]
        #[doc = "which type of presentation the content of their surfaces is suitable for."]
        #[doc = ""]
        #[doc = "Graphics APIs like EGL or Vulkan, that manage the buffer queue and commits"]
        #[doc = "of a wl_surface themselves, are likely to be using this extension"]
        #[doc = "internally. If a client is using such an API for a wl_surface, it should"]
        #[doc = "not directly use this extension on that surface, to avoid raising a"]
        #[doc = "tearing_control_exists protocol error."]
        #[doc = ""]
        #[doc = "Warning! The protocol described in this file is currently in the testing"]
        #[doc = "phase. Backward compatible changes may be added together with the"]
        #[doc = "corresponding interface version bump. Backward incompatible changes can"]
        #[doc = "only be done by creating a new major version of the extension."]
        pub trait WpTearingControlManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_tearing_control_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_tearing_control_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "wp_tearing_control_manager_v1#{}.get_tearing_control()",
                            object.id
                        );
                        self.get_tearing_control(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy this tearing control factory object. Other objects, including"]
            #[doc = "wp_tearing_control_v1 objects created by this factory, are not affected"]
            #[doc = "by this request."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Instantiate an interface extension for the given wl_surface to request"]
            #[doc = "asynchronous page flips for presentation."]
            #[doc = ""]
            #[doc = "If the given wl_surface already has a wp_tearing_control_v1 object"]
            #[doc = "associated, the tearing_control_exists protocol error is raised."]
            async fn get_tearing_control(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wp_tearing_control_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum PresentationHint {
            #[doc = "The content of this surface is meant to be synchronized to the"]
            #[doc = "vertical blanking period. This should not result in visible tearing"]
            #[doc = "and may result in a delay before a surface commit is presented."]
            Vsync = 0u32,
            #[doc = "The content of this surface is meant to be presented with minimal"]
            #[doc = "latency and tearing is acceptable."]
            Async = 1u32,
        }
        impl TryFrom<u32> for PresentationHint {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "An additional interface to a wl_surface object, which allows the client"]
        #[doc = "to hint to the compositor if the content on the surface is suitable for"]
        #[doc = "presentation with tearing."]
        #[doc = "The default presentation hint is vsync. See presentation_hint for more"]
        #[doc = "details."]
        pub trait WpTearingControlV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_tearing_control_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "wp_tearing_control_v1#{}.set_presentation_hint()",
                            object.id
                        );
                        self.set_presentation_hint(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    1u16 => {
                        tracing::debug!("wp_tearing_control_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Set the presentation hint for the associated wl_surface. This state is"]
            #[doc = "double-buffered and is applied on the next wl_surface.commit."]
            #[doc = ""]
            #[doc = "The compositor is free to dynamically respect or ignore this hint based"]
            #[doc = "on various conditions like hardware capabilities, surface state and"]
            #[doc = "user preferences."]
            async fn set_presentation_hint(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                hint: PresentationHint,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy this surface tearing object and revert the presentation hint to"]
            #[doc = "vsync. The change will be applied on the next wl_surface.commit."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
#[doc = "The way for a client to pass focus to another toplevel is as follows."]
#[doc = ""]
#[doc = "The client that intends to activate another toplevel uses the"]
#[doc = "xdg_activation_v1.get_activation_token request to get an activation token."]
#[doc = "This token is then forwarded to the client, which is supposed to activate"]
#[doc = "one of its surfaces, through a separate band of communication."]
#[doc = ""]
#[doc = "One established way of doing this is through the XDG_ACTIVATION_TOKEN"]
#[doc = "environment variable of a newly launched child process. The child process"]
#[doc = "should unset the environment variable again right after reading it out in"]
#[doc = "order to avoid propagating it to other child processes."]
#[doc = ""]
#[doc = "Another established way exists for Applications implementing the D-Bus"]
#[doc = "interface org.freedesktop.Application, which should get their token under"]
#[doc = "activation-token on their platform_data."]
#[doc = ""]
#[doc = "In general activation tokens may be transferred across clients through"]
#[doc = "means not described in this protocol."]
#[doc = ""]
#[doc = "The client to be activated will then pass the token"]
#[doc = "it received to the xdg_activation_v1.activate request. The compositor can"]
#[doc = "then use this token to decide how to react to the activation request."]
#[doc = ""]
#[doc = "The token the activating client gets may be ineffective either already at"]
#[doc = "the time it receives it, for example if it was not focused, for focus"]
#[doc = "stealing prevention. The activating client will have no way to discover"]
#[doc = "the validity of the token, and may still forward it to the to be activated"]
#[doc = "client."]
#[doc = ""]
#[doc = "The created activation token may optionally get information attached to it"]
#[doc = "that can be used by the compositor to identify the application that we"]
#[doc = "intend to activate. This can for example be used to display a visual hint"]
#[doc = "about what application is being started."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is currently in the testing"]
#[doc = "phase. Backward compatible changes may be added together with the"]
#[doc = "corresponding interface version bump. Backward incompatible changes can"]
#[doc = "only be done by creating a new major version of the extension."]
pub mod xdg_activation_v1 {
    pub mod xdg_activation_v1 {
        #[doc = "A global interface used for informing the compositor about applications"]
        #[doc = "being activated or started, or for applications to request to be"]
        #[doc = "activated."]
        pub trait XdgActivationV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_activation_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_activation_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_activation_v1#{}.get_activation_token()", object.id);
                        self.get_activation_token(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("xdg_activation_v1#{}.activate()", object.id);
                        self.activate(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Notify the compositor that the xdg_activation object will no longer be"]
            #[doc = "used."]
            #[doc = ""]
            #[doc = "The child objects created via this interface are unaffected and should"]
            #[doc = "be destroyed separately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Creates an xdg_activation_token_v1 object that will provide"]
            #[doc = "the initiating client with a unique token for this activation. This"]
            #[doc = "token should be offered to the clients to be activated."]
            async fn get_activation_token(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Requests surface activation. It's up to the compositor to display"]
            #[doc = "this information as desired, for example by placing the surface above"]
            #[doc = "the rest."]
            #[doc = ""]
            #[doc = "The compositor may know who requested this by checking the activation"]
            #[doc = "token and might decide not to follow through with the activation if it's"]
            #[doc = "considered unwanted."]
            #[doc = ""]
            #[doc = "Compositors can ignore unknown activation tokens when an invalid"]
            #[doc = "token is passed."]
            async fn activate(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                token: String,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod xdg_activation_token_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            AlreadyUsed = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "An object for setting up a token and receiving a token handle that can"]
        #[doc = "be passed as an activation token to another client."]
        #[doc = ""]
        #[doc = "The object is created using the xdg_activation_v1.get_activation_token"]
        #[doc = "request. This object should then be populated with the app_id, surface"]
        #[doc = "and serial information and committed. The compositor shall then issue a"]
        #[doc = "done event with the token. In case the request's parameters are invalid,"]
        #[doc = "the compositor will provide an invalid token."]
        pub trait XdgActivationTokenV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_activation_token_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_activation_token_v1#{}.set_serial()", object.id);
                        self.set_serial(
                            object,
                            client,
                            message.uint()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("xdg_activation_token_v1#{}.set_app_id()", object.id);
                        self.set_app_id(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("xdg_activation_token_v1#{}.set_surface()", object.id);
                        self.set_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("xdg_activation_token_v1#{}.commit()", object.id);
                        self.commit(object, client).await
                    }
                    4u16 => {
                        tracing::debug!("xdg_activation_token_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Provides information about the seat and serial event that requested the"]
            #[doc = "token."]
            #[doc = ""]
            #[doc = "The serial can come from an input or focus event. For instance, if a"]
            #[doc = "click triggers the launch of a third-party client, the launcher client"]
            #[doc = "should send a set_serial request with the serial and seat from the"]
            #[doc = "wl_pointer.button event."]
            #[doc = ""]
            #[doc = "Some compositors might refuse to activate toplevels when the token"]
            #[doc = "doesn't have a valid and recent enough event serial."]
            #[doc = ""]
            #[doc = "Must be sent before commit. This information is optional."]
            async fn set_serial(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "The requesting client can specify an app_id to associate the token"]
            #[doc = "being created with it."]
            #[doc = ""]
            #[doc = "Must be sent before commit. This information is optional."]
            async fn set_app_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                app_id: String,
            ) -> crate::server::Result<()>;
            #[doc = "This request sets the surface requesting the activation. Note, this is"]
            #[doc = "different from the surface that will be activated."]
            #[doc = ""]
            #[doc = "Some compositors might refuse to activate toplevels when the token"]
            #[doc = "doesn't have a requesting surface."]
            #[doc = ""]
            #[doc = "Must be sent before commit. This information is optional."]
            async fn set_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Requests an activation token based on the different parameters that"]
            #[doc = "have been offered through set_serial, set_surface and set_app_id."]
            async fn commit(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Notify the compositor that the xdg_activation_token_v1 object will no"]
            #[doc = "longer be used. The received token stays valid."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The 'done' event contains the unique token of this activation request"]
            #[doc = "and notifies that the provider is done."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
pub mod xdg_dialog_v1 {
    pub mod xdg_wm_dialog_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            AlreadyUsed = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "The xdg_wm_dialog_v1 interface is exposed as a global object allowing"]
        #[doc = "to register surfaces with a xdg_toplevel role as \"dialogs\" relative to"]
        #[doc = "another toplevel."]
        #[doc = ""]
        #[doc = "The compositor may let this relation influence how the surface is"]
        #[doc = "placed, displayed or interacted with."]
        #[doc = ""]
        #[doc = "Warning! The protocol described in this file is currently in the testing"]
        #[doc = "phase. Backward compatible changes may be added together with the"]
        #[doc = "corresponding interface version bump. Backward incompatible changes can"]
        #[doc = "only be done by creating a new major version of the extension."]
        pub trait XdgWmDialogV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_wm_dialog_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_wm_dialog_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_wm_dialog_v1#{}.get_xdg_dialog()", object.id);
                        self.get_xdg_dialog(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroys the xdg_wm_dialog_v1 object. This does not affect"]
            #[doc = "the xdg_dialog_v1 objects generated through it."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Creates a xdg_dialog_v1 object for the given toplevel. See the interface"]
            #[doc = "description for more details."]
            #[doc = ""]
            #[doc = "Compositors must raise an already_used error if clients attempt to"]
            #[doc = "create multiple xdg_dialog_v1 objects for the same xdg_toplevel."]
            async fn get_xdg_dialog(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                toplevel: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod xdg_dialog_v1 {
        #[doc = "A xdg_dialog_v1 object is an ancillary object tied to a xdg_toplevel. Its"]
        #[doc = "purpose is hinting the compositor that the toplevel is a \"dialog\" (e.g. a"]
        #[doc = "temporary window) relative to another toplevel (see"]
        #[doc = "xdg_toplevel.set_parent). If the xdg_toplevel is destroyed, the xdg_dialog_v1"]
        #[doc = "becomes inert."]
        #[doc = ""]
        #[doc = "Through this object, the client may provide additional hints about"]
        #[doc = "the purpose of the secondary toplevel. This interface has no effect"]
        #[doc = "on toplevels that are not attached to a parent toplevel."]
        pub trait XdgDialogV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_dialog_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_dialog_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_dialog_v1#{}.set_modal()", object.id);
                        self.set_modal(object, client).await
                    }
                    2u16 => {
                        tracing::debug!("xdg_dialog_v1#{}.unset_modal()", object.id);
                        self.unset_modal(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroys the xdg_dialog_v1 object. If this object is destroyed"]
            #[doc = "before the related xdg_toplevel, the compositor should unapply its"]
            #[doc = "effects."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Hints that the dialog has \"modal\" behavior. Modal dialogs typically"]
            #[doc = "require to be fully addressed by the user (i.e. closed) before resuming"]
            #[doc = "interaction with the parent toplevel, and may require a distinct"]
            #[doc = "presentation."]
            #[doc = ""]
            #[doc = "Clients must implement the logic to filter events in the parent"]
            #[doc = "toplevel on their own."]
            #[doc = ""]
            #[doc = "Compositors may choose any policy in event delivery to the parent"]
            #[doc = "toplevel, from delivering all events unfiltered to using them for"]
            #[doc = "internal consumption."]
            async fn set_modal(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Drops the hint that this dialog has \"modal\" behavior. See"]
            #[doc = "xdg_dialog_v1.set_modal for more details."]
            async fn unset_modal(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod xdg_toplevel_drag_v1 {
    pub mod xdg_toplevel_drag_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidSource = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This protocol enhances normal drag and drop with the ability to move a"]
        #[doc = "window at the same time. This allows having detachable parts of a window"]
        #[doc = "that when dragged out of it become a new window and can be dragged over"]
        #[doc = "an existing window to be reattached."]
        #[doc = ""]
        #[doc = "A typical workflow would be when the user starts dragging on top of a"]
        #[doc = "detachable part of a window, the client would create a wl_data_source and"]
        #[doc = "a xdg_toplevel_drag_v1 object and start the drag as normal via"]
        #[doc = "wl_data_device.start_drag. Once the client determines that the detachable"]
        #[doc = "window contents should be detached from the originating window, it creates"]
        #[doc = "a new xdg_toplevel with these contents and issues a"]
        #[doc = "xdg_toplevel_drag_v1.attach request before mapping it. From now on the new"]
        #[doc = "window is moved by the compositor during the drag as if the client called"]
        #[doc = "xdg_toplevel.move."]
        #[doc = ""]
        #[doc = "Dragging an existing window is similar. The client creates a"]
        #[doc = "xdg_toplevel_drag_v1 object and attaches the existing toplevel before"]
        #[doc = "starting the drag."]
        #[doc = ""]
        #[doc = "Clients use the existing drag and drop mechanism to detect when a window"]
        #[doc = "can be docked or undocked. If the client wants to snap a window into a"]
        #[doc = "parent window it should delete or unmap the dragged top-level. If the"]
        #[doc = "contents should be detached again it attaches a new toplevel as described"]
        #[doc = "above. If a drag operation is cancelled without being dropped, clients"]
        #[doc = "should revert to the previous state, deleting any newly created windows"]
        #[doc = "as appropriate. When a drag operation ends as indicated by"]
        #[doc = "wl_data_source.dnd_drop_performed the dragged toplevel window's final"]
        #[doc = "position is determined as if a xdg_toplevel_move operation ended."]
        #[doc = ""]
        #[doc = "Warning! The protocol described in this file is currently in the testing"]
        #[doc = "phase. Backward compatible changes may be added together with the"]
        #[doc = "corresponding interface version bump. Backward incompatible changes can"]
        #[doc = "only be done by creating a new major version of the extension."]
        pub trait XdgToplevelDragManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_toplevel_drag_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_toplevel_drag_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "xdg_toplevel_drag_manager_v1#{}.get_xdg_toplevel_drag()",
                            object.id
                        );
                        self.get_xdg_toplevel_drag(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy this xdg_toplevel_drag_manager_v1 object. Other objects,"]
            #[doc = "including xdg_toplevel_drag_v1 objects created by this factory, are not"]
            #[doc = "affected by this request."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create an xdg_toplevel_drag for a drag and drop operation that is going"]
            #[doc = "to be started with data_source."]
            #[doc = ""]
            #[doc = "This request can only be made on sources used in drag-and-drop, so it"]
            #[doc = "must be performed before wl_data_device.start_drag. Attempting to use"]
            #[doc = "the source other than for drag-and-drop such as in"]
            #[doc = "wl_data_device.set_selection will raise an invalid_source error."]
            #[doc = ""]
            #[doc = "Destroying data_source while a toplevel is attached to the"]
            #[doc = "xdg_toplevel_drag is undefined."]
            async fn get_xdg_toplevel_drag(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                data_source: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod xdg_toplevel_drag_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            ToplevelAttached = 0u32,
            OngoingDrag = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        pub trait XdgToplevelDragV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_toplevel_drag_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_toplevel_drag_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_toplevel_drag_v1#{}.attach()", object.id);
                        self.attach(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy this xdg_toplevel_drag_v1 object. This request must only be"]
            #[doc = "called after the underlying wl_data_source drag has ended, as indicated"]
            #[doc = "by the dnd_drop_performed or cancelled events. In any other case an"]
            #[doc = "ongoing_drag error is raised."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Request that the window will be moved with the cursor during the drag"]
            #[doc = "operation. The offset is a hint to the compositor how the toplevel"]
            #[doc = "should be positioned relative to the cursor hotspot in surface local"]
            #[doc = "coordinates. For example it might only be used when an unmapped window"]
            #[doc = "is attached. The attached window does not participate in the selection"]
            #[doc = "of the drag target."]
            #[doc = ""]
            #[doc = "If the toplevel is unmapped while it is attached, it is automatically"]
            #[doc = "detached from the drag. In this case this request has to be called again"]
            #[doc = "if the window should be attached after it is remapped."]
            #[doc = ""]
            #[doc = "This request can be called multiple times but issuing it while a"]
            #[doc = "toplevel with an active role is attached raises a toplevel_attached"]
            #[doc = "error."]
            async fn attach(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                toplevel: crate::wire::ObjectId,
                x_offset: i32,
                y_offset: i32,
            ) -> crate::server::Result<()>;
        }
    }
}
#[doc = "This protocol adds a xwayland_surface role which allows an Xwayland"]
#[doc = "server to associate an X11 window to a wl_surface."]
#[doc = ""]
#[doc = "Before this protocol, this would be done via the Xwayland server"]
#[doc = "providing the wl_surface's resource id via the a client message with"]
#[doc = "the WL_SURFACE_ID atom on the X window."]
#[doc = "This was problematic as a race could occur if the wl_surface"]
#[doc = "associated with a WL_SURFACE_ID for a window was destroyed before the"]
#[doc = "client message was processed by the compositor and another surface"]
#[doc = "(or other object) had taken its id due to recycling."]
#[doc = ""]
#[doc = "This protocol solves the problem by moving the X11 window to wl_surface"]
#[doc = "association step to the Wayland side, which means that the association"]
#[doc = "cannot happen out-of-sync with the resource lifetime of the wl_surface."]
#[doc = ""]
#[doc = "This protocol avoids duplicating the race on the other side by adding a"]
#[doc = "non-zero monotonic serial number which is entirely unique that is set on"]
#[doc = "both the wl_surface (via. xwayland_surface_v1's set_serial method) and"]
#[doc = "the X11 window (via. the `WL_SURFACE_SERIAL` client message) that can be"]
#[doc = "used to associate them, and synchronize the two timelines."]
#[doc = ""]
#[doc = "The key words \"must\", \"must not\", \"required\", \"shall\", \"shall not\","]
#[doc = "\"should\", \"should not\", \"recommended\",  \"may\", and \"optional\" in this"]
#[doc = "document are to be interpreted as described in IETF RFC 2119."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is currently in the testing"]
#[doc = "phase. Backward compatible changes may be added together with the"]
#[doc = "corresponding interface version bump. Backward incompatible changes can"]
#[doc = "only be done by creating a new major version of the extension."]
pub mod xwayland_shell_v1 {
    pub mod xwayland_shell_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            Role = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "xwayland_shell_v1 is a singleton global object that"]
        #[doc = "provides the ability to create a xwayland_surface_v1 object"]
        #[doc = "for a given wl_surface."]
        #[doc = ""]
        #[doc = "This interface is intended to be bound by the Xwayland server."]
        #[doc = ""]
        #[doc = "A compositor must not allow clients other than Xwayland to"]
        #[doc = "bind to this interface. A compositor should hide this global"]
        #[doc = "from other clients' wl_registry."]
        #[doc = "A client the compositor does not consider to be an Xwayland"]
        #[doc = "server attempting to bind this interface will result in"]
        #[doc = "an implementation-defined error."]
        #[doc = ""]
        #[doc = "An Xwayland server that has bound this interface must not"]
        #[doc = "set the `WL_SURFACE_ID` atom on a window."]
        pub trait XwaylandShellV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xwayland_shell_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xwayland_shell_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xwayland_shell_v1#{}.get_xwayland_surface()", object.id);
                        self.get_xwayland_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the xwayland_shell_v1 object."]
            #[doc = ""]
            #[doc = "The child objects created via this interface are unaffected."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create an xwayland_surface_v1 interface for a given wl_surface"]
            #[doc = "object and gives it the xwayland_surface role."]
            #[doc = ""]
            #[doc = "It is illegal to create an xwayland_surface_v1 for a wl_surface"]
            #[doc = "which already has an assigned role and this will result in the"]
            #[doc = "`role` protocol error."]
            #[doc = ""]
            #[doc = "See the documentation of xwayland_surface_v1 for more details"]
            #[doc = "about what an xwayland_surface_v1 is and how it is used."]
            async fn get_xwayland_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod xwayland_surface_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            AlreadyAssociated = 0u32,
            InvalidSerial = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "An Xwayland surface is a surface managed by an Xwayland server."]
        #[doc = "It is used for associating surfaces to Xwayland windows."]
        #[doc = ""]
        #[doc = "The Xwayland server associated with actions in this interface is"]
        #[doc = "determined by the Wayland client making the request."]
        #[doc = ""]
        #[doc = "The client must call wl_surface.commit on the corresponding wl_surface"]
        #[doc = "for the xwayland_surface_v1 state to take effect."]
        pub trait XwaylandSurfaceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xwayland_surface_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xwayland_surface_v1#{}.set_serial()", object.id);
                        self.set_serial(object, client, message.uint()?, message.uint()?)
                            .await
                    }
                    1u16 => {
                        tracing::debug!("xwayland_surface_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Associates an Xwayland window to a wl_surface."]
            #[doc = "The association state is double-buffered and will be applied at"]
            #[doc = "the time wl_surface.commit of the corresponding wl_surface is called."]
            #[doc = ""]
            #[doc = "The `serial_lo` and `serial_hi` parameters specify a non-zero"]
            #[doc = "monotonic serial number which is entirely unique and provided by the"]
            #[doc = "Xwayland server equal to the serial value provided by a client message"]
            #[doc = "with a message type of the `WL_SURFACE_SERIAL` atom on the X11 window"]
            #[doc = "for this surface to be associated to."]
            #[doc = ""]
            #[doc = "The serial value in the `WL_SURFACE_SERIAL` client message is specified"]
            #[doc = "as having the lo-bits specified in `l[0]` and the hi-bits specified"]
            #[doc = "in `l[1]`."]
            #[doc = ""]
            #[doc = "If the serial value provided by `serial_lo` and `serial_hi` is not"]
            #[doc = "valid, the `invalid_serial` protocol error will be raised."]
            #[doc = ""]
            #[doc = "An X11 window may be associated with multiple surfaces throughout its"]
            #[doc = "lifespan. (eg. unmapping and remapping a window)."]
            #[doc = ""]
            #[doc = "For each wl_surface, this state must not be committed more than once,"]
            #[doc = "otherwise the `already_associated` protocol error will be raised."]
            async fn set_serial(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial_lo: u32,
                serial_hi: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the xwayland_surface_v1 object."]
            #[doc = ""]
            #[doc = "Any already existing associations are unaffected by this action."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod fullscreen_shell_unstable_v1 {
    pub mod zwp_fullscreen_shell_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Capability {
            ArbitraryModes = 1u32,
            CursorPlane = 2u32,
        }
        impl TryFrom<u32> for Capability {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum PresentMethod {
            Default = 0u32,
            Center = 1u32,
            Zoom = 2u32,
            ZoomCrop = 3u32,
            Stretch = 4u32,
        }
        impl TryFrom<u32> for PresentMethod {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidMethod = 0u32,
            Role = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Displays a single surface per output."]
        #[doc = ""]
        #[doc = "This interface provides a mechanism for a single client to display"]
        #[doc = "simple full-screen surfaces.  While there technically may be multiple"]
        #[doc = "clients bound to this interface, only one of those clients should be"]
        #[doc = "shown at a time."]
        #[doc = ""]
        #[doc = "To present a surface, the client uses either the present_surface or"]
        #[doc = "present_surface_for_mode requests.  Presenting a surface takes effect"]
        #[doc = "on the next wl_surface.commit.  See the individual requests for"]
        #[doc = "details about scaling and mode switches."]
        #[doc = ""]
        #[doc = "The client can have at most one surface per output at any time."]
        #[doc = "Requesting a surface to be presented on an output that already has a"]
        #[doc = "surface replaces the previously presented surface.  Presenting a null"]
        #[doc = "surface removes its content and effectively disables the output."]
        #[doc = "Exactly what happens when an output is \"disabled\" is"]
        #[doc = "compositor-specific.  The same surface may be presented on multiple"]
        #[doc = "outputs simultaneously."]
        #[doc = ""]
        #[doc = "Once a surface is presented on an output, it stays on that output"]
        #[doc = "until either the client removes it or the compositor destroys the"]
        #[doc = "output.  This way, the client can update the output's contents by"]
        #[doc = "simply attaching a new buffer."]
        #[doc = ""]
        #[doc = "Warning! The protocol described in this file is experimental and"]
        #[doc = "backward incompatible changes may be made. Backward compatible changes"]
        #[doc = "may be added together with the corresponding interface version bump."]
        #[doc = "Backward incompatible changes are done by bumping the version number in"]
        #[doc = "the protocol and interface names and resetting the interface version."]
        #[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
        #[doc = "version number in the protocol and interface names are removed and the"]
        #[doc = "interface version number is reset."]
        pub trait ZwpFullscreenShellV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_fullscreen_shell_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_fullscreen_shell_v1#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zwp_fullscreen_shell_v1#{}.present_surface()", object.id);
                        self.present_surface(
                            object,
                            client,
                            message.object()?,
                            message.uint()?.try_into()?,
                            message.object()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "zwp_fullscreen_shell_v1#{}.present_surface_for_mode()",
                            object.id
                        );
                        self.present_surface_for_mode(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Release the binding from the wl_fullscreen_shell interface."]
            #[doc = ""]
            #[doc = "This destroys the server-side object and frees this binding.  If"]
            #[doc = "the client binds to wl_fullscreen_shell multiple times, it may wish"]
            #[doc = "to free some of those bindings."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Present a surface on the given output."]
            #[doc = ""]
            #[doc = "If the output is null, the compositor will present the surface on"]
            #[doc = "whatever display (or displays) it thinks best.  In particular, this"]
            #[doc = "may replace any or all surfaces currently presented so it should"]
            #[doc = "not be used in combination with placing surfaces on specific"]
            #[doc = "outputs."]
            #[doc = ""]
            #[doc = "The method parameter is a hint to the compositor for how the surface"]
            #[doc = "is to be presented.  In particular, it tells the compositor how to"]
            #[doc = "handle a size mismatch between the presented surface and the"]
            #[doc = "output.  The compositor is free to ignore this parameter."]
            #[doc = ""]
            #[doc = "The \"zoom\", \"zoom_crop\", and \"stretch\" methods imply a scaling"]
            #[doc = "operation on the surface.  This will override any kind of output"]
            #[doc = "scaling, so the buffer_scale property of the surface is effectively"]
            #[doc = "ignored."]
            #[doc = ""]
            #[doc = "This request gives the surface the role of a fullscreen shell surface."]
            #[doc = "If the surface already has another role, it raises a role protocol"]
            #[doc = "error."]
            async fn present_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: Option<crate::wire::ObjectId>,
                method: PresentMethod,
                output: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Presents a surface on the given output for a particular mode."]
            #[doc = ""]
            #[doc = "If the current size of the output differs from that of the surface,"]
            #[doc = "the compositor will attempt to change the size of the output to"]
            #[doc = "match the surface.  The result of the mode-switch operation will be"]
            #[doc = "returned via the provided wl_fullscreen_shell_mode_feedback object."]
            #[doc = ""]
            #[doc = "If the current output mode matches the one requested or if the"]
            #[doc = "compositor successfully switches the mode to match the surface,"]
            #[doc = "then the mode_successful event will be sent and the output will"]
            #[doc = "contain the contents of the given surface.  If the compositor"]
            #[doc = "cannot match the output size to the surface size, the mode_failed"]
            #[doc = "will be sent and the output will contain the contents of the"]
            #[doc = "previously presented surface (if any).  If another surface is"]
            #[doc = "presented on the given output before either of these has a chance"]
            #[doc = "to happen, the present_cancelled event will be sent."]
            #[doc = ""]
            #[doc = "Due to race conditions and other issues unknown to the client, no"]
            #[doc = "mode-switch operation is guaranteed to succeed.  However, if the"]
            #[doc = "mode is one advertised by wl_output.mode or if the compositor"]
            #[doc = "advertises the ARBITRARY_MODES capability, then the client should"]
            #[doc = "expect that the mode-switch operation will usually succeed."]
            #[doc = ""]
            #[doc = "If the size of the presented surface changes, the resulting output"]
            #[doc = "is undefined.  The compositor may attempt to change the output mode"]
            #[doc = "to compensate.  However, there is no guarantee that a suitable mode"]
            #[doc = "will be found and the client has no way to be notified of success"]
            #[doc = "or failure."]
            #[doc = ""]
            #[doc = "The framerate parameter specifies the desired framerate for the"]
            #[doc = "output in mHz.  The compositor is free to ignore this parameter.  A"]
            #[doc = "value of 0 indicates that the client has no preference."]
            #[doc = ""]
            #[doc = "If the value of wl_output.scale differs from wl_surface.buffer_scale,"]
            #[doc = "then the compositor may choose a mode that matches either the buffer"]
            #[doc = "size or the surface size.  In either case, the surface will fill the"]
            #[doc = "output."]
            #[doc = ""]
            #[doc = "This request gives the surface the role of a fullscreen shell surface."]
            #[doc = "If the surface already has another role, it raises a role protocol"]
            #[doc = "error."]
            async fn present_surface_for_mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
                output: crate::wire::ObjectId,
                framerate: i32,
                feedback: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Advertises a single capability of the compositor."]
            #[doc = ""]
            #[doc = "When the wl_fullscreen_shell interface is bound, this event is emitted"]
            #[doc = "once for each capability advertised.  Valid capabilities are given by"]
            #[doc = "the wl_fullscreen_shell.capability enum.  If clients want to take"]
            #[doc = "advantage of any of these capabilities, they should use a"]
            #[doc = "wl_display.sync request immediately after binding to ensure that they"]
            #[doc = "receive all the capability events."]
            async fn capability(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_fullscreen_shell_mode_feedback_v1 {
        pub trait ZwpFullscreenShellModeFeedbackV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_fullscreen_shell_mode_feedback_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This event indicates that the attempted mode switch operation was"]
            #[doc = "successful.  A surface of the size requested in the mode switch"]
            #[doc = "will fill the output without scaling."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy the"]
            #[doc = "wl_fullscreen_shell_mode_feedback object."]
            async fn mode_successful(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event indicates that the attempted mode switch operation"]
            #[doc = "failed.  This may be because the requested output mode is not"]
            #[doc = "possible or it may mean that the compositor does not want to allow it."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy the"]
            #[doc = "wl_fullscreen_shell_mode_feedback object."]
            async fn mode_failed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event indicates that the attempted mode switch operation was"]
            #[doc = "cancelled.  Most likely this is because the client requested a"]
            #[doc = "second mode switch before the first one completed."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy the"]
            #[doc = "wl_fullscreen_shell_mode_feedback object."]
            async fn present_cancelled(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
pub mod idle_inhibit_unstable_v1 {
    pub mod zwp_idle_inhibit_manager_v1 {
        #[doc = "This interface permits inhibiting the idle behavior such as screen"]
        #[doc = "blanking, locking, and screensaving.  The client binds the idle manager"]
        #[doc = "globally, then creates idle-inhibitor objects for each surface."]
        #[doc = ""]
        #[doc = "Warning! The protocol described in this file is experimental and"]
        #[doc = "backward incompatible changes may be made. Backward compatible changes"]
        #[doc = "may be added together with the corresponding interface version bump."]
        #[doc = "Backward incompatible changes are done by bumping the version number in"]
        #[doc = "the protocol and interface names and resetting the interface version."]
        #[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
        #[doc = "version number in the protocol and interface names are removed and the"]
        #[doc = "interface version number is reset."]
        pub trait ZwpIdleInhibitManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_idle_inhibit_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_idle_inhibit_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwp_idle_inhibit_manager_v1#{}.create_inhibitor()",
                            object.id
                        );
                        self.create_inhibitor(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the inhibit manager."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a new inhibitor object associated with the given surface."]
            async fn create_inhibitor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_idle_inhibitor_v1 {
        #[doc = "An idle inhibitor prevents the output that the associated surface is"]
        #[doc = "visible on from being set to a state where it is not visually usable due"]
        #[doc = "to lack of user interaction (e.g. blanked, dimmed, locked, set to power"]
        #[doc = "save, etc.)  Any screensaver processes are also blocked from displaying."]
        #[doc = ""]
        #[doc = "If the surface is destroyed, unmapped, becomes occluded, loses"]
        #[doc = "visibility, or otherwise becomes not visually relevant for the user, the"]
        #[doc = "idle inhibitor will not be honored by the compositor; if the surface"]
        #[doc = "subsequently regains visibility the inhibitor takes effect once again."]
        #[doc = "Likewise, the inhibitor isn't honored if the system was already idled at"]
        #[doc = "the time the inhibitor was established, although if the system later"]
        #[doc = "de-idles and re-idles the inhibitor will take effect."]
        pub trait ZwpIdleInhibitorV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_idle_inhibitor_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_idle_inhibitor_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Remove the inhibitor effect from the associated wl_surface."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod input_method_unstable_v1 {
    pub mod zwp_input_method_context_v1 {
        #[doc = "Corresponds to a text input on the input method side. An input method context"]
        #[doc = "is created on text input activation on the input method side. It allows"]
        #[doc = "receiving information about the text input from the application via events."]
        #[doc = "Input method contexts do not keep state after deactivation and should be"]
        #[doc = "destroyed after deactivation is handled."]
        #[doc = ""]
        #[doc = "Text is generally UTF-8 encoded, indices and lengths are in bytes."]
        #[doc = ""]
        #[doc = "Serials are used to synchronize the state between the text input and"]
        #[doc = "an input method. New serials are sent by the text input in the"]
        #[doc = "commit_state request and are used by the input method to indicate"]
        #[doc = "the known text input state in events like preedit_string, commit_string,"]
        #[doc = "and keysym. The text input can then ignore events from the input method"]
        #[doc = "which are based on an outdated state (for example after a reset)."]
        #[doc = ""]
        #[doc = "Warning! The protocol described in this file is experimental and"]
        #[doc = "backward incompatible changes may be made. Backward compatible changes"]
        #[doc = "may be added together with the corresponding interface version bump."]
        #[doc = "Backward incompatible changes are done by bumping the version number in"]
        #[doc = "the protocol and interface names and resetting the interface version."]
        #[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
        #[doc = "version number in the protocol and interface names are removed and the"]
        #[doc = "interface version number is reset."]
        pub trait ZwpInputMethodContextV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_input_method_context_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_input_method_context_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.commit_string()",
                            object.id
                        );
                        self.commit_string(
                            object,
                            client,
                            message.uint()?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.preedit_string()",
                            object.id
                        );
                        self.preedit_string(
                            object,
                            client,
                            message.uint()?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.preedit_styling()",
                            object.id
                        );
                        self.preedit_styling(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.preedit_cursor()",
                            object.id
                        );
                        self.preedit_cursor(object, client, message.int()?).await
                    }
                    5u16 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.delete_surrounding_text()",
                            object.id
                        );
                        self.delete_surrounding_text(
                            object,
                            client,
                            message.int()?,
                            message.uint()?,
                        )
                        .await
                    }
                    6u16 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.cursor_position()",
                            object.id
                        );
                        self.cursor_position(object, client, message.int()?, message.int()?)
                            .await
                    }
                    7u16 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.modifiers_map()",
                            object.id
                        );
                        self.modifiers_map(object, client, message.array()?).await
                    }
                    8u16 => {
                        tracing::debug!("zwp_input_method_context_v1#{}.keysym()", object.id);
                        self.keysym(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    9u16 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.grab_keyboard()",
                            object.id
                        );
                        self.grab_keyboard(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    10u16 => {
                        tracing::debug!("zwp_input_method_context_v1#{}.key()", object.id);
                        self.key(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    11u16 => {
                        tracing::debug!("zwp_input_method_context_v1#{}.modifiers()", object.id);
                        self.modifiers(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    12u16 => {
                        tracing::debug!("zwp_input_method_context_v1#{}.language()", object.id);
                        self.language(
                            object,
                            client,
                            message.uint()?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    13u16 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.text_direction()",
                            object.id
                        );
                        self.text_direction(object, client, message.uint()?, message.uint()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Send the commit string text for insertion to the application."]
            #[doc = ""]
            #[doc = "The text to commit could be either just a single character after a key"]
            #[doc = "press or the result of some composing (pre-edit). It could be also an"]
            #[doc = "empty text when some text should be removed (see"]
            #[doc = "delete_surrounding_text) or when the input cursor should be moved (see"]
            #[doc = "cursor_position)."]
            #[doc = ""]
            #[doc = "Any previously set composing text will be removed."]
            async fn commit_string(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                text: String,
            ) -> crate::server::Result<()>;
            #[doc = "Send the pre-edit string text to the application text input."]
            #[doc = ""]
            #[doc = "The commit text can be used to replace the pre-edit text on reset (for"]
            #[doc = "example on unfocus)."]
            #[doc = ""]
            #[doc = "Previously sent preedit_style and preedit_cursor requests are also"]
            #[doc = "processed by the text_input."]
            async fn preedit_string(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                text: String,
                commit: String,
            ) -> crate::server::Result<()>;
            #[doc = "Set the styling information on composing text. The style is applied for"]
            #[doc = "length in bytes from index relative to the beginning of"]
            #[doc = "the composing text (as byte offset). Multiple styles can"]
            #[doc = "be applied to a composing text."]
            #[doc = ""]
            #[doc = "This request should be sent before sending a preedit_string request."]
            async fn preedit_styling(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: u32,
                length: u32,
                style: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Set the cursor position inside the composing text (as byte offset)"]
            #[doc = "relative to the start of the composing text."]
            #[doc = ""]
            #[doc = "When index is negative no cursor should be displayed."]
            #[doc = ""]
            #[doc = "This request should be sent before sending a preedit_string request."]
            async fn preedit_cursor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Remove the surrounding text."]
            #[doc = ""]
            #[doc = "This request will be handled on the text_input side directly following"]
            #[doc = "a commit_string request."]
            async fn delete_surrounding_text(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: i32,
                length: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Set the cursor and anchor to a new position. Index is the new cursor"]
            #[doc = "position in bytes (when >= 0 this is relative to the end of the inserted text,"]
            #[doc = "otherwise it is relative to the beginning of the inserted text). Anchor is"]
            #[doc = "the new anchor position in bytes (when >= 0 this is relative to the end of the"]
            #[doc = "inserted text, otherwise it is relative to the beginning of the inserted"]
            #[doc = "text). When there should be no selected text, anchor should be the same"]
            #[doc = "as index."]
            #[doc = ""]
            #[doc = "This request will be handled on the text_input side directly following"]
            #[doc = "a commit_string request."]
            async fn cursor_position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: i32,
                anchor: i32,
            ) -> crate::server::Result<()>;
            async fn modifiers_map(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                map: Vec<u8>,
            ) -> crate::server::Result<()>;
            #[doc = "Notify when a key event was sent. Key events should not be used for"]
            #[doc = "normal text input operations, which should be done with commit_string,"]
            #[doc = "delete_surrounding_text, etc. The key event follows the wl_keyboard key"]
            #[doc = "event convention. Sym is an XKB keysym, state is a wl_keyboard key_state."]
            async fn keysym(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                sym: u32,
                state: u32,
                modifiers: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Allow an input method to receive hardware keyboard input and process"]
            #[doc = "key events to generate text events (with pre-edit) over the wire. This"]
            #[doc = "allows input methods which compose multiple key events for inputting"]
            #[doc = "text like it is done for CJK languages."]
            async fn grab_keyboard(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                keyboard: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Forward a wl_keyboard::key event to the client that was not processed"]
            #[doc = "by the input method itself. Should be used when filtering key events"]
            #[doc = "with grab_keyboard.  The arguments should be the ones from the"]
            #[doc = "wl_keyboard::key event."]
            #[doc = ""]
            #[doc = "For generating custom key events use the keysym request instead."]
            async fn key(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                key: u32,
                state: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Forward a wl_keyboard::modifiers event to the client that was not"]
            #[doc = "processed by the input method itself.  Should be used when filtering"]
            #[doc = "key events with grab_keyboard. The arguments should be the ones"]
            #[doc = "from the wl_keyboard::modifiers event."]
            async fn modifiers(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                mods_depressed: u32,
                mods_latched: u32,
                mods_locked: u32,
                group: u32,
            ) -> crate::server::Result<()>;
            async fn language(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                language: String,
            ) -> crate::server::Result<()>;
            async fn text_direction(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                direction: u32,
            ) -> crate::server::Result<()>;
            #[doc = "The plain surrounding text around the input position. Cursor is the"]
            #[doc = "position in bytes within the surrounding text relative to the beginning"]
            #[doc = "of the text. Anchor is the position in bytes of the selection anchor"]
            #[doc = "within the surrounding text relative to the beginning of the text. If"]
            #[doc = "there is no selected text then anchor is the same as cursor."]
            async fn surrounding_text(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            async fn reset(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            async fn content_type(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            async fn invoke_action(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            async fn commit_state(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            async fn preferred_language(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_input_method_v1 {
        #[doc = "An input method object is responsible for composing text in response to"]
        #[doc = "input from hardware or virtual keyboards. There is one input method"]
        #[doc = "object per seat. On activate there is a new input method context object"]
        #[doc = "created which allows the input method to communicate with the text input."]
        pub trait ZwpInputMethodV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_input_method_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "A text input was activated. Creates an input method context object"]
            #[doc = "which allows communication with the text input."]
            async fn activate(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The text input corresponding to the context argument was deactivated."]
            #[doc = "The input method context should be destroyed after deactivation is"]
            #[doc = "handled."]
            async fn deactivate(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_input_panel_v1 {
        #[doc = "Only one client can bind this interface at a time."]
        pub trait ZwpInputPanelV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_input_panel_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwp_input_panel_v1#{}.get_input_panel_surface()",
                            object.id
                        );
                        self.get_input_panel_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn get_input_panel_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_input_panel_surface_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Position {
            CenterBottom = 0u32,
        }
        impl TryFrom<u32> for Position {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        pub trait ZwpInputPanelSurfaceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_input_panel_surface_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_input_panel_surface_v1#{}.set_toplevel()", object.id);
                        self.set_toplevel(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwp_input_panel_surface_v1#{}.set_overlay_panel()",
                            object.id
                        );
                        self.set_overlay_panel(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Set the input_panel_surface type to keyboard."]
            #[doc = ""]
            #[doc = "A keyboard surface is only shown when a text input is active."]
            async fn set_toplevel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: crate::wire::ObjectId,
                position: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Set the input_panel_surface to be an overlay panel."]
            #[doc = ""]
            #[doc = "This is shown near the input cursor above the application window when"]
            #[doc = "a text input is active."]
            async fn set_overlay_panel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
#[doc = "This protocol specifies a way for a client to request and receive"]
#[doc = "high-resolution timestamps for input events."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and"]
#[doc = "backward incompatible changes may be made. Backward compatible changes"]
#[doc = "may be added together with the corresponding interface version bump."]
#[doc = "Backward incompatible changes are done by bumping the version number in"]
#[doc = "the protocol and interface names and resetting the interface version."]
#[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
#[doc = "version number in the protocol and interface names are removed and the"]
#[doc = "interface version number is reset."]
pub mod input_timestamps_unstable_v1 {
    pub mod zwp_input_timestamps_manager_v1 {
        #[doc = "A global interface used for requesting high-resolution timestamps"]
        #[doc = "for input events."]
        pub trait ZwpInputTimestampsManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_input_timestamps_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_input_timestamps_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwp_input_timestamps_manager_v1#{}.get_keyboard_timestamps()",
                            object.id
                        );
                        self.get_keyboard_timestamps(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "zwp_input_timestamps_manager_v1#{}.get_pointer_timestamps()",
                            object.id
                        );
                        self.get_pointer_timestamps(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!(
                            "zwp_input_timestamps_manager_v1#{}.get_touch_timestamps()",
                            object.id
                        );
                        self.get_touch_timestamps(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Informs the server that the client will no longer be using this"]
            #[doc = "protocol object. Existing objects created by this object are not"]
            #[doc = "affected."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Creates a new input timestamps object that represents a subscription"]
            #[doc = "to high-resolution timestamp events for all wl_keyboard events that"]
            #[doc = "carry a timestamp."]
            #[doc = ""]
            #[doc = "If the associated wl_keyboard object is invalidated, either through"]
            #[doc = "client action (e.g. release) or server-side changes, the input"]
            #[doc = "timestamps object becomes inert and the client should destroy it"]
            #[doc = "by calling zwp_input_timestamps_v1.destroy."]
            async fn get_keyboard_timestamps(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                keyboard: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Creates a new input timestamps object that represents a subscription"]
            #[doc = "to high-resolution timestamp events for all wl_pointer events that"]
            #[doc = "carry a timestamp."]
            #[doc = ""]
            #[doc = "If the associated wl_pointer object is invalidated, either through"]
            #[doc = "client action (e.g. release) or server-side changes, the input"]
            #[doc = "timestamps object becomes inert and the client should destroy it"]
            #[doc = "by calling zwp_input_timestamps_v1.destroy."]
            async fn get_pointer_timestamps(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                pointer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Creates a new input timestamps object that represents a subscription"]
            #[doc = "to high-resolution timestamp events for all wl_touch events that"]
            #[doc = "carry a timestamp."]
            #[doc = ""]
            #[doc = "If the associated wl_touch object becomes invalid, either through"]
            #[doc = "client action (e.g. release) or server-side changes, the input"]
            #[doc = "timestamps object becomes inert and the client should destroy it"]
            #[doc = "by calling zwp_input_timestamps_v1.destroy."]
            async fn get_touch_timestamps(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                touch: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_input_timestamps_v1 {
        #[doc = "Provides high-resolution timestamp events for a set of subscribed input"]
        #[doc = "events. The set of subscribed input events is determined by the"]
        #[doc = "zwp_input_timestamps_manager_v1 request used to create this object."]
        pub trait ZwpInputTimestampsV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_input_timestamps_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_input_timestamps_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Informs the server that the client will no longer be using this"]
            #[doc = "protocol object. After the server processes the request, no more"]
            #[doc = "timestamp events will be emitted."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The timestamp event is associated with the first subsequent input event"]
            #[doc = "carrying a timestamp which belongs to the set of input events this"]
            #[doc = "object is subscribed to."]
            #[doc = ""]
            #[doc = "The timestamp provided by this event is a high-resolution version of"]
            #[doc = "the timestamp argument of the associated input event. The provided"]
            #[doc = "timestamp is in the same clock domain and is at least as accurate as"]
            #[doc = "the associated input event timestamp."]
            #[doc = ""]
            #[doc = "The timestamp is expressed as tv_sec_hi, tv_sec_lo, tv_nsec triples,"]
            #[doc = "each component being an unsigned 32-bit value. Whole seconds are in"]
            #[doc = "tv_sec which is a 64-bit value combined from tv_sec_hi and tv_sec_lo,"]
            #[doc = "and the additional fractional part in tv_nsec as nanoseconds. Hence,"]
            #[doc = "for valid timestamps tv_nsec must be in [0, 999999999]."]
            async fn timestamp(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
#[doc = "This protocol specifies a way for a client to request the compositor"]
#[doc = "to ignore its own keyboard shortcuts for a given seat, so that all"]
#[doc = "key events from that seat get forwarded to a surface."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and"]
#[doc = "backward incompatible changes may be made. Backward compatible"]
#[doc = "changes may be added together with the corresponding interface"]
#[doc = "version bump."]
#[doc = "Backward incompatible changes are done by bumping the version"]
#[doc = "number in the protocol and interface names and resetting the"]
#[doc = "interface version. Once the protocol is to be declared stable,"]
#[doc = "the 'z' prefix and the version number in the protocol and"]
#[doc = "interface names are removed and the interface version number is"]
#[doc = "reset."]
pub mod keyboard_shortcuts_inhibit_unstable_v1 {
    pub mod zwp_keyboard_shortcuts_inhibit_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            AlreadyInhibited = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "A global interface used for inhibiting the compositor keyboard shortcuts."]
        pub trait ZwpKeyboardShortcutsInhibitManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_keyboard_shortcuts_inhibit_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwp_keyboard_shortcuts_inhibit_manager_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwp_keyboard_shortcuts_inhibit_manager_v1#{}.inhibit_shortcuts()",
                            object.id
                        );
                        self.inhibit_shortcuts(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the keyboard shortcuts inhibitor manager."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a new keyboard shortcuts inhibitor object associated with"]
            #[doc = "the given surface for the given seat."]
            #[doc = ""]
            #[doc = "If shortcuts are already inhibited for the specified seat and surface,"]
            #[doc = "a protocol error \"already_inhibited\" is raised by the compositor."]
            async fn inhibit_shortcuts(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_keyboard_shortcuts_inhibitor_v1 {
        #[doc = "A keyboard shortcuts inhibitor instructs the compositor to ignore"]
        #[doc = "its own keyboard shortcuts when the associated surface has keyboard"]
        #[doc = "focus. As a result, when the surface has keyboard focus on the given"]
        #[doc = "seat, it will receive all key events originating from the specified"]
        #[doc = "seat, even those which would normally be caught by the compositor for"]
        #[doc = "its own shortcuts."]
        #[doc = ""]
        #[doc = "The Wayland compositor is however under no obligation to disable"]
        #[doc = "all of its shortcuts, and may keep some special key combo for its own"]
        #[doc = "use, including but not limited to one allowing the user to forcibly"]
        #[doc = "restore normal keyboard events routing in the case of an unwilling"]
        #[doc = "client. The compositor may also use the same key combo to reactivate"]
        #[doc = "an existing shortcut inhibitor that was previously deactivated on"]
        #[doc = "user request."]
        #[doc = ""]
        #[doc = "When the compositor restores its own keyboard shortcuts, an"]
        #[doc = "\"inactive\" event is emitted to notify the client that the keyboard"]
        #[doc = "shortcuts inhibitor is not effectively active for the surface and"]
        #[doc = "seat any more, and the client should not expect to receive all"]
        #[doc = "keyboard events."]
        #[doc = ""]
        #[doc = "When the keyboard shortcuts inhibitor is inactive, the client has"]
        #[doc = "no way to forcibly reactivate the keyboard shortcuts inhibitor."]
        #[doc = ""]
        #[doc = "The user can chose to re-enable a previously deactivated keyboard"]
        #[doc = "shortcuts inhibitor using any mechanism the compositor may offer,"]
        #[doc = "in which case the compositor will send an \"active\" event to notify"]
        #[doc = "the client."]
        #[doc = ""]
        #[doc = "If the surface is destroyed, unmapped, or loses the seat's keyboard"]
        #[doc = "focus, the keyboard shortcuts inhibitor becomes irrelevant and the"]
        #[doc = "compositor will restore its own keyboard shortcuts but no \"inactive\""]
        #[doc = "event is emitted in this case."]
        pub trait ZwpKeyboardShortcutsInhibitorV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_keyboard_shortcuts_inhibitor_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwp_keyboard_shortcuts_inhibitor_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Remove the keyboard shortcuts inhibitor from the associated wl_surface."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event indicates that the shortcut inhibitor is active."]
            #[doc = ""]
            #[doc = "The compositor sends this event every time compositor shortcuts"]
            #[doc = "are inhibited on behalf of the surface. When active, the client"]
            #[doc = "may receive input events normally reserved by the compositor"]
            #[doc = "(see zwp_keyboard_shortcuts_inhibitor_v1)."]
            #[doc = ""]
            #[doc = "This occurs typically when the initial request \"inhibit_shortcuts\""]
            #[doc = "first becomes active or when the user instructs the compositor to"]
            #[doc = "re-enable and existing shortcuts inhibitor using any mechanism"]
            #[doc = "offered by the compositor."]
            async fn active(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event indicates that the shortcuts inhibitor is inactive,"]
            #[doc = "normal shortcuts processing is restored by the compositor."]
            async fn inactive(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
pub mod linux_dmabuf_unstable_v1 {
    pub mod zwp_linux_dmabuf_v1 {
        #[doc = "Following the interfaces from:"]
        #[doc = "https://www.khronos.org/registry/egl/extensions/EXT/EGL_EXT_image_dma_buf_import.txt"]
        #[doc = "https://www.khronos.org/registry/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import_modifiers.txt"]
        #[doc = "and the Linux DRM sub-system's AddFb2 ioctl."]
        #[doc = ""]
        #[doc = "This interface offers ways to create generic dmabuf-based wl_buffers."]
        #[doc = ""]
        #[doc = "Clients can use the get_surface_feedback request to get dmabuf feedback"]
        #[doc = "for a particular surface. If the client wants to retrieve feedback not"]
        #[doc = "tied to a surface, they can use the get_default_feedback request."]
        #[doc = ""]
        #[doc = "The following are required from clients:"]
        #[doc = ""]
        #[doc = "- Clients must ensure that either all data in the dma-buf is"]
        #[doc = "coherent for all subsequent read access or that coherency is"]
        #[doc = "correctly handled by the underlying kernel-side dma-buf"]
        #[doc = "implementation."]
        #[doc = ""]
        #[doc = "- Don't make any more attachments after sending the buffer to the"]
        #[doc = "compositor. Making more attachments later increases the risk of"]
        #[doc = "the compositor not being able to use (re-import) an existing"]
        #[doc = "dmabuf-based wl_buffer."]
        #[doc = ""]
        #[doc = "The underlying graphics stack must ensure the following:"]
        #[doc = ""]
        #[doc = "- The dmabuf file descriptors relayed to the server will stay valid"]
        #[doc = "for the whole lifetime of the wl_buffer. This means the server may"]
        #[doc = "at any time use those fds to import the dmabuf into any kernel"]
        #[doc = "sub-system that might accept it."]
        #[doc = ""]
        #[doc = "However, when the underlying graphics stack fails to deliver the"]
        #[doc = "promise, because of e.g. a device hot-unplug which raises internal"]
        #[doc = "errors, after the wl_buffer has been successfully created the"]
        #[doc = "compositor must not raise protocol errors to the client when dmabuf"]
        #[doc = "import later fails."]
        #[doc = ""]
        #[doc = "To create a wl_buffer from one or more dmabufs, a client creates a"]
        #[doc = "zwp_linux_dmabuf_params_v1 object with a zwp_linux_dmabuf_v1.create_params"]
        #[doc = "request. All planes required by the intended format are added with"]
        #[doc = "the 'add' request. Finally, a 'create' or 'create_immed' request is"]
        #[doc = "issued, which has the following outcome depending on the import success."]
        #[doc = ""]
        #[doc = "The 'create' request,"]
        #[doc = "- on success, triggers a 'created' event which provides the final"]
        #[doc = "wl_buffer to the client."]
        #[doc = "- on failure, triggers a 'failed' event to convey that the server"]
        #[doc = "cannot use the dmabufs received from the client."]
        #[doc = ""]
        #[doc = "For the 'create_immed' request,"]
        #[doc = "- on success, the server immediately imports the added dmabufs to"]
        #[doc = "create a wl_buffer. No event is sent from the server in this case."]
        #[doc = "- on failure, the server can choose to either:"]
        #[doc = "- terminate the client by raising a fatal error."]
        #[doc = "- mark the wl_buffer as failed, and send a 'failed' event to the"]
        #[doc = "client. If the client uses a failed wl_buffer as an argument to any"]
        #[doc = "request, the behaviour is compositor implementation-defined."]
        #[doc = ""]
        #[doc = "For all DRM formats and unless specified in another protocol extension,"]
        #[doc = "pre-multiplied alpha is used for pixel values."]
        #[doc = ""]
        #[doc = "Unless specified otherwise in another protocol extension, implicit"]
        #[doc = "synchronization is used. In other words, compositors and clients must"]
        #[doc = "wait and signal fences implicitly passed via the DMA-BUF's reservation"]
        #[doc = "mechanism."]
        #[doc = ""]
        #[doc = "Disclaimer: This protocol extension has been marked stable. This copy is"]
        #[doc = "no longer used and only retained for backwards compatibility. The"]
        #[doc = "canonical version can be found in the stable/ directory."]
        pub trait ZwpLinuxDmabufV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_dmabuf_v1";
            const VERSION: u32 = 5u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.create_params()", object.id);
                        self.create_params(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.get_default_feedback()", object.id);
                        self.get_default_feedback(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.get_surface_feedback()", object.id);
                        self.get_surface_feedback(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Objects created through this interface, especially wl_buffers, will"]
            #[doc = "remain valid."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This temporary object is used to collect multiple dmabuf handles into"]
            #[doc = "a single batch to create a wl_buffer. It can only be used once and"]
            #[doc = "should be destroyed after a 'created' or 'failed' event has been"]
            #[doc = "received."]
            async fn create_params(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                params_id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This request creates a new wp_linux_dmabuf_feedback object not bound"]
            #[doc = "to a particular surface. This object will deliver feedback about dmabuf"]
            #[doc = "parameters to use if the client doesn't support per-surface feedback"]
            #[doc = "(see get_surface_feedback)."]
            async fn get_default_feedback(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This request creates a new wp_linux_dmabuf_feedback object for the"]
            #[doc = "specified wl_surface. This object will deliver feedback about dmabuf"]
            #[doc = "parameters to use for buffers attached to this surface."]
            #[doc = ""]
            #[doc = "If the surface is destroyed before the wp_linux_dmabuf_feedback object,"]
            #[doc = "the feedback object becomes inert."]
            async fn get_surface_feedback(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This event advertises one buffer format that the server supports."]
            #[doc = "All the supported formats are advertised once when the client"]
            #[doc = "binds to this interface. A roundtrip after binding guarantees"]
            #[doc = "that the client has received all supported formats."]
            #[doc = ""]
            #[doc = "For the definition of the format codes, see the"]
            #[doc = "zwp_linux_buffer_params_v1::create request."]
            #[doc = ""]
            #[doc = "Starting version 4, the format event is deprecated and must not be"]
            #[doc = "sent by compositors. Instead, use get_default_feedback or"]
            #[doc = "get_surface_feedback."]
            async fn format(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event advertises the formats that the server supports, along with"]
            #[doc = "the modifiers supported for each format. All the supported modifiers"]
            #[doc = "for all the supported formats are advertised once when the client"]
            #[doc = "binds to this interface. A roundtrip after binding guarantees that"]
            #[doc = "the client has received all supported format-modifier pairs."]
            #[doc = ""]
            #[doc = "For legacy support, DRM_FORMAT_MOD_INVALID (that is, modifier_hi =="]
            #[doc = "0x00ffffff and modifier_lo == 0xffffffff) is allowed in this event."]
            #[doc = "It indicates that the server can support the format with an implicit"]
            #[doc = "modifier. When a plane has DRM_FORMAT_MOD_INVALID as its modifier, it"]
            #[doc = "is as if no explicit modifier is specified. The effective modifier"]
            #[doc = "will be derived from the dmabuf."]
            #[doc = ""]
            #[doc = "A compositor that sends valid modifiers and DRM_FORMAT_MOD_INVALID for"]
            #[doc = "a given format supports both explicit modifiers and implicit modifiers."]
            #[doc = ""]
            #[doc = "For the definition of the format and modifier codes, see the"]
            #[doc = "zwp_linux_buffer_params_v1::create and zwp_linux_buffer_params_v1::add"]
            #[doc = "requests."]
            #[doc = ""]
            #[doc = "Starting version 4, the modifier event is deprecated and must not be"]
            #[doc = "sent by compositors. Instead, use get_default_feedback or"]
            #[doc = "get_surface_feedback."]
            async fn modifier(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_linux_buffer_params_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            AlreadyUsed = 0u32,
            PlaneIdx = 1u32,
            PlaneSet = 2u32,
            Incomplete = 3u32,
            InvalidFormat = 4u32,
            InvalidDimensions = 5u32,
            OutOfBounds = 6u32,
            InvalidWlBuffer = 7u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! { # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Flags : u32 { # [doc = "contents are y-inverted"] const YInvert = 1u32 ; # [doc = "content is interlaced"] const Interlaced = 2u32 ; # [doc = "bottom field first"] const BottomFirst = 4u32 ; } }
        impl TryFrom<u32> for Flags {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "This temporary object is a collection of dmabufs and other"]
        #[doc = "parameters that together form a single logical buffer. The temporary"]
        #[doc = "object may eventually create one wl_buffer unless cancelled by"]
        #[doc = "destroying it before requesting 'create'."]
        #[doc = ""]
        #[doc = "Single-planar formats only require one dmabuf, however"]
        #[doc = "multi-planar formats may require more than one dmabuf. For all"]
        #[doc = "formats, an 'add' request must be called once per plane (even if the"]
        #[doc = "underlying dmabuf fd is identical)."]
        #[doc = ""]
        #[doc = "You must use consecutive plane indices ('plane_idx' argument for 'add')"]
        #[doc = "from zero to the number of planes used by the drm_fourcc format code."]
        #[doc = "All planes required by the format must be given exactly once, but can"]
        #[doc = "be given in any order. Each plane index can be set only once."]
        pub trait ZwpLinuxBufferParamsV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_buffer_params_v1";
            const VERSION: u32 = 5u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.add()", object.id);
                        self.add(
                            object,
                            client,
                            message.fd()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.create()", object.id);
                        self.create(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.uint()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.create_immed()", object.id);
                        self.create_immed(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.uint()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Cleans up the temporary data sent to the server for dmabuf-based"]
            #[doc = "wl_buffer creation."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This request adds one dmabuf to the set in this"]
            #[doc = "zwp_linux_buffer_params_v1."]
            #[doc = ""]
            #[doc = "The 64-bit unsigned value combined from modifier_hi and modifier_lo"]
            #[doc = "is the dmabuf layout modifier. DRM AddFB2 ioctl calls this the"]
            #[doc = "fb modifier, which is defined in drm_mode.h of Linux UAPI."]
            #[doc = "This is an opaque token. Drivers use this token to express tiling,"]
            #[doc = "compression, etc. driver-specific modifications to the base format"]
            #[doc = "defined by the DRM fourcc code."]
            #[doc = ""]
            #[doc = "Starting from version 4, the invalid_format protocol error is sent if"]
            #[doc = "the format + modifier pair was not advertised as supported."]
            #[doc = ""]
            #[doc = "Starting from version 5, the invalid_format protocol error is sent if"]
            #[doc = "all planes don't use the same modifier."]
            #[doc = ""]
            #[doc = "This request raises the PLANE_IDX error if plane_idx is too large."]
            #[doc = "The error PLANE_SET is raised if attempting to set a plane that"]
            #[doc = "was already set."]
            async fn add(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                fd: rustix::fd::OwnedFd,
                plane_idx: u32,
                offset: u32,
                stride: u32,
                modifier_hi: u32,
                modifier_lo: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This asks for creation of a wl_buffer from the added dmabuf"]
            #[doc = "buffers. The wl_buffer is not created immediately but returned via"]
            #[doc = "the 'created' event if the dmabuf sharing succeeds. The sharing"]
            #[doc = "may fail at runtime for reasons a client cannot predict, in"]
            #[doc = "which case the 'failed' event is triggered."]
            #[doc = ""]
            #[doc = "The 'format' argument is a DRM_FORMAT code, as defined by the"]
            #[doc = "libdrm's drm_fourcc.h. The Linux kernel's DRM sub-system is the"]
            #[doc = "authoritative source on how the format codes should work."]
            #[doc = ""]
            #[doc = "The 'flags' is a bitfield of the flags defined in enum \"flags\"."]
            #[doc = "'y_invert' means the that the image needs to be y-flipped."]
            #[doc = ""]
            #[doc = "Flag 'interlaced' means that the frame in the buffer is not"]
            #[doc = "progressive as usual, but interlaced. An interlaced buffer as"]
            #[doc = "supported here must always contain both top and bottom fields."]
            #[doc = "The top field always begins on the first pixel row. The temporal"]
            #[doc = "ordering between the two fields is top field first, unless"]
            #[doc = "'bottom_first' is specified. It is undefined whether 'bottom_first'"]
            #[doc = "is ignored if 'interlaced' is not set."]
            #[doc = ""]
            #[doc = "This protocol does not convey any information about field rate,"]
            #[doc = "duration, or timing, other than the relative ordering between the"]
            #[doc = "two fields in one buffer. A compositor may have to estimate the"]
            #[doc = "intended field rate from the incoming buffer rate. It is undefined"]
            #[doc = "whether the time of receiving wl_surface.commit with a new buffer"]
            #[doc = "attached, applying the wl_surface state, wl_surface.frame callback"]
            #[doc = "trigger, presentation, or any other point in the compositor cycle"]
            #[doc = "is used to measure the frame or field times. There is no support"]
            #[doc = "for detecting missed or late frames/fields/buffers either, and"]
            #[doc = "there is no support whatsoever for cooperating with interlaced"]
            #[doc = "compositor output."]
            #[doc = ""]
            #[doc = "The composited image quality resulting from the use of interlaced"]
            #[doc = "buffers is explicitly undefined. A compositor may use elaborate"]
            #[doc = "hardware features or software to deinterlace and create progressive"]
            #[doc = "output frames from a sequence of interlaced input buffers, or it"]
            #[doc = "may produce substandard image quality. However, compositors that"]
            #[doc = "cannot guarantee reasonable image quality in all cases are recommended"]
            #[doc = "to just reject all interlaced buffers."]
            #[doc = ""]
            #[doc = "Any argument errors, including non-positive width or height,"]
            #[doc = "mismatch between the number of planes and the format, bad"]
            #[doc = "format, bad offset or stride, may be indicated by fatal protocol"]
            #[doc = "errors: INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS,"]
            #[doc = "OUT_OF_BOUNDS."]
            #[doc = ""]
            #[doc = "Dmabuf import errors in the server that are not obvious client"]
            #[doc = "bugs are returned via the 'failed' event as non-fatal. This"]
            #[doc = "allows attempting dmabuf sharing and falling back in the client"]
            #[doc = "if it fails."]
            #[doc = ""]
            #[doc = "This request can be sent only once in the object's lifetime, after"]
            #[doc = "which the only legal request is destroy. This object should be"]
            #[doc = "destroyed after issuing a 'create' request. Attempting to use this"]
            #[doc = "object after issuing 'create' raises ALREADY_USED protocol error."]
            #[doc = ""]
            #[doc = "It is not mandatory to issue 'create'. If a client wants to"]
            #[doc = "cancel the buffer creation, it can just destroy this object."]
            async fn create(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
                format: u32,
                flags: Flags,
            ) -> crate::server::Result<()>;
            #[doc = "This asks for immediate creation of a wl_buffer by importing the"]
            #[doc = "added dmabufs."]
            #[doc = ""]
            #[doc = "In case of import success, no event is sent from the server, and the"]
            #[doc = "wl_buffer is ready to be used by the client."]
            #[doc = ""]
            #[doc = "Upon import failure, either of the following may happen, as seen fit"]
            #[doc = "by the implementation:"]
            #[doc = "- the client is terminated with one of the following fatal protocol"]
            #[doc = "errors:"]
            #[doc = "- INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS, OUT_OF_BOUNDS,"]
            #[doc = "in case of argument errors such as mismatch between the number"]
            #[doc = "of planes and the format, bad format, non-positive width or"]
            #[doc = "height, or bad offset or stride."]
            #[doc = "- INVALID_WL_BUFFER, in case the cause for failure is unknown or"]
            #[doc = "plaform specific."]
            #[doc = "- the server creates an invalid wl_buffer, marks it as failed and"]
            #[doc = "sends a 'failed' event to the client. The result of using this"]
            #[doc = "invalid wl_buffer as an argument in any request by the client is"]
            #[doc = "defined by the compositor implementation."]
            #[doc = ""]
            #[doc = "This takes the same arguments as a 'create' request, and obeys the"]
            #[doc = "same restrictions."]
            async fn create_immed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer_id: crate::wire::ObjectId,
                width: i32,
                height: i32,
                format: u32,
                flags: Flags,
            ) -> crate::server::Result<()>;
            #[doc = "This event indicates that the attempted buffer creation was"]
            #[doc = "successful. It provides the new wl_buffer referencing the dmabuf(s)."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy the"]
            #[doc = "zwp_linux_buffer_params_v1 object."]
            async fn created(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event indicates that the attempted buffer creation has"]
            #[doc = "failed. It usually means that one of the dmabuf constraints"]
            #[doc = "has not been fulfilled."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy the"]
            #[doc = "zwp_linux_buffer_params_v1 object."]
            async fn failed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_linux_dmabuf_feedback_v1 {
        bitflags::bitflags! { # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct TrancheFlags : u32 { # [doc = "direct scan-out tranche"] const Scanout = 1u32 ; } }
        impl TryFrom<u32> for TrancheFlags {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "This object advertises dmabuf parameters feedback. This includes the"]
        #[doc = "preferred devices and the supported formats/modifiers."]
        #[doc = ""]
        #[doc = "The parameters are sent once when this object is created and whenever they"]
        #[doc = "change. The done event is always sent once after all parameters have been"]
        #[doc = "sent. When a single parameter changes, all parameters are re-sent by the"]
        #[doc = "compositor."]
        #[doc = ""]
        #[doc = "Compositors can re-send the parameters when the current client buffer"]
        #[doc = "allocations are sub-optimal. Compositors should not re-send the"]
        #[doc = "parameters if re-allocating the buffers would not result in a more optimal"]
        #[doc = "configuration. In particular, compositors should avoid sending the exact"]
        #[doc = "same parameters multiple times in a row."]
        #[doc = ""]
        #[doc = "The tranche_target_device and tranche_formats events are grouped by"]
        #[doc = "tranches of preference. For each tranche, a tranche_target_device, one"]
        #[doc = "tranche_flags and one or more tranche_formats events are sent, followed"]
        #[doc = "by a tranche_done event finishing the list. The tranches are sent in"]
        #[doc = "descending order of preference. All formats and modifiers in the same"]
        #[doc = "tranche have the same preference."]
        #[doc = ""]
        #[doc = "To send parameters, the compositor sends one main_device event, tranches"]
        #[doc = "(each consisting of one tranche_target_device event, one tranche_flags"]
        #[doc = "event, tranche_formats events and then a tranche_done event), then one"]
        #[doc = "done event."]
        pub trait ZwpLinuxDmabufFeedbackV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_dmabuf_feedback_v1";
            const VERSION: u32 = 5u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_linux_dmabuf_feedback_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Using this request a client can tell the server that it is not going to"]
            #[doc = "use the wp_linux_dmabuf_feedback object anymore."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent after all parameters of a wp_linux_dmabuf_feedback"]
            #[doc = "object have been sent."]
            #[doc = ""]
            #[doc = "This allows changes to the wp_linux_dmabuf_feedback parameters to be"]
            #[doc = "seen as atomic, even if they happen via multiple events."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event provides a file descriptor which can be memory-mapped to"]
            #[doc = "access the format and modifier table."]
            #[doc = ""]
            #[doc = "The table contains a tightly packed array of consecutive format +"]
            #[doc = "modifier pairs. Each pair is 16 bytes wide. It contains a format as a"]
            #[doc = "32-bit unsigned integer, followed by 4 bytes of unused padding, and a"]
            #[doc = "modifier as a 64-bit unsigned integer. The native endianness is used."]
            #[doc = ""]
            #[doc = "The client must map the file descriptor in read-only private mode."]
            #[doc = ""]
            #[doc = "Compositors are not allowed to mutate the table file contents once this"]
            #[doc = "event has been sent. Instead, compositors must create a new, separate"]
            #[doc = "table file and re-send feedback parameters. Compositors are allowed to"]
            #[doc = "store duplicate format + modifier pairs in the table."]
            async fn format_table(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event advertises the main device that the server prefers to use"]
            #[doc = "when direct scan-out to the target device isn't possible. The"]
            #[doc = "advertised main device may be different for each"]
            #[doc = "wp_linux_dmabuf_feedback object, and may change over time."]
            #[doc = ""]
            #[doc = "There is exactly one main device. The compositor must send at least"]
            #[doc = "one preference tranche with tranche_target_device equal to main_device."]
            #[doc = ""]
            #[doc = "Clients need to create buffers that the main device can import and"]
            #[doc = "read from, otherwise creating the dmabuf wl_buffer will fail (see the"]
            #[doc = "wp_linux_buffer_params.create and create_immed requests for details)."]
            #[doc = "The main device will also likely be kept active by the compositor,"]
            #[doc = "so clients can use it instead of waking up another device for power"]
            #[doc = "savings."]
            #[doc = ""]
            #[doc = "In general the device is a DRM node. The DRM node type (primary vs."]
            #[doc = "render) is unspecified. Clients must not rely on the compositor sending"]
            #[doc = "a particular node type. Clients cannot check two devices for equality"]
            #[doc = "by comparing the dev_t value."]
            #[doc = ""]
            #[doc = "If explicit modifiers are not supported and the client performs buffer"]
            #[doc = "allocations on a different device than the main device, then the client"]
            #[doc = "must force the buffer to have a linear layout."]
            async fn main_device(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event splits tranche_target_device and tranche_formats events in"]
            #[doc = "preference tranches. It is sent after a set of tranche_target_device"]
            #[doc = "and tranche_formats events; it represents the end of a tranche. The"]
            #[doc = "next tranche will have a lower preference."]
            async fn tranche_done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event advertises the target device that the server prefers to use"]
            #[doc = "for a buffer created given this tranche. The advertised target device"]
            #[doc = "may be different for each preference tranche, and may change over time."]
            #[doc = ""]
            #[doc = "There is exactly one target device per tranche."]
            #[doc = ""]
            #[doc = "The target device may be a scan-out device, for example if the"]
            #[doc = "compositor prefers to directly scan-out a buffer created given this"]
            #[doc = "tranche. The target device may be a rendering device, for example if"]
            #[doc = "the compositor prefers to texture from said buffer."]
            #[doc = ""]
            #[doc = "The client can use this hint to allocate the buffer in a way that makes"]
            #[doc = "it accessible from the target device, ideally directly. The buffer must"]
            #[doc = "still be accessible from the main device, either through direct import"]
            #[doc = "or through a potentially more expensive fallback path. If the buffer"]
            #[doc = "can't be directly imported from the main device then clients must be"]
            #[doc = "prepared for the compositor changing the tranche priority or making"]
            #[doc = "wl_buffer creation fail (see the wp_linux_buffer_params.create and"]
            #[doc = "create_immed requests for details)."]
            #[doc = ""]
            #[doc = "If the device is a DRM node, the DRM node type (primary vs. render) is"]
            #[doc = "unspecified. Clients must not rely on the compositor sending a"]
            #[doc = "particular node type. Clients cannot check two devices for equality by"]
            #[doc = "comparing the dev_t value."]
            #[doc = ""]
            #[doc = "This event is tied to a preference tranche, see the tranche_done event."]
            async fn tranche_target_device(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event advertises the format + modifier combinations that the"]
            #[doc = "compositor supports."]
            #[doc = ""]
            #[doc = "It carries an array of indices, each referring to a format + modifier"]
            #[doc = "pair in the last received format table (see the format_table event)."]
            #[doc = "Each index is a 16-bit unsigned integer in native endianness."]
            #[doc = ""]
            #[doc = "For legacy support, DRM_FORMAT_MOD_INVALID is an allowed modifier."]
            #[doc = "It indicates that the server can support the format with an implicit"]
            #[doc = "modifier. When a buffer has DRM_FORMAT_MOD_INVALID as its modifier, it"]
            #[doc = "is as if no explicit modifier is specified. The effective modifier"]
            #[doc = "will be derived from the dmabuf."]
            #[doc = ""]
            #[doc = "A compositor that sends valid modifiers and DRM_FORMAT_MOD_INVALID for"]
            #[doc = "a given format supports both explicit modifiers and implicit modifiers."]
            #[doc = ""]
            #[doc = "Compositors must not send duplicate format + modifier pairs within the"]
            #[doc = "same tranche or across two different tranches with the same target"]
            #[doc = "device and flags."]
            #[doc = ""]
            #[doc = "This event is tied to a preference tranche, see the tranche_done event."]
            #[doc = ""]
            #[doc = "For the definition of the format and modifier codes, see the"]
            #[doc = "wp_linux_buffer_params.create request."]
            async fn tranche_formats(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event sets tranche-specific flags."]
            #[doc = ""]
            #[doc = "The scanout flag is a hint that direct scan-out may be attempted by the"]
            #[doc = "compositor on the target device if the client appropriately allocates a"]
            #[doc = "buffer. How to allocate a buffer that can be scanned out on the target"]
            #[doc = "device is implementation-defined."]
            #[doc = ""]
            #[doc = "This event is tied to a preference tranche, see the tranche_done event."]
            async fn tranche_flags(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
pub mod zwp_linux_explicit_synchronization_unstable_v1 {
    pub mod zwp_linux_explicit_synchronization_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            SynchronizationExists = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This global is a factory interface, allowing clients to request"]
        #[doc = "explicit synchronization for buffers on a per-surface basis."]
        #[doc = ""]
        #[doc = "See zwp_linux_surface_synchronization_v1 for more information."]
        #[doc = ""]
        #[doc = "This interface is derived from Chromium's"]
        #[doc = "zcr_linux_explicit_synchronization_v1."]
        #[doc = ""]
        #[doc = "Note: this protocol is superseded by linux-drm-syncobj."]
        #[doc = ""]
        #[doc = "Warning! The protocol described in this file is experimental and"]
        #[doc = "backward incompatible changes may be made. Backward compatible changes"]
        #[doc = "may be added together with the corresponding interface version bump."]
        #[doc = "Backward incompatible changes are done by bumping the version number in"]
        #[doc = "the protocol and interface names and resetting the interface version."]
        #[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
        #[doc = "version number in the protocol and interface names are removed and the"]
        #[doc = "interface version number is reset."]
        pub trait ZwpLinuxExplicitSynchronizationV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_explicit_synchronization_v1";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwp_linux_explicit_synchronization_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwp_linux_explicit_synchronization_v1#{}.get_synchronization()",
                            object.id
                        );
                        self.get_synchronization(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy this explicit synchronization factory object. Other objects,"]
            #[doc = "including zwp_linux_surface_synchronization_v1 objects created by this"]
            #[doc = "factory, shall not be affected by this request."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Instantiate an interface extension for the given wl_surface to provide"]
            #[doc = "explicit synchronization."]
            #[doc = ""]
            #[doc = "If the given wl_surface already has an explicit synchronization object"]
            #[doc = "associated, the synchronization_exists protocol error is raised."]
            #[doc = ""]
            #[doc = "Graphics APIs, like EGL or Vulkan, that manage the buffer queue and"]
            #[doc = "commits of a wl_surface themselves, are likely to be using this"]
            #[doc = "extension internally. If a client is using such an API for a"]
            #[doc = "wl_surface, it should not directly use this extension on that surface,"]
            #[doc = "to avoid raising a synchronization_exists protocol error."]
            async fn get_synchronization(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_linux_surface_synchronization_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidFence = 0u32,
            DuplicateFence = 1u32,
            DuplicateRelease = 2u32,
            NoSurface = 3u32,
            UnsupportedBuffer = 4u32,
            NoBuffer = 5u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This object implements per-surface explicit synchronization."]
        #[doc = ""]
        #[doc = "Synchronization refers to co-ordination of pipelined operations performed"]
        #[doc = "on buffers. Most GPU clients will schedule an asynchronous operation to"]
        #[doc = "render to the buffer, then immediately send the buffer to the compositor"]
        #[doc = "to be attached to a surface."]
        #[doc = ""]
        #[doc = "In implicit synchronization, ensuring that the rendering operation is"]
        #[doc = "complete before the compositor displays the buffer is an implementation"]
        #[doc = "detail handled by either the kernel or userspace graphics driver."]
        #[doc = ""]
        #[doc = "By contrast, in explicit synchronization, dma_fence objects mark when the"]
        #[doc = "asynchronous operations are complete. When submitting a buffer, the"]
        #[doc = "client provides an acquire fence which will be waited on before the"]
        #[doc = "compositor accesses the buffer. The Wayland server, through a"]
        #[doc = "zwp_linux_buffer_release_v1 object, will inform the client with an event"]
        #[doc = "which may be accompanied by a release fence, when the compositor will no"]
        #[doc = "longer access the buffer contents due to the specific commit that"]
        #[doc = "requested the release event."]
        #[doc = ""]
        #[doc = "Each surface can be associated with only one object of this interface at"]
        #[doc = "any time."]
        #[doc = ""]
        #[doc = "In version 1 of this interface, explicit synchronization is only"]
        #[doc = "guaranteed to be supported for buffers created with any version of the"]
        #[doc = "wp_linux_dmabuf buffer factory. Version 2 additionally guarantees"]
        #[doc = "explicit synchronization support for opaque EGL buffers, which is a type"]
        #[doc = "of platform specific buffers described in the EGL_WL_bind_wayland_display"]
        #[doc = "extension. Compositors are free to support explicit synchronization for"]
        #[doc = "additional buffer types."]
        pub trait ZwpLinuxSurfaceSynchronizationV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_surface_synchronization_v1";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwp_linux_surface_synchronization_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwp_linux_surface_synchronization_v1#{}.set_acquire_fence()",
                            object.id
                        );
                        self.set_acquire_fence(object, client, message.fd()?).await
                    }
                    2u16 => {
                        tracing::debug!(
                            "zwp_linux_surface_synchronization_v1#{}.get_release()",
                            object.id
                        );
                        self.get_release(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy this explicit synchronization object."]
            #[doc = ""]
            #[doc = "Any fence set by this object with set_acquire_fence since the last"]
            #[doc = "commit will be discarded by the server. Any fences set by this object"]
            #[doc = "before the last commit are not affected."]
            #[doc = ""]
            #[doc = "zwp_linux_buffer_release_v1 objects created by this object are not"]
            #[doc = "affected by this request."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the acquire fence that must be signaled before the compositor"]
            #[doc = "may sample from the buffer attached with wl_surface.attach. The fence"]
            #[doc = "is a dma_fence kernel object."]
            #[doc = ""]
            #[doc = "The acquire fence is double-buffered state, and will be applied on the"]
            #[doc = "next wl_surface.commit request for the associated surface. Thus, it"]
            #[doc = "applies only to the buffer that is attached to the surface at commit"]
            #[doc = "time."]
            #[doc = ""]
            #[doc = "If the provided fd is not a valid dma_fence fd, then an INVALID_FENCE"]
            #[doc = "error is raised."]
            #[doc = ""]
            #[doc = "If a fence has already been attached during the same commit cycle, a"]
            #[doc = "DUPLICATE_FENCE error is raised."]
            #[doc = ""]
            #[doc = "If the associated wl_surface was destroyed, a NO_SURFACE error is"]
            #[doc = "raised."]
            #[doc = ""]
            #[doc = "If at surface commit time the attached buffer does not support explicit"]
            #[doc = "synchronization, an UNSUPPORTED_BUFFER error is raised."]
            #[doc = ""]
            #[doc = "If at surface commit time there is no buffer attached, a NO_BUFFER"]
            #[doc = "error is raised."]
            async fn set_acquire_fence(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()>;
            #[doc = "Create a listener for the release of the buffer attached by the"]
            #[doc = "client with wl_surface.attach. See zwp_linux_buffer_release_v1"]
            #[doc = "documentation for more information."]
            #[doc = ""]
            #[doc = "The release object is double-buffered state, and will be associated"]
            #[doc = "with the buffer that is attached to the surface at wl_surface.commit"]
            #[doc = "time."]
            #[doc = ""]
            #[doc = "If a zwp_linux_buffer_release_v1 object has already been requested for"]
            #[doc = "the surface in the same commit cycle, a DUPLICATE_RELEASE error is"]
            #[doc = "raised."]
            #[doc = ""]
            #[doc = "If the associated wl_surface was destroyed, a NO_SURFACE error"]
            #[doc = "is raised."]
            #[doc = ""]
            #[doc = "If at surface commit time there is no buffer attached, a NO_BUFFER"]
            #[doc = "error is raised."]
            async fn get_release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                release: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_linux_buffer_release_v1 {
        #[doc = "This object is instantiated in response to a"]
        #[doc = "zwp_linux_surface_synchronization_v1.get_release request."]
        #[doc = ""]
        #[doc = "It provides an alternative to wl_buffer.release events, providing a"]
        #[doc = "unique release from a single wl_surface.commit request. The release event"]
        #[doc = "also supports explicit synchronization, providing a fence FD for the"]
        #[doc = "client to synchronize against."]
        #[doc = ""]
        #[doc = "Exactly one event, either a fenced_release or an immediate_release, will"]
        #[doc = "be emitted for the wl_surface.commit request. The compositor can choose"]
        #[doc = "release by release which event it uses."]
        #[doc = ""]
        #[doc = "This event does not replace wl_buffer.release events; servers are still"]
        #[doc = "required to send those events."]
        #[doc = ""]
        #[doc = "Once a buffer release object has delivered a 'fenced_release' or an"]
        #[doc = "'immediate_release' event it is automatically destroyed."]
        pub trait ZwpLinuxBufferReleaseV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_buffer_release_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Sent when the compositor has finalised its usage of the associated"]
            #[doc = "buffer for the relevant commit, providing a dma_fence which will be"]
            #[doc = "signaled when all operations by the compositor on that buffer for that"]
            #[doc = "commit have finished."]
            #[doc = ""]
            #[doc = "Once the fence has signaled, and assuming the associated buffer is not"]
            #[doc = "pending release from other wl_surface.commit requests, no additional"]
            #[doc = "explicit or implicit synchronization is required to safely reuse or"]
            #[doc = "destroy the buffer."]
            #[doc = ""]
            #[doc = "This event destroys the zwp_linux_buffer_release_v1 object."]
            async fn fenced_release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent when the compositor has finalised its usage of the associated"]
            #[doc = "buffer for the relevant commit, and either performed no operations"]
            #[doc = "using it, or has a guarantee that all its operations on that buffer for"]
            #[doc = "that commit have finished."]
            #[doc = ""]
            #[doc = "Once this event is received, and assuming the associated buffer is not"]
            #[doc = "pending release from other wl_surface.commit requests, no additional"]
            #[doc = "explicit or implicit synchronization is required to safely reuse or"]
            #[doc = "destroy the buffer."]
            #[doc = ""]
            #[doc = "This event destroys the zwp_linux_buffer_release_v1 object."]
            async fn immediate_release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
#[doc = "This protocol specifies a set of interfaces used for adding constraints to"]
#[doc = "the motion of a pointer. Possible constraints include confining pointer"]
#[doc = "motions to a given region, or locking it to its current position."]
#[doc = ""]
#[doc = "In order to constrain the pointer, a client must first bind the global"]
#[doc = "interface \"wp_pointer_constraints\" which, if a compositor supports pointer"]
#[doc = "constraints, is exposed by the registry. Using the bound global object, the"]
#[doc = "client uses the request that corresponds to the type of constraint it wants"]
#[doc = "to make. See wp_pointer_constraints for more details."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and backward"]
#[doc = "incompatible changes may be made. Backward compatible changes may be added"]
#[doc = "together with the corresponding interface version bump. Backward"]
#[doc = "incompatible changes are done by bumping the version number in the protocol"]
#[doc = "and interface names and resetting the interface version. Once the protocol"]
#[doc = "is to be declared stable, the 'z' prefix and the version number in the"]
#[doc = "protocol and interface names are removed and the interface version number is"]
#[doc = "reset."]
pub mod pointer_constraints_unstable_v1 {
    pub mod zwp_pointer_constraints_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            AlreadyConstrained = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Lifetime {
            #[doc = "A oneshot pointer constraint will never reactivate once it has been"]
            #[doc = "deactivated. See the corresponding deactivation event"]
            #[doc = "(wp_locked_pointer.unlocked and wp_confined_pointer.unconfined) for"]
            #[doc = "details."]
            Oneshot = 1u32,
            #[doc = "A persistent pointer constraint may again reactivate once it has"]
            #[doc = "been deactivated. See the corresponding deactivation event"]
            #[doc = "(wp_locked_pointer.unlocked and wp_confined_pointer.unconfined) for"]
            #[doc = "details."]
            Persistent = 2u32,
        }
        impl TryFrom<u32> for Lifetime {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "The global interface exposing pointer constraining functionality. It"]
        #[doc = "exposes two requests: lock_pointer for locking the pointer to its"]
        #[doc = "position, and confine_pointer for locking the pointer to a region."]
        #[doc = ""]
        #[doc = "The lock_pointer and confine_pointer requests create the objects"]
        #[doc = "wp_locked_pointer and wp_confined_pointer respectively, and the client can"]
        #[doc = "use these objects to interact with the lock."]
        #[doc = ""]
        #[doc = "For any surface, only one lock or confinement may be active across all"]
        #[doc = "wl_pointer objects of the same seat. If a lock or confinement is requested"]
        #[doc = "when another lock or confinement is active or requested on the same surface"]
        #[doc = "and with any of the wl_pointer objects of the same seat, an"]
        #[doc = "'already_constrained' error will be raised."]
        pub trait ZwpPointerConstraintsV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_pointer_constraints_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_pointer_constraints_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zwp_pointer_constraints_v1#{}.lock_pointer()", object.id);
                        self.lock_pointer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.object()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "zwp_pointer_constraints_v1#{}.confine_pointer()",
                            object.id
                        );
                        self.confine_pointer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.object()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Used by the client to notify the server that it will no longer use this"]
            #[doc = "pointer constraints object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The lock_pointer request lets the client request to disable movements of"]
            #[doc = "the virtual pointer (i.e. the cursor), effectively locking the pointer"]
            #[doc = "to a position. This request may not take effect immediately; in the"]
            #[doc = "future, when the compositor deems implementation-specific constraints"]
            #[doc = "are satisfied, the pointer lock will be activated and the compositor"]
            #[doc = "sends a locked event."]
            #[doc = ""]
            #[doc = "The protocol provides no guarantee that the constraints are ever"]
            #[doc = "satisfied, and does not require the compositor to send an error if the"]
            #[doc = "constraints cannot ever be satisfied. It is thus possible to request a"]
            #[doc = "lock that will never activate."]
            #[doc = ""]
            #[doc = "There may not be another pointer constraint of any kind requested or"]
            #[doc = "active on the surface for any of the wl_pointer objects of the seat of"]
            #[doc = "the passed pointer when requesting a lock. If there is, an error will be"]
            #[doc = "raised. See general pointer lock documentation for more details."]
            #[doc = ""]
            #[doc = "The intersection of the region passed with this request and the input"]
            #[doc = "region of the surface is used to determine where the pointer must be"]
            #[doc = "in order for the lock to activate. It is up to the compositor whether to"]
            #[doc = "warp the pointer or require some kind of user interaction for the lock"]
            #[doc = "to activate. If the region is null the surface input region is used."]
            #[doc = ""]
            #[doc = "A surface may receive pointer focus without the lock being activated."]
            #[doc = ""]
            #[doc = "The request creates a new object wp_locked_pointer which is used to"]
            #[doc = "interact with the lock as well as receive updates about its state. See"]
            #[doc = "the the description of wp_locked_pointer for further information."]
            #[doc = ""]
            #[doc = "Note that while a pointer is locked, the wl_pointer objects of the"]
            #[doc = "corresponding seat will not emit any wl_pointer.motion events, but"]
            #[doc = "relative motion events will still be emitted via wp_relative_pointer"]
            #[doc = "objects of the same seat. wl_pointer.axis and wl_pointer.button events"]
            #[doc = "are unaffected."]
            async fn lock_pointer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
                pointer: crate::wire::ObjectId,
                region: Option<crate::wire::ObjectId>,
                lifetime: Lifetime,
            ) -> crate::server::Result<()>;
            #[doc = "The confine_pointer request lets the client request to confine the"]
            #[doc = "pointer cursor to a given region. This request may not take effect"]
            #[doc = "immediately; in the future, when the compositor deems implementation-"]
            #[doc = "specific constraints are satisfied, the pointer confinement will be"]
            #[doc = "activated and the compositor sends a confined event."]
            #[doc = ""]
            #[doc = "The intersection of the region passed with this request and the input"]
            #[doc = "region of the surface is used to determine where the pointer must be"]
            #[doc = "in order for the confinement to activate. It is up to the compositor"]
            #[doc = "whether to warp the pointer or require some kind of user interaction for"]
            #[doc = "the confinement to activate. If the region is null the surface input"]
            #[doc = "region is used."]
            #[doc = ""]
            #[doc = "The request will create a new object wp_confined_pointer which is used"]
            #[doc = "to interact with the confinement as well as receive updates about its"]
            #[doc = "state. See the the description of wp_confined_pointer for further"]
            #[doc = "information."]
            async fn confine_pointer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
                pointer: crate::wire::ObjectId,
                region: Option<crate::wire::ObjectId>,
                lifetime: Lifetime,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_locked_pointer_v1 {
        #[doc = "The wp_locked_pointer interface represents a locked pointer state."]
        #[doc = ""]
        #[doc = "While the lock of this object is active, the wl_pointer objects of the"]
        #[doc = "associated seat will not emit any wl_pointer.motion events."]
        #[doc = ""]
        #[doc = "This object will send the event 'locked' when the lock is activated."]
        #[doc = "Whenever the lock is activated, it is guaranteed that the locked surface"]
        #[doc = "will already have received pointer focus and that the pointer will be"]
        #[doc = "within the region passed to the request creating this object."]
        #[doc = ""]
        #[doc = "To unlock the pointer, send the destroy request. This will also destroy"]
        #[doc = "the wp_locked_pointer object."]
        #[doc = ""]
        #[doc = "If the compositor decides to unlock the pointer the unlocked event is"]
        #[doc = "sent. See wp_locked_pointer.unlock for details."]
        #[doc = ""]
        #[doc = "When unlocking, the compositor may warp the cursor position to the set"]
        #[doc = "cursor position hint. If it does, it will not result in any relative"]
        #[doc = "motion events emitted via wp_relative_pointer."]
        #[doc = ""]
        #[doc = "If the surface the lock was requested on is destroyed and the lock is not"]
        #[doc = "yet activated, the wp_locked_pointer object is now defunct and must be"]
        #[doc = "destroyed."]
        pub trait ZwpLockedPointerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_locked_pointer_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_locked_pointer_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwp_locked_pointer_v1#{}.set_cursor_position_hint()",
                            object.id
                        );
                        self.set_cursor_position_hint(
                            object,
                            client,
                            message.fixed()?,
                            message.fixed()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zwp_locked_pointer_v1#{}.set_region()", object.id);
                        self.set_region(object, client, message.object()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the locked pointer object. If applicable, the compositor will"]
            #[doc = "unlock the pointer."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the cursor position hint relative to the top left corner of the"]
            #[doc = "surface."]
            #[doc = ""]
            #[doc = "If the client is drawing its own cursor, it should update the position"]
            #[doc = "hint to the position of its own cursor. A compositor may use this"]
            #[doc = "information to warp the pointer upon unlock in order to avoid pointer"]
            #[doc = "jumps."]
            #[doc = ""]
            #[doc = "The cursor position hint is double buffered. The new hint will only take"]
            #[doc = "effect when the associated surface gets it pending state applied. See"]
            #[doc = "wl_surface.commit for details."]
            async fn set_cursor_position_hint(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface_x: crate::wire::Fixed,
                surface_y: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            #[doc = "Set a new region used to lock the pointer."]
            #[doc = ""]
            #[doc = "The new lock region is double-buffered. The new lock region will"]
            #[doc = "only take effect when the associated surface gets its pending state"]
            #[doc = "applied. See wl_surface.commit for details."]
            #[doc = ""]
            #[doc = "For details about the lock region, see wp_locked_pointer."]
            async fn set_region(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                region: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Notification that the pointer lock of the seat's pointer is activated."]
            async fn locked(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notification that the pointer lock of the seat's pointer is no longer"]
            #[doc = "active. If this is a oneshot pointer lock (see"]
            #[doc = "wp_pointer_constraints.lifetime) this object is now defunct and should"]
            #[doc = "be destroyed. If this is a persistent pointer lock (see"]
            #[doc = "wp_pointer_constraints.lifetime) this pointer lock may again"]
            #[doc = "reactivate in the future."]
            async fn unlocked(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_confined_pointer_v1 {
        #[doc = "The wp_confined_pointer interface represents a confined pointer state."]
        #[doc = ""]
        #[doc = "This object will send the event 'confined' when the confinement is"]
        #[doc = "activated. Whenever the confinement is activated, it is guaranteed that"]
        #[doc = "the surface the pointer is confined to will already have received pointer"]
        #[doc = "focus and that the pointer will be within the region passed to the request"]
        #[doc = "creating this object. It is up to the compositor to decide whether this"]
        #[doc = "requires some user interaction and if the pointer will warp to within the"]
        #[doc = "passed region if outside."]
        #[doc = ""]
        #[doc = "To unconfine the pointer, send the destroy request. This will also destroy"]
        #[doc = "the wp_confined_pointer object."]
        #[doc = ""]
        #[doc = "If the compositor decides to unconfine the pointer the unconfined event is"]
        #[doc = "sent. The wp_confined_pointer object is at this point defunct and should"]
        #[doc = "be destroyed."]
        pub trait ZwpConfinedPointerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_confined_pointer_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_confined_pointer_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zwp_confined_pointer_v1#{}.set_region()", object.id);
                        self.set_region(object, client, message.object()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the confined pointer object. If applicable, the compositor will"]
            #[doc = "unconfine the pointer."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set a new region used to confine the pointer."]
            #[doc = ""]
            #[doc = "The new confine region is double-buffered. The new confine region will"]
            #[doc = "only take effect when the associated surface gets its pending state"]
            #[doc = "applied. See wl_surface.commit for details."]
            #[doc = ""]
            #[doc = "If the confinement is active when the new confinement region is applied"]
            #[doc = "and the pointer ends up outside of newly applied region, the pointer may"]
            #[doc = "warped to a position within the new confinement region. If warped, a"]
            #[doc = "wl_pointer.motion event will be emitted, but no"]
            #[doc = "wp_relative_pointer.relative_motion event."]
            #[doc = ""]
            #[doc = "The compositor may also, instead of using the new region, unconfine the"]
            #[doc = "pointer."]
            #[doc = ""]
            #[doc = "For details about the confine region, see wp_confined_pointer."]
            async fn set_region(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                region: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Notification that the pointer confinement of the seat's pointer is"]
            #[doc = "activated."]
            async fn confined(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notification that the pointer confinement of the seat's pointer is no"]
            #[doc = "longer active. If this is a oneshot pointer confinement (see"]
            #[doc = "wp_pointer_constraints.lifetime) this object is now defunct and should"]
            #[doc = "be destroyed. If this is a persistent pointer confinement (see"]
            #[doc = "wp_pointer_constraints.lifetime) this pointer confinement may again"]
            #[doc = "reactivate in the future."]
            async fn unconfined(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
pub mod pointer_gestures_unstable_v1 {
    pub mod zwp_pointer_gestures_v1 {
        #[doc = "A global interface to provide semantic touchpad gestures for a given"]
        #[doc = "pointer."]
        #[doc = ""]
        #[doc = "Three gestures are currently supported: swipe, pinch, and hold."]
        #[doc = "Pinch and swipe gestures follow a three-stage cycle: begin, update,"]
        #[doc = "end, hold gestures follow a two-stage cycle: begin and end. All"]
        #[doc = "gestures are identified by a unique id."]
        #[doc = ""]
        #[doc = "Warning! The protocol described in this file is experimental and"]
        #[doc = "backward incompatible changes may be made. Backward compatible changes"]
        #[doc = "may be added together with the corresponding interface version bump."]
        #[doc = "Backward incompatible changes are done by bumping the version number in"]
        #[doc = "the protocol and interface names and resetting the interface version."]
        #[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
        #[doc = "version number in the protocol and interface names are removed and the"]
        #[doc = "interface version number is reset."]
        pub trait ZwpPointerGesturesV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_pointer_gestures_v1";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwp_pointer_gestures_v1#{}.get_swipe_gesture()",
                            object.id
                        );
                        self.get_swipe_gesture(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwp_pointer_gestures_v1#{}.get_pinch_gesture()",
                            object.id
                        );
                        self.get_pinch_gesture(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zwp_pointer_gestures_v1#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    3u16 => {
                        tracing::debug!("zwp_pointer_gestures_v1#{}.get_hold_gesture()", object.id);
                        self.get_hold_gesture(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a swipe gesture object. See the"]
            #[doc = "wl_pointer_gesture_swipe interface for details."]
            async fn get_swipe_gesture(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                pointer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Create a pinch gesture object. See the"]
            #[doc = "wl_pointer_gesture_pinch interface for details."]
            async fn get_pinch_gesture(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                pointer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the pointer gesture object. Swipe, pinch and hold objects"]
            #[doc = "created via this gesture object remain valid."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a hold gesture object. See the"]
            #[doc = "wl_pointer_gesture_hold interface for details."]
            async fn get_hold_gesture(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                pointer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_pointer_gesture_swipe_v1 {
        #[doc = "A swipe gesture object notifies a client about a multi-finger swipe"]
        #[doc = "gesture detected on an indirect input device such as a touchpad."]
        #[doc = "The gesture is usually initiated by multiple fingers moving in the"]
        #[doc = "same direction but once initiated the direction may change."]
        #[doc = "The precise conditions of when such a gesture is detected are"]
        #[doc = "implementation-dependent."]
        #[doc = ""]
        #[doc = "A gesture consists of three stages: begin, update (optional) and end."]
        #[doc = "There cannot be multiple simultaneous hold, pinch or swipe gestures on a"]
        #[doc = "same pointer/seat, how compositors prevent these situations is"]
        #[doc = "implementation-dependent."]
        #[doc = ""]
        #[doc = "A gesture may be cancelled by the compositor or the hardware."]
        #[doc = "Clients should not consider performing permanent or irreversible"]
        #[doc = "actions until the end of a gesture has been received."]
        pub trait ZwpPointerGestureSwipeV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_pointer_gesture_swipe_v1";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_pointer_gesture_swipe_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent when a multi-finger swipe gesture is detected"]
            #[doc = "on the device."]
            async fn begin(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent when a multi-finger swipe gesture changes the"]
            #[doc = "position of the logical center."]
            #[doc = ""]
            #[doc = "The dx and dy coordinates are relative coordinates of the logical"]
            #[doc = "center of the gesture compared to the previous event."]
            async fn update(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent when a multi-finger swipe gesture ceases to"]
            #[doc = "be valid. This may happen when one or more fingers are lifted or"]
            #[doc = "the gesture is cancelled."]
            #[doc = ""]
            #[doc = "When a gesture is cancelled, the client should undo state changes"]
            #[doc = "caused by this gesture. What causes a gesture to be cancelled is"]
            #[doc = "implementation-dependent."]
            async fn end(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_pointer_gesture_pinch_v1 {
        #[doc = "A pinch gesture object notifies a client about a multi-finger pinch"]
        #[doc = "gesture detected on an indirect input device such as a touchpad."]
        #[doc = "The gesture is usually initiated by multiple fingers moving towards"]
        #[doc = "each other or away from each other, or by two or more fingers rotating"]
        #[doc = "around a logical center of gravity. The precise conditions of when"]
        #[doc = "such a gesture is detected are implementation-dependent."]
        #[doc = ""]
        #[doc = "A gesture consists of three stages: begin, update (optional) and end."]
        #[doc = "There cannot be multiple simultaneous hold, pinch or swipe gestures on a"]
        #[doc = "same pointer/seat, how compositors prevent these situations is"]
        #[doc = "implementation-dependent."]
        #[doc = ""]
        #[doc = "A gesture may be cancelled by the compositor or the hardware."]
        #[doc = "Clients should not consider performing permanent or irreversible"]
        #[doc = "actions until the end of a gesture has been received."]
        pub trait ZwpPointerGesturePinchV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_pointer_gesture_pinch_v1";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_pointer_gesture_pinch_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent when a multi-finger pinch gesture is detected"]
            #[doc = "on the device."]
            async fn begin(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent when a multi-finger pinch gesture changes the"]
            #[doc = "position of the logical center, the rotation or the relative scale."]
            #[doc = ""]
            #[doc = "The dx and dy coordinates are relative coordinates in the"]
            #[doc = "surface coordinate space of the logical center of the gesture."]
            #[doc = ""]
            #[doc = "The scale factor is an absolute scale compared to the"]
            #[doc = "pointer_gesture_pinch.begin event, e.g. a scale of 2 means the fingers"]
            #[doc = "are now twice as far apart as on pointer_gesture_pinch.begin."]
            #[doc = ""]
            #[doc = "The rotation is the relative angle in degrees clockwise compared to the previous"]
            #[doc = "pointer_gesture_pinch.begin or pointer_gesture_pinch.update event."]
            async fn update(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent when a multi-finger pinch gesture ceases to"]
            #[doc = "be valid. This may happen when one or more fingers are lifted or"]
            #[doc = "the gesture is cancelled."]
            #[doc = ""]
            #[doc = "When a gesture is cancelled, the client should undo state changes"]
            #[doc = "caused by this gesture. What causes a gesture to be cancelled is"]
            #[doc = "implementation-dependent."]
            async fn end(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_pointer_gesture_hold_v1 {
        #[doc = "A hold gesture object notifies a client about a single- or"]
        #[doc = "multi-finger hold gesture detected on an indirect input device such as"]
        #[doc = "a touchpad. The gesture is usually initiated by one or more fingers"]
        #[doc = "being held down without significant movement. The precise conditions"]
        #[doc = "of when such a gesture is detected are implementation-dependent."]
        #[doc = ""]
        #[doc = "In particular, this gesture may be used to cancel kinetic scrolling."]
        #[doc = ""]
        #[doc = "A hold gesture consists of two stages: begin and end. Unlike pinch and"]
        #[doc = "swipe there is no update stage."]
        #[doc = "There cannot be multiple simultaneous hold, pinch or swipe gestures on a"]
        #[doc = "same pointer/seat, how compositors prevent these situations is"]
        #[doc = "implementation-dependent."]
        #[doc = ""]
        #[doc = "A gesture may be cancelled by the compositor or the hardware."]
        #[doc = "Clients should not consider performing permanent or irreversible"]
        #[doc = "actions until the end of a gesture has been received."]
        pub trait ZwpPointerGestureHoldV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_pointer_gesture_hold_v1";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_pointer_gesture_hold_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent when a hold gesture is detected on the device."]
            async fn begin(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent when a hold gesture ceases to"]
            #[doc = "be valid. This may happen when the holding fingers are lifted or"]
            #[doc = "the gesture is cancelled, for example if the fingers move past an"]
            #[doc = "implementation-defined threshold, the finger count changes or the hold"]
            #[doc = "gesture changes into a different type of gesture."]
            #[doc = ""]
            #[doc = "When a gesture is cancelled, the client may need to undo state changes"]
            #[doc = "caused by this gesture. What causes a gesture to be cancelled is"]
            #[doc = "implementation-dependent."]
            async fn end(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
#[doc = "This protocol provides the ability to have a primary selection device to"]
#[doc = "match that of the X server. This primary selection is a shortcut to the"]
#[doc = "common clipboard selection, where text just needs to be selected in order"]
#[doc = "to allow copying it elsewhere. The de facto way to perform this action"]
#[doc = "is the middle mouse button, although it is not limited to this one."]
#[doc = ""]
#[doc = "Clients wishing to honor primary selection should create a primary"]
#[doc = "selection source and set it as the selection through"]
#[doc = "wp_primary_selection_device.set_selection whenever the text selection"]
#[doc = "changes. In order to minimize calls in pointer-driven text selection,"]
#[doc = "it should happen only once after the operation finished. Similarly,"]
#[doc = "a NULL source should be set when text is unselected."]
#[doc = ""]
#[doc = "wp_primary_selection_offer objects are first announced through the"]
#[doc = "wp_primary_selection_device.data_offer event. Immediately after this event,"]
#[doc = "the primary data offer will emit wp_primary_selection_offer.offer events"]
#[doc = "to let know of the mime types being offered."]
#[doc = ""]
#[doc = "When the primary selection changes, the client with the keyboard focus"]
#[doc = "will receive wp_primary_selection_device.selection events. Only the client"]
#[doc = "with the keyboard focus will receive such events with a non-NULL"]
#[doc = "wp_primary_selection_offer. Across keyboard focus changes, previously"]
#[doc = "focused clients will receive wp_primary_selection_device.events with a"]
#[doc = "NULL wp_primary_selection_offer."]
#[doc = ""]
#[doc = "In order to request the primary selection data, the client must pass"]
#[doc = "a recent serial pertaining to the press event that is triggering the"]
#[doc = "operation, if the compositor deems the serial valid and recent, the"]
#[doc = "wp_primary_selection_source.send event will happen in the other end"]
#[doc = "to let the transfer begin. The client owning the primary selection"]
#[doc = "should write the requested data, and close the file descriptor"]
#[doc = "immediately."]
#[doc = ""]
#[doc = "If the primary selection owner client disappeared during the transfer,"]
#[doc = "the client reading the data will receive a"]
#[doc = "wp_primary_selection_device.selection event with a NULL"]
#[doc = "wp_primary_selection_offer, the client should take this as a hint"]
#[doc = "to finish the reads related to the no longer existing offer."]
#[doc = ""]
#[doc = "The primary selection owner should be checking for errors during"]
#[doc = "writes, merely cancelling the ongoing transfer if any happened."]
pub mod wp_primary_selection_unstable_v1 {
    pub mod zwp_primary_selection_device_manager_v1 {
        #[doc = "The primary selection device manager is a singleton global object that"]
        #[doc = "provides access to the primary selection. It allows to create"]
        #[doc = "wp_primary_selection_source objects, as well as retrieving the per-seat"]
        #[doc = "wp_primary_selection_device objects."]
        pub trait ZwpPrimarySelectionDeviceManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_primary_selection_device_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwp_primary_selection_device_manager_v1#{}.create_source()",
                            object.id
                        );
                        self.create_source(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwp_primary_selection_device_manager_v1#{}.get_device()",
                            object.id
                        );
                        self.get_device(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "zwp_primary_selection_device_manager_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a new primary selection source."]
            async fn create_source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Create a new data device for a given seat."]
            async fn get_device(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the primary selection device manager."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_primary_selection_device_v1 {
        pub trait ZwpPrimarySelectionDeviceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_primary_selection_device_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwp_primary_selection_device_v1#{}.set_selection()",
                            object.id
                        );
                        self.set_selection(object, client, message.object()?, message.uint()?)
                            .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_primary_selection_device_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Replaces the current selection. The previous owner of the primary"]
            #[doc = "selection will receive a wp_primary_selection_source.cancelled event."]
            #[doc = ""]
            #[doc = "To unset the selection, set the source to NULL."]
            async fn set_selection(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: Option<crate::wire::ObjectId>,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the primary selection device."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Introduces a new wp_primary_selection_offer object that may be used"]
            #[doc = "to receive the current primary selection. Immediately following this"]
            #[doc = "event, the new wp_primary_selection_offer object will send"]
            #[doc = "wp_primary_selection_offer.offer events to describe the offered mime"]
            #[doc = "types."]
            async fn data_offer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The wp_primary_selection_device.selection event is sent to notify the"]
            #[doc = "client of a new primary selection. This event is sent after the"]
            #[doc = "wp_primary_selection.data_offer event introducing this object, and after"]
            #[doc = "the offer has announced its mimetypes through"]
            #[doc = "wp_primary_selection_offer.offer."]
            #[doc = ""]
            #[doc = "The data_offer is valid until a new offer or NULL is received"]
            #[doc = "or until the client loses keyboard focus. The client must destroy the"]
            #[doc = "previous selection data_offer, if any, upon receiving this event."]
            async fn selection(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_primary_selection_offer_v1 {
        #[doc = "A wp_primary_selection_offer represents an offer to transfer the contents"]
        #[doc = "of the primary selection clipboard to the client. Similar to"]
        #[doc = "wl_data_offer, the offer also describes the mime types that the data can"]
        #[doc = "be converted to and provides the mechanisms for transferring the data"]
        #[doc = "directly to the client."]
        pub trait ZwpPrimarySelectionOfferV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_primary_selection_offer_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_primary_selection_offer_v1#{}.receive()", object.id);
                        self.receive(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.fd()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_primary_selection_offer_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "To transfer the contents of the primary selection clipboard, the client"]
            #[doc = "issues this request and indicates the mime type that it wants to"]
            #[doc = "receive. The transfer happens through the passed file descriptor"]
            #[doc = "(typically created with the pipe system call). The source client writes"]
            #[doc = "the data in the mime type representation requested and then closes the"]
            #[doc = "file descriptor."]
            #[doc = ""]
            #[doc = "The receiving client reads from the read end of the pipe until EOF and"]
            #[doc = "closes its end, at which point the transfer is complete."]
            async fn receive(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
                fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the primary selection offer."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sent immediately after creating announcing the"]
            #[doc = "wp_primary_selection_offer through"]
            #[doc = "wp_primary_selection_device.data_offer. One event is sent per offered"]
            #[doc = "mime type."]
            async fn offer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_primary_selection_source_v1 {
        #[doc = "The source side of a wp_primary_selection_offer, it provides a way to"]
        #[doc = "describe the offered data and respond to requests to transfer the"]
        #[doc = "requested contents of the primary selection clipboard."]
        pub trait ZwpPrimarySelectionSourceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_primary_selection_source_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_primary_selection_source_v1#{}.offer()", object.id);
                        self.offer(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_primary_selection_source_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request adds a mime type to the set of mime types advertised to"]
            #[doc = "targets. Can be called several times to offer multiple types."]
            async fn offer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the primary selection source."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Request for the current primary selection contents from the client."]
            #[doc = "Send the specified mime type over the passed file descriptor, then"]
            #[doc = "close it."]
            async fn send(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This primary selection source is no longer valid. The client should"]
            #[doc = "clean up and destroy this primary selection source."]
            async fn cancelled(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
#[doc = "This protocol specifies a set of interfaces used for making clients able to"]
#[doc = "receive relative pointer events not obstructed by barriers (such as the"]
#[doc = "monitor edge or other pointer barriers)."]
#[doc = ""]
#[doc = "To start receiving relative pointer events, a client must first bind the"]
#[doc = "global interface \"wp_relative_pointer_manager\" which, if a compositor"]
#[doc = "supports relative pointer motion events, is exposed by the registry. After"]
#[doc = "having created the relative pointer manager proxy object, the client uses"]
#[doc = "it to create the actual relative pointer object using the"]
#[doc = "\"get_relative_pointer\" request given a wl_pointer. The relative pointer"]
#[doc = "motion events will then, when applicable, be transmitted via the proxy of"]
#[doc = "the newly created relative pointer object. See the documentation of the"]
#[doc = "relative pointer interface for more details."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and backward"]
#[doc = "incompatible changes may be made. Backward compatible changes may be added"]
#[doc = "together with the corresponding interface version bump. Backward"]
#[doc = "incompatible changes are done by bumping the version number in the protocol"]
#[doc = "and interface names and resetting the interface version. Once the protocol"]
#[doc = "is to be declared stable, the 'z' prefix and the version number in the"]
#[doc = "protocol and interface names are removed and the interface version number is"]
#[doc = "reset."]
pub mod relative_pointer_unstable_v1 {
    pub mod zwp_relative_pointer_manager_v1 {
        #[doc = "A global interface used for getting the relative pointer object for a"]
        #[doc = "given pointer."]
        pub trait ZwpRelativePointerManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_relative_pointer_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_relative_pointer_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwp_relative_pointer_manager_v1#{}.get_relative_pointer()",
                            object.id
                        );
                        self.get_relative_pointer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Used by the client to notify the server that it will no longer use this"]
            #[doc = "relative pointer manager object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a relative pointer interface given a wl_pointer object. See the"]
            #[doc = "wp_relative_pointer interface for more details."]
            async fn get_relative_pointer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                pointer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_relative_pointer_v1 {
        #[doc = "A wp_relative_pointer object is an extension to the wl_pointer interface"]
        #[doc = "used for emitting relative pointer events. It shares the same focus as"]
        #[doc = "wl_pointer objects of the same seat and will only emit events when it has"]
        #[doc = "focus."]
        pub trait ZwpRelativePointerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_relative_pointer_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_relative_pointer_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Relative x/y pointer motion from the pointer of the seat associated with"]
            #[doc = "this object."]
            #[doc = ""]
            #[doc = "A relative motion is in the same dimension as regular wl_pointer motion"]
            #[doc = "events, except they do not represent an absolute position. For example,"]
            #[doc = "moving a pointer from (x, y) to (x', y') would have the equivalent"]
            #[doc = "relative motion (x' - x, y' - y). If a pointer motion caused the"]
            #[doc = "absolute pointer position to be clipped by for example the edge of the"]
            #[doc = "monitor, the relative motion is unaffected by the clipping and will"]
            #[doc = "represent the unclipped motion."]
            #[doc = ""]
            #[doc = "This event also contains non-accelerated motion deltas. The"]
            #[doc = "non-accelerated delta is, when applicable, the regular pointer motion"]
            #[doc = "delta as it was before having applied motion acceleration and other"]
            #[doc = "transformations such as normalization."]
            #[doc = ""]
            #[doc = "Note that the non-accelerated delta does not represent 'raw' events as"]
            #[doc = "they were read from some device. Pointer motion acceleration is device-"]
            #[doc = "and configuration-specific and non-accelerated deltas and accelerated"]
            #[doc = "deltas may have the same value on some devices."]
            #[doc = ""]
            #[doc = "Relative motions are not coupled to wl_pointer.motion events, and can be"]
            #[doc = "sent in combination with such events, but also independently. There may"]
            #[doc = "also be scenarios where wl_pointer.motion is sent, but there is no"]
            #[doc = "relative motion. The order of an absolute and relative motion event"]
            #[doc = "originating from the same physical motion is not guaranteed."]
            #[doc = ""]
            #[doc = "If the client needs button events or focus state, it can receive them"]
            #[doc = "from a wl_pointer object of the same seat that the wp_relative_pointer"]
            #[doc = "object is associated with."]
            async fn relative_motion(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
#[doc = "This description provides a high-level overview of the interplay between"]
#[doc = "the interfaces defined this protocol. For details, see the protocol"]
#[doc = "specification."]
#[doc = ""]
#[doc = "More than one tablet may exist, and device-specifics matter. Tablets are"]
#[doc = "not represented by a single virtual device like wl_pointer. A client"]
#[doc = "binds to the tablet manager object which is just a proxy object. From"]
#[doc = "that, the client requests wp_tablet_manager.get_tablet_seat(wl_seat)"]
#[doc = "and that returns the actual interface that has all the tablets. With"]
#[doc = "this indirection, we can avoid merging wp_tablet into the actual Wayland"]
#[doc = "protocol, a long-term benefit."]
#[doc = ""]
#[doc = "The wp_tablet_seat sends a \"tablet added\" event for each tablet"]
#[doc = "connected. That event is followed by descriptive events about the"]
#[doc = "hardware; currently that includes events for name, vid/pid and"]
#[doc = "a wp_tablet.path event that describes a local path. This path can be"]
#[doc = "used to uniquely identify a tablet or get more information through"]
#[doc = "libwacom. Emulated or nested tablets can skip any of those, e.g. a"]
#[doc = "virtual tablet may not have a vid/pid. The sequence of descriptive"]
#[doc = "events is terminated by a wp_tablet.done event to signal that a client"]
#[doc = "may now finalize any initialization for that tablet."]
#[doc = ""]
#[doc = "Events from tablets require a tool in proximity. Tools are also managed"]
#[doc = "by the tablet seat; a \"tool added\" event is sent whenever a tool is new"]
#[doc = "to the compositor. That event is followed by a number of descriptive"]
#[doc = "events about the hardware; currently that includes capabilities,"]
#[doc = "hardware id and serial number, and tool type. Similar to the tablet"]
#[doc = "interface, a wp_tablet_tool.done event is sent to terminate that initial"]
#[doc = "sequence."]
#[doc = ""]
#[doc = "Any event from a tool happens on the wp_tablet_tool interface. When the"]
#[doc = "tool gets into proximity of the tablet, a proximity_in event is sent on"]
#[doc = "the wp_tablet_tool interface, listing the tablet and the surface. That"]
#[doc = "event is followed by a motion event with the coordinates. After that,"]
#[doc = "it's the usual motion, axis, button, etc. events. The protocol's"]
#[doc = "serialisation means events are grouped by wp_tablet_tool.frame events."]
#[doc = ""]
#[doc = "Two special events (that don't exist in X) are down and up. They signal"]
#[doc = "\"tip touching the surface\". For tablets without real proximity"]
#[doc = "detection, the sequence is: proximity_in, motion, down, frame."]
#[doc = ""]
#[doc = "When the tool leaves proximity, a proximity_out event is sent. If any"]
#[doc = "button is still down, a button release event is sent before this"]
#[doc = "proximity event. These button events are sent in the same frame as the"]
#[doc = "proximity event to signal to the client that the buttons were held when"]
#[doc = "the tool left proximity."]
#[doc = ""]
#[doc = "If the tool moves out of the surface but stays in proximity (i.e."]
#[doc = "between windows), compositor-specific grab policies apply. This usually"]
#[doc = "means that the proximity-out is delayed until all buttons are released."]
#[doc = ""]
#[doc = "Moving a tool physically from one tablet to the other has no real effect"]
#[doc = "on the protocol, since we already have the tool object from the \"tool"]
#[doc = "added\" event. All the information is already there and the proximity"]
#[doc = "events on both tablets are all a client needs to reconstruct what"]
#[doc = "happened."]
#[doc = ""]
#[doc = "Some extra axes are normalized, i.e. the client knows the range as"]
#[doc = "specified in the protocol (e.g. [0, 65535]), the granularity however is"]
#[doc = "unknown. The current normalized axes are pressure, distance, and slider."]
#[doc = ""]
#[doc = "Other extra axes are in physical units as specified in the protocol."]
#[doc = "The current extra axes with physical units are tilt, rotation and"]
#[doc = "wheel rotation."]
#[doc = ""]
#[doc = "Since tablets work independently of the pointer controlled by the mouse,"]
#[doc = "the focus handling is independent too and controlled by proximity."]
#[doc = "The wp_tablet_tool.set_cursor request sets a tool-specific cursor."]
#[doc = "This cursor surface may be the same as the mouse cursor, and it may be"]
#[doc = "the same across tools but it is possible to be more fine-grained. For"]
#[doc = "example, a client may set different cursors for the pen and eraser."]
#[doc = ""]
#[doc = "Tools are generally independent of tablets and it is"]
#[doc = "compositor-specific policy when a tool can be removed. Common approaches"]
#[doc = "will likely include some form of removing a tool when all tablets the"]
#[doc = "tool was used on are removed."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and"]
#[doc = "backward incompatible changes may be made. Backward compatible changes"]
#[doc = "may be added together with the corresponding interface version bump."]
#[doc = "Backward incompatible changes are done by bumping the version number in"]
#[doc = "the protocol and interface names and resetting the interface version."]
#[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
#[doc = "version number in the protocol and interface names are removed and the"]
#[doc = "interface version number is reset."]
pub mod tablet_unstable_v1 {
    pub mod zwp_tablet_manager_v1 {
        #[doc = "An object that provides access to the graphics tablets available on this"]
        #[doc = "system. All tablets are associated with a seat, to get access to the"]
        #[doc = "actual tablets, use wp_tablet_manager.get_tablet_seat."]
        pub trait ZwpTabletManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_manager_v1#{}.get_tablet_seat()", object.id);
                        self.get_tablet_seat(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Get the wp_tablet_seat object for the given seat. This object"]
            #[doc = "provides access to all graphics tablets in this seat."]
            async fn get_tablet_seat(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tablet_seat: crate::wire::ObjectId,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the wp_tablet_manager object. Objects created from this"]
            #[doc = "object are unaffected and should be destroyed separately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_tablet_seat_v1 {
        #[doc = "An object that provides access to the graphics tablets available on this"]
        #[doc = "seat. After binding to this interface, the compositor sends a set of"]
        #[doc = "wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events."]
        pub trait ZwpTabletSeatV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_seat_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_seat_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the wp_tablet_seat object. Objects created from this"]
            #[doc = "object are unaffected and should be destroyed separately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent whenever a new tablet becomes available on this"]
            #[doc = "seat. This event only provides the object id of the tablet, any"]
            #[doc = "static information about the tablet (device name, vid/pid, etc.) is"]
            #[doc = "sent through the wp_tablet interface."]
            async fn tablet_added(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent whenever a tool that has not previously been used"]
            #[doc = "with a tablet comes into use. This event only provides the object id"]
            #[doc = "of the tool; any static information about the tool (capabilities,"]
            #[doc = "type, etc.) is sent through the wp_tablet_tool interface."]
            async fn tool_added(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_tablet_tool_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Type {
            Pen = 320u32,
            Eraser = 321u32,
            Brush = 322u32,
            Pencil = 323u32,
            Airbrush = 324u32,
            Finger = 325u32,
            Mouse = 326u32,
            Lens = 327u32,
        }
        impl TryFrom<u32> for Type {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Capability {
            Tilt = 1u32,
            Pressure = 2u32,
            Distance = 3u32,
            Rotation = 4u32,
            Slider = 5u32,
            Wheel = 6u32,
        }
        impl TryFrom<u32> for Capability {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ButtonState {
            Released = 0u32,
            Pressed = 1u32,
        }
        impl TryFrom<u32> for ButtonState {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            Role = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "An object that represents a physical tool that has been, or is"]
        #[doc = "currently in use with a tablet in this seat. Each wp_tablet_tool"]
        #[doc = "object stays valid until the client destroys it; the compositor"]
        #[doc = "reuses the wp_tablet_tool object to indicate that the object's"]
        #[doc = "respective physical tool has come into proximity of a tablet again."]
        #[doc = ""]
        #[doc = "A wp_tablet_tool object's relation to a physical tool depends on the"]
        #[doc = "tablet's ability to report serial numbers. If the tablet supports"]
        #[doc = "this capability, then the object represents a specific physical tool"]
        #[doc = "and can be identified even when used on multiple tablets."]
        #[doc = ""]
        #[doc = "A tablet tool has a number of static characteristics, e.g. tool type,"]
        #[doc = "hardware_serial and capabilities. These capabilities are sent in an"]
        #[doc = "event sequence after the wp_tablet_seat.tool_added event before any"]
        #[doc = "actual events from this tool. This initial event sequence is"]
        #[doc = "terminated by a wp_tablet_tool.done event."]
        #[doc = ""]
        #[doc = "Tablet tool events are grouped by wp_tablet_tool.frame events."]
        #[doc = "Any events received before a wp_tablet_tool.frame event should be"]
        #[doc = "considered part of the same hardware state change."]
        pub trait ZwpTabletToolV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_tool_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_tool_v1#{}.set_cursor()", object.id);
                        self.set_cursor(
                            object,
                            client,
                            message.uint()?,
                            message.object()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_tool_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Sets the surface of the cursor used for this tool on the given"]
            #[doc = "tablet. This request only takes effect if the tool is in proximity"]
            #[doc = "of one of the requesting client's surfaces or the surface parameter"]
            #[doc = "is the current pointer surface. If there was a previous surface set"]
            #[doc = "with this request it is replaced. If surface is NULL, the cursor"]
            #[doc = "image is hidden."]
            #[doc = ""]
            #[doc = "The parameters hotspot_x and hotspot_y define the position of the"]
            #[doc = "pointer surface relative to the pointer location. Its top-left corner"]
            #[doc = "is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the"]
            #[doc = "coordinates of the pointer location, in surface-local coordinates."]
            #[doc = ""]
            #[doc = "On surface.attach requests to the pointer surface, hotspot_x and"]
            #[doc = "hotspot_y are decremented by the x and y parameters passed to the"]
            #[doc = "request. Attach must be confirmed by wl_surface.commit as usual."]
            #[doc = ""]
            #[doc = "The hotspot can also be updated by passing the currently set pointer"]
            #[doc = "surface to this request with new values for hotspot_x and hotspot_y."]
            #[doc = ""]
            #[doc = "The current and pending input regions of the wl_surface are cleared,"]
            #[doc = "and wl_surface.set_input_region is ignored until the wl_surface is no"]
            #[doc = "longer used as the cursor. When the use as a cursor ends, the current"]
            #[doc = "and pending input regions become undefined, and the wl_surface is"]
            #[doc = "unmapped."]
            #[doc = ""]
            #[doc = "This request gives the surface the role of a cursor. The role"]
            #[doc = "assigned by this request is the same as assigned by"]
            #[doc = "wl_pointer.set_cursor meaning the same surface can be"]
            #[doc = "used both as a wl_pointer cursor and a wp_tablet cursor. If the"]
            #[doc = "surface already has another role, it raises a protocol error."]
            #[doc = "The surface may be used on multiple tablets and across multiple"]
            #[doc = "seats."]
            async fn set_cursor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: Option<crate::wire::ObjectId>,
                hotspot_x: i32,
                hotspot_y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "This destroys the client's resource for this tool object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The tool type is the high-level type of the tool and usually decides"]
            #[doc = "the interaction expected from this tool."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn r#type(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "If the physical tool can be identified by a unique 64-bit serial"]
            #[doc = "number, this event notifies the client of this serial number."]
            #[doc = ""]
            #[doc = "If multiple tablets are available in the same seat and the tool is"]
            #[doc = "uniquely identifiable by the serial number, that tool may move"]
            #[doc = "between tablets."]
            #[doc = ""]
            #[doc = "Otherwise, if the tool has no serial number and this event is"]
            #[doc = "missing, the tool is tied to the tablet it first comes into"]
            #[doc = "proximity with. Even if the physical tool is used on multiple"]
            #[doc = "tablets, separate wp_tablet_tool objects will be created, one per"]
            #[doc = "tablet."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn hardware_serial(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event notifies the client of a hardware id available on this tool."]
            #[doc = ""]
            #[doc = "The hardware id is a device-specific 64-bit id that provides extra"]
            #[doc = "information about the tool in use, beyond the wl_tool.type"]
            #[doc = "enumeration. The format of the id is specific to tablets made by"]
            #[doc = "Wacom Inc. For example, the hardware id of a Wacom Grip"]
            #[doc = "Pen (a stylus) is 0x802."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn hardware_id_wacom(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event notifies the client of any capabilities of this tool,"]
            #[doc = "beyond the main set of x/y axes and tip up/down detection."]
            #[doc = ""]
            #[doc = "One event is sent for each extra capability available on this tool."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn capability(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event signals the end of the initial burst of descriptive"]
            #[doc = "events. A client may consider the static description of the tool to"]
            #[doc = "be complete and finalize initialization of the tool."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent when the tool is removed from the system and will"]
            #[doc = "send no further events. Should the physical tool come back into"]
            #[doc = "proximity later, a new wp_tablet_tool object will be created."]
            #[doc = ""]
            #[doc = "It is compositor-dependent when a tool is removed. A compositor may"]
            #[doc = "remove a tool on proximity out, tablet removal or any other reason."]
            #[doc = "A compositor may also keep a tool alive until shutdown."]
            #[doc = ""]
            #[doc = "If the tool is currently in proximity, a proximity_out event will be"]
            #[doc = "sent before the removed event. See wp_tablet_tool.proximity_out for"]
            #[doc = "the handling of any buttons logically down."]
            #[doc = ""]
            #[doc = "When this event is received, the client must wp_tablet_tool.destroy"]
            #[doc = "the object."]
            async fn removed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notification that this tool is focused on a certain surface."]
            #[doc = ""]
            #[doc = "This event can be received when the tool has moved from one surface to"]
            #[doc = "another, or when the tool has come back into proximity above the"]
            #[doc = "surface."]
            #[doc = ""]
            #[doc = "If any button is logically down when the tool comes into proximity,"]
            #[doc = "the respective button event is sent after the proximity_in event but"]
            #[doc = "within the same frame as the proximity_in event."]
            async fn proximity_in(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notification that this tool has either left proximity, or is no"]
            #[doc = "longer focused on a certain surface."]
            #[doc = ""]
            #[doc = "When the tablet tool leaves proximity of the tablet, button release"]
            #[doc = "events are sent for each button that was held down at the time of"]
            #[doc = "leaving proximity. These events are sent before the proximity_out"]
            #[doc = "event but within the same wp_tablet.frame."]
            #[doc = ""]
            #[doc = "If the tool stays within proximity of the tablet, but the focus"]
            #[doc = "changes from one surface to another, a button release event may not"]
            #[doc = "be sent until the button is actually released or the tool leaves the"]
            #[doc = "proximity of the tablet."]
            async fn proximity_out(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the tablet tool comes in contact with the surface of the"]
            #[doc = "tablet."]
            #[doc = ""]
            #[doc = "If the tool is already in contact with the tablet when entering the"]
            #[doc = "input region, the client owning said region will receive a"]
            #[doc = "wp_tablet.proximity_in event, followed by a wp_tablet.down"]
            #[doc = "event and a wp_tablet.frame event."]
            #[doc = ""]
            #[doc = "Note that this event describes logical contact, not physical"]
            #[doc = "contact. On some devices, a compositor may not consider a tool in"]
            #[doc = "logical contact until a minimum physical pressure threshold is"]
            #[doc = "exceeded."]
            async fn down(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the tablet tool stops making contact with the surface of"]
            #[doc = "the tablet, or when the tablet tool moves out of the input region"]
            #[doc = "and the compositor grab (if any) is dismissed."]
            #[doc = ""]
            #[doc = "If the tablet tool moves out of the input region while in contact"]
            #[doc = "with the surface of the tablet and the compositor does not have an"]
            #[doc = "ongoing grab on the surface, the client owning said region will"]
            #[doc = "receive a wp_tablet.up event, followed by a wp_tablet.proximity_out"]
            #[doc = "event and a wp_tablet.frame event. If the compositor has an ongoing"]
            #[doc = "grab on this device, this event sequence is sent whenever the grab"]
            #[doc = "is dismissed in the future."]
            #[doc = ""]
            #[doc = "Note that this event describes logical contact, not physical"]
            #[doc = "contact. On some devices, a compositor may not consider a tool out"]
            #[doc = "of logical contact until physical pressure falls below a specific"]
            #[doc = "threshold."]
            async fn up(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever a tablet tool moves."]
            async fn motion(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the pressure axis on a tool changes. The value of this"]
            #[doc = "event is normalized to a value between 0 and 65535."]
            #[doc = ""]
            #[doc = "Note that pressure may be nonzero even when a tool is not in logical"]
            #[doc = "contact. See the down and up events for more details."]
            async fn pressure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the distance axis on a tool changes. The value of this"]
            #[doc = "event is normalized to a value between 0 and 65535."]
            #[doc = ""]
            #[doc = "Note that distance may be nonzero even when a tool is not in logical"]
            #[doc = "contact. See the down and up events for more details."]
            async fn distance(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever one or both of the tilt axes on a tool change. Each tilt"]
            #[doc = "value is in 0.01 of a degree, relative to the z-axis of the tablet."]
            #[doc = "The angle is positive when the top of a tool tilts along the"]
            #[doc = "positive x or y axis."]
            async fn tilt(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the z-rotation axis on the tool changes. The"]
            #[doc = "rotation value is in 0.01 of a degree clockwise from the tool's"]
            #[doc = "logical neutral position."]
            async fn rotation(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the slider position on the tool changes. The"]
            #[doc = "value is normalized between -65535 and 65535, with 0 as the logical"]
            #[doc = "neutral position of the slider."]
            #[doc = ""]
            #[doc = "The slider is available on e.g. the Wacom Airbrush tool."]
            async fn slider(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the wheel on the tool emits an event. This event"]
            #[doc = "contains two values for the same axis change. The degrees value is"]
            #[doc = "in 0.01 of a degree in the same orientation as the"]
            #[doc = "wl_pointer.vertical_scroll axis. The clicks value is in discrete"]
            #[doc = "logical clicks of the mouse wheel. This value may be zero if the"]
            #[doc = "movement of the wheel was less than one logical click."]
            #[doc = ""]
            #[doc = "Clients should choose either value and avoid mixing degrees and"]
            #[doc = "clicks. The compositor may accumulate values smaller than a logical"]
            #[doc = "click and emulate click events when a certain threshold is met."]
            #[doc = "Thus, wl_tablet_tool.wheel events with non-zero clicks values may"]
            #[doc = "have different degrees values."]
            async fn wheel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever a button on the tool is pressed or released."]
            #[doc = ""]
            #[doc = "If a button is held down when the tool moves in or out of proximity,"]
            #[doc = "button events are generated by the compositor. See"]
            #[doc = "wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for"]
            #[doc = "details."]
            async fn button(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Marks the end of a series of axis and/or button updates from the"]
            #[doc = "tablet. The Wayland protocol requires axis updates to be sent"]
            #[doc = "sequentially, however all events within a frame should be considered"]
            #[doc = "one hardware event."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_tablet_v1 {
        #[doc = "The wp_tablet interface represents one graphics tablet device. The"]
        #[doc = "tablet interface itself does not generate events; all events are"]
        #[doc = "generated by wp_tablet_tool objects when in proximity above a tablet."]
        #[doc = ""]
        #[doc = "A tablet has a number of static characteristics, e.g. device name and"]
        #[doc = "pid/vid. These capabilities are sent in an event sequence after the"]
        #[doc = "wp_tablet_seat.tablet_added event. This initial event sequence is"]
        #[doc = "terminated by a wp_tablet.done event."]
        pub trait ZwpTabletV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This destroys the client's resource for this tablet object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet.done event."]
            async fn name(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet.done event."]
            async fn id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "A system-specific device path that indicates which device is behind"]
            #[doc = "this wp_tablet. This information may be used to gather additional"]
            #[doc = "information about the device, e.g. through libwacom."]
            #[doc = ""]
            #[doc = "A device may have more than one device path. If so, multiple"]
            #[doc = "wp_tablet.path events are sent. A device may be emulated and not"]
            #[doc = "have a device path, and in that case this event will not be sent."]
            #[doc = ""]
            #[doc = "The format of the path is unspecified, it may be a device node, a"]
            #[doc = "sysfs path, or some other identifier. It is up to the client to"]
            #[doc = "identify the string provided."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet.done event."]
            async fn path(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent immediately to signal the end of the initial"]
            #[doc = "burst of descriptive events. A client may consider the static"]
            #[doc = "description of the tablet to be complete and finalize initialization"]
            #[doc = "of the tablet."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent when the tablet has been removed from the system. When a tablet"]
            #[doc = "is removed, some tools may be removed."]
            #[doc = ""]
            #[doc = "When this event is received, the client must wp_tablet.destroy"]
            #[doc = "the object."]
            async fn removed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
#[doc = "This description provides a high-level overview of the interplay between"]
#[doc = "the interfaces defined this protocol. For details, see the protocol"]
#[doc = "specification."]
#[doc = ""]
#[doc = "More than one tablet may exist, and device-specifics matter. Tablets are"]
#[doc = "not represented by a single virtual device like wl_pointer. A client"]
#[doc = "binds to the tablet manager object which is just a proxy object. From"]
#[doc = "that, the client requests wp_tablet_manager.get_tablet_seat(wl_seat)"]
#[doc = "and that returns the actual interface that has all the tablets. With"]
#[doc = "this indirection, we can avoid merging wp_tablet into the actual Wayland"]
#[doc = "protocol, a long-term benefit."]
#[doc = ""]
#[doc = "The wp_tablet_seat sends a \"tablet added\" event for each tablet"]
#[doc = "connected. That event is followed by descriptive events about the"]
#[doc = "hardware; currently that includes events for name, vid/pid and"]
#[doc = "a wp_tablet.path event that describes a local path. This path can be"]
#[doc = "used to uniquely identify a tablet or get more information through"]
#[doc = "libwacom. Emulated or nested tablets can skip any of those, e.g. a"]
#[doc = "virtual tablet may not have a vid/pid. The sequence of descriptive"]
#[doc = "events is terminated by a wp_tablet.done event to signal that a client"]
#[doc = "may now finalize any initialization for that tablet."]
#[doc = ""]
#[doc = "Events from tablets require a tool in proximity. Tools are also managed"]
#[doc = "by the tablet seat; a \"tool added\" event is sent whenever a tool is new"]
#[doc = "to the compositor. That event is followed by a number of descriptive"]
#[doc = "events about the hardware; currently that includes capabilities,"]
#[doc = "hardware id and serial number, and tool type. Similar to the tablet"]
#[doc = "interface, a wp_tablet_tool.done event is sent to terminate that initial"]
#[doc = "sequence."]
#[doc = ""]
#[doc = "Any event from a tool happens on the wp_tablet_tool interface. When the"]
#[doc = "tool gets into proximity of the tablet, a proximity_in event is sent on"]
#[doc = "the wp_tablet_tool interface, listing the tablet and the surface. That"]
#[doc = "event is followed by a motion event with the coordinates. After that,"]
#[doc = "it's the usual motion, axis, button, etc. events. The protocol's"]
#[doc = "serialisation means events are grouped by wp_tablet_tool.frame events."]
#[doc = ""]
#[doc = "Two special events (that don't exist in X) are down and up. They signal"]
#[doc = "\"tip touching the surface\". For tablets without real proximity"]
#[doc = "detection, the sequence is: proximity_in, motion, down, frame."]
#[doc = ""]
#[doc = "When the tool leaves proximity, a proximity_out event is sent. If any"]
#[doc = "button is still down, a button release event is sent before this"]
#[doc = "proximity event. These button events are sent in the same frame as the"]
#[doc = "proximity event to signal to the client that the buttons were held when"]
#[doc = "the tool left proximity."]
#[doc = ""]
#[doc = "If the tool moves out of the surface but stays in proximity (i.e."]
#[doc = "between windows), compositor-specific grab policies apply. This usually"]
#[doc = "means that the proximity-out is delayed until all buttons are released."]
#[doc = ""]
#[doc = "Moving a tool physically from one tablet to the other has no real effect"]
#[doc = "on the protocol, since we already have the tool object from the \"tool"]
#[doc = "added\" event. All the information is already there and the proximity"]
#[doc = "events on both tablets are all a client needs to reconstruct what"]
#[doc = "happened."]
#[doc = ""]
#[doc = "Some extra axes are normalized, i.e. the client knows the range as"]
#[doc = "specified in the protocol (e.g. [0, 65535]), the granularity however is"]
#[doc = "unknown. The current normalized axes are pressure, distance, and slider."]
#[doc = ""]
#[doc = "Other extra axes are in physical units as specified in the protocol."]
#[doc = "The current extra axes with physical units are tilt, rotation and"]
#[doc = "wheel rotation."]
#[doc = ""]
#[doc = "Since tablets work independently of the pointer controlled by the mouse,"]
#[doc = "the focus handling is independent too and controlled by proximity."]
#[doc = "The wp_tablet_tool.set_cursor request sets a tool-specific cursor."]
#[doc = "This cursor surface may be the same as the mouse cursor, and it may be"]
#[doc = "the same across tools but it is possible to be more fine-grained. For"]
#[doc = "example, a client may set different cursors for the pen and eraser."]
#[doc = ""]
#[doc = "Tools are generally independent of tablets and it is"]
#[doc = "compositor-specific policy when a tool can be removed. Common approaches"]
#[doc = "will likely include some form of removing a tool when all tablets the"]
#[doc = "tool was used on are removed."]
#[doc = ""]
#[doc = "Disclaimer: This protocol extension has been marked stable. This copy is"]
#[doc = "no longer used and only retained for backwards compatibility. The"]
#[doc = "canonical version can be found in the stable/ directory."]
pub mod tablet_unstable_v2 {
    pub mod zwp_tablet_manager_v2 {
        #[doc = "An object that provides access to the graphics tablets available on this"]
        #[doc = "system. All tablets are associated with a seat, to get access to the"]
        #[doc = "actual tablets, use wp_tablet_manager.get_tablet_seat."]
        pub trait ZwpTabletManagerV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_manager_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_manager_v2#{}.get_tablet_seat()", object.id);
                        self.get_tablet_seat(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_manager_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Get the wp_tablet_seat object for the given seat. This object"]
            #[doc = "provides access to all graphics tablets in this seat."]
            async fn get_tablet_seat(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tablet_seat: crate::wire::ObjectId,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the wp_tablet_manager object. Objects created from this"]
            #[doc = "object are unaffected and should be destroyed separately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_tablet_seat_v2 {
        #[doc = "An object that provides access to the graphics tablets available on this"]
        #[doc = "seat. After binding to this interface, the compositor sends a set of"]
        #[doc = "wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events."]
        pub trait ZwpTabletSeatV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_seat_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_seat_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the wp_tablet_seat object. Objects created from this"]
            #[doc = "object are unaffected and should be destroyed separately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent whenever a new tablet becomes available on this"]
            #[doc = "seat. This event only provides the object id of the tablet, any"]
            #[doc = "static information about the tablet (device name, vid/pid, etc.) is"]
            #[doc = "sent through the wp_tablet interface."]
            async fn tablet_added(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent whenever a tool that has not previously been used"]
            #[doc = "with a tablet comes into use. This event only provides the object id"]
            #[doc = "of the tool; any static information about the tool (capabilities,"]
            #[doc = "type, etc.) is sent through the wp_tablet_tool interface."]
            async fn tool_added(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent whenever a new pad is known to the system. Typically,"]
            #[doc = "pads are physically attached to tablets and a pad_added event is"]
            #[doc = "sent immediately after the wp_tablet_seat.tablet_added."]
            #[doc = "However, some standalone pad devices logically attach to tablets at"]
            #[doc = "runtime, and the client must wait for wp_tablet_pad.enter to know"]
            #[doc = "the tablet a pad is attached to."]
            #[doc = ""]
            #[doc = "This event only provides the object id of the pad. All further"]
            #[doc = "features (buttons, strips, rings) are sent through the wp_tablet_pad"]
            #[doc = "interface."]
            async fn pad_added(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_tablet_tool_v2 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Type {
            Pen = 320u32,
            Eraser = 321u32,
            Brush = 322u32,
            Pencil = 323u32,
            Airbrush = 324u32,
            Finger = 325u32,
            Mouse = 326u32,
            Lens = 327u32,
        }
        impl TryFrom<u32> for Type {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Capability {
            Tilt = 1u32,
            Pressure = 2u32,
            Distance = 3u32,
            Rotation = 4u32,
            Slider = 5u32,
            Wheel = 6u32,
        }
        impl TryFrom<u32> for Capability {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ButtonState {
            Released = 0u32,
            Pressed = 1u32,
        }
        impl TryFrom<u32> for ButtonState {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            Role = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "An object that represents a physical tool that has been, or is"]
        #[doc = "currently in use with a tablet in this seat. Each wp_tablet_tool"]
        #[doc = "object stays valid until the client destroys it; the compositor"]
        #[doc = "reuses the wp_tablet_tool object to indicate that the object's"]
        #[doc = "respective physical tool has come into proximity of a tablet again."]
        #[doc = ""]
        #[doc = "A wp_tablet_tool object's relation to a physical tool depends on the"]
        #[doc = "tablet's ability to report serial numbers. If the tablet supports"]
        #[doc = "this capability, then the object represents a specific physical tool"]
        #[doc = "and can be identified even when used on multiple tablets."]
        #[doc = ""]
        #[doc = "A tablet tool has a number of static characteristics, e.g. tool type,"]
        #[doc = "hardware_serial and capabilities. These capabilities are sent in an"]
        #[doc = "event sequence after the wp_tablet_seat.tool_added event before any"]
        #[doc = "actual events from this tool. This initial event sequence is"]
        #[doc = "terminated by a wp_tablet_tool.done event."]
        #[doc = ""]
        #[doc = "Tablet tool events are grouped by wp_tablet_tool.frame events."]
        #[doc = "Any events received before a wp_tablet_tool.frame event should be"]
        #[doc = "considered part of the same hardware state change."]
        pub trait ZwpTabletToolV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_tool_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_tool_v2#{}.set_cursor()", object.id);
                        self.set_cursor(
                            object,
                            client,
                            message.uint()?,
                            message.object()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_tool_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Sets the surface of the cursor used for this tool on the given"]
            #[doc = "tablet. This request only takes effect if the tool is in proximity"]
            #[doc = "of one of the requesting client's surfaces or the surface parameter"]
            #[doc = "is the current pointer surface. If there was a previous surface set"]
            #[doc = "with this request it is replaced. If surface is NULL, the cursor"]
            #[doc = "image is hidden."]
            #[doc = ""]
            #[doc = "The parameters hotspot_x and hotspot_y define the position of the"]
            #[doc = "pointer surface relative to the pointer location. Its top-left corner"]
            #[doc = "is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the"]
            #[doc = "coordinates of the pointer location, in surface-local coordinates."]
            #[doc = ""]
            #[doc = "On surface.attach requests to the pointer surface, hotspot_x and"]
            #[doc = "hotspot_y are decremented by the x and y parameters passed to the"]
            #[doc = "request. Attach must be confirmed by wl_surface.commit as usual."]
            #[doc = ""]
            #[doc = "The hotspot can also be updated by passing the currently set pointer"]
            #[doc = "surface to this request with new values for hotspot_x and hotspot_y."]
            #[doc = ""]
            #[doc = "The current and pending input regions of the wl_surface are cleared,"]
            #[doc = "and wl_surface.set_input_region is ignored until the wl_surface is no"]
            #[doc = "longer used as the cursor. When the use as a cursor ends, the current"]
            #[doc = "and pending input regions become undefined, and the wl_surface is"]
            #[doc = "unmapped."]
            #[doc = ""]
            #[doc = "This request gives the surface the role of a wp_tablet_tool cursor. A"]
            #[doc = "surface may only ever be used as the cursor surface for one"]
            #[doc = "wp_tablet_tool. If the surface already has another role or has"]
            #[doc = "previously been used as cursor surface for a different tool, a"]
            #[doc = "protocol error is raised."]
            async fn set_cursor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: Option<crate::wire::ObjectId>,
                hotspot_x: i32,
                hotspot_y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "This destroys the client's resource for this tool object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The tool type is the high-level type of the tool and usually decides"]
            #[doc = "the interaction expected from this tool."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn r#type(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "If the physical tool can be identified by a unique 64-bit serial"]
            #[doc = "number, this event notifies the client of this serial number."]
            #[doc = ""]
            #[doc = "If multiple tablets are available in the same seat and the tool is"]
            #[doc = "uniquely identifiable by the serial number, that tool may move"]
            #[doc = "between tablets."]
            #[doc = ""]
            #[doc = "Otherwise, if the tool has no serial number and this event is"]
            #[doc = "missing, the tool is tied to the tablet it first comes into"]
            #[doc = "proximity with. Even if the physical tool is used on multiple"]
            #[doc = "tablets, separate wp_tablet_tool objects will be created, one per"]
            #[doc = "tablet."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn hardware_serial(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event notifies the client of a hardware id available on this tool."]
            #[doc = ""]
            #[doc = "The hardware id is a device-specific 64-bit id that provides extra"]
            #[doc = "information about the tool in use, beyond the wl_tool.type"]
            #[doc = "enumeration. The format of the id is specific to tablets made by"]
            #[doc = "Wacom Inc. For example, the hardware id of a Wacom Grip"]
            #[doc = "Pen (a stylus) is 0x802."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn hardware_id_wacom(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event notifies the client of any capabilities of this tool,"]
            #[doc = "beyond the main set of x/y axes and tip up/down detection."]
            #[doc = ""]
            #[doc = "One event is sent for each extra capability available on this tool."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn capability(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event signals the end of the initial burst of descriptive"]
            #[doc = "events. A client may consider the static description of the tool to"]
            #[doc = "be complete and finalize initialization of the tool."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent when the tool is removed from the system and will"]
            #[doc = "send no further events. Should the physical tool come back into"]
            #[doc = "proximity later, a new wp_tablet_tool object will be created."]
            #[doc = ""]
            #[doc = "It is compositor-dependent when a tool is removed. A compositor may"]
            #[doc = "remove a tool on proximity out, tablet removal or any other reason."]
            #[doc = "A compositor may also keep a tool alive until shutdown."]
            #[doc = ""]
            #[doc = "If the tool is currently in proximity, a proximity_out event will be"]
            #[doc = "sent before the removed event. See wp_tablet_tool.proximity_out for"]
            #[doc = "the handling of any buttons logically down."]
            #[doc = ""]
            #[doc = "When this event is received, the client must wp_tablet_tool.destroy"]
            #[doc = "the object."]
            async fn removed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notification that this tool is focused on a certain surface."]
            #[doc = ""]
            #[doc = "This event can be received when the tool has moved from one surface to"]
            #[doc = "another, or when the tool has come back into proximity above the"]
            #[doc = "surface."]
            #[doc = ""]
            #[doc = "If any button is logically down when the tool comes into proximity,"]
            #[doc = "the respective button event is sent after the proximity_in event but"]
            #[doc = "within the same frame as the proximity_in event."]
            async fn proximity_in(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notification that this tool has either left proximity, or is no"]
            #[doc = "longer focused on a certain surface."]
            #[doc = ""]
            #[doc = "When the tablet tool leaves proximity of the tablet, button release"]
            #[doc = "events are sent for each button that was held down at the time of"]
            #[doc = "leaving proximity. These events are sent before the proximity_out"]
            #[doc = "event but within the same wp_tablet.frame."]
            #[doc = ""]
            #[doc = "If the tool stays within proximity of the tablet, but the focus"]
            #[doc = "changes from one surface to another, a button release event may not"]
            #[doc = "be sent until the button is actually released or the tool leaves the"]
            #[doc = "proximity of the tablet."]
            async fn proximity_out(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the tablet tool comes in contact with the surface of the"]
            #[doc = "tablet."]
            #[doc = ""]
            #[doc = "If the tool is already in contact with the tablet when entering the"]
            #[doc = "input region, the client owning said region will receive a"]
            #[doc = "wp_tablet.proximity_in event, followed by a wp_tablet.down"]
            #[doc = "event and a wp_tablet.frame event."]
            #[doc = ""]
            #[doc = "Note that this event describes logical contact, not physical"]
            #[doc = "contact. On some devices, a compositor may not consider a tool in"]
            #[doc = "logical contact until a minimum physical pressure threshold is"]
            #[doc = "exceeded."]
            async fn down(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the tablet tool stops making contact with the surface of"]
            #[doc = "the tablet, or when the tablet tool moves out of the input region"]
            #[doc = "and the compositor grab (if any) is dismissed."]
            #[doc = ""]
            #[doc = "If the tablet tool moves out of the input region while in contact"]
            #[doc = "with the surface of the tablet and the compositor does not have an"]
            #[doc = "ongoing grab on the surface, the client owning said region will"]
            #[doc = "receive a wp_tablet.up event, followed by a wp_tablet.proximity_out"]
            #[doc = "event and a wp_tablet.frame event. If the compositor has an ongoing"]
            #[doc = "grab on this device, this event sequence is sent whenever the grab"]
            #[doc = "is dismissed in the future."]
            #[doc = ""]
            #[doc = "Note that this event describes logical contact, not physical"]
            #[doc = "contact. On some devices, a compositor may not consider a tool out"]
            #[doc = "of logical contact until physical pressure falls below a specific"]
            #[doc = "threshold."]
            async fn up(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever a tablet tool moves."]
            async fn motion(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the pressure axis on a tool changes. The value of this"]
            #[doc = "event is normalized to a value between 0 and 65535."]
            #[doc = ""]
            #[doc = "Note that pressure may be nonzero even when a tool is not in logical"]
            #[doc = "contact. See the down and up events for more details."]
            async fn pressure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the distance axis on a tool changes. The value of this"]
            #[doc = "event is normalized to a value between 0 and 65535."]
            #[doc = ""]
            #[doc = "Note that distance may be nonzero even when a tool is not in logical"]
            #[doc = "contact. See the down and up events for more details."]
            async fn distance(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever one or both of the tilt axes on a tool change. Each tilt"]
            #[doc = "value is in degrees, relative to the z-axis of the tablet."]
            #[doc = "The angle is positive when the top of a tool tilts along the"]
            #[doc = "positive x or y axis."]
            async fn tilt(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the z-rotation axis on the tool changes. The"]
            #[doc = "rotation value is in degrees clockwise from the tool's"]
            #[doc = "logical neutral position."]
            async fn rotation(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the slider position on the tool changes. The"]
            #[doc = "value is normalized between -65535 and 65535, with 0 as the logical"]
            #[doc = "neutral position of the slider."]
            #[doc = ""]
            #[doc = "The slider is available on e.g. the Wacom Airbrush tool."]
            async fn slider(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the wheel on the tool emits an event. This event"]
            #[doc = "contains two values for the same axis change. The degrees value is"]
            #[doc = "in the same orientation as the wl_pointer.vertical_scroll axis. The"]
            #[doc = "clicks value is in discrete logical clicks of the mouse wheel. This"]
            #[doc = "value may be zero if the movement of the wheel was less"]
            #[doc = "than one logical click."]
            #[doc = ""]
            #[doc = "Clients should choose either value and avoid mixing degrees and"]
            #[doc = "clicks. The compositor may accumulate values smaller than a logical"]
            #[doc = "click and emulate click events when a certain threshold is met."]
            #[doc = "Thus, wl_tablet_tool.wheel events with non-zero clicks values may"]
            #[doc = "have different degrees values."]
            async fn wheel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever a button on the tool is pressed or released."]
            #[doc = ""]
            #[doc = "If a button is held down when the tool moves in or out of proximity,"]
            #[doc = "button events are generated by the compositor. See"]
            #[doc = "wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for"]
            #[doc = "details."]
            async fn button(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Marks the end of a series of axis and/or button updates from the"]
            #[doc = "tablet. The Wayland protocol requires axis updates to be sent"]
            #[doc = "sequentially, however all events within a frame should be considered"]
            #[doc = "one hardware event."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_tablet_v2 {
        #[doc = "The wp_tablet interface represents one graphics tablet device. The"]
        #[doc = "tablet interface itself does not generate events; all events are"]
        #[doc = "generated by wp_tablet_tool objects when in proximity above a tablet."]
        #[doc = ""]
        #[doc = "A tablet has a number of static characteristics, e.g. device name and"]
        #[doc = "pid/vid. These capabilities are sent in an event sequence after the"]
        #[doc = "wp_tablet_seat.tablet_added event. This initial event sequence is"]
        #[doc = "terminated by a wp_tablet.done event."]
        pub trait ZwpTabletV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This destroys the client's resource for this tablet object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "A descriptive name for the tablet device."]
            #[doc = ""]
            #[doc = "If the device has no descriptive name, this event is not sent."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet.done event."]
            async fn name(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The USB vendor and product IDs for the tablet device."]
            #[doc = ""]
            #[doc = "If the device has no USB vendor/product ID, this event is not sent."]
            #[doc = "This can happen for virtual devices or non-USB devices, for instance."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet.done event."]
            async fn id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "A system-specific device path that indicates which device is behind"]
            #[doc = "this wp_tablet. This information may be used to gather additional"]
            #[doc = "information about the device, e.g. through libwacom."]
            #[doc = ""]
            #[doc = "A device may have more than one device path. If so, multiple"]
            #[doc = "wp_tablet.path events are sent. A device may be emulated and not"]
            #[doc = "have a device path, and in that case this event will not be sent."]
            #[doc = ""]
            #[doc = "The format of the path is unspecified, it may be a device node, a"]
            #[doc = "sysfs path, or some other identifier. It is up to the client to"]
            #[doc = "identify the string provided."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet.done event."]
            async fn path(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent immediately to signal the end of the initial"]
            #[doc = "burst of descriptive events. A client may consider the static"]
            #[doc = "description of the tablet to be complete and finalize initialization"]
            #[doc = "of the tablet."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent when the tablet has been removed from the system. When a tablet"]
            #[doc = "is removed, some tools may be removed."]
            #[doc = ""]
            #[doc = "When this event is received, the client must wp_tablet.destroy"]
            #[doc = "the object."]
            async fn removed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_tablet_pad_ring_v2 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Source {
            Finger = 1u32,
        }
        impl TryFrom<u32> for Source {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "A circular interaction area, such as the touch ring on the Wacom Intuos"]
        #[doc = "Pro series tablets."]
        #[doc = ""]
        #[doc = "Events on a ring are logically grouped by the wl_tablet_pad_ring.frame"]
        #[doc = "event."]
        pub trait ZwpTabletPadRingV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_ring_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_pad_ring_v2#{}.set_feedback()", object.id);
                        self.set_feedback(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_pad_ring_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Request that the compositor use the provided feedback string"]
            #[doc = "associated with this ring. This request should be issued immediately"]
            #[doc = "after a wp_tablet_pad_group.mode_switch event from the corresponding"]
            #[doc = "group is received, or whenever the ring is mapped to a different"]
            #[doc = "action. See wp_tablet_pad_group.mode_switch for more details."]
            #[doc = ""]
            #[doc = "Clients are encouraged to provide context-aware descriptions for"]
            #[doc = "the actions associated with the ring; compositors may use this"]
            #[doc = "information to offer visual feedback about the button layout"]
            #[doc = "(eg. on-screen displays)."]
            #[doc = ""]
            #[doc = "The provided string 'description' is a UTF-8 encoded string to be"]
            #[doc = "associated with this ring, and is considered user-visible; general"]
            #[doc = "internationalization rules apply."]
            #[doc = ""]
            #[doc = "The serial argument will be that of the last"]
            #[doc = "wp_tablet_pad_group.mode_switch event received for the group of this"]
            #[doc = "ring. Requests providing other serials than the most recent one will be"]
            #[doc = "ignored."]
            async fn set_feedback(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                description: String,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This destroys the client's resource for this ring object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Source information for ring events."]
            #[doc = ""]
            #[doc = "This event does not occur on its own. It is sent before a"]
            #[doc = "wp_tablet_pad_ring.frame event and carries the source information"]
            #[doc = "for all events within that frame."]
            #[doc = ""]
            #[doc = "The source specifies how this event was generated. If the source is"]
            #[doc = "wp_tablet_pad_ring.source.finger, a wp_tablet_pad_ring.stop event"]
            #[doc = "will be sent when the user lifts the finger off the device."]
            #[doc = ""]
            #[doc = "This event is optional. If the source is unknown for an interaction,"]
            #[doc = "no event is sent."]
            async fn source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the angle on a ring changes."]
            #[doc = ""]
            #[doc = "The angle is provided in degrees clockwise from the logical"]
            #[doc = "north of the ring in the pad's current rotation."]
            async fn angle(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Stop notification for ring events."]
            #[doc = ""]
            #[doc = "For some wp_tablet_pad_ring.source types, a wp_tablet_pad_ring.stop"]
            #[doc = "event is sent to notify a client that the interaction with the ring"]
            #[doc = "has terminated. This enables the client to implement kinetic scrolling."]
            #[doc = "See the wp_tablet_pad_ring.source documentation for information on"]
            #[doc = "when this event may be generated."]
            #[doc = ""]
            #[doc = "Any wp_tablet_pad_ring.angle events with the same source after this"]
            #[doc = "event should be considered as the start of a new interaction."]
            async fn stop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Indicates the end of a set of ring events that logically belong"]
            #[doc = "together. A client is expected to accumulate the data in all events"]
            #[doc = "within the frame before proceeding."]
            #[doc = ""]
            #[doc = "All wp_tablet_pad_ring events before a wp_tablet_pad_ring.frame event belong"]
            #[doc = "logically together. For example, on termination of a finger interaction"]
            #[doc = "on a ring the compositor will send a wp_tablet_pad_ring.source event,"]
            #[doc = "a wp_tablet_pad_ring.stop event and a wp_tablet_pad_ring.frame event."]
            #[doc = ""]
            #[doc = "A wp_tablet_pad_ring.frame event is sent for every logical event"]
            #[doc = "group, even if the group only contains a single wp_tablet_pad_ring"]
            #[doc = "event. Specifically, a client may get a sequence: angle, frame,"]
            #[doc = "angle, frame, etc."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_tablet_pad_strip_v2 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Source {
            Finger = 1u32,
        }
        impl TryFrom<u32> for Source {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "A linear interaction area, such as the strips found in Wacom Cintiq"]
        #[doc = "models."]
        #[doc = ""]
        #[doc = "Events on a strip are logically grouped by the wl_tablet_pad_strip.frame"]
        #[doc = "event."]
        pub trait ZwpTabletPadStripV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_strip_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_pad_strip_v2#{}.set_feedback()", object.id);
                        self.set_feedback(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_pad_strip_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Requests the compositor to use the provided feedback string"]
            #[doc = "associated with this strip. This request should be issued immediately"]
            #[doc = "after a wp_tablet_pad_group.mode_switch event from the corresponding"]
            #[doc = "group is received, or whenever the strip is mapped to a different"]
            #[doc = "action. See wp_tablet_pad_group.mode_switch for more details."]
            #[doc = ""]
            #[doc = "Clients are encouraged to provide context-aware descriptions for"]
            #[doc = "the actions associated with the strip, and compositors may use this"]
            #[doc = "information to offer visual feedback about the button layout"]
            #[doc = "(eg. on-screen displays)."]
            #[doc = ""]
            #[doc = "The provided string 'description' is a UTF-8 encoded string to be"]
            #[doc = "associated with this ring, and is considered user-visible; general"]
            #[doc = "internationalization rules apply."]
            #[doc = ""]
            #[doc = "The serial argument will be that of the last"]
            #[doc = "wp_tablet_pad_group.mode_switch event received for the group of this"]
            #[doc = "strip. Requests providing other serials than the most recent one will be"]
            #[doc = "ignored."]
            async fn set_feedback(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                description: String,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This destroys the client's resource for this strip object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Source information for strip events."]
            #[doc = ""]
            #[doc = "This event does not occur on its own. It is sent before a"]
            #[doc = "wp_tablet_pad_strip.frame event and carries the source information"]
            #[doc = "for all events within that frame."]
            #[doc = ""]
            #[doc = "The source specifies how this event was generated. If the source is"]
            #[doc = "wp_tablet_pad_strip.source.finger, a wp_tablet_pad_strip.stop event"]
            #[doc = "will be sent when the user lifts their finger off the device."]
            #[doc = ""]
            #[doc = "This event is optional. If the source is unknown for an interaction,"]
            #[doc = "no event is sent."]
            async fn source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the position on a strip changes."]
            #[doc = ""]
            #[doc = "The position is normalized to a range of [0, 65535], the 0-value"]
            #[doc = "represents the top-most and/or left-most position of the strip in"]
            #[doc = "the pad's current rotation."]
            async fn position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Stop notification for strip events."]
            #[doc = ""]
            #[doc = "For some wp_tablet_pad_strip.source types, a wp_tablet_pad_strip.stop"]
            #[doc = "event is sent to notify a client that the interaction with the strip"]
            #[doc = "has terminated. This enables the client to implement kinetic"]
            #[doc = "scrolling. See the wp_tablet_pad_strip.source documentation for"]
            #[doc = "information on when this event may be generated."]
            #[doc = ""]
            #[doc = "Any wp_tablet_pad_strip.position events with the same source after this"]
            #[doc = "event should be considered as the start of a new interaction."]
            async fn stop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Indicates the end of a set of events that represent one logical"]
            #[doc = "hardware strip event. A client is expected to accumulate the data"]
            #[doc = "in all events within the frame before proceeding."]
            #[doc = ""]
            #[doc = "All wp_tablet_pad_strip events before a wp_tablet_pad_strip.frame event belong"]
            #[doc = "logically together. For example, on termination of a finger interaction"]
            #[doc = "on a strip the compositor will send a wp_tablet_pad_strip.source event,"]
            #[doc = "a wp_tablet_pad_strip.stop event and a wp_tablet_pad_strip.frame"]
            #[doc = "event."]
            #[doc = ""]
            #[doc = "A wp_tablet_pad_strip.frame event is sent for every logical event"]
            #[doc = "group, even if the group only contains a single wp_tablet_pad_strip"]
            #[doc = "event. Specifically, a client may get a sequence: position, frame,"]
            #[doc = "position, frame, etc."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_tablet_pad_group_v2 {
        #[doc = "A pad group describes a distinct (sub)set of buttons, rings and strips"]
        #[doc = "present in the tablet. The criteria of this grouping is usually positional,"]
        #[doc = "eg. if a tablet has buttons on the left and right side, 2 groups will be"]
        #[doc = "presented. The physical arrangement of groups is undisclosed and may"]
        #[doc = "change on the fly."]
        #[doc = ""]
        #[doc = "Pad groups will announce their features during pad initialization. Between"]
        #[doc = "the corresponding wp_tablet_pad.group event and wp_tablet_pad_group.done, the"]
        #[doc = "pad group will announce the buttons, rings and strips contained in it,"]
        #[doc = "plus the number of supported modes."]
        #[doc = ""]
        #[doc = "Modes are a mechanism to allow multiple groups of actions for every element"]
        #[doc = "in the pad group. The number of groups and available modes in each is"]
        #[doc = "persistent across device plugs. The current mode is user-switchable, it"]
        #[doc = "will be announced through the wp_tablet_pad_group.mode_switch event both"]
        #[doc = "whenever it is switched, and after wp_tablet_pad.enter."]
        #[doc = ""]
        #[doc = "The current mode logically applies to all elements in the pad group,"]
        #[doc = "although it is at clients' discretion whether to actually perform different"]
        #[doc = "actions, and/or issue the respective .set_feedback requests to notify the"]
        #[doc = "compositor. See the wp_tablet_pad_group.mode_switch event for more details."]
        pub trait ZwpTabletPadGroupV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_group_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_pad_group_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the wp_tablet_pad_group object. Objects created from this object"]
            #[doc = "are unaffected and should be destroyed separately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sent on wp_tablet_pad_group initialization to announce the available"]
            #[doc = "buttons in the group. Button indices start at 0, a button may only be"]
            #[doc = "in one group at a time."]
            #[doc = ""]
            #[doc = "This event is first sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad_group.done event."]
            #[doc = ""]
            #[doc = "Some buttons are reserved by the compositor. These buttons may not be"]
            #[doc = "assigned to any wp_tablet_pad_group. Compositors may broadcast this"]
            #[doc = "event in the case of changes to the mapping of these reserved buttons."]
            #[doc = "If the compositor happens to reserve all buttons in a group, this event"]
            #[doc = "will be sent with an empty array."]
            async fn buttons(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent on wp_tablet_pad_group initialization to announce available rings."]
            #[doc = "One event is sent for each ring available on this pad group."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad_group.done event."]
            async fn ring(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent on wp_tablet_pad initialization to announce available strips."]
            #[doc = "One event is sent for each strip available on this pad group."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad_group.done event."]
            async fn strip(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent on wp_tablet_pad_group initialization to announce that the pad"]
            #[doc = "group may switch between modes. A client may use a mode to store a"]
            #[doc = "specific configuration for buttons, rings and strips and use the"]
            #[doc = "wl_tablet_pad_group.mode_switch event to toggle between these"]
            #[doc = "configurations. Mode indices start at 0."]
            #[doc = ""]
            #[doc = "Switching modes is compositor-dependent. See the"]
            #[doc = "wp_tablet_pad_group.mode_switch event for more details."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad_group.done event. This event is only sent when more than"]
            #[doc = "more than one mode is available."]
            async fn modes(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent immediately to signal the end of the initial"]
            #[doc = "burst of descriptive events. A client may consider the static"]
            #[doc = "description of the tablet to be complete and finalize initialization"]
            #[doc = "of the tablet group."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notification that the mode was switched."]
            #[doc = ""]
            #[doc = "A mode applies to all buttons, rings and strips in a group"]
            #[doc = "simultaneously, but a client is not required to assign different actions"]
            #[doc = "for each mode. For example, a client may have mode-specific button"]
            #[doc = "mappings but map the ring to vertical scrolling in all modes. Mode"]
            #[doc = "indices start at 0."]
            #[doc = ""]
            #[doc = "Switching modes is compositor-dependent. The compositor may provide"]
            #[doc = "visual cues to the client about the mode, e.g. by toggling LEDs on"]
            #[doc = "the tablet device. Mode-switching may be software-controlled or"]
            #[doc = "controlled by one or more physical buttons. For example, on a Wacom"]
            #[doc = "Intuos Pro, the button inside the ring may be assigned to switch"]
            #[doc = "between modes."]
            #[doc = ""]
            #[doc = "The compositor will also send this event after wp_tablet_pad.enter on"]
            #[doc = "each group in order to notify of the current mode. Groups that only"]
            #[doc = "feature one mode will use mode=0 when emitting this event."]
            #[doc = ""]
            #[doc = "If a button action in the new mode differs from the action in the"]
            #[doc = "previous mode, the client should immediately issue a"]
            #[doc = "wp_tablet_pad.set_feedback request for each changed button."]
            #[doc = ""]
            #[doc = "If a ring or strip action in the new mode differs from the action"]
            #[doc = "in the previous mode, the client should immediately issue a"]
            #[doc = "wp_tablet_ring.set_feedback or wp_tablet_strip.set_feedback request"]
            #[doc = "for each changed ring or strip."]
            async fn mode_switch(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_tablet_pad_v2 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ButtonState {
            Released = 0u32,
            Pressed = 1u32,
        }
        impl TryFrom<u32> for ButtonState {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "A pad device is a set of buttons, rings and strips"]
        #[doc = "usually physically present on the tablet device itself. Some"]
        #[doc = "exceptions exist where the pad device is physically detached, e.g. the"]
        #[doc = "Wacom ExpressKey Remote."]
        #[doc = ""]
        #[doc = "Pad devices have no axes that control the cursor and are generally"]
        #[doc = "auxiliary devices to the tool devices used on the tablet surface."]
        #[doc = ""]
        #[doc = "A pad device has a number of static characteristics, e.g. the number"]
        #[doc = "of rings. These capabilities are sent in an event sequence after the"]
        #[doc = "wp_tablet_seat.pad_added event before any actual events from this pad."]
        #[doc = "This initial event sequence is terminated by a wp_tablet_pad.done"]
        #[doc = "event."]
        #[doc = ""]
        #[doc = "All pad features (buttons, rings and strips) are logically divided into"]
        #[doc = "groups and all pads have at least one group. The available groups are"]
        #[doc = "notified through the wp_tablet_pad.group event; the compositor will"]
        #[doc = "emit one event per group before emitting wp_tablet_pad.done."]
        #[doc = ""]
        #[doc = "Groups may have multiple modes. Modes allow clients to map multiple"]
        #[doc = "actions to a single pad feature. Only one mode can be active per group,"]
        #[doc = "although different groups may have different active modes."]
        pub trait ZwpTabletPadV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_pad_v2#{}.set_feedback()", object.id);
                        self.set_feedback(
                            object,
                            client,
                            message.uint()?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_pad_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Requests the compositor to use the provided feedback string"]
            #[doc = "associated with this button. This request should be issued immediately"]
            #[doc = "after a wp_tablet_pad_group.mode_switch event from the corresponding"]
            #[doc = "group is received, or whenever a button is mapped to a different"]
            #[doc = "action. See wp_tablet_pad_group.mode_switch for more details."]
            #[doc = ""]
            #[doc = "Clients are encouraged to provide context-aware descriptions for"]
            #[doc = "the actions associated with each button, and compositors may use"]
            #[doc = "this information to offer visual feedback on the button layout"]
            #[doc = "(e.g. on-screen displays)."]
            #[doc = ""]
            #[doc = "Button indices start at 0. Setting the feedback string on a button"]
            #[doc = "that is reserved by the compositor (i.e. not belonging to any"]
            #[doc = "wp_tablet_pad_group) does not generate an error but the compositor"]
            #[doc = "is free to ignore the request."]
            #[doc = ""]
            #[doc = "The provided string 'description' is a UTF-8 encoded string to be"]
            #[doc = "associated with this ring, and is considered user-visible; general"]
            #[doc = "internationalization rules apply."]
            #[doc = ""]
            #[doc = "The serial argument will be that of the last"]
            #[doc = "wp_tablet_pad_group.mode_switch event received for the group of this"]
            #[doc = "button. Requests providing other serials than the most recent one will"]
            #[doc = "be ignored."]
            async fn set_feedback(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                button: u32,
                description: String,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the wp_tablet_pad object. Objects created from this object"]
            #[doc = "are unaffected and should be destroyed separately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sent on wp_tablet_pad initialization to announce available groups."]
            #[doc = "One event is sent for each pad group available."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad.done event. At least one group will be announced."]
            async fn group(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "A system-specific device path that indicates which device is behind"]
            #[doc = "this wp_tablet_pad. This information may be used to gather additional"]
            #[doc = "information about the device, e.g. through libwacom."]
            #[doc = ""]
            #[doc = "The format of the path is unspecified, it may be a device node, a"]
            #[doc = "sysfs path, or some other identifier. It is up to the client to"]
            #[doc = "identify the string provided."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad.done event."]
            async fn path(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent on wp_tablet_pad initialization to announce the available"]
            #[doc = "buttons."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad.done event. This event is only sent when at least one"]
            #[doc = "button is available."]
            async fn buttons(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event signals the end of the initial burst of descriptive"]
            #[doc = "events. A client may consider the static description of the pad to"]
            #[doc = "be complete and finalize initialization of the pad."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent whenever the physical state of a button changes."]
            async fn button(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notification that this pad is focused on the specified surface."]
            async fn enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notification that this pad is no longer focused on the specified"]
            #[doc = "surface."]
            async fn leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent when the pad has been removed from the system. When a tablet"]
            #[doc = "is removed its pad(s) will be removed too."]
            #[doc = ""]
            #[doc = "When this event is received, the client must destroy all rings, strips"]
            #[doc = "and groups that were offered by this pad, and issue wp_tablet_pad.destroy"]
            #[doc = "the pad itself."]
            async fn removed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
pub mod text_input_unstable_v1 {
    pub mod zwp_text_input_v1 {
        bitflags::bitflags! { # [doc = "Content hint is a bitmask to allow to modify the behavior of the text"] # [doc = "input."] # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct ContentHint : u32 { # [doc = "no special behaviour"] const None = 0u32 ; # [doc = "auto completion, correction and capitalization"] const Default = 7u32 ; # [doc = "hidden and sensitive text"] const Password = 192u32 ; # [doc = "suggest word completions"] const AutoCompletion = 1u32 ; # [doc = "suggest word corrections"] const AutoCorrection = 2u32 ; # [doc = "switch to uppercase letters at the start of a sentence"] const AutoCapitalization = 4u32 ; # [doc = "prefer lowercase letters"] const Lowercase = 8u32 ; # [doc = "prefer uppercase letters"] const Uppercase = 16u32 ; # [doc = "prefer casing for titles and headings (can be language dependent)"] const Titlecase = 32u32 ; # [doc = "characters should be hidden"] const HiddenText = 64u32 ; # [doc = "typed text should not be stored"] const SensitiveData = 128u32 ; # [doc = "just latin characters should be entered"] const Latin = 256u32 ; # [doc = "the text input is multiline"] const Multiline = 512u32 ; } }
        impl TryFrom<u32> for ContentHint {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ContentPurpose {
            Normal = 0u32,
            Alpha = 1u32,
            Digits = 2u32,
            Number = 3u32,
            Phone = 4u32,
            Url = 5u32,
            Email = 6u32,
            Name = 7u32,
            Password = 8u32,
            Date = 9u32,
            Time = 10u32,
            Datetime = 11u32,
            Terminal = 12u32,
        }
        impl TryFrom<u32> for ContentPurpose {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum PreeditStyle {
            Default = 0u32,
            None = 1u32,
            Active = 2u32,
            Inactive = 3u32,
            Highlight = 4u32,
            Underline = 5u32,
            Selection = 6u32,
            Incorrect = 7u32,
        }
        impl TryFrom<u32> for PreeditStyle {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum TextDirection {
            Auto = 0u32,
            Ltr = 1u32,
            Rtl = 2u32,
        }
        impl TryFrom<u32> for TextDirection {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "An object used for text input. Adds support for text input and input"]
        #[doc = "methods to applications. A text_input object is created from a"]
        #[doc = "wl_text_input_manager and corresponds typically to a text entry in an"]
        #[doc = "application."]
        #[doc = ""]
        #[doc = "Requests are used to activate/deactivate the text_input object and set"]
        #[doc = "state information like surrounding and selected text or the content type."]
        #[doc = "The information about entered text is sent to the text_input object via"]
        #[doc = "the pre-edit and commit events. Using this interface removes the need"]
        #[doc = "for applications to directly process hardware key events and compose text"]
        #[doc = "out of them."]
        #[doc = ""]
        #[doc = "Text is generally UTF-8 encoded, indices and lengths are in bytes."]
        #[doc = ""]
        #[doc = "Serials are used to synchronize the state between the text input and"]
        #[doc = "an input method. New serials are sent by the text input in the"]
        #[doc = "commit_state request and are used by the input method to indicate"]
        #[doc = "the known text input state in events like preedit_string, commit_string,"]
        #[doc = "and keysym. The text input can then ignore events from the input method"]
        #[doc = "which are based on an outdated state (for example after a reset)."]
        #[doc = ""]
        #[doc = "Warning! The protocol described in this file is experimental and"]
        #[doc = "backward incompatible changes may be made. Backward compatible changes"]
        #[doc = "may be added together with the corresponding interface version bump."]
        #[doc = "Backward incompatible changes are done by bumping the version number in"]
        #[doc = "the protocol and interface names and resetting the interface version."]
        #[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
        #[doc = "version number in the protocol and interface names are removed and the"]
        #[doc = "interface version number is reset."]
        pub trait ZwpTextInputV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_text_input_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_text_input_v1#{}.activate()", object.id);
                        self.activate(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_text_input_v1#{}.deactivate()", object.id);
                        self.deactivate(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zwp_text_input_v1#{}.show_input_panel()", object.id);
                        self.show_input_panel(object, client).await
                    }
                    3u16 => {
                        tracing::debug!("zwp_text_input_v1#{}.hide_input_panel()", object.id);
                        self.hide_input_panel(object, client).await
                    }
                    4u16 => {
                        tracing::debug!("zwp_text_input_v1#{}.reset()", object.id);
                        self.reset(object, client).await
                    }
                    5u16 => {
                        tracing::debug!("zwp_text_input_v1#{}.set_surrounding_text()", object.id);
                        self.set_surrounding_text(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    6u16 => {
                        tracing::debug!("zwp_text_input_v1#{}.set_content_type()", object.id);
                        self.set_content_type(
                            object,
                            client,
                            message.uint()?.try_into()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    7u16 => {
                        tracing::debug!("zwp_text_input_v1#{}.set_cursor_rectangle()", object.id);
                        self.set_cursor_rectangle(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    8u16 => {
                        tracing::debug!("zwp_text_input_v1#{}.set_preferred_language()", object.id);
                        self.set_preferred_language(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    9u16 => {
                        tracing::debug!("zwp_text_input_v1#{}.commit_state()", object.id);
                        self.commit_state(object, client, message.uint()?).await
                    }
                    10u16 => {
                        tracing::debug!("zwp_text_input_v1#{}.invoke_action()", object.id);
                        self.invoke_action(object, client, message.uint()?, message.uint()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Requests the text_input object to be activated (typically when the"]
            #[doc = "text entry gets focus)."]
            #[doc = ""]
            #[doc = "The seat argument is a wl_seat which maintains the focus for this"]
            #[doc = "activation. The surface argument is a wl_surface assigned to the"]
            #[doc = "text_input object and tracked for focus lost. The enter event"]
            #[doc = "is emitted on successful activation."]
            async fn activate(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Requests the text_input object to be deactivated (typically when the"]
            #[doc = "text entry lost focus). The seat argument is a wl_seat which was used"]
            #[doc = "for activation."]
            async fn deactivate(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Requests input panels (virtual keyboard) to show."]
            async fn show_input_panel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Requests input panels (virtual keyboard) to hide."]
            async fn hide_input_panel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Should be called by an editor widget when the input state should be"]
            #[doc = "reset, for example after the text was changed outside of the normal"]
            #[doc = "input method flow."]
            async fn reset(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the plain surrounding text around the input position. Text is"]
            #[doc = "UTF-8 encoded. Cursor is the byte offset within the"]
            #[doc = "surrounding text. Anchor is the byte offset of the"]
            #[doc = "selection anchor within the surrounding text. If there is no selected"]
            #[doc = "text anchor, then it is the same as cursor."]
            async fn set_surrounding_text(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                text: String,
                cursor: u32,
                anchor: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the content purpose and content hint. While the purpose is the"]
            #[doc = "basic purpose of an input field, the hint flags allow to modify some"]
            #[doc = "of the behavior."]
            #[doc = ""]
            #[doc = "When no content type is explicitly set, a normal content purpose with"]
            #[doc = "default hints (auto completion, auto correction, auto capitalization)"]
            #[doc = "should be assumed."]
            async fn set_content_type(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                hint: ContentHint,
                purpose: ContentPurpose,
            ) -> crate::server::Result<()>;
            async fn set_cursor_rectangle(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Sets a specific language. This allows for example a virtual keyboard to"]
            #[doc = "show a language specific layout. The \"language\" argument is an RFC-3066"]
            #[doc = "format language tag."]
            #[doc = ""]
            #[doc = "It could be used for example in a word processor to indicate the"]
            #[doc = "language of the currently edited document or in an instant message"]
            #[doc = "application which tracks languages of contacts."]
            async fn set_preferred_language(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                language: String,
            ) -> crate::server::Result<()>;
            async fn commit_state(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()>;
            async fn invoke_action(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                button: u32,
                index: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Notify the text_input object when it received focus. Typically in"]
            #[doc = "response to an activate request."]
            async fn enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notify the text_input object when it lost focus. Either in response"]
            #[doc = "to a deactivate request or when the assigned surface lost focus or was"]
            #[doc = "destroyed."]
            async fn leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Transfer an array of 0-terminated modifier names. The position in"]
            #[doc = "the array is the index of the modifier as used in the modifiers"]
            #[doc = "bitmask in the keysym event."]
            async fn modifiers_map(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notify when the visibility state of the input panel changed."]
            async fn input_panel_state(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notify when a new composing text (pre-edit) should be set around the"]
            #[doc = "current cursor position. Any previously set composing text should"]
            #[doc = "be removed."]
            #[doc = ""]
            #[doc = "The commit text can be used to replace the preedit text on reset"]
            #[doc = "(for example on unfocus)."]
            #[doc = ""]
            #[doc = "The text input should also handle all preedit_style and preedit_cursor"]
            #[doc = "events occurring directly before preedit_string."]
            async fn preedit_string(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sets styling information on composing text. The style is applied for"]
            #[doc = "length bytes from index relative to the beginning of the composing"]
            #[doc = "text (as byte offset). Multiple styles can"]
            #[doc = "be applied to a composing text by sending multiple preedit_styling"]
            #[doc = "events."]
            #[doc = ""]
            #[doc = "This event is handled as part of a following preedit_string event."]
            async fn preedit_styling(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sets the cursor position inside the composing text (as byte"]
            #[doc = "offset) relative to the start of the composing text. When index is a"]
            #[doc = "negative number no cursor is shown."]
            #[doc = ""]
            #[doc = "This event is handled as part of a following preedit_string event."]
            async fn preedit_cursor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notify when text should be inserted into the editor widget. The text to"]
            #[doc = "commit could be either just a single character after a key press or the"]
            #[doc = "result of some composing (pre-edit). It could also be an empty text"]
            #[doc = "when some text should be removed (see delete_surrounding_text) or when"]
            #[doc = "the input cursor should be moved (see cursor_position)."]
            #[doc = ""]
            #[doc = "Any previously set composing text should be removed."]
            async fn commit_string(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notify when the cursor or anchor position should be modified."]
            #[doc = ""]
            #[doc = "This event should be handled as part of a following commit_string"]
            #[doc = "event."]
            async fn cursor_position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notify when the text around the current cursor position should be"]
            #[doc = "deleted."]
            #[doc = ""]
            #[doc = "Index is relative to the current cursor (in bytes)."]
            #[doc = "Length is the length of deleted text (in bytes)."]
            #[doc = ""]
            #[doc = "This event should be handled as part of a following commit_string"]
            #[doc = "event."]
            async fn delete_surrounding_text(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notify when a key event was sent. Key events should not be used"]
            #[doc = "for normal text input operations, which should be done with"]
            #[doc = "commit_string, delete_surrounding_text, etc. The key event follows"]
            #[doc = "the wl_keyboard key event convention. Sym is an XKB keysym, state a"]
            #[doc = "wl_keyboard key_state. Modifiers are a mask for effective modifiers"]
            #[doc = "(where the modifier indices are set by the modifiers_map event)"]
            async fn keysym(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sets the language of the input text. The \"language\" argument is an"]
            #[doc = "RFC-3066 format language tag."]
            async fn language(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sets the text direction of input text."]
            #[doc = ""]
            #[doc = "It is mainly needed for showing an input cursor on the correct side of"]
            #[doc = "the editor when there is no input done yet and making sure neutral"]
            #[doc = "direction text is laid out properly."]
            async fn text_direction(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_text_input_manager_v1 {
        #[doc = "A factory for text_input objects. This object is a global singleton."]
        pub trait ZwpTextInputManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_text_input_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwp_text_input_manager_v1#{}.create_text_input()",
                            object.id
                        );
                        self.create_text_input(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Creates a new text_input object."]
            async fn create_text_input(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
}
#[doc = "This protocol allows compositors to act as input methods and to send text"]
#[doc = "to applications. A text input object is used to manage state of what are"]
#[doc = "typically text entry fields in the application."]
#[doc = ""]
#[doc = "This document adheres to the RFC 2119 when using words like \"must\","]
#[doc = "\"should\", \"may\", etc."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and"]
#[doc = "backward incompatible changes may be made. Backward compatible changes"]
#[doc = "may be added together with the corresponding interface version bump."]
#[doc = "Backward incompatible changes are done by bumping the version number in"]
#[doc = "the protocol and interface names and resetting the interface version."]
#[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
#[doc = "version number in the protocol and interface names are removed and the"]
#[doc = "interface version number is reset."]
pub mod text_input_unstable_v3 {
    pub mod zwp_text_input_v3 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ChangeCause {
            InputMethod = 0u32,
            Other = 1u32,
        }
        impl TryFrom<u32> for ChangeCause {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! { # [doc = "Content hint is a bitmask to allow to modify the behavior of the text"] # [doc = "input."] # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct ContentHint : u32 { # [doc = "no special behavior"] const None = 0u32 ; # [doc = "suggest word completions"] const Completion = 1u32 ; # [doc = "suggest word corrections"] const Spellcheck = 2u32 ; # [doc = "switch to uppercase letters at the start of a sentence"] const AutoCapitalization = 4u32 ; # [doc = "prefer lowercase letters"] const Lowercase = 8u32 ; # [doc = "prefer uppercase letters"] const Uppercase = 16u32 ; # [doc = "prefer casing for titles and headings (can be language dependent)"] const Titlecase = 32u32 ; # [doc = "characters should be hidden"] const HiddenText = 64u32 ; # [doc = "typed text should not be stored"] const SensitiveData = 128u32 ; # [doc = "just Latin characters should be entered"] const Latin = 256u32 ; # [doc = "the text input is multiline"] const Multiline = 512u32 ; } }
        impl TryFrom<u32> for ContentHint {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ContentPurpose {
            Normal = 0u32,
            Alpha = 1u32,
            Digits = 2u32,
            Number = 3u32,
            Phone = 4u32,
            Url = 5u32,
            Email = 6u32,
            Name = 7u32,
            Password = 8u32,
            Pin = 9u32,
            Date = 10u32,
            Time = 11u32,
            Datetime = 12u32,
            Terminal = 13u32,
        }
        impl TryFrom<u32> for ContentPurpose {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "The zwp_text_input_v3 interface represents text input and input methods"]
        #[doc = "associated with a seat. It provides enter/leave events to follow the"]
        #[doc = "text input focus for a seat."]
        #[doc = ""]
        #[doc = "Requests are used to enable/disable the text-input object and set"]
        #[doc = "state information like surrounding and selected text or the content type."]
        #[doc = "The information about the entered text is sent to the text-input object"]
        #[doc = "via the preedit_string and commit_string events."]
        #[doc = ""]
        #[doc = "Text is valid UTF-8 encoded, indices and lengths are in bytes. Indices"]
        #[doc = "must not point to middle bytes inside a code point: they must either"]
        #[doc = "point to the first byte of a code point or to the end of the buffer."]
        #[doc = "Lengths must be measured between two valid indices."]
        #[doc = ""]
        #[doc = "Focus moving throughout surfaces will result in the emission of"]
        #[doc = "zwp_text_input_v3.enter and zwp_text_input_v3.leave events. The focused"]
        #[doc = "surface must commit zwp_text_input_v3.enable and"]
        #[doc = "zwp_text_input_v3.disable requests as the keyboard focus moves across"]
        #[doc = "editable and non-editable elements of the UI. Those two requests are not"]
        #[doc = "expected to be paired with each other, the compositor must be able to"]
        #[doc = "handle consecutive series of the same request."]
        #[doc = ""]
        #[doc = "State is sent by the state requests (set_surrounding_text,"]
        #[doc = "set_content_type and set_cursor_rectangle) and a commit request. After an"]
        #[doc = "enter event or disable request all state information is invalidated and"]
        #[doc = "needs to be resent by the client."]
        pub trait ZwpTextInputV3: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_text_input_v3";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_text_input_v3#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zwp_text_input_v3#{}.enable()", object.id);
                        self.enable(object, client).await
                    }
                    2u16 => {
                        tracing::debug!("zwp_text_input_v3#{}.disable()", object.id);
                        self.disable(object, client).await
                    }
                    3u16 => {
                        tracing::debug!("zwp_text_input_v3#{}.set_surrounding_text()", object.id);
                        self.set_surrounding_text(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("zwp_text_input_v3#{}.set_text_change_cause()", object.id);
                        self.set_text_change_cause(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    5u16 => {
                        tracing::debug!("zwp_text_input_v3#{}.set_content_type()", object.id);
                        self.set_content_type(
                            object,
                            client,
                            message.uint()?.try_into()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    6u16 => {
                        tracing::debug!("zwp_text_input_v3#{}.set_cursor_rectangle()", object.id);
                        self.set_cursor_rectangle(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    7u16 => {
                        tracing::debug!("zwp_text_input_v3#{}.commit()", object.id);
                        self.commit(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the wp_text_input object. Also disables all surfaces enabled"]
            #[doc = "through this wp_text_input object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Requests text input on the surface previously obtained from the enter"]
            #[doc = "event."]
            #[doc = ""]
            #[doc = "This request must be issued every time the active text input changes"]
            #[doc = "to a new one, including within the current surface. Use"]
            #[doc = "zwp_text_input_v3.disable when there is no longer any input focus on"]
            #[doc = "the current surface."]
            #[doc = ""]
            #[doc = "Clients must not enable more than one text input on the single seat"]
            #[doc = "and should disable the current text input before enabling the new one."]
            #[doc = "At most one instance of text input may be in enabled state per instance,"]
            #[doc = "Requests to enable the another text input when some text input is active"]
            #[doc = "must be ignored by compositor."]
            #[doc = ""]
            #[doc = "This request resets all state associated with previous enable, disable,"]
            #[doc = "set_surrounding_text, set_text_change_cause, set_content_type, and"]
            #[doc = "set_cursor_rectangle requests, as well as the state associated with"]
            #[doc = "preedit_string, commit_string, and delete_surrounding_text events."]
            #[doc = ""]
            #[doc = "The set_surrounding_text, set_content_type and set_cursor_rectangle"]
            #[doc = "requests must follow if the text input supports the necessary"]
            #[doc = "functionality."]
            #[doc = ""]
            #[doc = "State set with this request is double-buffered. It will get applied on"]
            #[doc = "the next zwp_text_input_v3.commit request, and stay valid until the"]
            #[doc = "next committed enable or disable request."]
            #[doc = ""]
            #[doc = "The changes must be applied by the compositor after issuing a"]
            #[doc = "zwp_text_input_v3.commit request."]
            async fn enable(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Explicitly disable text input on the current surface (typically when"]
            #[doc = "there is no focus on any text entry inside the surface)."]
            #[doc = ""]
            #[doc = "State set with this request is double-buffered. It will get applied on"]
            #[doc = "the next zwp_text_input_v3.commit request."]
            async fn disable(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the surrounding plain text around the input, excluding the preedit"]
            #[doc = "text."]
            #[doc = ""]
            #[doc = "The client should notify the compositor of any changes in any of the"]
            #[doc = "values carried with this request, including changes caused by handling"]
            #[doc = "incoming text-input events as well as changes caused by other"]
            #[doc = "mechanisms like keyboard typing."]
            #[doc = ""]
            #[doc = "If the client is unaware of the text around the cursor, it should not"]
            #[doc = "issue this request, to signify lack of support to the compositor."]
            #[doc = ""]
            #[doc = "Text is UTF-8 encoded, and should include the cursor position, the"]
            #[doc = "complete selection and additional characters before and after them."]
            #[doc = "There is a maximum length of wayland messages, so text can not be"]
            #[doc = "longer than 4000 bytes."]
            #[doc = ""]
            #[doc = "Cursor is the byte offset of the cursor within text buffer."]
            #[doc = ""]
            #[doc = "Anchor is the byte offset of the selection anchor within text buffer."]
            #[doc = "If there is no selected text, anchor is the same as cursor."]
            #[doc = ""]
            #[doc = "If any preedit text is present, it is replaced with a cursor for the"]
            #[doc = "purpose of this event."]
            #[doc = ""]
            #[doc = "Values set with this request are double-buffered. They will get applied"]
            #[doc = "on the next zwp_text_input_v3.commit request, and stay valid until the"]
            #[doc = "next committed enable or disable request."]
            #[doc = ""]
            #[doc = "The initial state for affected fields is empty, meaning that the text"]
            #[doc = "input does not support sending surrounding text. If the empty values"]
            #[doc = "get applied, subsequent attempts to change them may have no effect."]
            async fn set_surrounding_text(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                text: String,
                cursor: i32,
                anchor: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Tells the compositor why the text surrounding the cursor changed."]
            #[doc = ""]
            #[doc = "Whenever the client detects an external change in text, cursor, or"]
            #[doc = "anchor posision, it must issue this request to the compositor. This"]
            #[doc = "request is intended to give the input method a chance to update the"]
            #[doc = "preedit text in an appropriate way, e.g. by removing it when the user"]
            #[doc = "starts typing with a keyboard."]
            #[doc = ""]
            #[doc = "cause describes the source of the change."]
            #[doc = ""]
            #[doc = "The value set with this request is double-buffered. It must be applied"]
            #[doc = "and reset to initial at the next zwp_text_input_v3.commit request."]
            #[doc = ""]
            #[doc = "The initial value of cause is input_method."]
            async fn set_text_change_cause(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                cause: ChangeCause,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the content purpose and content hint. While the purpose is the"]
            #[doc = "basic purpose of an input field, the hint flags allow to modify some of"]
            #[doc = "the behavior."]
            #[doc = ""]
            #[doc = "Values set with this request are double-buffered. They will get applied"]
            #[doc = "on the next zwp_text_input_v3.commit request."]
            #[doc = "Subsequent attempts to update them may have no effect. The values"]
            #[doc = "remain valid until the next committed enable or disable request."]
            #[doc = ""]
            #[doc = "The initial value for hint is none, and the initial value for purpose"]
            #[doc = "is normal."]
            async fn set_content_type(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                hint: ContentHint,
                purpose: ContentPurpose,
            ) -> crate::server::Result<()>;
            #[doc = "Marks an area around the cursor as a x, y, width, height rectangle in"]
            #[doc = "surface local coordinates."]
            #[doc = ""]
            #[doc = "Allows the compositor to put a window with word suggestions near the"]
            #[doc = "cursor, without obstructing the text being input."]
            #[doc = ""]
            #[doc = "If the client is unaware of the position of edited text, it should not"]
            #[doc = "issue this request, to signify lack of support to the compositor."]
            #[doc = ""]
            #[doc = "Values set with this request are double-buffered. They will get applied"]
            #[doc = "on the next zwp_text_input_v3.commit request, and stay valid until the"]
            #[doc = "next committed enable or disable request."]
            #[doc = ""]
            #[doc = "The initial values describing a cursor rectangle are empty. That means"]
            #[doc = "the text input does not support describing the cursor area. If the"]
            #[doc = "empty values get applied, subsequent attempts to change them may have"]
            #[doc = "no effect."]
            async fn set_cursor_rectangle(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Atomically applies state changes recently sent to the compositor."]
            #[doc = ""]
            #[doc = "The commit request establishes and updates the state of the client, and"]
            #[doc = "must be issued after any changes to apply them."]
            #[doc = ""]
            #[doc = "Text input state (enabled status, content purpose, content hint,"]
            #[doc = "surrounding text and change cause, cursor rectangle) is conceptually"]
            #[doc = "double-buffered within the context of a text input, i.e. between a"]
            #[doc = "committed enable request and the following committed enable or disable"]
            #[doc = "request."]
            #[doc = ""]
            #[doc = "Protocol requests modify the pending state, as opposed to the current"]
            #[doc = "state in use by the input method. A commit request atomically applies"]
            #[doc = "all pending state, replacing the current state. After commit, the new"]
            #[doc = "pending state is as documented for each related request."]
            #[doc = ""]
            #[doc = "Requests are applied in the order of arrival."]
            #[doc = ""]
            #[doc = "Neither current nor pending state are modified unless noted otherwise."]
            #[doc = ""]
            #[doc = "The compositor must count the number of commit requests coming from"]
            #[doc = "each zwp_text_input_v3 object and use the count as the serial in done"]
            #[doc = "events."]
            async fn commit(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Notification that this seat's text-input focus is on a certain surface."]
            #[doc = ""]
            #[doc = "If client has created multiple text input objects, compositor must send"]
            #[doc = "this event to all of them."]
            #[doc = ""]
            #[doc = "When the seat has the keyboard capability the text-input focus follows"]
            #[doc = "the keyboard focus. This event sets the current surface for the"]
            #[doc = "text-input object."]
            async fn enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notification that this seat's text-input focus is no longer on a"]
            #[doc = "certain surface. The client should reset any preedit string previously"]
            #[doc = "set."]
            #[doc = ""]
            #[doc = "The leave notification clears the current surface. It is sent before"]
            #[doc = "the enter notification for the new focus. After leave event, compositor"]
            #[doc = "must ignore requests from any text input instances until next enter"]
            #[doc = "event."]
            #[doc = ""]
            #[doc = "When the seat has the keyboard capability the text-input focus follows"]
            #[doc = "the keyboard focus."]
            async fn leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notify when a new composing text (pre-edit) should be set at the"]
            #[doc = "current cursor position. Any previously set composing text must be"]
            #[doc = "removed. Any previously existing selected text must be removed."]
            #[doc = ""]
            #[doc = "The argument text contains the pre-edit string buffer."]
            #[doc = ""]
            #[doc = "The parameters cursor_begin and cursor_end are counted in bytes"]
            #[doc = "relative to the beginning of the submitted text buffer. Cursor should"]
            #[doc = "be hidden when both are equal to -1."]
            #[doc = ""]
            #[doc = "They could be represented by the client as a line if both values are"]
            #[doc = "the same, or as a text highlight otherwise."]
            #[doc = ""]
            #[doc = "Values set with this event are double-buffered. They must be applied"]
            #[doc = "and reset to initial on the next zwp_text_input_v3.done event."]
            #[doc = ""]
            #[doc = "The initial value of text is an empty string, and cursor_begin,"]
            #[doc = "cursor_end and cursor_hidden are all 0."]
            async fn preedit_string(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notify when text should be inserted into the editor widget. The text to"]
            #[doc = "commit could be either just a single character after a key press or the"]
            #[doc = "result of some composing (pre-edit)."]
            #[doc = ""]
            #[doc = "Values set with this event are double-buffered. They must be applied"]
            #[doc = "and reset to initial on the next zwp_text_input_v3.done event."]
            #[doc = ""]
            #[doc = "The initial value of text is an empty string."]
            async fn commit_string(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Notify when the text around the current cursor position should be"]
            #[doc = "deleted."]
            #[doc = ""]
            #[doc = "Before_length and after_length are the number of bytes before and after"]
            #[doc = "the current cursor index (excluding the selection) to delete."]
            #[doc = ""]
            #[doc = "If a preedit text is present, in effect before_length is counted from"]
            #[doc = "the beginning of it, and after_length from its end (see done event"]
            #[doc = "sequence)."]
            #[doc = ""]
            #[doc = "Values set with this event are double-buffered. They must be applied"]
            #[doc = "and reset to initial on the next zwp_text_input_v3.done event."]
            #[doc = ""]
            #[doc = "The initial values of both before_length and after_length are 0."]
            async fn delete_surrounding_text(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Instruct the application to apply changes to state requested by the"]
            #[doc = "preedit_string, commit_string and delete_surrounding_text events. The"]
            #[doc = "state relating to these events is double-buffered, and each one"]
            #[doc = "modifies the pending state. This event replaces the current state with"]
            #[doc = "the pending state."]
            #[doc = ""]
            #[doc = "The application must proceed by evaluating the changes in the following"]
            #[doc = "order:"]
            #[doc = ""]
            #[doc = "1. Replace existing preedit string with the cursor."]
            #[doc = "2. Delete requested surrounding text."]
            #[doc = "3. Insert commit string with the cursor at its end."]
            #[doc = "4. Calculate surrounding text to send."]
            #[doc = "5. Insert new preedit text in cursor position."]
            #[doc = "6. Place cursor inside preedit text."]
            #[doc = ""]
            #[doc = "The serial number reflects the last state of the zwp_text_input_v3"]
            #[doc = "object known to the compositor. The value of the serial argument must"]
            #[doc = "be equal to the number of commit requests already issued on that object."]
            #[doc = ""]
            #[doc = "When the client receives a done event with a serial different than the"]
            #[doc = "number of past commit requests, it must proceed with evaluating and"]
            #[doc = "applying the changes as normal, except it should not change the current"]
            #[doc = "state of the zwp_text_input_v3 object. All pending state requests"]
            #[doc = "(set_surrounding_text, set_content_type and set_cursor_rectangle) on"]
            #[doc = "the zwp_text_input_v3 object should be sent and committed after"]
            #[doc = "receiving a zwp_text_input_v3.done event with a matching serial."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwp_text_input_manager_v3 {
        #[doc = "A factory for text-input objects. This object is a global singleton."]
        pub trait ZwpTextInputManagerV3: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_text_input_manager_v3";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_text_input_manager_v3#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zwp_text_input_manager_v3#{}.get_text_input()", object.id);
                        self.get_text_input(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the wp_text_input_manager object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Creates a new text-input object for a given seat."]
            async fn get_text_input(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod xdg_decoration_unstable_v1 {
    pub mod zxdg_decoration_manager_v1 {
        #[doc = "This interface allows a compositor to announce support for server-side"]
        #[doc = "decorations."]
        #[doc = ""]
        #[doc = "A window decoration is a set of window controls as deemed appropriate by"]
        #[doc = "the party managing them, such as user interface components used to move,"]
        #[doc = "resize and change a window's state."]
        #[doc = ""]
        #[doc = "A client can use this protocol to request being decorated by a supporting"]
        #[doc = "compositor."]
        #[doc = ""]
        #[doc = "If compositor and client do not negotiate the use of a server-side"]
        #[doc = "decoration using this protocol, clients continue to self-decorate as they"]
        #[doc = "see fit."]
        #[doc = ""]
        #[doc = "Warning! The protocol described in this file is experimental and"]
        #[doc = "backward incompatible changes may be made. Backward compatible changes"]
        #[doc = "may be added together with the corresponding interface version bump."]
        #[doc = "Backward incompatible changes are done by bumping the version number in"]
        #[doc = "the protocol and interface names and resetting the interface version."]
        #[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
        #[doc = "version number in the protocol and interface names are removed and the"]
        #[doc = "interface version number is reset."]
        pub trait ZxdgDecorationManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_decoration_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_decoration_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zxdg_decoration_manager_v1#{}.get_toplevel_decoration()",
                            object.id
                        );
                        self.get_toplevel_decoration(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the decoration manager. This doesn't destroy objects created"]
            #[doc = "with the manager."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a new decoration object associated with the given toplevel."]
            #[doc = ""]
            #[doc = "Creating an xdg_toplevel_decoration from an xdg_toplevel which has a"]
            #[doc = "buffer attached or committed is a client error, and any attempts by a"]
            #[doc = "client to attach or manipulate a buffer prior to the first"]
            #[doc = "xdg_toplevel_decoration.configure event must also be treated as"]
            #[doc = "errors."]
            async fn get_toplevel_decoration(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                toplevel: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zxdg_toplevel_decoration_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            UnconfiguredBuffer = 0u32,
            AlreadyConstructed = 1u32,
            Orphaned = 2u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Mode {
            ClientSide = 1u32,
            ServerSide = 2u32,
        }
        impl TryFrom<u32> for Mode {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "The decoration object allows the compositor to toggle server-side window"]
        #[doc = "decorations for a toplevel surface. The client can request to switch to"]
        #[doc = "another mode."]
        #[doc = ""]
        #[doc = "The xdg_toplevel_decoration object must be destroyed before its"]
        #[doc = "xdg_toplevel."]
        pub trait ZxdgToplevelDecorationV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_toplevel_decoration_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_toplevel_decoration_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_toplevel_decoration_v1#{}.set_mode()", object.id);
                        self.set_mode(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    2u16 => {
                        tracing::debug!("zxdg_toplevel_decoration_v1#{}.unset_mode()", object.id);
                        self.unset_mode(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Switch back to a mode without any server-side decorations at the next"]
            #[doc = "commit."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the toplevel surface decoration mode. This informs the compositor"]
            #[doc = "that the client prefers the provided decoration mode."]
            #[doc = ""]
            #[doc = "After requesting a decoration mode, the compositor will respond by"]
            #[doc = "emitting an xdg_surface.configure event. The client should then update"]
            #[doc = "its content, drawing it without decorations if the received mode is"]
            #[doc = "server-side decorations. The client must also acknowledge the configure"]
            #[doc = "when committing the new content (see xdg_surface.ack_configure)."]
            #[doc = ""]
            #[doc = "The compositor can decide not to use the client's mode and enforce a"]
            #[doc = "different mode instead."]
            #[doc = ""]
            #[doc = "Clients whose decoration mode depend on the xdg_toplevel state may send"]
            #[doc = "a set_mode request in response to an xdg_surface.configure event and wait"]
            #[doc = "for the next xdg_surface.configure event to prevent unwanted state."]
            #[doc = "Such clients are responsible for preventing configure loops and must"]
            #[doc = "make sure not to send multiple successive set_mode requests with the"]
            #[doc = "same decoration mode."]
            async fn set_mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mode: Mode,
            ) -> crate::server::Result<()>;
            #[doc = "Unset the toplevel surface decoration mode. This informs the compositor"]
            #[doc = "that the client doesn't prefer a particular decoration mode."]
            #[doc = ""]
            #[doc = "This request has the same semantics as set_mode."]
            async fn unset_mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The configure event configures the effective decoration mode. The"]
            #[doc = "configured state should not be applied immediately. Clients must send an"]
            #[doc = "ack_configure in response to this event. See xdg_surface.configure and"]
            #[doc = "xdg_surface.ack_configure for details."]
            #[doc = ""]
            #[doc = "A configure event can be sent at any time. The specified mode must be"]
            #[doc = "obeyed by the client."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
#[doc = "This protocol specifies a way for making it possible to reference a surface"]
#[doc = "of a different client. With such a reference, a client can, by using the"]
#[doc = "interfaces provided by this protocol, manipulate the relationship between"]
#[doc = "its own surfaces and the surface of some other client. For example, stack"]
#[doc = "some of its own surface above the other clients surface."]
#[doc = ""]
#[doc = "In order for a client A to get a reference of a surface of client B, client"]
#[doc = "B must first export its surface using xdg_exporter.export. Upon doing this,"]
#[doc = "client B will receive a handle (a unique string) that it may share with"]
#[doc = "client A in some way (for example D-Bus). After client A has received the"]
#[doc = "handle from client B, it may use xdg_importer.import to create a reference"]
#[doc = "to the surface client B just exported. See the corresponding requests for"]
#[doc = "details."]
#[doc = ""]
#[doc = "A possible use case for this is out-of-process dialogs. For example when a"]
#[doc = "sandboxed client without file system access needs the user to select a file"]
#[doc = "on the file system, given sandbox environment support, it can export its"]
#[doc = "surface, passing the exported surface handle to an unsandboxed process that"]
#[doc = "can show a file browser dialog and stack it above the sandboxed client's"]
#[doc = "surface."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and backward"]
#[doc = "incompatible changes may be made. Backward compatible changes may be added"]
#[doc = "together with the corresponding interface version bump. Backward"]
#[doc = "incompatible changes are done by bumping the version number in the protocol"]
#[doc = "and interface names and resetting the interface version. Once the protocol"]
#[doc = "is to be declared stable, the 'z' prefix and the version number in the"]
#[doc = "protocol and interface names are removed and the interface version number is"]
#[doc = "reset."]
pub mod xdg_foreign_unstable_v1 {
    pub mod zxdg_exporter_v1 {
        #[doc = "A global interface used for exporting surfaces that can later be imported"]
        #[doc = "using xdg_importer."]
        pub trait ZxdgExporterV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_exporter_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_exporter_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_exporter_v1#{}.export()", object.id);
                        self.export(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Notify the compositor that the xdg_exporter object will no longer be"]
            #[doc = "used."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The export request exports the passed surface so that it can later be"]
            #[doc = "imported via xdg_importer. When called, a new xdg_exported object will"]
            #[doc = "be created and xdg_exported.handle will be sent immediately. See the"]
            #[doc = "corresponding interface and event for details."]
            #[doc = ""]
            #[doc = "A surface may be exported multiple times, and each exported handle may"]
            #[doc = "be used to create an xdg_imported multiple times. Only xdg_surface"]
            #[doc = "surfaces may be exported."]
            async fn export(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zxdg_importer_v1 {
        #[doc = "A global interface used for importing surfaces exported by xdg_exporter."]
        #[doc = "With this interface, a client can create a reference to a surface of"]
        #[doc = "another client."]
        pub trait ZxdgImporterV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_importer_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_importer_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_importer_v1#{}.import()", object.id);
                        self.import(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Notify the compositor that the xdg_importer object will no longer be"]
            #[doc = "used."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The import request imports a surface from any client given a handle"]
            #[doc = "retrieved by exporting said surface using xdg_exporter.export. When"]
            #[doc = "called, a new xdg_imported object will be created. This new object"]
            #[doc = "represents the imported surface, and the importing client can"]
            #[doc = "manipulate its relationship using it. See xdg_imported for details."]
            async fn import(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                handle: String,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zxdg_exported_v1 {
        #[doc = "An xdg_exported object represents an exported reference to a surface. The"]
        #[doc = "exported surface may be referenced as long as the xdg_exported object not"]
        #[doc = "destroyed. Destroying the xdg_exported invalidates any relationship the"]
        #[doc = "importer may have established using xdg_imported."]
        pub trait ZxdgExportedV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_exported_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_exported_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Revoke the previously exported surface. This invalidates any"]
            #[doc = "relationship the importer may have set up using the xdg_imported created"]
            #[doc = "given the handle sent via xdg_exported.handle."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The handle event contains the unique handle of this exported surface"]
            #[doc = "reference. It may be shared with any client, which then can use it to"]
            #[doc = "import the surface by calling xdg_importer.import. A handle may be"]
            #[doc = "used to import the surface multiple times."]
            async fn handle(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zxdg_imported_v1 {
        #[doc = "An xdg_imported object represents an imported reference to surface exported"]
        #[doc = "by some client. A client can use this interface to manipulate"]
        #[doc = "relationships between its own surfaces and the imported surface."]
        pub trait ZxdgImportedV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_imported_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_imported_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_imported_v1#{}.set_parent_of()", object.id);
                        self.set_parent_of(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Notify the compositor that it will no longer use the xdg_imported"]
            #[doc = "object. Any relationship that may have been set up will at this point"]
            #[doc = "be invalidated."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the imported surface as the parent of some surface of the client."]
            #[doc = "The passed surface must be a toplevel xdg_surface. Calling this function"]
            #[doc = "sets up a surface to surface relation with the same stacking and positioning"]
            #[doc = "semantics as xdg_surface.set_parent."]
            async fn set_parent_of(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "The imported surface handle has been destroyed and any relationship set"]
            #[doc = "up has been invalidated. This may happen for various reasons, for"]
            #[doc = "example if the exported surface or the exported surface handle has been"]
            #[doc = "destroyed, if the handle used for importing was invalid."]
            async fn destroyed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
#[doc = "This protocol specifies a way for making it possible to reference a surface"]
#[doc = "of a different client. With such a reference, a client can, by using the"]
#[doc = "interfaces provided by this protocol, manipulate the relationship between"]
#[doc = "its own surfaces and the surface of some other client. For example, stack"]
#[doc = "some of its own surface above the other clients surface."]
#[doc = ""]
#[doc = "In order for a client A to get a reference of a surface of client B, client"]
#[doc = "B must first export its surface using xdg_exporter.export_toplevel. Upon"]
#[doc = "doing this, client B will receive a handle (a unique string) that it may"]
#[doc = "share with client A in some way (for example D-Bus). After client A has"]
#[doc = "received the handle from client B, it may use xdg_importer.import_toplevel"]
#[doc = "to create a reference to the surface client B just exported. See the"]
#[doc = "corresponding requests for details."]
#[doc = ""]
#[doc = "A possible use case for this is out-of-process dialogs. For example when a"]
#[doc = "sandboxed client without file system access needs the user to select a file"]
#[doc = "on the file system, given sandbox environment support, it can export its"]
#[doc = "surface, passing the exported surface handle to an unsandboxed process that"]
#[doc = "can show a file browser dialog and stack it above the sandboxed client's"]
#[doc = "surface."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and backward"]
#[doc = "incompatible changes may be made. Backward compatible changes may be added"]
#[doc = "together with the corresponding interface version bump. Backward"]
#[doc = "incompatible changes are done by bumping the version number in the protocol"]
#[doc = "and interface names and resetting the interface version. Once the protocol"]
#[doc = "is to be declared stable, the 'z' prefix and the version number in the"]
#[doc = "protocol and interface names are removed and the interface version number is"]
#[doc = "reset."]
pub mod xdg_foreign_unstable_v2 {
    pub mod zxdg_exporter_v2 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidSurface = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "A global interface used for exporting surfaces that can later be imported"]
        #[doc = "using xdg_importer."]
        pub trait ZxdgExporterV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_exporter_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_exporter_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_exporter_v2#{}.export_toplevel()", object.id);
                        self.export_toplevel(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Notify the compositor that the xdg_exporter object will no longer be"]
            #[doc = "used."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The export_toplevel request exports the passed surface so that it can later be"]
            #[doc = "imported via xdg_importer. When called, a new xdg_exported object will"]
            #[doc = "be created and xdg_exported.handle will be sent immediately. See the"]
            #[doc = "corresponding interface and event for details."]
            #[doc = ""]
            #[doc = "A surface may be exported multiple times, and each exported handle may"]
            #[doc = "be used to create an xdg_imported multiple times. Only xdg_toplevel"]
            #[doc = "equivalent surfaces may be exported, otherwise an invalid_surface"]
            #[doc = "protocol error is sent."]
            async fn export_toplevel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zxdg_importer_v2 {
        #[doc = "A global interface used for importing surfaces exported by xdg_exporter."]
        #[doc = "With this interface, a client can create a reference to a surface of"]
        #[doc = "another client."]
        pub trait ZxdgImporterV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_importer_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_importer_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_importer_v2#{}.import_toplevel()", object.id);
                        self.import_toplevel(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Notify the compositor that the xdg_importer object will no longer be"]
            #[doc = "used."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The import_toplevel request imports a surface from any client given a handle"]
            #[doc = "retrieved by exporting said surface using xdg_exporter.export_toplevel."]
            #[doc = "When called, a new xdg_imported object will be created. This new object"]
            #[doc = "represents the imported surface, and the importing client can"]
            #[doc = "manipulate its relationship using it. See xdg_imported for details."]
            async fn import_toplevel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                handle: String,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zxdg_exported_v2 {
        #[doc = "An xdg_exported object represents an exported reference to a surface. The"]
        #[doc = "exported surface may be referenced as long as the xdg_exported object not"]
        #[doc = "destroyed. Destroying the xdg_exported invalidates any relationship the"]
        #[doc = "importer may have established using xdg_imported."]
        pub trait ZxdgExportedV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_exported_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_exported_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Revoke the previously exported surface. This invalidates any"]
            #[doc = "relationship the importer may have set up using the xdg_imported created"]
            #[doc = "given the handle sent via xdg_exported.handle."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The handle event contains the unique handle of this exported surface"]
            #[doc = "reference. It may be shared with any client, which then can use it to"]
            #[doc = "import the surface by calling xdg_importer.import_toplevel. A handle"]
            #[doc = "may be used to import the surface multiple times."]
            async fn handle(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zxdg_imported_v2 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidSurface = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "An xdg_imported object represents an imported reference to surface exported"]
        #[doc = "by some client. A client can use this interface to manipulate"]
        #[doc = "relationships between its own surfaces and the imported surface."]
        pub trait ZxdgImportedV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_imported_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_imported_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_imported_v2#{}.set_parent_of()", object.id);
                        self.set_parent_of(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Notify the compositor that it will no longer use the xdg_imported"]
            #[doc = "object. Any relationship that may have been set up will at this point"]
            #[doc = "be invalidated."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the imported surface as the parent of some surface of the client."]
            #[doc = "The passed surface must be an xdg_toplevel equivalent, otherwise an"]
            #[doc = "invalid_surface protocol error is sent. Calling this function sets up"]
            #[doc = "a surface to surface relation with the same stacking and positioning"]
            #[doc = "semantics as xdg_toplevel.set_parent."]
            async fn set_parent_of(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "The imported surface handle has been destroyed and any relationship set"]
            #[doc = "up has been invalidated. This may happen for various reasons, for"]
            #[doc = "example if the exported surface or the exported surface handle has been"]
            #[doc = "destroyed, if the handle used for importing was invalid."]
            async fn destroyed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
#[doc = "This protocol aims at describing outputs in a way which is more in line"]
#[doc = "with the concept of an output on desktop oriented systems."]
#[doc = ""]
#[doc = "Some information are more specific to the concept of an output for"]
#[doc = "a desktop oriented system and may not make sense in other applications,"]
#[doc = "such as IVI systems for example."]
#[doc = ""]
#[doc = "Typically, the global compositor space on a desktop system is made of"]
#[doc = "a contiguous or overlapping set of rectangular regions."]
#[doc = ""]
#[doc = "The logical_position and logical_size events defined in this protocol"]
#[doc = "might provide information identical to their counterparts already"]
#[doc = "available from wl_output, in which case the information provided by this"]
#[doc = "protocol should be preferred to their equivalent in wl_output. The goal is"]
#[doc = "to move the desktop specific concepts (such as output location within the"]
#[doc = "global compositor space, etc.) out of the core wl_output protocol."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and"]
#[doc = "backward incompatible changes may be made. Backward compatible"]
#[doc = "changes may be added together with the corresponding interface"]
#[doc = "version bump."]
#[doc = "Backward incompatible changes are done by bumping the version"]
#[doc = "number in the protocol and interface names and resetting the"]
#[doc = "interface version. Once the protocol is to be declared stable,"]
#[doc = "the 'z' prefix and the version number in the protocol and"]
#[doc = "interface names are removed and the interface version number is"]
#[doc = "reset."]
pub mod xdg_output_unstable_v1 {
    pub mod zxdg_output_manager_v1 {
        #[doc = "A global factory interface for xdg_output objects."]
        pub trait ZxdgOutputManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_output_manager_v1";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_output_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_output_manager_v1#{}.get_xdg_output()", object.id);
                        self.get_xdg_output(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Using this request a client can tell the server that it is not"]
            #[doc = "going to use the xdg_output_manager object anymore."]
            #[doc = ""]
            #[doc = "Any objects already created through this instance are not affected."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This creates a new xdg_output object for the given wl_output."]
            async fn get_xdg_output(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zxdg_output_v1 {
        #[doc = "An xdg_output describes part of the compositor geometry."]
        #[doc = ""]
        #[doc = "This typically corresponds to a monitor that displays part of the"]
        #[doc = "compositor space."]
        #[doc = ""]
        #[doc = "For objects version 3 onwards, after all xdg_output properties have been"]
        #[doc = "sent (when the object is created and when properties are updated), a"]
        #[doc = "wl_output.done event is sent. This allows changes to the output"]
        #[doc = "properties to be seen as atomic, even if they happen via multiple events."]
        pub trait ZxdgOutputV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_output_v1";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_output_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Using this request a client can tell the server that it is not"]
            #[doc = "going to use the xdg_output object anymore."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The position event describes the location of the wl_output within"]
            #[doc = "the global compositor space."]
            #[doc = ""]
            #[doc = "The logical_position event is sent after creating an xdg_output"]
            #[doc = "(see xdg_output_manager.get_xdg_output) and whenever the location"]
            #[doc = "of the output changes within the global compositor space."]
            async fn logical_position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The logical_size event describes the size of the output in the"]
            #[doc = "global compositor space."]
            #[doc = ""]
            #[doc = "Most regular Wayland clients should not pay attention to the"]
            #[doc = "logical size and would rather rely on xdg_shell interfaces."]
            #[doc = ""]
            #[doc = "Some clients such as Xwayland, however, need this to configure"]
            #[doc = "their surfaces in the global compositor space as the compositor"]
            #[doc = "may apply a different scale from what is advertised by the output"]
            #[doc = "scaling property (to achieve fractional scaling, for example)."]
            #[doc = ""]
            #[doc = "For example, for a wl_output mode 3840×2160 and a scale factor 2:"]
            #[doc = ""]
            #[doc = "- A compositor not scaling the monitor viewport in its compositing space"]
            #[doc = "will advertise a logical size of 3840×2160,"]
            #[doc = ""]
            #[doc = "- A compositor scaling the monitor viewport with scale factor 2 will"]
            #[doc = "advertise a logical size of 1920×1080,"]
            #[doc = ""]
            #[doc = "- A compositor scaling the monitor viewport using a fractional scale of"]
            #[doc = "1.5 will advertise a logical size of 2560×1440."]
            #[doc = ""]
            #[doc = "For example, for a wl_output mode 1920×1080 and a 90 degree rotation,"]
            #[doc = "the compositor will advertise a logical size of 1080x1920."]
            #[doc = ""]
            #[doc = "The logical_size event is sent after creating an xdg_output"]
            #[doc = "(see xdg_output_manager.get_xdg_output) and whenever the logical"]
            #[doc = "size of the output changes, either as a result of a change in the"]
            #[doc = "applied scale or because of a change in the corresponding output"]
            #[doc = "mode(see wl_output.mode) or transform (see wl_output.transform)."]
            async fn logical_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent after all other properties of an xdg_output"]
            #[doc = "have been sent."]
            #[doc = ""]
            #[doc = "This allows changes to the xdg_output properties to be seen as"]
            #[doc = "atomic, even if they happen via multiple events."]
            #[doc = ""]
            #[doc = "For objects version 3 onwards, this event is deprecated. Compositors"]
            #[doc = "are not required to send it anymore and must send wl_output.done"]
            #[doc = "instead."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Many compositors will assign names to their outputs, show them to the"]
            #[doc = "user, allow them to be configured by name, etc. The client may wish to"]
            #[doc = "know this name as well to offer the user similar behaviors."]
            #[doc = ""]
            #[doc = "The naming convention is compositor defined, but limited to"]
            #[doc = "alphanumeric characters and dashes (-). Each name is unique among all"]
            #[doc = "wl_output globals, but if a wl_output global is destroyed the same name"]
            #[doc = "may be reused later. The names will also remain consistent across"]
            #[doc = "sessions with the same hardware and software configuration."]
            #[doc = ""]
            #[doc = "Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do"]
            #[doc = "not assume that the name is a reflection of an underlying DRM"]
            #[doc = "connector, X11 connection, etc."]
            #[doc = ""]
            #[doc = "The name event is sent after creating an xdg_output (see"]
            #[doc = "xdg_output_manager.get_xdg_output). This event is only sent once per"]
            #[doc = "xdg_output, and the name does not change over the lifetime of the"]
            #[doc = "wl_output global."]
            #[doc = ""]
            #[doc = "This event is deprecated, instead clients should use wl_output.name."]
            #[doc = "Compositors must still support this event."]
            async fn name(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Many compositors can produce human-readable descriptions of their"]
            #[doc = "outputs.  The client may wish to know this description as well, to"]
            #[doc = "communicate the user for various purposes."]
            #[doc = ""]
            #[doc = "The description is a UTF-8 string with no convention defined for its"]
            #[doc = "contents. Examples might include 'Foocorp 11\" Display' or 'Virtual X11"]
            #[doc = "output via :1'."]
            #[doc = ""]
            #[doc = "The description event is sent after creating an xdg_output (see"]
            #[doc = "xdg_output_manager.get_xdg_output) and whenever the description"]
            #[doc = "changes. The description is optional, and may not be sent at all."]
            #[doc = ""]
            #[doc = "For objects of version 2 and lower, this event is only sent once per"]
            #[doc = "xdg_output, and the description does not change over the lifetime of"]
            #[doc = "the wl_output global."]
            #[doc = ""]
            #[doc = "This event is deprecated, instead clients should use"]
            #[doc = "wl_output.description. Compositors must still support this event."]
            async fn description(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
pub mod xdg_shell_unstable_v5 {
    pub mod xdg_shell {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Version {
            Current = 5u32,
        }
        impl TryFrom<u32> for Version {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            Role = 0u32,
            DefunctSurfaces = 1u32,
            NotTheTopmostPopup = 2u32,
            InvalidPopupParent = 3u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "xdg_shell allows clients to turn a wl_surface into a \"real window\""]
        #[doc = "which can be dragged, resized, stacked, and moved around by the"]
        #[doc = "user. Everything about this interface is suited towards traditional"]
        #[doc = "desktop environments."]
        pub trait XdgShell: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_shell";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_shell#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_shell#{}.use_unstable_version()", object.id);
                        self.use_unstable_version(object, client, message.int()?)
                            .await
                    }
                    2u16 => {
                        tracing::debug!("xdg_shell#{}.get_xdg_surface()", object.id);
                        self.get_xdg_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("xdg_shell#{}.get_xdg_popup()", object.id);
                        self.get_xdg_popup(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("xdg_shell#{}.pong()", object.id);
                        self.pong(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy this xdg_shell object."]
            #[doc = ""]
            #[doc = "Destroying a bound xdg_shell object while there are surfaces"]
            #[doc = "still alive created by this xdg_shell object instance is illegal"]
            #[doc = "and will result in a protocol error."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Negotiate the unstable version of the interface.  This"]
            #[doc = "mechanism is in place to ensure client and server agree on the"]
            #[doc = "unstable versions of the protocol that they speak or exit"]
            #[doc = "cleanly if they don't agree.  This request will go away once"]
            #[doc = "the xdg-shell protocol is stable."]
            async fn use_unstable_version(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                version: i32,
            ) -> crate::server::Result<()>;
            #[doc = "This creates an xdg_surface for the given surface and gives it the"]
            #[doc = "xdg_surface role. A wl_surface can only be given an xdg_surface role"]
            #[doc = "once. If get_xdg_surface is called with a wl_surface that already has"]
            #[doc = "an active xdg_surface associated with it, or if it had any other role,"]
            #[doc = "an error is raised."]
            #[doc = ""]
            #[doc = "See the documentation of xdg_surface for more details about what an"]
            #[doc = "xdg_surface is and how it is used."]
            async fn get_xdg_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This creates an xdg_popup for the given surface and gives it the"]
            #[doc = "xdg_popup role. A wl_surface can only be given an xdg_popup role"]
            #[doc = "once. If get_xdg_popup is called with a wl_surface that already has"]
            #[doc = "an active xdg_popup associated with it, or if it had any other role,"]
            #[doc = "an error is raised."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action"]
            #[doc = "like a button press, key press, or touch down event."]
            #[doc = ""]
            #[doc = "See the documentation of xdg_popup for more details about what an"]
            #[doc = "xdg_popup is and how it is used."]
            async fn get_xdg_popup(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
                parent: crate::wire::ObjectId,
                seat: crate::wire::ObjectId,
                serial: u32,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "A client must respond to a ping event with a pong request or"]
            #[doc = "the client may be deemed unresponsive."]
            async fn pong(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "The ping event asks the client if it's still alive. Pass the"]
            #[doc = "serial specified in the event back to the compositor by sending"]
            #[doc = "a \"pong\" request back with the specified serial."]
            #[doc = ""]
            #[doc = "Compositors can use this to determine if the client is still"]
            #[doc = "alive. It's unspecified what will happen if the client doesn't"]
            #[doc = "respond to the ping request, or in what timeframe. Clients should"]
            #[doc = "try to respond in a reasonable amount of time."]
            #[doc = ""]
            #[doc = "A compositor is free to ping in any way it wants, but a client must"]
            #[doc = "always respond to any xdg_shell object it created."]
            async fn ping(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod xdg_surface {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ResizeEdge {
            None = 0u32,
            Top = 1u32,
            Bottom = 2u32,
            Left = 4u32,
            TopLeft = 5u32,
            BottomLeft = 6u32,
            Right = 8u32,
            TopRight = 9u32,
            BottomRight = 10u32,
        }
        impl TryFrom<u32> for ResizeEdge {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum State {
            #[doc = "The surface is maximized. The window geometry specified in the configure"]
            #[doc = "event must be obeyed by the client."]
            Maximized = 1u32,
            #[doc = "The surface is fullscreen. The window geometry specified in the configure"]
            #[doc = "event must be obeyed by the client."]
            Fullscreen = 2u32,
            #[doc = "The surface is being resized. The window geometry specified in the"]
            #[doc = "configure event is a maximum; the client cannot resize beyond it."]
            #[doc = "Clients that have aspect ratio or cell sizing configuration can use"]
            #[doc = "a smaller size, however."]
            Resizing = 3u32,
            #[doc = "Client window decorations should be painted as if the window is"]
            #[doc = "active. Do not assume this means that the window actually has"]
            #[doc = "keyboard or pointer focus."]
            Activated = 4u32,
        }
        impl TryFrom<u32> for State {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "An interface that may be implemented by a wl_surface, for"]
        #[doc = "implementations that provide a desktop-style user interface."]
        #[doc = ""]
        #[doc = "It provides requests to treat surfaces like windows, allowing to set"]
        #[doc = "properties like maximized, fullscreen, minimized, and to move and resize"]
        #[doc = "them, and associate metadata like title and app id."]
        #[doc = ""]
        #[doc = "The client must call wl_surface.commit on the corresponding wl_surface"]
        #[doc = "for the xdg_surface state to take effect. Prior to committing the new"]
        #[doc = "state, it can set up initial configuration, such as maximizing or setting"]
        #[doc = "a window geometry."]
        #[doc = ""]
        #[doc = "Even without attaching a buffer the compositor must respond to initial"]
        #[doc = "committed configuration, for instance sending a configure event with"]
        #[doc = "expected window geometry if the client maximized its surface during"]
        #[doc = "initialization."]
        #[doc = ""]
        #[doc = "For a surface to be mapped by the compositor the client must have"]
        #[doc = "committed both an xdg_surface state and a buffer."]
        pub trait XdgSurface: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_surface";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_surface#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_surface#{}.set_parent()", object.id);
                        self.set_parent(object, client, message.object()?).await
                    }
                    2u16 => {
                        tracing::debug!("xdg_surface#{}.set_title()", object.id);
                        self.set_title(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("xdg_surface#{}.set_app_id()", object.id);
                        self.set_app_id(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("xdg_surface#{}.show_window_menu()", object.id);
                        self.show_window_menu(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    5u16 => {
                        tracing::debug!("xdg_surface#{}.move()", object.id);
                        self.r#move(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    6u16 => {
                        tracing::debug!("xdg_surface#{}.resize()", object.id);
                        self.resize(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    7u16 => {
                        tracing::debug!("xdg_surface#{}.ack_configure()", object.id);
                        self.ack_configure(object, client, message.uint()?).await
                    }
                    8u16 => {
                        tracing::debug!("xdg_surface#{}.set_window_geometry()", object.id);
                        self.set_window_geometry(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    9u16 => {
                        tracing::debug!("xdg_surface#{}.set_maximized()", object.id);
                        self.set_maximized(object, client).await
                    }
                    10u16 => {
                        tracing::debug!("xdg_surface#{}.unset_maximized()", object.id);
                        self.unset_maximized(object, client).await
                    }
                    11u16 => {
                        tracing::debug!("xdg_surface#{}.set_fullscreen()", object.id);
                        self.set_fullscreen(object, client, message.object()?).await
                    }
                    12u16 => {
                        tracing::debug!("xdg_surface#{}.unset_fullscreen()", object.id);
                        self.unset_fullscreen(object, client).await
                    }
                    13u16 => {
                        tracing::debug!("xdg_surface#{}.set_minimized()", object.id);
                        self.set_minimized(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Unmap and destroy the window. The window will be effectively"]
            #[doc = "hidden from the user's point of view, and all state like"]
            #[doc = "maximization, fullscreen, and so on, will be lost."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the \"parent\" of this surface. This window should be stacked"]
            #[doc = "above a parent. The parent surface must be mapped as long as this"]
            #[doc = "surface is mapped."]
            #[doc = ""]
            #[doc = "Parent windows should be set on dialogs, toolboxes, or other"]
            #[doc = "\"auxiliary\" surfaces, so that the parent is raised when the dialog"]
            #[doc = "is raised."]
            async fn set_parent(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                parent: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Set a short title for the surface."]
            #[doc = ""]
            #[doc = "This string may be used to identify the surface in a task bar,"]
            #[doc = "window list, or other user interface elements provided by the"]
            #[doc = "compositor."]
            #[doc = ""]
            #[doc = "The string must be encoded in UTF-8."]
            async fn set_title(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                title: String,
            ) -> crate::server::Result<()>;
            #[doc = "Set an application identifier for the surface."]
            #[doc = ""]
            #[doc = "The app ID identifies the general class of applications to which"]
            #[doc = "the surface belongs. The compositor can use this to group multiple"]
            #[doc = "surfaces together, or to determine how to launch a new application."]
            #[doc = ""]
            #[doc = "For D-Bus activatable applications, the app ID is used as the D-Bus"]
            #[doc = "service name."]
            #[doc = ""]
            #[doc = "The compositor shell will try to group application surfaces together"]
            #[doc = "by their app ID.  As a best practice, it is suggested to select app"]
            #[doc = "ID's that match the basename of the application's .desktop file."]
            #[doc = "For example, \"org.freedesktop.FooViewer\" where the .desktop file is"]
            #[doc = "\"org.freedesktop.FooViewer.desktop\"."]
            #[doc = ""]
            #[doc = "See the desktop-entry specification [0] for more details on"]
            #[doc = "application identifiers and how they relate to well-known D-Bus"]
            #[doc = "names and .desktop files."]
            #[doc = ""]
            #[doc = "[0] http://standards.freedesktop.org/desktop-entry-spec/"]
            async fn set_app_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                app_id: String,
            ) -> crate::server::Result<()>;
            #[doc = "Clients implementing client-side decorations might want to show"]
            #[doc = "a context menu when right-clicking on the decorations, giving the"]
            #[doc = "user a menu that they can use to maximize or minimize the window."]
            #[doc = ""]
            #[doc = "This request asks the compositor to pop up such a window menu at"]
            #[doc = "the given position, relative to the local surface coordinates of"]
            #[doc = "the parent surface. There are no guarantees as to what menu items"]
            #[doc = "the window menu contains."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action"]
            #[doc = "like a button press, key press, or touch down event."]
            async fn show_window_menu(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Start an interactive, user-driven move of the surface."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action"]
            #[doc = "like a button press, key press, or touch down event. The passed"]
            #[doc = "serial is used to determine the type of interactive move (touch,"]
            #[doc = "pointer, etc)."]
            #[doc = ""]
            #[doc = "The server may ignore move requests depending on the state of"]
            #[doc = "the surface (e.g. fullscreen or maximized), or if the passed serial"]
            #[doc = "is no longer valid."]
            #[doc = ""]
            #[doc = "If triggered, the surface will lose the focus of the device"]
            #[doc = "(wl_pointer, wl_touch, etc) used for the move. It is up to the"]
            #[doc = "compositor to visually indicate that the move is taking place, such as"]
            #[doc = "updating a pointer cursor, during the move. There is no guarantee"]
            #[doc = "that the device focus will return when the move is completed."]
            async fn r#move(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Start a user-driven, interactive resize of the surface."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action"]
            #[doc = "like a button press, key press, or touch down event. The passed"]
            #[doc = "serial is used to determine the type of interactive resize (touch,"]
            #[doc = "pointer, etc)."]
            #[doc = ""]
            #[doc = "The server may ignore resize requests depending on the state of"]
            #[doc = "the surface (e.g. fullscreen or maximized)."]
            #[doc = ""]
            #[doc = "If triggered, the client will receive configure events with the"]
            #[doc = "\"resize\" state enum value and the expected sizes. See the \"resize\""]
            #[doc = "enum value for more details about what is required. The client"]
            #[doc = "must also acknowledge configure events using \"ack_configure\". After"]
            #[doc = "the resize is completed, the client will receive another \"configure\""]
            #[doc = "event without the resize state."]
            #[doc = ""]
            #[doc = "If triggered, the surface also will lose the focus of the device"]
            #[doc = "(wl_pointer, wl_touch, etc) used for the resize. It is up to the"]
            #[doc = "compositor to visually indicate that the resize is taking place,"]
            #[doc = "such as updating a pointer cursor, during the resize. There is no"]
            #[doc = "guarantee that the device focus will return when the resize is"]
            #[doc = "completed."]
            #[doc = ""]
            #[doc = "The edges parameter specifies how the surface should be resized,"]
            #[doc = "and is one of the values of the resize_edge enum. The compositor"]
            #[doc = "may use this information to update the surface position for"]
            #[doc = "example when dragging the top left corner. The compositor may also"]
            #[doc = "use this information to adapt its behavior, e.g. choose an"]
            #[doc = "appropriate cursor image."]
            async fn resize(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
                edges: u32,
            ) -> crate::server::Result<()>;
            #[doc = "When a configure event is received, if a client commits the"]
            #[doc = "surface in response to the configure event, then the client"]
            #[doc = "must make an ack_configure request sometime before the commit"]
            #[doc = "request, passing along the serial of the configure event."]
            #[doc = ""]
            #[doc = "For instance, the compositor might use this information to move"]
            #[doc = "a surface to the top left only when the client has drawn itself"]
            #[doc = "for the maximized or fullscreen state."]
            #[doc = ""]
            #[doc = "If the client receives multiple configure events before it"]
            #[doc = "can respond to one, it only has to ack the last configure event."]
            #[doc = ""]
            #[doc = "A client is not required to commit immediately after sending"]
            #[doc = "an ack_configure request - it may even ack_configure several times"]
            #[doc = "before its next surface commit."]
            #[doc = ""]
            #[doc = "The compositor expects that the most recently received"]
            #[doc = "ack_configure request at the time of a commit indicates which"]
            #[doc = "configure event the client is responding to."]
            async fn ack_configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "The window geometry of a window is its \"visible bounds\" from the"]
            #[doc = "user's perspective. Client-side decorations often have invisible"]
            #[doc = "portions like drop-shadows which should be ignored for the"]
            #[doc = "purposes of aligning, placing and constraining windows."]
            #[doc = ""]
            #[doc = "The window geometry is double buffered, and will be applied at the"]
            #[doc = "time wl_surface.commit of the corresponding wl_surface is called."]
            #[doc = ""]
            #[doc = "Once the window geometry of the surface is set once, it is not"]
            #[doc = "possible to unset it, and it will remain the same until"]
            #[doc = "set_window_geometry is called again, even if a new subsurface or"]
            #[doc = "buffer is attached."]
            #[doc = ""]
            #[doc = "If never set, the value is the full bounds of the surface,"]
            #[doc = "including any subsurfaces. This updates dynamically on every"]
            #[doc = "commit. This unset mode is meant for extremely simple clients."]
            #[doc = ""]
            #[doc = "If responding to a configure event, the window geometry in here"]
            #[doc = "must respect the sizing negotiations specified by the states in"]
            #[doc = "the configure event."]
            #[doc = ""]
            #[doc = "The arguments are given in the surface local coordinate space of"]
            #[doc = "the wl_surface associated with this xdg_surface."]
            #[doc = ""]
            #[doc = "The width and height must be greater than zero."]
            async fn set_window_geometry(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Maximize the surface."]
            #[doc = ""]
            #[doc = "After requesting that the surface should be maximized, the compositor"]
            #[doc = "will respond by emitting a configure event with the \"maximized\" state"]
            #[doc = "and the required window geometry. The client should then update its"]
            #[doc = "content, drawing it in a maximized state, i.e. without shadow or other"]
            #[doc = "decoration outside of the window geometry. The client must also"]
            #[doc = "acknowledge the configure when committing the new content (see"]
            #[doc = "ack_configure)."]
            #[doc = ""]
            #[doc = "It is up to the compositor to decide how and where to maximize the"]
            #[doc = "surface, for example which output and what region of the screen should"]
            #[doc = "be used."]
            #[doc = ""]
            #[doc = "If the surface was already maximized, the compositor will still emit"]
            #[doc = "a configure event with the \"maximized\" state."]
            #[doc = ""]
            #[doc = "Note that unrelated compositor side state changes may cause"]
            #[doc = "configure events to be emitted at any time, meaning trying to"]
            #[doc = "match this request to a specific future configure event is"]
            #[doc = "futile."]
            async fn set_maximized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Unmaximize the surface."]
            #[doc = ""]
            #[doc = "After requesting that the surface should be unmaximized, the compositor"]
            #[doc = "will respond by emitting a configure event without the \"maximized\""]
            #[doc = "state. If available, the compositor will include the window geometry"]
            #[doc = "dimensions the window had prior to being maximized in the configure"]
            #[doc = "request. The client must then update its content, drawing it in a"]
            #[doc = "regular state, i.e. potentially with shadow, etc. The client must also"]
            #[doc = "acknowledge the configure when committing the new content (see"]
            #[doc = "ack_configure)."]
            #[doc = ""]
            #[doc = "It is up to the compositor to position the surface after it was"]
            #[doc = "unmaximized; usually the position the surface had before maximizing, if"]
            #[doc = "applicable."]
            #[doc = ""]
            #[doc = "If the surface was already not maximized, the compositor will still"]
            #[doc = "emit a configure event without the \"maximized\" state."]
            #[doc = ""]
            #[doc = "Note that unrelated compositor side state changes may cause"]
            #[doc = "configure events to be emitted at any time, meaning trying to"]
            #[doc = "match this request to a specific future configure event is"]
            #[doc = "futile."]
            async fn unset_maximized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Make the surface fullscreen."]
            #[doc = ""]
            #[doc = "You can specify an output that you would prefer to be fullscreen."]
            #[doc = "If this value is NULL, it's up to the compositor to choose which"]
            #[doc = "display will be used to map this surface."]
            #[doc = ""]
            #[doc = "If the surface doesn't cover the whole output, the compositor will"]
            #[doc = "position the surface in the center of the output and compensate with"]
            #[doc = "black borders filling the rest of the output."]
            async fn set_fullscreen(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            async fn unset_fullscreen(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Request that the compositor minimize your surface. There is no"]
            #[doc = "way to know if the surface is currently minimized, nor is there"]
            #[doc = "any way to unset minimization on this surface."]
            #[doc = ""]
            #[doc = "If you are looking to throttle redrawing when minimized, please"]
            #[doc = "instead use the wl_surface.frame event for this, as this will"]
            #[doc = "also work with live previews on windows in Alt-Tab, Expose or"]
            #[doc = "similar compositor features."]
            async fn set_minimized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The configure event asks the client to resize its surface or to"]
            #[doc = "change its state."]
            #[doc = ""]
            #[doc = "The width and height arguments specify a hint to the window"]
            #[doc = "about how its surface should be resized in window geometry"]
            #[doc = "coordinates. See set_window_geometry."]
            #[doc = ""]
            #[doc = "If the width or height arguments are zero, it means the client"]
            #[doc = "should decide its own window dimension. This may happen when the"]
            #[doc = "compositor need to configure the state of the surface but doesn't"]
            #[doc = "have any information about any previous or expected dimension."]
            #[doc = ""]
            #[doc = "The states listed in the event specify how the width/height"]
            #[doc = "arguments should be interpreted, and possibly how it should be"]
            #[doc = "drawn."]
            #[doc = ""]
            #[doc = "Clients should arrange their surface for the new size and"]
            #[doc = "states, and then send a ack_configure request with the serial"]
            #[doc = "sent in this configure event at some point before committing"]
            #[doc = "the new surface."]
            #[doc = ""]
            #[doc = "If the client receives multiple configure events before it"]
            #[doc = "can respond to one, it is free to discard all but the last"]
            #[doc = "event it received."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The close event is sent by the compositor when the user"]
            #[doc = "wants the surface to be closed. This should be equivalent to"]
            #[doc = "the user clicking the close button in client-side decorations,"]
            #[doc = "if your application has any..."]
            #[doc = ""]
            #[doc = "This is only a request that the user intends to close your"]
            #[doc = "window. The client may choose to ignore this request, or show"]
            #[doc = "a dialog to ask the user to save their data..."]
            async fn close(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod xdg_popup {
        #[doc = "A popup surface is a short-lived, temporary surface that can be"]
        #[doc = "used to implement menus. It takes an explicit grab on the surface"]
        #[doc = "that will be dismissed when the user dismisses the popup. This can"]
        #[doc = "be done by the user clicking outside the surface, using the keyboard,"]
        #[doc = "or even locking the screen through closing the lid or a timeout."]
        #[doc = ""]
        #[doc = "When the popup is dismissed, a popup_done event will be sent out,"]
        #[doc = "and at the same time the surface will be unmapped. The xdg_popup"]
        #[doc = "object is now inert and cannot be reactivated, so clients should"]
        #[doc = "destroy it. Explicitly destroying the xdg_popup object will also"]
        #[doc = "dismiss the popup and unmap the surface."]
        #[doc = ""]
        #[doc = "Clients will receive events for all their surfaces during this"]
        #[doc = "grab (which is an \"owner-events\" grab in X11 parlance). This is"]
        #[doc = "done so that users can navigate through submenus and other"]
        #[doc = "\"nested\" popup windows without having to dismiss the topmost"]
        #[doc = "popup."]
        #[doc = ""]
        #[doc = "Clients that want to dismiss the popup when another surface of"]
        #[doc = "their own is clicked should dismiss the popup using the destroy"]
        #[doc = "request."]
        #[doc = ""]
        #[doc = "The parent surface must have either an xdg_surface or xdg_popup"]
        #[doc = "role."]
        #[doc = ""]
        #[doc = "Specifying an xdg_popup for the parent means that the popups are"]
        #[doc = "nested, with this popup now being the topmost popup. Nested"]
        #[doc = "popups must be destroyed in the reverse order they were created"]
        #[doc = "in, e.g. the only popup you are allowed to destroy at all times"]
        #[doc = "is the topmost one."]
        #[doc = ""]
        #[doc = "If there is an existing popup when creating a new popup, the"]
        #[doc = "parent must be the current topmost popup."]
        #[doc = ""]
        #[doc = "A parent surface must be mapped before the new popup is mapped."]
        #[doc = ""]
        #[doc = "When compositors choose to dismiss a popup, they will likely"]
        #[doc = "dismiss every nested popup as well. When a compositor dismisses"]
        #[doc = "popups, it will follow the same dismissing order as required"]
        #[doc = "from the client."]
        #[doc = ""]
        #[doc = "The x and y arguments passed when creating the popup object specify"]
        #[doc = "where the top left of the popup should be placed, relative to the"]
        #[doc = "local surface coordinates of the parent surface. See"]
        #[doc = "xdg_shell.get_xdg_popup."]
        #[doc = ""]
        #[doc = "The client must call wl_surface.commit on the corresponding wl_surface"]
        #[doc = "for the xdg_popup state to take effect."]
        #[doc = ""]
        #[doc = "For a surface to be mapped by the compositor the client must have"]
        #[doc = "committed both the xdg_popup state and a buffer."]
        pub trait XdgPopup: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_popup";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_popup#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This destroys the popup. Explicitly destroying the xdg_popup"]
            #[doc = "object will also dismiss the popup, and unmap the surface."]
            #[doc = ""]
            #[doc = "If this xdg_popup is not the \"topmost\" popup, a protocol error"]
            #[doc = "will be sent."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The popup_done event is sent out when a popup is dismissed by the"]
            #[doc = "compositor. The client should destroy the xdg_popup object at this"]
            #[doc = "point."]
            async fn popup_done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
pub mod xdg_shell_unstable_v6 {
    pub mod zxdg_shell_v6 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            Role = 0u32,
            DefunctSurfaces = 1u32,
            NotTheTopmostPopup = 2u32,
            InvalidPopupParent = 3u32,
            InvalidSurfaceState = 4u32,
            InvalidPositioner = 5u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "xdg_shell allows clients to turn a wl_surface into a \"real window\""]
        #[doc = "which can be dragged, resized, stacked, and moved around by the"]
        #[doc = "user. Everything about this interface is suited towards traditional"]
        #[doc = "desktop environments."]
        pub trait ZxdgShellV6: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_shell_v6";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_shell_v6#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_shell_v6#{}.create_positioner()", object.id);
                        self.create_positioner(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zxdg_shell_v6#{}.get_xdg_surface()", object.id);
                        self.get_xdg_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("zxdg_shell_v6#{}.pong()", object.id);
                        self.pong(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy this xdg_shell object."]
            #[doc = ""]
            #[doc = "Destroying a bound xdg_shell object while there are surfaces"]
            #[doc = "still alive created by this xdg_shell object instance is illegal"]
            #[doc = "and will result in a protocol error."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a positioner object. A positioner object is used to position"]
            #[doc = "surfaces relative to some parent surface. See the interface description"]
            #[doc = "and xdg_surface.get_popup for details."]
            async fn create_positioner(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This creates an xdg_surface for the given surface. While xdg_surface"]
            #[doc = "itself is not a role, the corresponding surface may only be assigned"]
            #[doc = "a role extending xdg_surface, such as xdg_toplevel or xdg_popup."]
            #[doc = ""]
            #[doc = "This creates an xdg_surface for the given surface. An xdg_surface is"]
            #[doc = "used as basis to define a role to a given surface, such as xdg_toplevel"]
            #[doc = "or xdg_popup. It also manages functionality shared between xdg_surface"]
            #[doc = "based surface roles."]
            #[doc = ""]
            #[doc = "See the documentation of xdg_surface for more details about what an"]
            #[doc = "xdg_surface is and how it is used."]
            async fn get_xdg_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "A client must respond to a ping event with a pong request or"]
            #[doc = "the client may be deemed unresponsive. See xdg_shell.ping."]
            async fn pong(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "The ping event asks the client if it's still alive. Pass the"]
            #[doc = "serial specified in the event back to the compositor by sending"]
            #[doc = "a \"pong\" request back with the specified serial. See xdg_shell.ping."]
            #[doc = ""]
            #[doc = "Compositors can use this to determine if the client is still"]
            #[doc = "alive. It's unspecified what will happen if the client doesn't"]
            #[doc = "respond to the ping request, or in what timeframe. Clients should"]
            #[doc = "try to respond in a reasonable amount of time."]
            #[doc = ""]
            #[doc = "A compositor is free to ping in any way it wants, but a client must"]
            #[doc = "always respond to any xdg_shell object it created."]
            async fn ping(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zxdg_positioner_v6 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidInput = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! { # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Anchor : u32 { # [doc = "the center of the anchor rectangle"] const None = 0u32 ; # [doc = "the top edge of the anchor rectangle"] const Top = 1u32 ; # [doc = "the bottom edge of the anchor rectangle"] const Bottom = 2u32 ; # [doc = "the left edge of the anchor rectangle"] const Left = 4u32 ; # [doc = "the right edge of the anchor rectangle"] const Right = 8u32 ; } }
        impl TryFrom<u32> for Anchor {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        bitflags::bitflags! { # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Gravity : u32 { # [doc = "center over the anchor edge"] const None = 0u32 ; # [doc = "position above the anchor edge"] const Top = 1u32 ; # [doc = "position below the anchor edge"] const Bottom = 2u32 ; # [doc = "position to the left of the anchor edge"] const Left = 4u32 ; # [doc = "position to the right of the anchor edge"] const Right = 8u32 ; } }
        impl TryFrom<u32> for Gravity {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        bitflags::bitflags! { # [doc = "The constraint adjustment value define ways the compositor will adjust"] # [doc = "the position of the surface, if the unadjusted position would result"] # [doc = "in the surface being partly constrained."] # [doc = ""] # [doc = "Whether a surface is considered 'constrained' is left to the compositor"] # [doc = "to determine. For example, the surface may be partly outside the"] # [doc = "compositor's defined 'work area', thus necessitating the child surface's"] # [doc = "position be adjusted until it is entirely inside the work area."] # [doc = ""] # [doc = "The adjustments can be combined, according to a defined precedence: 1)"] # [doc = "Flip, 2) Slide, 3) Resize."] # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct ConstraintAdjustment : u32 { const None = 0u32 ; const SlideX = 1u32 ; const SlideY = 2u32 ; const FlipX = 4u32 ; const FlipY = 8u32 ; const ResizeX = 16u32 ; const ResizeY = 32u32 ; } }
        impl TryFrom<u32> for ConstraintAdjustment {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "The xdg_positioner provides a collection of rules for the placement of a"]
        #[doc = "child surface relative to a parent surface. Rules can be defined to ensure"]
        #[doc = "the child surface remains within the visible area's borders, and to"]
        #[doc = "specify how the child surface changes its position, such as sliding along"]
        #[doc = "an axis, or flipping around a rectangle. These positioner-created rules are"]
        #[doc = "constrained by the requirement that a child surface must intersect with or"]
        #[doc = "be at least partially adjacent to its parent surface."]
        #[doc = ""]
        #[doc = "See the various requests for details about possible rules."]
        #[doc = ""]
        #[doc = "At the time of the request, the compositor makes a copy of the rules"]
        #[doc = "specified by the xdg_positioner. Thus, after the request is complete the"]
        #[doc = "xdg_positioner object can be destroyed or reused; further changes to the"]
        #[doc = "object will have no effect on previous usages."]
        #[doc = ""]
        #[doc = "For an xdg_positioner object to be considered complete, it must have a"]
        #[doc = "non-zero size set by set_size, and a non-zero anchor rectangle set by"]
        #[doc = "set_anchor_rect. Passing an incomplete xdg_positioner object when"]
        #[doc = "positioning a surface raises an error."]
        pub trait ZxdgPositionerV6: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_positioner_v6";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_positioner_v6#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_positioner_v6#{}.set_size()", object.id);
                        self.set_size(object, client, message.int()?, message.int()?)
                            .await
                    }
                    2u16 => {
                        tracing::debug!("zxdg_positioner_v6#{}.set_anchor_rect()", object.id);
                        self.set_anchor_rect(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("zxdg_positioner_v6#{}.set_anchor()", object.id);
                        self.set_anchor(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    4u16 => {
                        tracing::debug!("zxdg_positioner_v6#{}.set_gravity()", object.id);
                        self.set_gravity(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    5u16 => {
                        tracing::debug!(
                            "zxdg_positioner_v6#{}.set_constraint_adjustment()",
                            object.id
                        );
                        self.set_constraint_adjustment(object, client, message.uint()?)
                            .await
                    }
                    6u16 => {
                        tracing::debug!("zxdg_positioner_v6#{}.set_offset()", object.id);
                        self.set_offset(object, client, message.int()?, message.int()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Notify the compositor that the xdg_positioner will no longer be used."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the size of the surface that is to be positioned with the positioner"]
            #[doc = "object. The size is in surface-local coordinates and corresponds to the"]
            #[doc = "window geometry. See xdg_surface.set_window_geometry."]
            #[doc = ""]
            #[doc = "If a zero or negative size is set the invalid_input error is raised."]
            async fn set_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Specify the anchor rectangle within the parent surface that the child"]
            #[doc = "surface will be placed relative to. The rectangle is relative to the"]
            #[doc = "window geometry as defined by xdg_surface.set_window_geometry of the"]
            #[doc = "parent surface. The rectangle must be at least 1x1 large."]
            #[doc = ""]
            #[doc = "When the xdg_positioner object is used to position a child surface, the"]
            #[doc = "anchor rectangle may not extend outside the window geometry of the"]
            #[doc = "positioned child's parent surface."]
            #[doc = ""]
            #[doc = "If a zero or negative size is set the invalid_input error is raised."]
            async fn set_anchor_rect(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Defines a set of edges for the anchor rectangle. These are used to"]
            #[doc = "derive an anchor point that the child surface will be positioned"]
            #[doc = "relative to. If two orthogonal edges are specified (e.g. 'top' and"]
            #[doc = "'left'), then the anchor point will be the intersection of the edges"]
            #[doc = "(e.g. the top left position of the rectangle); otherwise, the derived"]
            #[doc = "anchor point will be centered on the specified edge, or in the center of"]
            #[doc = "the anchor rectangle if no edge is specified."]
            #[doc = ""]
            #[doc = "If two parallel anchor edges are specified (e.g. 'left' and 'right'),"]
            #[doc = "the invalid_input error is raised."]
            async fn set_anchor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                anchor: Anchor,
            ) -> crate::server::Result<()>;
            #[doc = "Defines in what direction a surface should be positioned, relative to"]
            #[doc = "the anchor point of the parent surface. If two orthogonal gravities are"]
            #[doc = "specified (e.g. 'bottom' and 'right'), then the child surface will be"]
            #[doc = "placed in the specified direction; otherwise, the child surface will be"]
            #[doc = "centered over the anchor point on any axis that had no gravity"]
            #[doc = "specified."]
            #[doc = ""]
            #[doc = "If two parallel gravities are specified (e.g. 'left' and 'right'), the"]
            #[doc = "invalid_input error is raised."]
            async fn set_gravity(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                gravity: Gravity,
            ) -> crate::server::Result<()>;
            #[doc = "Specify how the window should be positioned if the originally intended"]
            #[doc = "position caused the surface to be constrained, meaning at least"]
            #[doc = "partially outside positioning boundaries set by the compositor. The"]
            #[doc = "adjustment is set by constructing a bitmask describing the adjustment to"]
            #[doc = "be made when the surface is constrained on that axis."]
            #[doc = ""]
            #[doc = "If no bit for one axis is set, the compositor will assume that the child"]
            #[doc = "surface should not change its position on that axis when constrained."]
            #[doc = ""]
            #[doc = "If more than one bit for one axis is set, the order of how adjustments"]
            #[doc = "are applied is specified in the corresponding adjustment descriptions."]
            #[doc = ""]
            #[doc = "The default adjustment is none."]
            async fn set_constraint_adjustment(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                constraint_adjustment: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Specify the surface position offset relative to the position of the"]
            #[doc = "anchor on the anchor rectangle and the anchor on the surface. For"]
            #[doc = "example if the anchor of the anchor rectangle is at (x, y), the surface"]
            #[doc = "has the gravity bottom|right, and the offset is (ox, oy), the calculated"]
            #[doc = "surface position will be (x + ox, y + oy). The offset position of the"]
            #[doc = "surface is the one used for constraint testing. See"]
            #[doc = "set_constraint_adjustment."]
            #[doc = ""]
            #[doc = "An example use case is placing a popup menu on top of a user interface"]
            #[doc = "element, while aligning the user interface element of the parent surface"]
            #[doc = "with some user interface element placed somewhere in the popup surface."]
            async fn set_offset(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zxdg_surface_v6 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            NotConstructed = 1u32,
            AlreadyConstructed = 2u32,
            UnconfiguredBuffer = 3u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "An interface that may be implemented by a wl_surface, for"]
        #[doc = "implementations that provide a desktop-style user interface."]
        #[doc = ""]
        #[doc = "It provides a base set of functionality required to construct user"]
        #[doc = "interface elements requiring management by the compositor, such as"]
        #[doc = "toplevel windows, menus, etc. The types of functionality are split into"]
        #[doc = "xdg_surface roles."]
        #[doc = ""]
        #[doc = "Creating an xdg_surface does not set the role for a wl_surface. In order"]
        #[doc = "to map an xdg_surface, the client must create a role-specific object"]
        #[doc = "using, e.g., get_toplevel, get_popup. The wl_surface for any given"]
        #[doc = "xdg_surface can have at most one role, and may not be assigned any role"]
        #[doc = "not based on xdg_surface."]
        #[doc = ""]
        #[doc = "A role must be assigned before any other requests are made to the"]
        #[doc = "xdg_surface object."]
        #[doc = ""]
        #[doc = "The client must call wl_surface.commit on the corresponding wl_surface"]
        #[doc = "for the xdg_surface state to take effect."]
        #[doc = ""]
        #[doc = "Creating an xdg_surface from a wl_surface which has a buffer attached or"]
        #[doc = "committed is a client error, and any attempts by a client to attach or"]
        #[doc = "manipulate a buffer prior to the first xdg_surface.configure call must"]
        #[doc = "also be treated as errors."]
        #[doc = ""]
        #[doc = "For a surface to be mapped by the compositor, the following conditions"]
        #[doc = "must be met: (1) the client has assigned an xdg_surface based role to the"]
        #[doc = "surface, (2) the client has set and committed the xdg_surface state and"]
        #[doc = "the role dependent state to the surface and (3) the client has committed a"]
        #[doc = "buffer to the surface."]
        pub trait ZxdgSurfaceV6: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_surface_v6";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_surface_v6#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_surface_v6#{}.get_toplevel()", object.id);
                        self.get_toplevel(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zxdg_surface_v6#{}.get_popup()", object.id);
                        self.get_popup(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("zxdg_surface_v6#{}.set_window_geometry()", object.id);
                        self.set_window_geometry(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("zxdg_surface_v6#{}.ack_configure()", object.id);
                        self.ack_configure(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the xdg_surface object. An xdg_surface must only be destroyed"]
            #[doc = "after its role object has been destroyed. If the role object still"]
            #[doc = "exists when this request is issued, the zxdg_shell_v6.defunct_surfaces"]
            #[doc = "is raised."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This creates an xdg_toplevel object for the given xdg_surface and gives"]
            #[doc = "the associated wl_surface the xdg_toplevel role. If the surface already"]
            #[doc = "had a role, the zxdg_shell_v6.role error is raised."]
            #[doc = ""]
            #[doc = "See the documentation of xdg_toplevel for more details about what an"]
            #[doc = "xdg_toplevel is and how it is used."]
            async fn get_toplevel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This creates an xdg_popup object for the given xdg_surface and gives the"]
            #[doc = "associated wl_surface the xdg_popup role. If the surface already"]
            #[doc = "had a role, the zxdg_shell_v6.role error is raised."]
            #[doc = ""]
            #[doc = "See the documentation of xdg_popup for more details about what an"]
            #[doc = "xdg_popup is and how it is used."]
            async fn get_popup(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                parent: crate::wire::ObjectId,
                positioner: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "The window geometry of a surface is its \"visible bounds\" from the"]
            #[doc = "user's perspective. Client-side decorations often have invisible"]
            #[doc = "portions like drop-shadows which should be ignored for the"]
            #[doc = "purposes of aligning, placing and constraining windows."]
            #[doc = ""]
            #[doc = "The window geometry is double buffered, and will be applied at the"]
            #[doc = "time wl_surface.commit of the corresponding wl_surface is called."]
            #[doc = ""]
            #[doc = "Once the window geometry of the surface is set, it is not possible to"]
            #[doc = "unset it, and it will remain the same until set_window_geometry is"]
            #[doc = "called again, even if a new subsurface or buffer is attached."]
            #[doc = ""]
            #[doc = "If never set, the value is the full bounds of the surface,"]
            #[doc = "including any subsurfaces. This updates dynamically on every"]
            #[doc = "commit. This unset is meant for extremely simple clients."]
            #[doc = ""]
            #[doc = "The arguments are given in the surface-local coordinate space of"]
            #[doc = "the wl_surface associated with this xdg_surface."]
            #[doc = ""]
            #[doc = "The width and height must be greater than zero. Setting an invalid size"]
            #[doc = "will raise an error. When applied, the effective window geometry will be"]
            #[doc = "the set window geometry clamped to the bounding rectangle of the"]
            #[doc = "combined geometry of the surface of the xdg_surface and the associated"]
            #[doc = "subsurfaces."]
            async fn set_window_geometry(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "When a configure event is received, if a client commits the"]
            #[doc = "surface in response to the configure event, then the client"]
            #[doc = "must make an ack_configure request sometime before the commit"]
            #[doc = "request, passing along the serial of the configure event."]
            #[doc = ""]
            #[doc = "For instance, for toplevel surfaces the compositor might use this"]
            #[doc = "information to move a surface to the top left only when the client has"]
            #[doc = "drawn itself for the maximized or fullscreen state."]
            #[doc = ""]
            #[doc = "If the client receives multiple configure events before it"]
            #[doc = "can respond to one, it only has to ack the last configure event."]
            #[doc = ""]
            #[doc = "A client is not required to commit immediately after sending"]
            #[doc = "an ack_configure request - it may even ack_configure several times"]
            #[doc = "before its next surface commit."]
            #[doc = ""]
            #[doc = "A client may send multiple ack_configure requests before committing, but"]
            #[doc = "only the last request sent before a commit indicates which configure"]
            #[doc = "event the client really is responding to."]
            #[doc = ""]
            #[doc = "If an invalid serial is used, the zxdg_shell_v6.invalid_surface_state"]
            #[doc = "error is raised."]
            async fn ack_configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "The configure event marks the end of a configure sequence. A configure"]
            #[doc = "sequence is a set of one or more events configuring the state of the"]
            #[doc = "xdg_surface, including the final xdg_surface.configure event."]
            #[doc = ""]
            #[doc = "Where applicable, xdg_surface surface roles will during a configure"]
            #[doc = "sequence extend this event as a latched state sent as events before the"]
            #[doc = "xdg_surface.configure event. Such events should be considered to make up"]
            #[doc = "a set of atomically applied configuration states, where the"]
            #[doc = "xdg_surface.configure commits the accumulated state."]
            #[doc = ""]
            #[doc = "Clients should arrange their surface for the new states, and then send"]
            #[doc = "an ack_configure request with the serial sent in this configure event at"]
            #[doc = "some point before committing the new surface."]
            #[doc = ""]
            #[doc = "If the client receives multiple configure events before it can respond"]
            #[doc = "to one, it is free to discard all but the last event it received."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zxdg_toplevel_v6 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ResizeEdge {
            None = 0u32,
            Top = 1u32,
            Bottom = 2u32,
            Left = 4u32,
            TopLeft = 5u32,
            BottomLeft = 6u32,
            Right = 8u32,
            TopRight = 9u32,
            BottomRight = 10u32,
        }
        impl TryFrom<u32> for ResizeEdge {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum State {
            #[doc = "The surface is maximized. The window geometry specified in the configure"]
            #[doc = "event must be obeyed by the client. If the window geometry is not obyed,"]
            #[doc = "the zxdg_shell_v6.invalid_surface_state error is raised."]
            Maximized = 1u32,
            #[doc = "The surface is fullscreen. See set_fullscreen for more information."]
            Fullscreen = 2u32,
            #[doc = "The surface is being resized. The window geometry specified in the"]
            #[doc = "configure event is a maximum; the client cannot resize beyond it. If the"]
            #[doc = "client attempts to resize above it, the zxdg_shell_v6.invalid_surface_state"]
            #[doc = "error is raised."]
            #[doc = "Clients that have aspect ratio or cell sizing configuration can use"]
            #[doc = "a smaller size, however."]
            Resizing = 3u32,
            #[doc = "Client window decorations should be painted as if the window is"]
            #[doc = "active. Do not assume this means that the window actually has"]
            #[doc = "keyboard or pointer focus."]
            Activated = 4u32,
        }
        impl TryFrom<u32> for State {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This interface defines an xdg_surface role which allows a surface to,"]
        #[doc = "among other things, set window-like properties such as maximize,"]
        #[doc = "fullscreen, and minimize, set application-specific metadata like title and"]
        #[doc = "id, and well as trigger user interactive operations such as interactive"]
        #[doc = "resize and move."]
        pub trait ZxdgToplevelV6: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_toplevel_v6";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_parent()", object.id);
                        self.set_parent(object, client, message.object()?).await
                    }
                    2u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_title()", object.id);
                        self.set_title(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_app_id()", object.id);
                        self.set_app_id(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.show_window_menu()", object.id);
                        self.show_window_menu(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    5u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.move()", object.id);
                        self.r#move(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    6u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.resize()", object.id);
                        self.resize(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    7u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_max_size()", object.id);
                        self.set_max_size(object, client, message.int()?, message.int()?)
                            .await
                    }
                    8u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_min_size()", object.id);
                        self.set_min_size(object, client, message.int()?, message.int()?)
                            .await
                    }
                    9u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_maximized()", object.id);
                        self.set_maximized(object, client).await
                    }
                    10u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.unset_maximized()", object.id);
                        self.unset_maximized(object, client).await
                    }
                    11u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_fullscreen()", object.id);
                        self.set_fullscreen(object, client, message.object()?).await
                    }
                    12u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.unset_fullscreen()", object.id);
                        self.unset_fullscreen(object, client).await
                    }
                    13u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_minimized()", object.id);
                        self.set_minimized(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Unmap and destroy the window. The window will be effectively"]
            #[doc = "hidden from the user's point of view, and all state like"]
            #[doc = "maximization, fullscreen, and so on, will be lost."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the \"parent\" of this surface. This window should be stacked"]
            #[doc = "above a parent. The parent surface must be mapped as long as this"]
            #[doc = "surface is mapped."]
            #[doc = ""]
            #[doc = "Parent windows should be set on dialogs, toolboxes, or other"]
            #[doc = "\"auxiliary\" surfaces, so that the parent is raised when the dialog"]
            #[doc = "is raised."]
            async fn set_parent(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                parent: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Set a short title for the surface."]
            #[doc = ""]
            #[doc = "This string may be used to identify the surface in a task bar,"]
            #[doc = "window list, or other user interface elements provided by the"]
            #[doc = "compositor."]
            #[doc = ""]
            #[doc = "The string must be encoded in UTF-8."]
            async fn set_title(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                title: String,
            ) -> crate::server::Result<()>;
            #[doc = "Set an application identifier for the surface."]
            #[doc = ""]
            #[doc = "The app ID identifies the general class of applications to which"]
            #[doc = "the surface belongs. The compositor can use this to group multiple"]
            #[doc = "surfaces together, or to determine how to launch a new application."]
            #[doc = ""]
            #[doc = "For D-Bus activatable applications, the app ID is used as the D-Bus"]
            #[doc = "service name."]
            #[doc = ""]
            #[doc = "The compositor shell will try to group application surfaces together"]
            #[doc = "by their app ID. As a best practice, it is suggested to select app"]
            #[doc = "ID's that match the basename of the application's .desktop file."]
            #[doc = "For example, \"org.freedesktop.FooViewer\" where the .desktop file is"]
            #[doc = "\"org.freedesktop.FooViewer.desktop\"."]
            #[doc = ""]
            #[doc = "See the desktop-entry specification [0] for more details on"]
            #[doc = "application identifiers and how they relate to well-known D-Bus"]
            #[doc = "names and .desktop files."]
            #[doc = ""]
            #[doc = "[0] http://standards.freedesktop.org/desktop-entry-spec/"]
            async fn set_app_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                app_id: String,
            ) -> crate::server::Result<()>;
            #[doc = "Clients implementing client-side decorations might want to show"]
            #[doc = "a context menu when right-clicking on the decorations, giving the"]
            #[doc = "user a menu that they can use to maximize or minimize the window."]
            #[doc = ""]
            #[doc = "This request asks the compositor to pop up such a window menu at"]
            #[doc = "the given position, relative to the local surface coordinates of"]
            #[doc = "the parent surface. There are no guarantees as to what menu items"]
            #[doc = "the window menu contains."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action"]
            #[doc = "like a button press, key press, or touch down event."]
            async fn show_window_menu(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Start an interactive, user-driven move of the surface."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action"]
            #[doc = "like a button press, key press, or touch down event. The passed"]
            #[doc = "serial is used to determine the type of interactive move (touch,"]
            #[doc = "pointer, etc)."]
            #[doc = ""]
            #[doc = "The server may ignore move requests depending on the state of"]
            #[doc = "the surface (e.g. fullscreen or maximized), or if the passed serial"]
            #[doc = "is no longer valid."]
            #[doc = ""]
            #[doc = "If triggered, the surface will lose the focus of the device"]
            #[doc = "(wl_pointer, wl_touch, etc) used for the move. It is up to the"]
            #[doc = "compositor to visually indicate that the move is taking place, such as"]
            #[doc = "updating a pointer cursor, during the move. There is no guarantee"]
            #[doc = "that the device focus will return when the move is completed."]
            async fn r#move(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Start a user-driven, interactive resize of the surface."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action"]
            #[doc = "like a button press, key press, or touch down event. The passed"]
            #[doc = "serial is used to determine the type of interactive resize (touch,"]
            #[doc = "pointer, etc)."]
            #[doc = ""]
            #[doc = "The server may ignore resize requests depending on the state of"]
            #[doc = "the surface (e.g. fullscreen or maximized)."]
            #[doc = ""]
            #[doc = "If triggered, the client will receive configure events with the"]
            #[doc = "\"resize\" state enum value and the expected sizes. See the \"resize\""]
            #[doc = "enum value for more details about what is required. The client"]
            #[doc = "must also acknowledge configure events using \"ack_configure\". After"]
            #[doc = "the resize is completed, the client will receive another \"configure\""]
            #[doc = "event without the resize state."]
            #[doc = ""]
            #[doc = "If triggered, the surface also will lose the focus of the device"]
            #[doc = "(wl_pointer, wl_touch, etc) used for the resize. It is up to the"]
            #[doc = "compositor to visually indicate that the resize is taking place,"]
            #[doc = "such as updating a pointer cursor, during the resize. There is no"]
            #[doc = "guarantee that the device focus will return when the resize is"]
            #[doc = "completed."]
            #[doc = ""]
            #[doc = "The edges parameter specifies how the surface should be resized,"]
            #[doc = "and is one of the values of the resize_edge enum. The compositor"]
            #[doc = "may use this information to update the surface position for"]
            #[doc = "example when dragging the top left corner. The compositor may also"]
            #[doc = "use this information to adapt its behavior, e.g. choose an"]
            #[doc = "appropriate cursor image."]
            async fn resize(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
                edges: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Set a maximum size for the window."]
            #[doc = ""]
            #[doc = "The client can specify a maximum size so that the compositor does"]
            #[doc = "not try to configure the window beyond this size."]
            #[doc = ""]
            #[doc = "The width and height arguments are in window geometry coordinates."]
            #[doc = "See xdg_surface.set_window_geometry."]
            #[doc = ""]
            #[doc = "Values set in this way are double-buffered. They will get applied"]
            #[doc = "on the next commit."]
            #[doc = ""]
            #[doc = "The compositor can use this information to allow or disallow"]
            #[doc = "different states like maximize or fullscreen and draw accurate"]
            #[doc = "animations."]
            #[doc = ""]
            #[doc = "Similarly, a tiling window manager may use this information to"]
            #[doc = "place and resize client windows in a more effective way."]
            #[doc = ""]
            #[doc = "The client should not rely on the compositor to obey the maximum"]
            #[doc = "size. The compositor may decide to ignore the values set by the"]
            #[doc = "client and request a larger size."]
            #[doc = ""]
            #[doc = "If never set, or a value of zero in the request, means that the"]
            #[doc = "client has no expected maximum size in the given dimension."]
            #[doc = "As a result, a client wishing to reset the maximum size"]
            #[doc = "to an unspecified state can use zero for width and height in the"]
            #[doc = "request."]
            #[doc = ""]
            #[doc = "Requesting a maximum size to be smaller than the minimum size of"]
            #[doc = "a surface is illegal and will result in a protocol error."]
            #[doc = ""]
            #[doc = "The width and height must be greater than or equal to zero. Using"]
            #[doc = "strictly negative values for width and height will result in the"]
            #[doc = "zxdg_shell_v6.invalid_surface_state error being raised."]
            async fn set_max_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Set a minimum size for the window."]
            #[doc = ""]
            #[doc = "The client can specify a minimum size so that the compositor does"]
            #[doc = "not try to configure the window below this size."]
            #[doc = ""]
            #[doc = "The width and height arguments are in window geometry coordinates."]
            #[doc = "See xdg_surface.set_window_geometry."]
            #[doc = ""]
            #[doc = "Values set in this way are double-buffered. They will get applied"]
            #[doc = "on the next commit."]
            #[doc = ""]
            #[doc = "The compositor can use this information to allow or disallow"]
            #[doc = "different states like maximize or fullscreen and draw accurate"]
            #[doc = "animations."]
            #[doc = ""]
            #[doc = "Similarly, a tiling window manager may use this information to"]
            #[doc = "place and resize client windows in a more effective way."]
            #[doc = ""]
            #[doc = "The client should not rely on the compositor to obey the minimum"]
            #[doc = "size. The compositor may decide to ignore the values set by the"]
            #[doc = "client and request a smaller size."]
            #[doc = ""]
            #[doc = "If never set, or a value of zero in the request, means that the"]
            #[doc = "client has no expected minimum size in the given dimension."]
            #[doc = "As a result, a client wishing to reset the minimum size"]
            #[doc = "to an unspecified state can use zero for width and height in the"]
            #[doc = "request."]
            #[doc = ""]
            #[doc = "Requesting a minimum size to be larger than the maximum size of"]
            #[doc = "a surface is illegal and will result in a protocol error."]
            #[doc = ""]
            #[doc = "The width and height must be greater than or equal to zero. Using"]
            #[doc = "strictly negative values for width and height will result in the"]
            #[doc = "zxdg_shell_v6.invalid_surface_state error being raised."]
            async fn set_min_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Maximize the surface."]
            #[doc = ""]
            #[doc = "After requesting that the surface should be maximized, the compositor"]
            #[doc = "will respond by emitting a configure event with the \"maximized\" state"]
            #[doc = "and the required window geometry. The client should then update its"]
            #[doc = "content, drawing it in a maximized state, i.e. without shadow or other"]
            #[doc = "decoration outside of the window geometry. The client must also"]
            #[doc = "acknowledge the configure when committing the new content (see"]
            #[doc = "ack_configure)."]
            #[doc = ""]
            #[doc = "It is up to the compositor to decide how and where to maximize the"]
            #[doc = "surface, for example which output and what region of the screen should"]
            #[doc = "be used."]
            #[doc = ""]
            #[doc = "If the surface was already maximized, the compositor will still emit"]
            #[doc = "a configure event with the \"maximized\" state."]
            #[doc = ""]
            #[doc = "Note that unrelated compositor side state changes may cause"]
            #[doc = "configure events to be emitted at any time, meaning trying to"]
            #[doc = "match this request to a specific future configure event is"]
            #[doc = "futile."]
            async fn set_maximized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Unmaximize the surface."]
            #[doc = ""]
            #[doc = "After requesting that the surface should be unmaximized, the compositor"]
            #[doc = "will respond by emitting a configure event without the \"maximized\""]
            #[doc = "state. If available, the compositor will include the window geometry"]
            #[doc = "dimensions the window had prior to being maximized in the configure"]
            #[doc = "request. The client must then update its content, drawing it in a"]
            #[doc = "regular state, i.e. potentially with shadow, etc. The client must also"]
            #[doc = "acknowledge the configure when committing the new content (see"]
            #[doc = "ack_configure)."]
            #[doc = ""]
            #[doc = "It is up to the compositor to position the surface after it was"]
            #[doc = "unmaximized; usually the position the surface had before maximizing, if"]
            #[doc = "applicable."]
            #[doc = ""]
            #[doc = "If the surface was already not maximized, the compositor will still"]
            #[doc = "emit a configure event without the \"maximized\" state."]
            #[doc = ""]
            #[doc = "Note that unrelated changes in the state of compositor may cause"]
            #[doc = "configure events to be emitted by the compositor between processing"]
            #[doc = "this request and emitting corresponding configure event, so trying"]
            #[doc = "to match the request with the event is futile."]
            async fn unset_maximized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Make the surface fullscreen."]
            #[doc = ""]
            #[doc = "You can specify an output that you would prefer to be fullscreen."]
            #[doc = "If this value is NULL, it's up to the compositor to choose which"]
            #[doc = "display will be used to map this surface."]
            #[doc = ""]
            #[doc = "If the surface doesn't cover the whole output, the compositor will"]
            #[doc = "position the surface in the center of the output and compensate with"]
            #[doc = "black borders filling the rest of the output."]
            async fn set_fullscreen(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            async fn unset_fullscreen(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Request that the compositor minimize your surface. There is no"]
            #[doc = "way to know if the surface is currently minimized, nor is there"]
            #[doc = "any way to unset minimization on this surface."]
            #[doc = ""]
            #[doc = "If you are looking to throttle redrawing when minimized, please"]
            #[doc = "instead use the wl_surface.frame event for this, as this will"]
            #[doc = "also work with live previews on windows in Alt-Tab, Expose or"]
            #[doc = "similar compositor features."]
            async fn set_minimized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This configure event asks the client to resize its toplevel surface or"]
            #[doc = "to change its state. The configured state should not be applied"]
            #[doc = "immediately. See xdg_surface.configure for details."]
            #[doc = ""]
            #[doc = "The width and height arguments specify a hint to the window"]
            #[doc = "about how its surface should be resized in window geometry"]
            #[doc = "coordinates. See set_window_geometry."]
            #[doc = ""]
            #[doc = "If the width or height arguments are zero, it means the client"]
            #[doc = "should decide its own window dimension. This may happen when the"]
            #[doc = "compositor needs to configure the state of the surface but doesn't"]
            #[doc = "have any information about any previous or expected dimension."]
            #[doc = ""]
            #[doc = "The states listed in the event specify how the width/height"]
            #[doc = "arguments should be interpreted, and possibly how it should be"]
            #[doc = "drawn."]
            #[doc = ""]
            #[doc = "Clients must send an ack_configure in response to this event. See"]
            #[doc = "xdg_surface.configure and xdg_surface.ack_configure for details."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The close event is sent by the compositor when the user"]
            #[doc = "wants the surface to be closed. This should be equivalent to"]
            #[doc = "the user clicking the close button in client-side decorations,"]
            #[doc = "if your application has any."]
            #[doc = ""]
            #[doc = "This is only a request that the user intends to close the"]
            #[doc = "window. The client may choose to ignore this request, or show"]
            #[doc = "a dialog to ask the user to save their data, etc."]
            async fn close(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zxdg_popup_v6 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidGrab = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "A popup surface is a short-lived, temporary surface. It can be used to"]
        #[doc = "implement for example menus, popovers, tooltips and other similar user"]
        #[doc = "interface concepts."]
        #[doc = ""]
        #[doc = "A popup can be made to take an explicit grab. See xdg_popup.grab for"]
        #[doc = "details."]
        #[doc = ""]
        #[doc = "When the popup is dismissed, a popup_done event will be sent out, and at"]
        #[doc = "the same time the surface will be unmapped. See the xdg_popup.popup_done"]
        #[doc = "event for details."]
        #[doc = ""]
        #[doc = "Explicitly destroying the xdg_popup object will also dismiss the popup and"]
        #[doc = "unmap the surface. Clients that want to dismiss the popup when another"]
        #[doc = "surface of their own is clicked should dismiss the popup using the destroy"]
        #[doc = "request."]
        #[doc = ""]
        #[doc = "The parent surface must have either the xdg_toplevel or xdg_popup surface"]
        #[doc = "role."]
        #[doc = ""]
        #[doc = "A newly created xdg_popup will be stacked on top of all previously created"]
        #[doc = "xdg_popup surfaces associated with the same xdg_toplevel."]
        #[doc = ""]
        #[doc = "The parent of an xdg_popup must be mapped (see the xdg_surface"]
        #[doc = "description) before the xdg_popup itself."]
        #[doc = ""]
        #[doc = "The x and y arguments passed when creating the popup object specify"]
        #[doc = "where the top left of the popup should be placed, relative to the"]
        #[doc = "local surface coordinates of the parent surface. See"]
        #[doc = "xdg_surface.get_popup. An xdg_popup must intersect with or be at least"]
        #[doc = "partially adjacent to its parent surface."]
        #[doc = ""]
        #[doc = "The client must call wl_surface.commit on the corresponding wl_surface"]
        #[doc = "for the xdg_popup state to take effect."]
        pub trait ZxdgPopupV6: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_popup_v6";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_popup_v6#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_popup_v6#{}.grab()", object.id);
                        self.grab(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This destroys the popup. Explicitly destroying the xdg_popup"]
            #[doc = "object will also dismiss the popup, and unmap the surface."]
            #[doc = ""]
            #[doc = "If this xdg_popup is not the \"topmost\" popup, a protocol error"]
            #[doc = "will be sent."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This request makes the created popup take an explicit grab. An explicit"]
            #[doc = "grab will be dismissed when the user dismisses the popup, or when the"]
            #[doc = "client destroys the xdg_popup. This can be done by the user clicking"]
            #[doc = "outside the surface, using the keyboard, or even locking the screen"]
            #[doc = "through closing the lid or a timeout."]
            #[doc = ""]
            #[doc = "If the compositor denies the grab, the popup will be immediately"]
            #[doc = "dismissed."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action like a"]
            #[doc = "button press, key press, or touch down event. The serial number of the"]
            #[doc = "event should be passed as 'serial'."]
            #[doc = ""]
            #[doc = "The parent of a grabbing popup must either be an xdg_toplevel surface or"]
            #[doc = "another xdg_popup with an explicit grab. If the parent is another"]
            #[doc = "xdg_popup it means that the popups are nested, with this popup now being"]
            #[doc = "the topmost popup."]
            #[doc = ""]
            #[doc = "Nested popups must be destroyed in the reverse order they were created"]
            #[doc = "in, e.g. the only popup you are allowed to destroy at all times is the"]
            #[doc = "topmost one."]
            #[doc = ""]
            #[doc = "When compositors choose to dismiss a popup, they may dismiss every"]
            #[doc = "nested grabbing popup as well. When a compositor dismisses popups, it"]
            #[doc = "will follow the same dismissing order as required from the client."]
            #[doc = ""]
            #[doc = "The parent of a grabbing popup must either be another xdg_popup with an"]
            #[doc = "active explicit grab, or an xdg_popup or xdg_toplevel, if there are no"]
            #[doc = "explicit grabs already taken."]
            #[doc = ""]
            #[doc = "If the topmost grabbing popup is destroyed, the grab will be returned to"]
            #[doc = "the parent of the popup, if that parent previously had an explicit grab."]
            #[doc = ""]
            #[doc = "If the parent is a grabbing popup which has already been dismissed, this"]
            #[doc = "popup will be immediately dismissed. If the parent is a popup that did"]
            #[doc = "not take an explicit grab, an error will be raised."]
            #[doc = ""]
            #[doc = "During a popup grab, the client owning the grab will receive pointer"]
            #[doc = "and touch events for all their surfaces as normal (similar to an"]
            #[doc = "\"owner-events\" grab in X11 parlance), while the top most grabbing popup"]
            #[doc = "will always have keyboard focus."]
            async fn grab(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This event asks the popup surface to configure itself given the"]
            #[doc = "configuration. The configured state should not be applied immediately."]
            #[doc = "See xdg_surface.configure for details."]
            #[doc = ""]
            #[doc = "The x and y arguments represent the position the popup was placed at"]
            #[doc = "given the xdg_positioner rule, relative to the upper left corner of the"]
            #[doc = "window geometry of the parent surface."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The popup_done event is sent out when a popup is dismissed by the"]
            #[doc = "compositor. The client should destroy the xdg_popup object at this"]
            #[doc = "point."]
            async fn popup_done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
#[doc = "This protocol allows a privileged client to control data devices. In"]
#[doc = "particular, the client will be able to manage the current selection and take"]
#[doc = "the role of a clipboard manager."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and"]
#[doc = "backward incompatible changes may be made. Backward compatible changes"]
#[doc = "may be added together with the corresponding interface version bump."]
#[doc = "Backward incompatible changes are done by bumping the version number in"]
#[doc = "the protocol and interface names and resetting the interface version."]
#[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
#[doc = "version number in the protocol and interface names are removed and the"]
#[doc = "interface version number is reset."]
pub mod wlr_data_control_unstable_v1 {
    pub mod zwlr_data_control_manager_v1 {
        #[doc = "This interface is a manager that allows creating per-seat data device"]
        #[doc = "controls."]
        pub trait ZwlrDataControlManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_data_control_manager_v1";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwlr_data_control_manager_v1#{}.create_data_source()",
                            object.id
                        );
                        self.create_data_source(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwlr_data_control_manager_v1#{}.get_data_device()",
                            object.id
                        );
                        self.get_data_device(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zwlr_data_control_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a new data source."]
            async fn create_data_source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Create a data device that can be used to manage a seat's selection."]
            async fn get_data_device(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "All objects created by the manager will still remain valid, until their"]
            #[doc = "appropriate destroy request has been called."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwlr_data_control_device_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            UsedSource = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This interface allows a client to manage a seat's selection."]
        #[doc = ""]
        #[doc = "When the seat is destroyed, this object becomes inert."]
        pub trait ZwlrDataControlDeviceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_data_control_device_v1";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwlr_data_control_device_v1#{}.set_selection()",
                            object.id
                        );
                        self.set_selection(object, client, message.object()?).await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_data_control_device_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    2u16 => {
                        tracing::debug!(
                            "zwlr_data_control_device_v1#{}.set_primary_selection()",
                            object.id
                        );
                        self.set_primary_selection(object, client, message.object()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request asks the compositor to set the selection to the data from"]
            #[doc = "the source on behalf of the client."]
            #[doc = ""]
            #[doc = "The given source may not be used in any further set_selection or"]
            #[doc = "set_primary_selection requests. Attempting to use a previously used"]
            #[doc = "source is a protocol error."]
            #[doc = ""]
            #[doc = "To unset the selection, set the source to NULL."]
            async fn set_selection(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys the data device object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This request asks the compositor to set the primary selection to the"]
            #[doc = "data from the source on behalf of the client."]
            #[doc = ""]
            #[doc = "The given source may not be used in any further set_selection or"]
            #[doc = "set_primary_selection requests. Attempting to use a previously used"]
            #[doc = "source is a protocol error."]
            #[doc = ""]
            #[doc = "To unset the primary selection, set the source to NULL."]
            #[doc = ""]
            #[doc = "The compositor will ignore this request if it does not support primary"]
            #[doc = "selection."]
            async fn set_primary_selection(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "The data_offer event introduces a new wlr_data_control_offer object,"]
            #[doc = "which will subsequently be used in either the"]
            #[doc = "wlr_data_control_device.selection event (for the regular clipboard"]
            #[doc = "selections) or the wlr_data_control_device.primary_selection event (for"]
            #[doc = "the primary clipboard selections). Immediately following the"]
            #[doc = "wlr_data_control_device.data_offer event, the new data_offer object"]
            #[doc = "will send out wlr_data_control_offer.offer events to describe the MIME"]
            #[doc = "types it offers."]
            async fn data_offer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The selection event is sent out to notify the client of a new"]
            #[doc = "wlr_data_control_offer for the selection for this device. The"]
            #[doc = "wlr_data_control_device.data_offer and the wlr_data_control_offer.offer"]
            #[doc = "events are sent out immediately before this event to introduce the data"]
            #[doc = "offer object. The selection event is sent to a client when a new"]
            #[doc = "selection is set. The wlr_data_control_offer is valid until a new"]
            #[doc = "wlr_data_control_offer or NULL is received. The client must destroy the"]
            #[doc = "previous selection wlr_data_control_offer, if any, upon receiving this"]
            #[doc = "event."]
            #[doc = ""]
            #[doc = "The first selection event is sent upon binding the"]
            #[doc = "wlr_data_control_device object."]
            async fn selection(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This data control object is no longer valid and should be destroyed by"]
            #[doc = "the client."]
            async fn finished(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The primary_selection event is sent out to notify the client of a new"]
            #[doc = "wlr_data_control_offer for the primary selection for this device. The"]
            #[doc = "wlr_data_control_device.data_offer and the wlr_data_control_offer.offer"]
            #[doc = "events are sent out immediately before this event to introduce the data"]
            #[doc = "offer object. The primary_selection event is sent to a client when a"]
            #[doc = "new primary selection is set. The wlr_data_control_offer is valid until"]
            #[doc = "a new wlr_data_control_offer or NULL is received. The client must"]
            #[doc = "destroy the previous primary selection wlr_data_control_offer, if any,"]
            #[doc = "upon receiving this event."]
            #[doc = ""]
            #[doc = "If the compositor supports primary selection, the first"]
            #[doc = "primary_selection event is sent upon binding the"]
            #[doc = "wlr_data_control_device object."]
            async fn primary_selection(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwlr_data_control_source_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidOffer = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "The wlr_data_control_source object is the source side of a"]
        #[doc = "wlr_data_control_offer. It is created by the source client in a data"]
        #[doc = "transfer and provides a way to describe the offered data and a way to"]
        #[doc = "respond to requests to transfer the data."]
        pub trait ZwlrDataControlSourceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_data_control_source_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_data_control_source_v1#{}.offer()", object.id);
                        self.offer(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_data_control_source_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request adds a MIME type to the set of MIME types advertised to"]
            #[doc = "targets. Can be called several times to offer multiple types."]
            #[doc = ""]
            #[doc = "Calling this after wlr_data_control_device.set_selection is a protocol"]
            #[doc = "error."]
            async fn offer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys the data source object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Request for data from the client. Send the data as the specified MIME"]
            #[doc = "type over the passed file descriptor, then close it."]
            async fn send(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This data source is no longer valid. The data source has been replaced"]
            #[doc = "by another data source."]
            #[doc = ""]
            #[doc = "The client should clean up and destroy this data source."]
            async fn cancelled(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwlr_data_control_offer_v1 {
        #[doc = "A wlr_data_control_offer represents a piece of data offered for transfer"]
        #[doc = "by another client (the source client). The offer describes the different"]
        #[doc = "MIME types that the data can be converted to and provides the mechanism"]
        #[doc = "for transferring the data directly from the source client."]
        pub trait ZwlrDataControlOfferV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_data_control_offer_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_data_control_offer_v1#{}.receive()", object.id);
                        self.receive(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.fd()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_data_control_offer_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "To transfer the offered data, the client issues this request and"]
            #[doc = "indicates the MIME type it wants to receive. The transfer happens"]
            #[doc = "through the passed file descriptor (typically created with the pipe"]
            #[doc = "system call). The source client writes the data in the MIME type"]
            #[doc = "representation requested and then closes the file descriptor."]
            #[doc = ""]
            #[doc = "The receiving client reads from the read end of the pipe until EOF and"]
            #[doc = "then closes its end, at which point the transfer is complete."]
            #[doc = ""]
            #[doc = "This request may happen multiple times for different MIME types."]
            async fn receive(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
                fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys the data offer object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sent immediately after creating the wlr_data_control_offer object."]
            #[doc = "One event per offered MIME type."]
            async fn offer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
#[doc = "An interface to capture surfaces in an efficient way by exporting DMA-BUFs."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and"]
#[doc = "backward incompatible changes may be made. Backward compatible changes"]
#[doc = "may be added together with the corresponding interface version bump."]
#[doc = "Backward incompatible changes are done by bumping the version number in"]
#[doc = "the protocol and interface names and resetting the interface version."]
#[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
#[doc = "version number in the protocol and interface names are removed and the"]
#[doc = "interface version number is reset."]
pub mod wlr_export_dmabuf_unstable_v1 {
    pub mod zwlr_export_dmabuf_manager_v1 {
        #[doc = "This object is a manager with which to start capturing from sources."]
        pub trait ZwlrExportDmabufManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_export_dmabuf_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwlr_export_dmabuf_manager_v1#{}.capture_output()",
                            object.id
                        );
                        self.capture_output(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_export_dmabuf_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Capture the next frame of an entire output."]
            async fn capture_output(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                frame: crate::wire::ObjectId,
                overlay_cursor: i32,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "All objects created by the manager will still remain valid, until their"]
            #[doc = "appropriate destroy request has been called."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwlr_export_dmabuf_frame_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Flags {
            Transient = 1u32,
        }
        impl TryFrom<u32> for Flags {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum CancelReason {
            Temporary = 0u32,
            Permanent = 1u32,
            Resizing = 2u32,
        }
        impl TryFrom<u32> for CancelReason {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This object represents a single DMA-BUF frame."]
        #[doc = ""]
        #[doc = "If the capture is successful, the compositor will first send a \"frame\""]
        #[doc = "event, followed by one or several \"object\". When the frame is available"]
        #[doc = "for readout, the \"ready\" event is sent."]
        #[doc = ""]
        #[doc = "If the capture failed, the \"cancel\" event is sent. This can happen anytime"]
        #[doc = "before the \"ready\" event."]
        #[doc = ""]
        #[doc = "Once either a \"ready\" or a \"cancel\" event is received, the client should"]
        #[doc = "destroy the frame. Once an \"object\" event is received, the client is"]
        #[doc = "responsible for closing the associated file descriptor."]
        #[doc = ""]
        #[doc = "All frames are read-only and may not be written into or altered."]
        pub trait ZwlrExportDmabufFrameV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_export_dmabuf_frame_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_export_dmabuf_frame_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Unreferences the frame. This request must be called as soon as its no"]
            #[doc = "longer used."]
            #[doc = ""]
            #[doc = "It can be called at any time by the client. The client will still have"]
            #[doc = "to close any FDs it has been given."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Main event supplying the client with information about the frame. If the"]
            #[doc = "capture didn't fail, this event is always emitted first before any other"]
            #[doc = "events."]
            #[doc = ""]
            #[doc = "This event is followed by a number of \"object\" as specified by the"]
            #[doc = "\"num_objects\" argument."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Event which serves to supply the client with the file descriptors"]
            #[doc = "containing the data for each object."]
            #[doc = ""]
            #[doc = "After receiving this event, the client must always close the file"]
            #[doc = "descriptor as soon as they're done with it and even if the frame fails."]
            async fn object(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent as soon as the frame is presented, indicating it is"]
            #[doc = "available for reading. This event includes the time at which"]
            #[doc = "presentation happened at."]
            #[doc = ""]
            #[doc = "The timestamp is expressed as tv_sec_hi, tv_sec_lo, tv_nsec triples,"]
            #[doc = "each component being an unsigned 32-bit value. Whole seconds are in"]
            #[doc = "tv_sec which is a 64-bit value combined from tv_sec_hi and tv_sec_lo,"]
            #[doc = "and the additional fractional part in tv_nsec as nanoseconds. Hence,"]
            #[doc = "for valid timestamps tv_nsec must be in [0, 999999999]. The seconds part"]
            #[doc = "may have an arbitrary offset at start."]
            #[doc = ""]
            #[doc = "After receiving this event, the client should destroy this object."]
            async fn ready(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "If the capture failed or if the frame is no longer valid after the"]
            #[doc = "\"frame\" event has been emitted, this event will be used to inform the"]
            #[doc = "client to scrap the frame."]
            #[doc = ""]
            #[doc = "If the failure is temporary, the client may capture again the same"]
            #[doc = "source. If the failure is permanent, any further attempts to capture the"]
            #[doc = "same source will fail again."]
            #[doc = ""]
            #[doc = "After receiving this event, the client should destroy this object."]
            async fn cancel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
pub mod wlr_foreign_toplevel_management_unstable_v1 {
    pub mod zwlr_foreign_toplevel_manager_v1 {
        #[doc = "The purpose of this protocol is to enable the creation of taskbars"]
        #[doc = "and docks by providing them with a list of opened applications and"]
        #[doc = "letting them request certain actions on them, like maximizing, etc."]
        #[doc = ""]
        #[doc = "After a client binds the zwlr_foreign_toplevel_manager_v1, each opened"]
        #[doc = "toplevel window will be sent via the toplevel event"]
        pub trait ZwlrForeignToplevelManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_foreign_toplevel_manager_v1";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_foreign_toplevel_manager_v1#{}.stop()", object.id);
                        self.stop(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Indicates the client no longer wishes to receive events for new toplevels."]
            #[doc = "However the compositor may emit further toplevel_created events, until"]
            #[doc = "the finished event is emitted."]
            #[doc = ""]
            #[doc = "The client must not send any more requests after this one."]
            async fn stop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is emitted whenever a new toplevel window is created. It"]
            #[doc = "is emitted for all toplevels, regardless of the app that has created"]
            #[doc = "them."]
            #[doc = ""]
            #[doc = "All initial details of the toplevel(title, app_id, states, etc.) will"]
            #[doc = "be sent immediately after this event via the corresponding events in"]
            #[doc = "zwlr_foreign_toplevel_handle_v1."]
            async fn toplevel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event indicates that the compositor is done sending events to the"]
            #[doc = "zwlr_foreign_toplevel_manager_v1. The server will destroy the object"]
            #[doc = "immediately after sending this request, so it will become invalid and"]
            #[doc = "the client should free any resources associated with it."]
            async fn finished(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwlr_foreign_toplevel_handle_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum State {
            Maximized = 0u32,
            Minimized = 1u32,
            Activated = 2u32,
            Fullscreen = 3u32,
        }
        impl TryFrom<u32> for State {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidRectangle = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "A zwlr_foreign_toplevel_handle_v1 object represents an opened toplevel"]
        #[doc = "window. Each app may have multiple opened toplevels."]
        #[doc = ""]
        #[doc = "Each toplevel has a list of outputs it is visible on, conveyed to the"]
        #[doc = "client with the output_enter and output_leave events."]
        pub trait ZwlrForeignToplevelHandleV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_foreign_toplevel_handle_v1";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwlr_foreign_toplevel_handle_v1#{}.set_maximized()",
                            object.id
                        );
                        self.set_maximized(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwlr_foreign_toplevel_handle_v1#{}.unset_maximized()",
                            object.id
                        );
                        self.unset_maximized(object, client).await
                    }
                    2u16 => {
                        tracing::debug!(
                            "zwlr_foreign_toplevel_handle_v1#{}.set_minimized()",
                            object.id
                        );
                        self.set_minimized(object, client).await
                    }
                    3u16 => {
                        tracing::debug!(
                            "zwlr_foreign_toplevel_handle_v1#{}.unset_minimized()",
                            object.id
                        );
                        self.unset_minimized(object, client).await
                    }
                    4u16 => {
                        tracing::debug!("zwlr_foreign_toplevel_handle_v1#{}.activate()", object.id);
                        self.activate(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    5u16 => {
                        tracing::debug!("zwlr_foreign_toplevel_handle_v1#{}.close()", object.id);
                        self.close(object, client).await
                    }
                    6u16 => {
                        tracing::debug!(
                            "zwlr_foreign_toplevel_handle_v1#{}.set_rectangle()",
                            object.id
                        );
                        self.set_rectangle(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    7u16 => {
                        tracing::debug!("zwlr_foreign_toplevel_handle_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    8u16 => {
                        tracing::debug!(
                            "zwlr_foreign_toplevel_handle_v1#{}.set_fullscreen()",
                            object.id
                        );
                        self.set_fullscreen(object, client, message.object()?).await
                    }
                    9u16 => {
                        tracing::debug!(
                            "zwlr_foreign_toplevel_handle_v1#{}.unset_fullscreen()",
                            object.id
                        );
                        self.unset_fullscreen(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Requests that the toplevel be maximized. If the maximized state actually"]
            #[doc = "changes, this will be indicated by the state event."]
            async fn set_maximized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Requests that the toplevel be unmaximized. If the maximized state actually"]
            #[doc = "changes, this will be indicated by the state event."]
            async fn unset_maximized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Requests that the toplevel be minimized. If the minimized state actually"]
            #[doc = "changes, this will be indicated by the state event."]
            async fn set_minimized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Requests that the toplevel be unminimized. If the minimized state actually"]
            #[doc = "changes, this will be indicated by the state event."]
            async fn unset_minimized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Request that this toplevel be activated on the given seat."]
            #[doc = "There is no guarantee the toplevel will be actually activated."]
            async fn activate(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Send a request to the toplevel to close itself. The compositor would"]
            #[doc = "typically use a shell-specific method to carry out this request, for"]
            #[doc = "example by sending the xdg_toplevel.close event. However, this gives"]
            #[doc = "no guarantees the toplevel will actually be destroyed. If and when"]
            #[doc = "this happens, the zwlr_foreign_toplevel_handle_v1.closed event will"]
            #[doc = "be emitted."]
            async fn close(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The rectangle of the surface specified in this request corresponds to"]
            #[doc = "the place where the app using this protocol represents the given toplevel."]
            #[doc = "It can be used by the compositor as a hint for some operations, e.g"]
            #[doc = "minimizing. The client is however not required to set this, in which"]
            #[doc = "case the compositor is free to decide some default value."]
            #[doc = ""]
            #[doc = "If the client specifies more than one rectangle, only the last one is"]
            #[doc = "considered."]
            #[doc = ""]
            #[doc = "The dimensions are given in surface-local coordinates."]
            #[doc = "Setting width=height=0 removes the already-set rectangle."]
            async fn set_rectangle(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys the zwlr_foreign_toplevel_handle_v1 object."]
            #[doc = ""]
            #[doc = "This request should be called either when the client does not want to"]
            #[doc = "use the toplevel anymore or after the closed event to finalize the"]
            #[doc = "destruction of the object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Requests that the toplevel be fullscreened on the given output. If the"]
            #[doc = "fullscreen state and/or the outputs the toplevel is visible on actually"]
            #[doc = "change, this will be indicated by the state and output_enter/leave"]
            #[doc = "events."]
            #[doc = ""]
            #[doc = "The output parameter is only a hint to the compositor. Also, if output"]
            #[doc = "is NULL, the compositor should decide which output the toplevel will be"]
            #[doc = "fullscreened on, if at all."]
            async fn set_fullscreen(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Requests that the toplevel be unfullscreened. If the fullscreen state"]
            #[doc = "actually changes, this will be indicated by the state event."]
            async fn unset_fullscreen(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is emitted whenever the title of the toplevel changes."]
            async fn title(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is emitted whenever the app-id of the toplevel changes."]
            async fn app_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is emitted whenever the toplevel becomes visible on"]
            #[doc = "the given output. A toplevel may be visible on multiple outputs."]
            async fn output_enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is emitted whenever the toplevel stops being visible on"]
            #[doc = "the given output. It is guaranteed that an entered-output event"]
            #[doc = "with the same output has been emitted before this event."]
            async fn output_leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is emitted immediately after the zlw_foreign_toplevel_handle_v1"]
            #[doc = "is created and each time the toplevel state changes, either because of a"]
            #[doc = "compositor action or because of a request in this protocol."]
            async fn state(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent after all changes in the toplevel state have been"]
            #[doc = "sent."]
            #[doc = ""]
            #[doc = "This allows changes to the zwlr_foreign_toplevel_handle_v1 properties"]
            #[doc = "to be seen as atomic, even if they happen via multiple events."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event means the toplevel has been destroyed. It is guaranteed there"]
            #[doc = "won't be any more events for this zwlr_foreign_toplevel_handle_v1. The"]
            #[doc = "toplevel itself becomes inert so any requests will be ignored except the"]
            #[doc = "destroy request."]
            async fn closed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is emitted whenever the parent of the toplevel changes."]
            #[doc = ""]
            #[doc = "No event is emitted when the parent handle is destroyed by the client."]
            async fn parent(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
#[doc = "This protocol allows a privileged client to set the gamma tables for"]
#[doc = "outputs."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and"]
#[doc = "backward incompatible changes may be made. Backward compatible changes"]
#[doc = "may be added together with the corresponding interface version bump."]
#[doc = "Backward incompatible changes are done by bumping the version number in"]
#[doc = "the protocol and interface names and resetting the interface version."]
#[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
#[doc = "version number in the protocol and interface names are removed and the"]
#[doc = "interface version number is reset."]
pub mod wlr_gamma_control_unstable_v1 {
    pub mod zwlr_gamma_control_manager_v1 {
        #[doc = "This interface is a manager that allows creating per-output gamma"]
        #[doc = "controls."]
        pub trait ZwlrGammaControlManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_gamma_control_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwlr_gamma_control_manager_v1#{}.get_gamma_control()",
                            object.id
                        );
                        self.get_gamma_control(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_gamma_control_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a gamma control that can be used to adjust gamma tables for the"]
            #[doc = "provided output."]
            async fn get_gamma_control(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "All objects created by the manager will still remain valid, until their"]
            #[doc = "appropriate destroy request has been called."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwlr_gamma_control_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidGamma = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This interface allows a client to adjust gamma tables for a particular"]
        #[doc = "output."]
        #[doc = ""]
        #[doc = "The client will receive the gamma size, and will then be able to set gamma"]
        #[doc = "tables. At any time the compositor can send a failed event indicating that"]
        #[doc = "this object is no longer valid."]
        #[doc = ""]
        #[doc = "There can only be at most one gamma control object per output, which"]
        #[doc = "has exclusive access to this particular output. When the gamma control"]
        #[doc = "object is destroyed, the gamma table is restored to its original value."]
        pub trait ZwlrGammaControlV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_gamma_control_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_gamma_control_v1#{}.set_gamma()", object.id);
                        self.set_gamma(object, client, message.fd()?).await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_gamma_control_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Set the gamma table. The file descriptor can be memory-mapped to provide"]
            #[doc = "the raw gamma table, which contains successive gamma ramps for the red,"]
            #[doc = "green and blue channels. Each gamma ramp is an array of 16-byte unsigned"]
            #[doc = "integers which has the same length as the gamma size."]
            #[doc = ""]
            #[doc = "The file descriptor data must have the same length as three times the"]
            #[doc = "gamma size."]
            async fn set_gamma(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys the gamma control object. If the object is still valid, this"]
            #[doc = "restores the original gamma tables."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Advertise the size of each gamma ramp."]
            #[doc = ""]
            #[doc = "This event is sent immediately when the gamma control object is created."]
            async fn gamma_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event indicates that the gamma control is no longer valid. This"]
            #[doc = "can happen for a number of reasons, including:"]
            #[doc = "- The output doesn't support gamma tables"]
            #[doc = "- Setting the gamma tables failed"]
            #[doc = "- Another client already has exclusive gamma control for this output"]
            #[doc = "- The compositor has transferred gamma control to another client"]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy this object."]
            async fn failed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
pub mod wlr_input_inhibit_unstable_v1 {
    pub mod zwlr_input_inhibit_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            AlreadyInhibited = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Clients can use this interface to prevent input events from being sent to"]
        #[doc = "any surfaces but its own, which is useful for example in lock screen"]
        #[doc = "software. It is assumed that access to this interface will be locked down"]
        #[doc = "to whitelisted clients by the compositor."]
        #[doc = ""]
        #[doc = "Note! This protocol is deprecated and not intended for production use."]
        #[doc = "For screen lockers, use the ext-session-lock-v1 protocol."]
        pub trait ZwlrInputInhibitManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_input_inhibit_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwlr_input_inhibit_manager_v1#{}.get_inhibitor()",
                            object.id
                        );
                        self.get_inhibitor(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Activates the input inhibitor. As long as the inhibitor is active, the"]
            #[doc = "compositor will not send input events to other clients."]
            async fn get_inhibitor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwlr_input_inhibitor_v1 {
        #[doc = "While this resource exists, input to clients other than the owner of the"]
        #[doc = "inhibitor resource will not receive input events. Any client which"]
        #[doc = "previously had focus will receive a leave event and will not be given"]
        #[doc = "focus again. The client that owns this resource will receive all input"]
        #[doc = "events normally. The compositor will also disable all of its own input"]
        #[doc = "processing (such as keyboard shortcuts) while the inhibitor is active."]
        #[doc = ""]
        #[doc = "The compositor may continue to send input events to selected clients,"]
        #[doc = "such as an on-screen keyboard (via the input-method protocol)."]
        pub trait ZwlrInputInhibitorV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_input_inhibitor_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_input_inhibitor_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the inhibitor and allow other clients to receive input."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod wlr_layer_shell_unstable_v1 {
    pub mod zwlr_layer_shell_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            Role = 0u32,
            InvalidLayer = 1u32,
            AlreadyConstructed = 2u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Layer {
            Background = 0u32,
            Bottom = 1u32,
            Top = 2u32,
            Overlay = 3u32,
        }
        impl TryFrom<u32> for Layer {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Clients can use this interface to assign the surface_layer role to"]
        #[doc = "wl_surfaces. Such surfaces are assigned to a \"layer\" of the output and"]
        #[doc = "rendered with a defined z-depth respective to each other. They may also be"]
        #[doc = "anchored to the edges and corners of a screen and specify input handling"]
        #[doc = "semantics. This interface should be suitable for the implementation of"]
        #[doc = "many desktop shell components, and a broad number of other applications"]
        #[doc = "that interact with the desktop."]
        pub trait ZwlrLayerShellV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_layer_shell_v1";
            const VERSION: u32 = 5u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_layer_shell_v1#{}.get_layer_surface()", object.id);
                        self.get_layer_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.object()?,
                            message.uint()?.try_into()?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_layer_shell_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a layer surface for an existing surface. This assigns the role of"]
            #[doc = "layer_surface, or raises a protocol error if another role is already"]
            #[doc = "assigned."]
            #[doc = ""]
            #[doc = "Creating a layer surface from a wl_surface which has a buffer attached"]
            #[doc = "or committed is a client error, and any attempts by a client to attach"]
            #[doc = "or manipulate a buffer prior to the first layer_surface.configure call"]
            #[doc = "must also be treated as errors."]
            #[doc = ""]
            #[doc = "After creating a layer_surface object and setting it up, the client"]
            #[doc = "must perform an initial commit without any buffer attached."]
            #[doc = "The compositor will reply with a layer_surface.configure event."]
            #[doc = "The client must acknowledge it and is then allowed to attach a buffer"]
            #[doc = "to map the surface."]
            #[doc = ""]
            #[doc = "You may pass NULL for output to allow the compositor to decide which"]
            #[doc = "output to use. Generally this will be the one that the user most"]
            #[doc = "recently interacted with."]
            #[doc = ""]
            #[doc = "Clients can specify a namespace that defines the purpose of the layer"]
            #[doc = "surface."]
            async fn get_layer_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
                output: Option<crate::wire::ObjectId>,
                layer: Layer,
                namespace: String,
            ) -> crate::server::Result<()>;
            #[doc = "This request indicates that the client will not use the layer_shell"]
            #[doc = "object any more. Objects that have been created through this instance"]
            #[doc = "are not affected."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwlr_layer_surface_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum KeyboardInteractivity {
            #[doc = "This value indicates that this surface is not interested in keyboard"]
            #[doc = "events and the compositor should never assign it the keyboard focus."]
            #[doc = ""]
            #[doc = "This is the default value, set for newly created layer shell surfaces."]
            #[doc = ""]
            #[doc = "This is useful for e.g. desktop widgets that display information or"]
            #[doc = "only have interaction with non-keyboard input devices."]
            None = 0u32,
            #[doc = "Request exclusive keyboard focus if this surface is above the shell surface layer."]
            #[doc = ""]
            #[doc = "For the top and overlay layers, the seat will always give"]
            #[doc = "exclusive keyboard focus to the top-most layer which has keyboard"]
            #[doc = "interactivity set to exclusive. If this layer contains multiple"]
            #[doc = "surfaces with keyboard interactivity set to exclusive, the compositor"]
            #[doc = "determines the one receiving keyboard events in an implementation-"]
            #[doc = "defined manner. In this case, no guarantee is made when this surface"]
            #[doc = "will receive keyboard focus (if ever)."]
            #[doc = ""]
            #[doc = "For the bottom and background layers, the compositor is allowed to use"]
            #[doc = "normal focus semantics."]
            #[doc = ""]
            #[doc = "This setting is mainly intended for applications that need to ensure"]
            #[doc = "they receive all keyboard events, such as a lock screen or a password"]
            #[doc = "prompt."]
            Exclusive = 1u32,
            #[doc = "This requests the compositor to allow this surface to be focused and"]
            #[doc = "unfocused by the user in an implementation-defined manner. The user"]
            #[doc = "should be able to unfocus this surface even regardless of the layer"]
            #[doc = "it is on."]
            #[doc = ""]
            #[doc = "Typically, the compositor will want to use its normal mechanism to"]
            #[doc = "manage keyboard focus between layer shell surfaces with this setting"]
            #[doc = "and regular toplevels on the desktop layer (e.g. click to focus)."]
            #[doc = "Nevertheless, it is possible for a compositor to require a special"]
            #[doc = "interaction to focus or unfocus layer shell surfaces (e.g. requiring"]
            #[doc = "a click even if focus follows the mouse normally, or providing a"]
            #[doc = "keybinding to switch focus between layers)."]
            #[doc = ""]
            #[doc = "This setting is mainly intended for desktop shell components (e.g."]
            #[doc = "panels) that allow keyboard interaction. Using this option can allow"]
            #[doc = "implementing a desktop shell that can be fully usable without the"]
            #[doc = "mouse."]
            OnDemand = 2u32,
        }
        impl TryFrom<u32> for KeyboardInteractivity {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidSurfaceState = 0u32,
            InvalidSize = 1u32,
            InvalidAnchor = 2u32,
            InvalidKeyboardInteractivity = 3u32,
            InvalidExclusiveEdge = 4u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! { # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Anchor : u32 { # [doc = "the top edge of the anchor rectangle"] const Top = 1u32 ; # [doc = "the bottom edge of the anchor rectangle"] const Bottom = 2u32 ; # [doc = "the left edge of the anchor rectangle"] const Left = 4u32 ; # [doc = "the right edge of the anchor rectangle"] const Right = 8u32 ; } }
        impl TryFrom<u32> for Anchor {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "An interface that may be implemented by a wl_surface, for surfaces that"]
        #[doc = "are designed to be rendered as a layer of a stacked desktop-like"]
        #[doc = "environment."]
        #[doc = ""]
        #[doc = "Layer surface state (layer, size, anchor, exclusive zone,"]
        #[doc = "margin, interactivity) is double-buffered, and will be applied at the"]
        #[doc = "time wl_surface.commit of the corresponding wl_surface is called."]
        #[doc = ""]
        #[doc = "Attaching a null buffer to a layer surface unmaps it."]
        #[doc = ""]
        #[doc = "Unmapping a layer_surface means that the surface cannot be shown by the"]
        #[doc = "compositor until it is explicitly mapped again. The layer_surface"]
        #[doc = "returns to the state it had right after layer_shell.get_layer_surface."]
        #[doc = "The client can re-map the surface by performing a commit without any"]
        #[doc = "buffer attached, waiting for a configure event and handling it as usual."]
        pub trait ZwlrLayerSurfaceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_layer_surface_v1";
            const VERSION: u32 = 5u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.set_size()", object.id);
                        self.set_size(object, client, message.uint()?, message.uint()?)
                            .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.set_anchor()", object.id);
                        self.set_anchor(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    2u16 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.set_exclusive_zone()", object.id);
                        self.set_exclusive_zone(object, client, message.int()?)
                            .await
                    }
                    3u16 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.set_margin()", object.id);
                        self.set_margin(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!(
                            "zwlr_layer_surface_v1#{}.set_keyboard_interactivity()",
                            object.id
                        );
                        self.set_keyboard_interactivity(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    5u16 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.get_popup()", object.id);
                        self.get_popup(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    6u16 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.ack_configure()", object.id);
                        self.ack_configure(object, client, message.uint()?).await
                    }
                    7u16 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    8u16 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.set_layer()", object.id);
                        self.set_layer(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    9u16 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.set_exclusive_edge()", object.id);
                        self.set_exclusive_edge(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Sets the size of the surface in surface-local coordinates. The"]
            #[doc = "compositor will display the surface centered with respect to its"]
            #[doc = "anchors."]
            #[doc = ""]
            #[doc = "If you pass 0 for either value, the compositor will assign it and"]
            #[doc = "inform you of the assignment in the configure event. You must set your"]
            #[doc = "anchor to opposite edges in the dimensions you omit; not doing so is a"]
            #[doc = "protocol error. Both values are 0 by default."]
            #[doc = ""]
            #[doc = "Size is double-buffered, see wl_surface.commit."]
            async fn set_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: u32,
                height: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Requests that the compositor anchor the surface to the specified edges"]
            #[doc = "and corners. If two orthogonal edges are specified (e.g. 'top' and"]
            #[doc = "'left'), then the anchor point will be the intersection of the edges"]
            #[doc = "(e.g. the top left corner of the output); otherwise the anchor point"]
            #[doc = "will be centered on that edge, or in the center if none is specified."]
            #[doc = ""]
            #[doc = "Anchor is double-buffered, see wl_surface.commit."]
            async fn set_anchor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                anchor: Anchor,
            ) -> crate::server::Result<()>;
            #[doc = "Requests that the compositor avoids occluding an area with other"]
            #[doc = "surfaces. The compositor's use of this information is"]
            #[doc = "implementation-dependent - do not assume that this region will not"]
            #[doc = "actually be occluded."]
            #[doc = ""]
            #[doc = "A positive value is only meaningful if the surface is anchored to one"]
            #[doc = "edge or an edge and both perpendicular edges. If the surface is not"]
            #[doc = "anchored, anchored to only two perpendicular edges (a corner), anchored"]
            #[doc = "to only two parallel edges or anchored to all edges, a positive value"]
            #[doc = "will be treated the same as zero."]
            #[doc = ""]
            #[doc = "A positive zone is the distance from the edge in surface-local"]
            #[doc = "coordinates to consider exclusive."]
            #[doc = ""]
            #[doc = "Surfaces that do not wish to have an exclusive zone may instead specify"]
            #[doc = "how they should interact with surfaces that do. If set to zero, the"]
            #[doc = "surface indicates that it would like to be moved to avoid occluding"]
            #[doc = "surfaces with a positive exclusive zone. If set to -1, the surface"]
            #[doc = "indicates that it would not like to be moved to accommodate for other"]
            #[doc = "surfaces, and the compositor should extend it all the way to the edges"]
            #[doc = "it is anchored to."]
            #[doc = ""]
            #[doc = "For example, a panel might set its exclusive zone to 10, so that"]
            #[doc = "maximized shell surfaces are not shown on top of it. A notification"]
            #[doc = "might set its exclusive zone to 0, so that it is moved to avoid"]
            #[doc = "occluding the panel, but shell surfaces are shown underneath it. A"]
            #[doc = "wallpaper or lock screen might set their exclusive zone to -1, so that"]
            #[doc = "they stretch below or over the panel."]
            #[doc = ""]
            #[doc = "The default value is 0."]
            #[doc = ""]
            #[doc = "Exclusive zone is double-buffered, see wl_surface.commit."]
            async fn set_exclusive_zone(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                zone: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Requests that the surface be placed some distance away from the anchor"]
            #[doc = "point on the output, in surface-local coordinates. Setting this value"]
            #[doc = "for edges you are not anchored to has no effect."]
            #[doc = ""]
            #[doc = "The exclusive zone includes the margin."]
            #[doc = ""]
            #[doc = "Margin is double-buffered, see wl_surface.commit."]
            async fn set_margin(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                top: i32,
                right: i32,
                bottom: i32,
                left: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Set how keyboard events are delivered to this surface. By default,"]
            #[doc = "layer shell surfaces do not receive keyboard events; this request can"]
            #[doc = "be used to change this."]
            #[doc = ""]
            #[doc = "This setting is inherited by child surfaces set by the get_popup"]
            #[doc = "request."]
            #[doc = ""]
            #[doc = "Layer surfaces receive pointer, touch, and tablet events normally. If"]
            #[doc = "you do not want to receive them, set the input region on your surface"]
            #[doc = "to an empty region."]
            #[doc = ""]
            #[doc = "Keyboard interactivity is double-buffered, see wl_surface.commit."]
            async fn set_keyboard_interactivity(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                keyboard_interactivity: KeyboardInteractivity,
            ) -> crate::server::Result<()>;
            #[doc = "This assigns an xdg_popup's parent to this layer_surface.  This popup"]
            #[doc = "should have been created via xdg_surface::get_popup with the parent set"]
            #[doc = "to NULL, and this request must be invoked before committing the popup's"]
            #[doc = "initial state."]
            #[doc = ""]
            #[doc = "See the documentation of xdg_popup for more details about what an"]
            #[doc = "xdg_popup is and how it is used."]
            async fn get_popup(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                popup: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "When a configure event is received, if a client commits the"]
            #[doc = "surface in response to the configure event, then the client"]
            #[doc = "must make an ack_configure request sometime before the commit"]
            #[doc = "request, passing along the serial of the configure event."]
            #[doc = ""]
            #[doc = "If the client receives multiple configure events before it"]
            #[doc = "can respond to one, it only has to ack the last configure event."]
            #[doc = ""]
            #[doc = "A client is not required to commit immediately after sending"]
            #[doc = "an ack_configure request - it may even ack_configure several times"]
            #[doc = "before its next surface commit."]
            #[doc = ""]
            #[doc = "A client may send multiple ack_configure requests before committing, but"]
            #[doc = "only the last request sent before a commit indicates which configure"]
            #[doc = "event the client really is responding to."]
            async fn ack_configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This request destroys the layer surface."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Change the layer that the surface is rendered on."]
            #[doc = ""]
            #[doc = "Layer is double-buffered, see wl_surface.commit."]
            async fn set_layer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                layer: super::super::wlr_layer_shell_unstable_v1::zwlr_layer_shell_v1::Layer,
            ) -> crate::server::Result<()>;
            #[doc = "Requests an edge for the exclusive zone to apply. The exclusive"]
            #[doc = "edge will be automatically deduced from anchor points when possible,"]
            #[doc = "but when the surface is anchored to a corner, it will be necessary"]
            #[doc = "to set it explicitly to disambiguate, as it is not possible to deduce"]
            #[doc = "which one of the two corner edges should be used."]
            #[doc = ""]
            #[doc = "The edge must be one the surface is anchored to, otherwise the"]
            #[doc = "invalid_exclusive_edge protocol error will be raised."]
            async fn set_exclusive_edge(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                edge: Anchor,
            ) -> crate::server::Result<()>;
            #[doc = "The configure event asks the client to resize its surface."]
            #[doc = ""]
            #[doc = "Clients should arrange their surface for the new states, and then send"]
            #[doc = "an ack_configure request with the serial sent in this configure event at"]
            #[doc = "some point before committing the new surface."]
            #[doc = ""]
            #[doc = "The client is free to dismiss all but the last configure event it"]
            #[doc = "received."]
            #[doc = ""]
            #[doc = "The width and height arguments specify the size of the window in"]
            #[doc = "surface-local coordinates."]
            #[doc = ""]
            #[doc = "The size is a hint, in the sense that the client is free to ignore it if"]
            #[doc = "it doesn't resize, pick a smaller size (to satisfy aspect ratio or"]
            #[doc = "resize in steps of NxM pixels). If the client picks a smaller size and"]
            #[doc = "is anchored to two opposite anchors (e.g. 'top' and 'bottom'), the"]
            #[doc = "surface will be centered on this axis."]
            #[doc = ""]
            #[doc = "If the width or height arguments are zero, it means the client should"]
            #[doc = "decide its own window dimension."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "The closed event is sent by the compositor when the surface will no"]
            #[doc = "longer be shown. The output may have been destroyed or the user may"]
            #[doc = "have asked for it to be removed. Further changes to the surface will be"]
            #[doc = "ignored. The client should destroy the resource after receiving this"]
            #[doc = "event, and create a new surface if they so choose."]
            async fn closed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
#[doc = "This protocol exposes interfaces to obtain and modify output device"]
#[doc = "configuration."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and"]
#[doc = "backward incompatible changes may be made. Backward compatible changes"]
#[doc = "may be added together with the corresponding interface version bump."]
#[doc = "Backward incompatible changes are done by bumping the version number in"]
#[doc = "the protocol and interface names and resetting the interface version."]
#[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
#[doc = "version number in the protocol and interface names are removed and the"]
#[doc = "interface version number is reset."]
pub mod wlr_output_management_unstable_v1 {
    pub mod zwlr_output_manager_v1 {
        #[doc = "This interface is a manager that allows reading and writing the current"]
        #[doc = "output device configuration."]
        #[doc = ""]
        #[doc = "Output devices that display pixels (e.g. a physical monitor or a virtual"]
        #[doc = "output in a window) are represented as heads. Heads cannot be created nor"]
        #[doc = "destroyed by the client, but they can be enabled or disabled and their"]
        #[doc = "properties can be changed. Each head may have one or more available modes."]
        #[doc = ""]
        #[doc = "Whenever a head appears (e.g. a monitor is plugged in), it will be"]
        #[doc = "advertised via the head event. Immediately after the output manager is"]
        #[doc = "bound, all current heads are advertised."]
        #[doc = ""]
        #[doc = "Whenever a head's properties change, the relevant wlr_output_head events"]
        #[doc = "will be sent. Not all head properties will be sent: only properties that"]
        #[doc = "have changed need to."]
        #[doc = ""]
        #[doc = "Whenever a head disappears (e.g. a monitor is unplugged), a"]
        #[doc = "wlr_output_head.finished event will be sent."]
        #[doc = ""]
        #[doc = "After one or more heads appear, change or disappear, the done event will"]
        #[doc = "be sent. It carries a serial which can be used in a create_configuration"]
        #[doc = "request to update heads properties."]
        #[doc = ""]
        #[doc = "The information obtained from this protocol should only be used for output"]
        #[doc = "configuration purposes. This protocol is not designed to be a generic"]
        #[doc = "output property advertisement protocol for regular clients. Instead,"]
        #[doc = "protocols such as xdg-output should be used."]
        pub trait ZwlrOutputManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_output_manager_v1";
            const VERSION: u32 = 4u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwlr_output_manager_v1#{}.create_configuration()",
                            object.id
                        );
                        self.create_configuration(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_output_manager_v1#{}.stop()", object.id);
                        self.stop(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a new output configuration object. This allows to update head"]
            #[doc = "properties."]
            async fn create_configuration(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Indicates the client no longer wishes to receive events for output"]
            #[doc = "configuration changes. However the compositor may emit further events,"]
            #[doc = "until the finished event is emitted."]
            #[doc = ""]
            #[doc = "The client must not send any more requests after this one."]
            async fn stop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event introduces a new head. This happens whenever a new head"]
            #[doc = "appears (e.g. a monitor is plugged in) or after the output manager is"]
            #[doc = "bound."]
            async fn head(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent after all information has been sent after binding to"]
            #[doc = "the output manager object and after any subsequent changes. This applies"]
            #[doc = "to child head and mode objects as well. In other words, this event is"]
            #[doc = "sent whenever a head or mode is created or destroyed and whenever one of"]
            #[doc = "their properties has been changed. Not all state is re-sent each time"]
            #[doc = "the current configuration changes: only the actual changes are sent."]
            #[doc = ""]
            #[doc = "This allows changes to the output configuration to be seen as atomic,"]
            #[doc = "even if they happen via multiple events."]
            #[doc = ""]
            #[doc = "A serial is sent to be used in a future create_configuration request."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event indicates that the compositor is done sending manager events."]
            #[doc = "The compositor will destroy the object immediately after sending this"]
            #[doc = "event, so it will become invalid and the client should release any"]
            #[doc = "resources associated with it."]
            async fn finished(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwlr_output_head_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum AdaptiveSyncState {
            Disabled = 0u32,
            Enabled = 1u32,
        }
        impl TryFrom<u32> for AdaptiveSyncState {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "A head is an output device. The difference between a wl_output object and"]
        #[doc = "a head is that heads are advertised even if they are turned off. A head"]
        #[doc = "object only advertises properties and cannot be used directly to change"]
        #[doc = "them."]
        #[doc = ""]
        #[doc = "A head has some read-only properties: modes, name, description and"]
        #[doc = "physical_size. These cannot be changed by clients."]
        #[doc = ""]
        #[doc = "Other properties can be updated via a wlr_output_configuration object."]
        #[doc = ""]
        #[doc = "Properties sent via this interface are applied atomically via the"]
        #[doc = "wlr_output_manager.done event. No guarantees are made regarding the order"]
        #[doc = "in which properties are sent."]
        pub trait ZwlrOutputHeadV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_output_head_v1";
            const VERSION: u32 = 4u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_output_head_v1#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request indicates that the client will no longer use this head"]
            #[doc = "object."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event describes the head name."]
            #[doc = ""]
            #[doc = "The naming convention is compositor defined, but limited to alphanumeric"]
            #[doc = "characters and dashes (-). Each name is unique among all wlr_output_head"]
            #[doc = "objects, but if a wlr_output_head object is destroyed the same name may"]
            #[doc = "be reused later. The names will also remain consistent across sessions"]
            #[doc = "with the same hardware and software configuration."]
            #[doc = ""]
            #[doc = "Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do"]
            #[doc = "not assume that the name is a reflection of an underlying DRM"]
            #[doc = "connector, X11 connection, etc."]
            #[doc = ""]
            #[doc = "If the compositor implements the xdg-output protocol and this head is"]
            #[doc = "enabled, the xdg_output.name event must report the same name."]
            #[doc = ""]
            #[doc = "The name event is sent after a wlr_output_head object is created. This"]
            #[doc = "event is only sent once per object, and the name does not change over"]
            #[doc = "the lifetime of the wlr_output_head object."]
            async fn name(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event describes a human-readable description of the head."]
            #[doc = ""]
            #[doc = "The description is a UTF-8 string with no convention defined for its"]
            #[doc = "contents. Examples might include 'Foocorp 11\" Display' or 'Virtual X11"]
            #[doc = "output via :1'. However, do not assume that the name is a reflection of"]
            #[doc = "the make, model, serial of the underlying DRM connector or the display"]
            #[doc = "name of the underlying X11 connection, etc."]
            #[doc = ""]
            #[doc = "If the compositor implements xdg-output and this head is enabled,"]
            #[doc = "the xdg_output.description must report the same description."]
            #[doc = ""]
            #[doc = "The description event is sent after a wlr_output_head object is created."]
            #[doc = "This event is only sent once per object, and the description does not"]
            #[doc = "change over the lifetime of the wlr_output_head object."]
            async fn description(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event describes the physical size of the head. This event is only"]
            #[doc = "sent if the head has a physical size (e.g. is not a projector or a"]
            #[doc = "virtual device)."]
            async fn physical_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event introduces a mode for this head. It is sent once per"]
            #[doc = "supported mode."]
            async fn mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event describes whether the head is enabled. A disabled head is not"]
            #[doc = "mapped to a region of the global compositor space."]
            #[doc = ""]
            #[doc = "When a head is disabled, some properties (current_mode, position,"]
            #[doc = "transform and scale) are irrelevant."]
            async fn enabled(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event describes the mode currently in use for this head. It is only"]
            #[doc = "sent if the output is enabled."]
            async fn current_mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This events describes the position of the head in the global compositor"]
            #[doc = "space. It is only sent if the output is enabled."]
            async fn position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event describes the transformation currently applied to the head."]
            #[doc = "It is only sent if the output is enabled."]
            async fn transform(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This events describes the scale of the head in the global compositor"]
            #[doc = "space. It is only sent if the output is enabled."]
            async fn scale(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event indicates that the head is no longer available. The head"]
            #[doc = "object becomes inert. Clients should send a destroy request and release"]
            #[doc = "any resources associated with it."]
            async fn finished(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event describes the manufacturer of the head."]
            #[doc = ""]
            #[doc = "This must report the same make as the wl_output interface does in its"]
            #[doc = "geometry event."]
            #[doc = ""]
            #[doc = "Together with the model and serial_number events the purpose is to"]
            #[doc = "allow clients to recognize heads from previous sessions and for example"]
            #[doc = "load head-specific configurations back."]
            #[doc = ""]
            #[doc = "It is not guaranteed this event will be ever sent. A reason for that"]
            #[doc = "can be that the compositor does not have information about the make of"]
            #[doc = "the head or the definition of a make is not sensible in the current"]
            #[doc = "setup, for example in a virtual session. Clients can still try to"]
            #[doc = "identify the head by available information from other events but should"]
            #[doc = "be aware that there is an increased risk of false positives."]
            #[doc = ""]
            #[doc = "It is not recommended to display the make string in UI to users. For"]
            #[doc = "that the string provided by the description event should be preferred."]
            async fn make(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event describes the model of the head."]
            #[doc = ""]
            #[doc = "This must report the same model as the wl_output interface does in its"]
            #[doc = "geometry event."]
            #[doc = ""]
            #[doc = "Together with the make and serial_number events the purpose is to"]
            #[doc = "allow clients to recognize heads from previous sessions and for example"]
            #[doc = "load head-specific configurations back."]
            #[doc = ""]
            #[doc = "It is not guaranteed this event will be ever sent. A reason for that"]
            #[doc = "can be that the compositor does not have information about the model of"]
            #[doc = "the head or the definition of a model is not sensible in the current"]
            #[doc = "setup, for example in a virtual session. Clients can still try to"]
            #[doc = "identify the head by available information from other events but should"]
            #[doc = "be aware that there is an increased risk of false positives."]
            #[doc = ""]
            #[doc = "It is not recommended to display the model string in UI to users. For"]
            #[doc = "that the string provided by the description event should be preferred."]
            async fn model(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event describes the serial number of the head."]
            #[doc = ""]
            #[doc = "Together with the make and model events the purpose is to allow clients"]
            #[doc = "to recognize heads from previous sessions and for example load head-"]
            #[doc = "specific configurations back."]
            #[doc = ""]
            #[doc = "It is not guaranteed this event will be ever sent. A reason for that"]
            #[doc = "can be that the compositor does not have information about the serial"]
            #[doc = "number of the head or the definition of a serial number is not sensible"]
            #[doc = "in the current setup. Clients can still try to identify the head by"]
            #[doc = "available information from other events but should be aware that there"]
            #[doc = "is an increased risk of false positives."]
            #[doc = ""]
            #[doc = "It is not recommended to display the serial_number string in UI to"]
            #[doc = "users. For that the string provided by the description event should be"]
            #[doc = "preferred."]
            async fn serial_number(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event describes whether adaptive sync is currently enabled for"]
            #[doc = "the head or not. Adaptive sync is also known as Variable Refresh"]
            #[doc = "Rate or VRR."]
            async fn adaptive_sync(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwlr_output_mode_v1 {
        #[doc = "This object describes an output mode."]
        #[doc = ""]
        #[doc = "Some heads don't support output modes, in which case modes won't be"]
        #[doc = "advertised."]
        #[doc = ""]
        #[doc = "Properties sent via this interface are applied atomically via the"]
        #[doc = "wlr_output_manager.done event. No guarantees are made regarding the order"]
        #[doc = "in which properties are sent."]
        pub trait ZwlrOutputModeV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_output_mode_v1";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_output_mode_v1#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request indicates that the client will no longer use this mode"]
            #[doc = "object."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event describes the mode size. The size is given in physical"]
            #[doc = "hardware units of the output device. This is not necessarily the same as"]
            #[doc = "the output size in the global compositor space. For instance, the output"]
            #[doc = "may be scaled or transformed."]
            async fn size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event describes the mode's fixed vertical refresh rate. It is only"]
            #[doc = "sent if the mode has a fixed refresh rate."]
            async fn refresh(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event advertises this mode as preferred."]
            async fn preferred(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event indicates that the mode is no longer available. The mode"]
            #[doc = "object becomes inert. Clients should send a destroy request and release"]
            #[doc = "any resources associated with it."]
            async fn finished(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwlr_output_configuration_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            AlreadyConfiguredHead = 1u32,
            UnconfiguredHead = 2u32,
            AlreadyUsed = 3u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This object is used by the client to describe a full output configuration."]
        #[doc = ""]
        #[doc = "First, the client needs to setup the output configuration. Each head can"]
        #[doc = "be either enabled (and configured) or disabled. It is a protocol error to"]
        #[doc = "send two enable_head or disable_head requests with the same head. It is a"]
        #[doc = "protocol error to omit a head in a configuration."]
        #[doc = ""]
        #[doc = "Then, the client can apply or test the configuration. The compositor will"]
        #[doc = "then reply with a succeeded, failed or cancelled event. Finally the client"]
        #[doc = "should destroy the configuration object."]
        pub trait ZwlrOutputConfigurationV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_output_configuration_v1";
            const VERSION: u32 = 4u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_output_configuration_v1#{}.enable_head()", object.id);
                        self.enable_head(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwlr_output_configuration_v1#{}.disable_head()",
                            object.id
                        );
                        self.disable_head(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zwlr_output_configuration_v1#{}.apply()", object.id);
                        self.apply(object, client).await
                    }
                    3u16 => {
                        tracing::debug!("zwlr_output_configuration_v1#{}.test()", object.id);
                        self.test(object, client).await
                    }
                    4u16 => {
                        tracing::debug!("zwlr_output_configuration_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Enable a head. This request creates a head configuration object that can"]
            #[doc = "be used to change the head's properties."]
            async fn enable_head(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                head: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Disable a head."]
            async fn disable_head(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                head: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Apply the new output configuration."]
            #[doc = ""]
            #[doc = "In case the configuration is successfully applied, there is no guarantee"]
            #[doc = "that the new output state matches completely the requested"]
            #[doc = "configuration. For instance, a compositor might round the scale if it"]
            #[doc = "doesn't support fractional scaling."]
            #[doc = ""]
            #[doc = "After this request has been sent, the compositor must respond with an"]
            #[doc = "succeeded, failed or cancelled event. Sending a request that isn't the"]
            #[doc = "destructor is a protocol error."]
            async fn apply(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Test the new output configuration. The configuration won't be applied,"]
            #[doc = "but will only be validated."]
            #[doc = ""]
            #[doc = "Even if the compositor succeeds to test a configuration, applying it may"]
            #[doc = "fail."]
            #[doc = ""]
            #[doc = "After this request has been sent, the compositor must respond with an"]
            #[doc = "succeeded, failed or cancelled event. Sending a request that isn't the"]
            #[doc = "destructor is a protocol error."]
            async fn test(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Using this request a client can tell the compositor that it is not going"]
            #[doc = "to use the configuration object anymore. Any changes to the outputs"]
            #[doc = "that have not been applied will be discarded."]
            #[doc = ""]
            #[doc = "This request also destroys wlr_output_configuration_head objects created"]
            #[doc = "via this object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sent after the compositor has successfully applied the changes or"]
            #[doc = "tested them."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy this object."]
            #[doc = ""]
            #[doc = "If the current configuration has changed, events to describe the changes"]
            #[doc = "will be sent followed by a wlr_output_manager.done event."]
            async fn succeeded(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent if the compositor rejects the changes or failed to apply them. The"]
            #[doc = "compositor should revert any changes made by the apply request that"]
            #[doc = "triggered this event."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy this object."]
            async fn failed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Sent if the compositor cancels the configuration because the state of an"]
            #[doc = "output changed and the client has outdated information (e.g. after an"]
            #[doc = "output has been hotplugged)."]
            #[doc = ""]
            #[doc = "The client can create a new configuration with a newer serial and try"]
            #[doc = "again."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy this object."]
            async fn cancelled(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
    pub mod zwlr_output_configuration_head_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            AlreadySet = 1u32,
            InvalidMode = 2u32,
            InvalidCustomMode = 3u32,
            InvalidTransform = 4u32,
            InvalidScale = 5u32,
            InvalidAdaptiveSyncState = 6u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This object is used by the client to update a single head's configuration."]
        #[doc = ""]
        #[doc = "It is a protocol error to set the same property twice."]
        pub trait ZwlrOutputConfigurationHeadV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_output_configuration_head_v1";
            const VERSION: u32 = 4u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwlr_output_configuration_head_v1#{}.set_mode()",
                            object.id
                        );
                        self.set_mode(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwlr_output_configuration_head_v1#{}.set_custom_mode()",
                            object.id
                        );
                        self.set_custom_mode(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "zwlr_output_configuration_head_v1#{}.set_position()",
                            object.id
                        );
                        self.set_position(object, client, message.int()?, message.int()?)
                            .await
                    }
                    3u16 => {
                        tracing::debug!(
                            "zwlr_output_configuration_head_v1#{}.set_transform()",
                            object.id
                        );
                        self.set_transform(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    4u16 => {
                        tracing::debug!(
                            "zwlr_output_configuration_head_v1#{}.set_scale()",
                            object.id
                        );
                        self.set_scale(object, client, message.fixed()?).await
                    }
                    5u16 => {
                        tracing::debug!(
                            "zwlr_output_configuration_head_v1#{}.set_adaptive_sync()",
                            object.id
                        );
                        self.set_adaptive_sync(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request sets the head's mode."]
            async fn set_mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mode: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This request assigns a custom mode to the head. The size is given in"]
            #[doc = "physical hardware units of the output device. If set to zero, the"]
            #[doc = "refresh rate is unspecified."]
            #[doc = ""]
            #[doc = "It is a protocol error to set both a mode and a custom mode."]
            async fn set_custom_mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
                refresh: i32,
            ) -> crate::server::Result<()>;
            #[doc = "This request sets the head's position in the global compositor space."]
            async fn set_position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "This request sets the head's transform."]
            async fn set_transform(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                transform: super::super::wayland::wl_output::Transform,
            ) -> crate::server::Result<()>;
            #[doc = "This request sets the head's scale."]
            async fn set_scale(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                scale: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            #[doc = "This request enables/disables adaptive sync. Adaptive sync is also"]
            #[doc = "known as Variable Refresh Rate or VRR."]
            async fn set_adaptive_sync(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                state : super :: super :: wlr_output_management_unstable_v1 :: zwlr_output_head_v1 :: AdaptiveSyncState,
            ) -> crate::server::Result<()>;
        }
    }
}
#[doc = "This protocol allows clients to control power management modes"]
#[doc = "of outputs that are currently part of the compositor space. The"]
#[doc = "intent is to allow special clients like desktop shells to power"]
#[doc = "down outputs when the system is idle."]
#[doc = ""]
#[doc = "To modify outputs not currently part of the compositor space see"]
#[doc = "wlr-output-management."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and"]
#[doc = "backward incompatible changes may be made. Backward compatible changes"]
#[doc = "may be added together with the corresponding interface version bump."]
#[doc = "Backward incompatible changes are done by bumping the version number in"]
#[doc = "the protocol and interface names and resetting the interface version."]
#[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
#[doc = "version number in the protocol and interface names are removed and the"]
#[doc = "interface version number is reset."]
pub mod wlr_output_power_management_unstable_v1 {
    pub mod zwlr_output_power_manager_v1 {
        #[doc = "This interface is a manager that allows creating per-output power"]
        #[doc = "management mode controls."]
        pub trait ZwlrOutputPowerManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_output_power_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwlr_output_power_manager_v1#{}.get_output_power()",
                            object.id
                        );
                        self.get_output_power(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_output_power_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create an output power management mode control that can be used to"]
            #[doc = "adjust the power management mode for a given output."]
            async fn get_output_power(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "All objects created by the manager will still remain valid, until their"]
            #[doc = "appropriate destroy request has been called."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwlr_output_power_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Mode {
            Off = 0u32,
            On = 1u32,
        }
        impl TryFrom<u32> for Mode {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidMode = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This object offers requests to set the power management mode of"]
        #[doc = "an output."]
        pub trait ZwlrOutputPowerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_output_power_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_output_power_v1#{}.set_mode()", object.id);
                        self.set_mode(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_output_power_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Set an output's power save mode to the given mode. The mode change"]
            #[doc = "is effective immediately. If the output does not support the given"]
            #[doc = "mode a failed event is sent."]
            async fn set_mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mode: Mode,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys the output power management mode control object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Report the power management mode change of an output."]
            #[doc = ""]
            #[doc = "The mode event is sent after an output changed its power"]
            #[doc = "management mode. The reason can be a client using set_mode or the"]
            #[doc = "compositor deciding to change an output's mode."]
            #[doc = "This event is also sent immediately when the object is created"]
            #[doc = "so the client is informed about the current power management mode."]
            async fn mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event indicates that the output power management mode control"]
            #[doc = "is no longer valid. This can happen for a number of reasons,"]
            #[doc = "including:"]
            #[doc = "- The output doesn't support power management"]
            #[doc = "- Another client already has exclusive power management mode control"]
            #[doc = "for this output"]
            #[doc = "- The output disappeared"]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy this object."]
            async fn failed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
#[doc = "This protocol allows clients to ask the compositor to copy part of the"]
#[doc = "screen content to a client buffer."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and"]
#[doc = "backward incompatible changes may be made. Backward compatible changes"]
#[doc = "may be added together with the corresponding interface version bump."]
#[doc = "Backward incompatible changes are done by bumping the version number in"]
#[doc = "the protocol and interface names and resetting the interface version."]
#[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
#[doc = "version number in the protocol and interface names are removed and the"]
#[doc = "interface version number is reset."]
pub mod wlr_screencopy_unstable_v1 {
    pub mod zwlr_screencopy_manager_v1 {
        #[doc = "This object is a manager which offers requests to start capturing from a"]
        #[doc = "source."]
        pub trait ZwlrScreencopyManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_screencopy_manager_v1";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwlr_screencopy_manager_v1#{}.capture_output()",
                            object.id
                        );
                        self.capture_output(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwlr_screencopy_manager_v1#{}.capture_output_region()",
                            object.id
                        );
                        self.capture_output_region(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zwlr_screencopy_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Capture the next frame of an entire output."]
            async fn capture_output(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                frame: crate::wire::ObjectId,
                overlay_cursor: i32,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Capture the next frame of an output's region."]
            #[doc = ""]
            #[doc = "The region is given in output logical coordinates, see"]
            #[doc = "xdg_output.logical_size. The region will be clipped to the output's"]
            #[doc = "extents."]
            async fn capture_output_region(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                frame: crate::wire::ObjectId,
                overlay_cursor: i32,
                output: crate::wire::ObjectId,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "All objects created by the manager will still remain valid, until their"]
            #[doc = "appropriate destroy request has been called."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwlr_screencopy_frame_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            AlreadyUsed = 0u32,
            InvalidBuffer = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! { # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Flags : u32 { # [doc = "contents are y-inverted"] const YInvert = 1u32 ; } }
        impl TryFrom<u32> for Flags {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "This object represents a single frame."]
        #[doc = ""]
        #[doc = "When created, a series of buffer events will be sent, each representing a"]
        #[doc = "supported buffer type. The \"buffer_done\" event is sent afterwards to"]
        #[doc = "indicate that all supported buffer types have been enumerated. The client"]
        #[doc = "will then be able to send a \"copy\" request. If the capture is successful,"]
        #[doc = "the compositor will send a \"flags\" followed by a \"ready\" event."]
        #[doc = ""]
        #[doc = "For objects version 2 or lower, wl_shm buffers are always supported, ie."]
        #[doc = "the \"buffer\" event is guaranteed to be sent."]
        #[doc = ""]
        #[doc = "If the capture failed, the \"failed\" event is sent. This can happen anytime"]
        #[doc = "before the \"ready\" event."]
        #[doc = ""]
        #[doc = "Once either a \"ready\" or a \"failed\" event is received, the client should"]
        #[doc = "destroy the frame."]
        pub trait ZwlrScreencopyFrameV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_screencopy_frame_v1";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_screencopy_frame_v1#{}.copy()", object.id);
                        self.copy(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_screencopy_frame_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    2u16 => {
                        tracing::debug!(
                            "zwlr_screencopy_frame_v1#{}.copy_with_damage()",
                            object.id
                        );
                        self.copy_with_damage(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Copy the frame to the supplied buffer. The buffer must have a the"]
            #[doc = "correct size, see zwlr_screencopy_frame_v1.buffer and"]
            #[doc = "zwlr_screencopy_frame_v1.linux_dmabuf. The buffer needs to have a"]
            #[doc = "supported format."]
            #[doc = ""]
            #[doc = "If the frame is successfully copied, a \"flags\" and a \"ready\" events are"]
            #[doc = "sent. Otherwise, a \"failed\" event is sent."]
            async fn copy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys the frame. This request can be sent at any time by the client."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Same as copy, except it waits until there is damage to copy."]
            async fn copy_with_damage(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Provides information about wl_shm buffer parameters that need to be"]
            #[doc = "used for this frame. This event is sent once after the frame is created"]
            #[doc = "if wl_shm buffers are supported."]
            async fn buffer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Provides flags about the frame. This event is sent once before the"]
            #[doc = "\"ready\" event."]
            async fn flags(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Called as soon as the frame is copied, indicating it is available"]
            #[doc = "for reading. This event includes the time at which presentation happened"]
            #[doc = "at."]
            #[doc = ""]
            #[doc = "The timestamp is expressed as tv_sec_hi, tv_sec_lo, tv_nsec triples,"]
            #[doc = "each component being an unsigned 32-bit value. Whole seconds are in"]
            #[doc = "tv_sec which is a 64-bit value combined from tv_sec_hi and tv_sec_lo,"]
            #[doc = "and the additional fractional part in tv_nsec as nanoseconds. Hence,"]
            #[doc = "for valid timestamps tv_nsec must be in [0, 999999999]. The seconds part"]
            #[doc = "may have an arbitrary offset at start."]
            #[doc = ""]
            #[doc = "After receiving this event, the client should destroy the object."]
            async fn ready(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event indicates that the attempted frame copy has failed."]
            #[doc = ""]
            #[doc = "After receiving this event, the client should destroy the object."]
            async fn failed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent right before the ready event when copy_with_damage is"]
            #[doc = "requested. It may be generated multiple times for each copy_with_damage"]
            #[doc = "request."]
            #[doc = ""]
            #[doc = "The arguments describe a box around an area that has changed since the"]
            #[doc = "last copy request that was derived from the current screencopy manager"]
            #[doc = "instance."]
            #[doc = ""]
            #[doc = "The union of all regions received between the call to copy_with_damage"]
            #[doc = "and a ready event is the total damage since the prior ready event."]
            async fn damage(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "Provides information about linux-dmabuf buffer parameters that need to"]
            #[doc = "be used for this frame. This event is sent once after the frame is"]
            #[doc = "created if linux-dmabuf buffers are supported."]
            async fn linux_dmabuf(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
            #[doc = "This event is sent once after all buffer events have been sent."]
            #[doc = ""]
            #[doc = "The client should proceed to create a buffer of one of the supported"]
            #[doc = "types, and send a \"copy\" request."]
            async fn buffer_done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                todo!()
            }
        }
    }
}
pub mod wlr_virtual_pointer_unstable_v1 {
    pub mod zwlr_virtual_pointer_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            InvalidAxis = 0u32,
            InvalidAxisSource = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This protocol allows clients to emulate a physical pointer device. The"]
        #[doc = "requests are mostly mirror opposites of those specified in wl_pointer."]
        pub trait ZwlrVirtualPointerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_virtual_pointer_v1";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.motion()", object.id);
                        self.motion(
                            object,
                            client,
                            message.uint()?,
                            message.fixed()?,
                            message.fixed()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.motion_absolute()", object.id);
                        self.motion_absolute(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.button()", object.id);
                        self.button(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.axis()", object.id);
                        self.axis(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?.try_into()?,
                            message.fixed()?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.frame()", object.id);
                        self.frame(object, client).await
                    }
                    5u16 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.axis_source()", object.id);
                        self.axis_source(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    6u16 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.axis_stop()", object.id);
                        self.axis_stop(object, client, message.uint()?, message.uint()?.try_into()?)
                            .await
                    }
                    7u16 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.axis_discrete()", object.id);
                        self.axis_discrete(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?.try_into()?,
                            message.fixed()?,
                            message.int()?,
                        )
                        .await
                    }
                    8u16 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "The pointer has moved by a relative amount to the previous request."]
            #[doc = ""]
            #[doc = "Values are in the global compositor space."]
            async fn motion(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                dx: crate::wire::Fixed,
                dy: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            #[doc = "The pointer has moved in an absolute coordinate frame."]
            #[doc = ""]
            #[doc = "Value of x can range from 0 to x_extent, value of y can range from 0"]
            #[doc = "to y_extent."]
            async fn motion_absolute(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                x: u32,
                y: u32,
                x_extent: u32,
                y_extent: u32,
            ) -> crate::server::Result<()>;
            #[doc = "A button was pressed or released."]
            async fn button(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                button: u32,
                state: super::super::wayland::wl_pointer::ButtonState,
            ) -> crate::server::Result<()>;
            #[doc = "Scroll and other axis requests."]
            async fn axis(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                axis: super::super::wayland::wl_pointer::Axis,
                value: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            #[doc = "Indicates the set of events that logically belong together."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Source information for scroll and other axis."]
            async fn axis_source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                axis_source: super::super::wayland::wl_pointer::AxisSource,
            ) -> crate::server::Result<()>;
            #[doc = "Stop notification for scroll and other axes."]
            async fn axis_stop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                axis: super::super::wayland::wl_pointer::Axis,
            ) -> crate::server::Result<()>;
            #[doc = "Discrete step information for scroll and other axes."]
            #[doc = ""]
            #[doc = "This event allows the client to extend data normally sent using the axis"]
            #[doc = "event with discrete value."]
            async fn axis_discrete(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                axis: super::super::wayland::wl_pointer::Axis,
                value: crate::wire::Fixed,
                discrete: i32,
            ) -> crate::server::Result<()>;
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwlr_virtual_pointer_manager_v1 {
        #[doc = "This object allows clients to create individual virtual pointer objects."]
        pub trait ZwlrVirtualPointerManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_virtual_pointer_manager_v1";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwlr_virtual_pointer_manager_v1#{}.create_virtual_pointer()",
                            object.id
                        );
                        self.create_virtual_pointer(
                            object,
                            client,
                            message.object()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_virtual_pointer_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    2u16 => {
                        tracing :: debug ! ("zwlr_virtual_pointer_manager_v1#{}.create_virtual_pointer_with_output()" , object . id);
                        self.create_virtual_pointer_with_output(
                            object,
                            client,
                            message.object()?,
                            message.object()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Creates a new virtual pointer. The optional seat is a suggestion to the"]
            #[doc = "compositor."]
            async fn create_virtual_pointer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: Option<crate::wire::ObjectId>,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Creates a new virtual pointer. The seat and the output arguments are"]
            #[doc = "optional. If the seat argument is set, the compositor should assign the"]
            #[doc = "input device to the requested seat. If the output argument is set, the"]
            #[doc = "compositor should map the input device to the requested output."]
            async fn create_virtual_pointer_with_output(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: Option<crate::wire::ObjectId>,
                output: Option<crate::wire::ObjectId>,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
}
