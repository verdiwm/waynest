#![allow(unused)]
#![allow(async_fn_in_trait)]
pub mod wayland {
    #[doc = "The core global object.  This is a special singleton object.  It"]
    #[doc = "is used for internal Wayland protocol features."]
    pub mod wl_display {
        #[doc = "These errors are global and can be emitted in response to any"]
        #[doc = "server request."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "server couldn't find object"]
            InvalidObject = 0u32,
            #[doc = "method doesn't exist on the specified interface or malformed request"]
            InvalidMethod = 1u32,
            #[doc = "server is out of memory"]
            NoMemory = 2u32,
            #[doc = "implementation error in compositor"]
            Implementation = 3u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidObject),
                    1u32 => Ok(Self::InvalidMethod),
                    2u32 => Ok(Self::NoMemory),
                    3u32 => Ok(Self::Implementation),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wl_display interface. See the module level documentation for more info"]
        pub trait WlDisplay: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_display";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_display#{}.sync()", object.id);
                        self.sync(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("wl_display#{}.get_registry()", object.id);
                        self.get_registry(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "The sync request asks the server to emit the 'done' event"]
            #[doc = "on the returned wl_callback object.  Since requests are"]
            #[doc = "handled in-order and events are delivered in-order, this can"]
            #[doc = "be used as a barrier to ensure all previous requests and the"]
            #[doc = "resulting events have been handled."]
            #[doc = ""]
            #[doc = "The object returned by this request will be destroyed by the"]
            #[doc = "compositor after the callback is fired and as such the client must not"]
            #[doc = "attempt to use it after that point."]
            #[doc = ""]
            #[doc = "The callback_data passed in the callback is undefined and should be ignored."]
            async fn sync(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                callback: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This request creates a registry object that allows the client"]
            #[doc = "to list and bind the global objects available from the"]
            #[doc = "compositor."]
            #[doc = ""]
            #[doc = "It should be noted that the server side resources consumed in"]
            #[doc = "response to a get_registry request can only be released when the"]
            #[doc = "client disconnects, not when the client side proxy is destroyed."]
            #[doc = "Therefore, clients should invoke get_registry as infrequently as"]
            #[doc = "possible to avoid wasting memory."]
            async fn get_registry(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                registry: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "The error event is sent out when a fatal (non-recoverable)"]
            #[doc = "error has occurred.  The object_id argument is the object"]
            #[doc = "where the error occurred, most often in response to a request"]
            #[doc = "to that object.  The code identifies the error and is defined"]
            #[doc = "by the object interface.  As such, each interface defines its"]
            #[doc = "own set of error codes.  The message is a brief description"]
            #[doc = "of the error, for (debugging) convenience."]
            async fn error(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                object_id: crate::wire::ObjectId,
                code: u32,
                message: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_display#{}.error()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(object_id))
                    .put_uint(code)
                    .put_string(Some(message))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is used internally by the object ID management"]
            #[doc = "logic. When a client deletes an object that it had created,"]
            #[doc = "the server will send this event to acknowledge that it has"]
            #[doc = "seen the delete request. When the client receives this event,"]
            #[doc = "it will know that it can safely reuse the object ID."]
            async fn delete_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_display#{}.delete_id()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(id).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "The singleton global registry object.  The server has a number of"]
    #[doc = "global objects that are available to all clients.  These objects"]
    #[doc = "typically represent an actual object in the server (for example,"]
    #[doc = "an input device) or they are singleton objects that provide"]
    #[doc = "extension functionality."]
    #[doc = ""]
    #[doc = "When a client creates a registry object, the registry object"]
    #[doc = "will emit a global event for each global currently in the"]
    #[doc = "registry.  Globals come and go as a result of device or"]
    #[doc = "monitor hotplugs, reconfiguration or other events, and the"]
    #[doc = "registry will send out global and global_remove events to"]
    #[doc = "keep the client up to date with the changes.  To mark the end"]
    #[doc = "of the initial burst of events, the client can use the"]
    #[doc = "wl_display.sync request immediately after calling"]
    #[doc = "wl_display.get_registry."]
    #[doc = ""]
    #[doc = "A client can bind to a global object by using the bind"]
    #[doc = "request.  This creates a client-side handle that lets the object"]
    #[doc = "emit events to the client and lets the client invoke requests on"]
    #[doc = "the object."]
    pub mod wl_registry {
        #[doc = "Trait to implement the wl_registry interface. See the module level documentation for more info"]
        pub trait WlRegistry: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_registry";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_registry#{}.bind()", object.id);
                        self.bind(object, client, message.uint()?, message.new_id()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Binds a new, client-created object to the server using the"]
            #[doc = "specified name as the identifier."]
            async fn bind(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: u32,
                id: crate::wire::NewId,
            ) -> crate::server::Result<()>;
            #[doc = "Notify the client of global objects."]
            #[doc = ""]
            #[doc = "The event notifies the client that a global object with"]
            #[doc = "the given name is now available, and it implements the"]
            #[doc = "given version of the given interface."]
            async fn global(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: u32,
                interface: String,
                version: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_registry#{}.global()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(name)
                    .put_string(Some(interface))
                    .put_uint(version)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notify the client of removed global objects."]
            #[doc = ""]
            #[doc = "This event notifies the client that the global identified"]
            #[doc = "by name is no longer available.  If the client bound to"]
            #[doc = "the global using the bind request, the client should now"]
            #[doc = "destroy that object."]
            #[doc = ""]
            #[doc = "The object remains valid and requests to the object will be"]
            #[doc = "ignored until the client destroys it, to avoid races between"]
            #[doc = "the global going away and a client sending a request to it."]
            async fn global_remove(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_registry#{}.global_remove()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(name).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "Clients can handle the 'done' event to get notified when"]
    #[doc = "the related request is done."]
    #[doc = ""]
    #[doc = "Note, because wl_callback objects are created from multiple independent"]
    #[doc = "factory interfaces, the wl_callback interface is frozen at version 1."]
    pub mod wl_callback {
        #[doc = "Trait to implement the wl_callback interface. See the module level documentation for more info"]
        pub trait WlCallback: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_callback";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Notify the client when the related request is done."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                callback_data: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_callback#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(callback_data)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A compositor.  This object is a singleton global.  The"]
    #[doc = "compositor is in charge of combining the contents of multiple"]
    #[doc = "surfaces into one displayable output."]
    pub mod wl_compositor {
        #[doc = "Trait to implement the wl_compositor interface. See the module level documentation for more info"]
        pub trait WlCompositor: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_compositor";
            const VERSION: u32 = 6u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_compositor#{}.create_surface()", object.id);
                        self.create_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("wl_compositor#{}.create_region()", object.id);
                        self.create_region(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Ask the compositor to create a new surface."]
            async fn create_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Ask the compositor to create a new region."]
            async fn create_region(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "The wl_shm_pool object encapsulates a piece of memory shared"]
    #[doc = "between the compositor and client.  Through the wl_shm_pool"]
    #[doc = "object, the client can allocate shared memory wl_buffer objects."]
    #[doc = "All objects created through the same pool share the same"]
    #[doc = "underlying mapped memory. Reusing the mapped memory avoids the"]
    #[doc = "setup/teardown overhead and is useful when interactively resizing"]
    #[doc = "a surface or for many small buffers."]
    pub mod wl_shm_pool {
        #[doc = "Trait to implement the wl_shm_pool interface. See the module level documentation for more info"]
        pub trait WlShmPool: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_shm_pool";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_shm_pool#{}.create_buffer()", object.id);
                        self.create_buffer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("wl_shm_pool#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    2u16 => {
                        tracing::debug!("wl_shm_pool#{}.resize()", object.id);
                        self.resize(object, client, message.int()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a wl_buffer object from the pool."]
            #[doc = ""]
            #[doc = "The buffer is created offset bytes into the pool and has"]
            #[doc = "width and height as specified.  The stride argument specifies"]
            #[doc = "the number of bytes from the beginning of one row to the beginning"]
            #[doc = "of the next.  The format is the pixel format of the buffer and"]
            #[doc = "must be one of those advertised through the wl_shm.format event."]
            #[doc = ""]
            #[doc = "A buffer will keep a reference to the pool it was created from"]
            #[doc = "so it is valid to destroy the pool immediately after creating"]
            #[doc = "a buffer from it."]
            async fn create_buffer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                offset: i32,
                width: i32,
                height: i32,
                stride: i32,
                format: super::super::wayland::wl_shm::Format,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the shared memory pool."]
            #[doc = ""]
            #[doc = "The mmapped memory will be released when all"]
            #[doc = "buffers that have been created from this pool"]
            #[doc = "are gone."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This request will cause the server to remap the backing memory"]
            #[doc = "for the pool from the file descriptor passed when the pool was"]
            #[doc = "created, but using the new size.  This request can only be"]
            #[doc = "used to make the pool bigger."]
            #[doc = ""]
            #[doc = "This request only changes the amount of bytes that are mmapped"]
            #[doc = "by the server and does not touch the file corresponding to the"]
            #[doc = "file descriptor passed at creation time. It is the client's"]
            #[doc = "responsibility to ensure that the file is at least as big as"]
            #[doc = "the new pool size."]
            async fn resize(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                size: i32,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "A singleton global object that provides support for shared"]
    #[doc = "memory."]
    #[doc = ""]
    #[doc = "Clients can create wl_shm_pool objects using the create_pool"]
    #[doc = "request."]
    #[doc = ""]
    #[doc = "On binding the wl_shm object one or more format events"]
    #[doc = "are emitted to inform clients about the valid pixel formats"]
    #[doc = "that can be used for buffers."]
    pub mod wl_shm {
        #[doc = "These errors can be emitted in response to wl_shm requests."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "buffer format is not known"]
            InvalidFormat = 0u32,
            #[doc = "invalid size or stride during pool or buffer creation"]
            InvalidStride = 1u32,
            #[doc = "mmapping the file descriptor failed"]
            InvalidFd = 2u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidFormat),
                    1u32 => Ok(Self::InvalidStride),
                    2u32 => Ok(Self::InvalidFd),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This describes the memory layout of an individual pixel."]
        #[doc = ""]
        #[doc = "All renderers should support argb8888 and xrgb8888 but any other"]
        #[doc = "formats are optional and may not be supported by the particular"]
        #[doc = "renderer in use."]
        #[doc = ""]
        #[doc = "The drm format codes match the macros defined in drm_fourcc.h, except"]
        #[doc = "argb8888 and xrgb8888. The formats actually supported by the compositor"]
        #[doc = "will be reported by the format event."]
        #[doc = ""]
        #[doc = "For all wl_shm formats and unless specified in another protocol"]
        #[doc = "extension, pre-multiplied alpha is used for pixel values."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Format {
            #[doc = "32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian"]
            Argb8888 = 0u32,
            #[doc = "32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian"]
            Xrgb8888 = 1u32,
            #[doc = "8-bit color index format, [7:0] C"]
            C8 = 538982467u32,
            #[doc = "8-bit RGB format, [7:0] R:G:B 3:3:2"]
            Rgb332 = 943867730u32,
            #[doc = "8-bit BGR format, [7:0] B:G:R 2:3:3"]
            Bgr233 = 944916290u32,
            #[doc = "16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian"]
            Xrgb4444 = 842093144u32,
            #[doc = "16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian"]
            Xbgr4444 = 842089048u32,
            #[doc = "16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian"]
            Rgbx4444 = 842094674u32,
            #[doc = "16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian"]
            Bgrx4444 = 842094658u32,
            #[doc = "16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian"]
            Argb4444 = 842093121u32,
            #[doc = "16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian"]
            Abgr4444 = 842089025u32,
            #[doc = "16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian"]
            Rgba4444 = 842088786u32,
            #[doc = "16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian"]
            Bgra4444 = 842088770u32,
            #[doc = "16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian"]
            Xrgb1555 = 892424792u32,
            #[doc = "16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian"]
            Xbgr1555 = 892420696u32,
            #[doc = "16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian"]
            Rgbx5551 = 892426322u32,
            #[doc = "16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian"]
            Bgrx5551 = 892426306u32,
            #[doc = "16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian"]
            Argb1555 = 892424769u32,
            #[doc = "16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian"]
            Abgr1555 = 892420673u32,
            #[doc = "16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian"]
            Rgba5551 = 892420434u32,
            #[doc = "16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian"]
            Bgra5551 = 892420418u32,
            #[doc = "16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian"]
            Rgb565 = 909199186u32,
            #[doc = "16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian"]
            Bgr565 = 909199170u32,
            #[doc = "24-bit RGB format, [23:0] R:G:B little endian"]
            Rgb888 = 875710290u32,
            #[doc = "24-bit BGR format, [23:0] B:G:R little endian"]
            Bgr888 = 875710274u32,
            #[doc = "32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian"]
            Xbgr8888 = 875709016u32,
            #[doc = "32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian"]
            Rgbx8888 = 875714642u32,
            #[doc = "32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian"]
            Bgrx8888 = 875714626u32,
            #[doc = "32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian"]
            Abgr8888 = 875708993u32,
            #[doc = "32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian"]
            Rgba8888 = 875708754u32,
            #[doc = "32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian"]
            Bgra8888 = 875708738u32,
            #[doc = "32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian"]
            Xrgb2101010 = 808669784u32,
            #[doc = "32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian"]
            Xbgr2101010 = 808665688u32,
            #[doc = "32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian"]
            Rgbx1010102 = 808671314u32,
            #[doc = "32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian"]
            Bgrx1010102 = 808671298u32,
            #[doc = "32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian"]
            Argb2101010 = 808669761u32,
            #[doc = "32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian"]
            Abgr2101010 = 808665665u32,
            #[doc = "32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian"]
            Rgba1010102 = 808665426u32,
            #[doc = "32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian"]
            Bgra1010102 = 808665410u32,
            #[doc = "packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian"]
            Yuyv = 1448695129u32,
            #[doc = "packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian"]
            Yvyu = 1431918169u32,
            #[doc = "packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian"]
            Uyvy = 1498831189u32,
            #[doc = "packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian"]
            Vyuy = 1498765654u32,
            #[doc = "packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian"]
            Ayuv = 1448433985u32,
            #[doc = "2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane"]
            Nv12 = 842094158u32,
            #[doc = "2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane"]
            Nv21 = 825382478u32,
            #[doc = "2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane"]
            Nv16 = 909203022u32,
            #[doc = "2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane"]
            Nv61 = 825644622u32,
            #[doc = "3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes"]
            Yuv410 = 961959257u32,
            #[doc = "3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes"]
            Yvu410 = 961893977u32,
            #[doc = "3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes"]
            Yuv411 = 825316697u32,
            #[doc = "3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes"]
            Yvu411 = 825316953u32,
            #[doc = "3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes"]
            Yuv420 = 842093913u32,
            #[doc = "3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes"]
            Yvu420 = 842094169u32,
            #[doc = "3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes"]
            Yuv422 = 909202777u32,
            #[doc = "3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes"]
            Yvu422 = 909203033u32,
            #[doc = "3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes"]
            Yuv444 = 875713881u32,
            #[doc = "3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes"]
            Yvu444 = 875714137u32,
            #[doc = "[7:0] R"]
            R8 = 538982482u32,
            #[doc = "[15:0] R little endian"]
            R16 = 540422482u32,
            #[doc = "[15:0] R:G 8:8 little endian"]
            Rg88 = 943212370u32,
            #[doc = "[15:0] G:R 8:8 little endian"]
            Gr88 = 943215175u32,
            #[doc = "[31:0] R:G 16:16 little endian"]
            Rg1616 = 842221394u32,
            #[doc = "[31:0] G:R 16:16 little endian"]
            Gr1616 = 842224199u32,
            #[doc = "[63:0] x:R:G:B 16:16:16:16 little endian"]
            Xrgb16161616f = 1211388504u32,
            #[doc = "[63:0] x:B:G:R 16:16:16:16 little endian"]
            Xbgr16161616f = 1211384408u32,
            #[doc = "[63:0] A:R:G:B 16:16:16:16 little endian"]
            Argb16161616f = 1211388481u32,
            #[doc = "[63:0] A:B:G:R 16:16:16:16 little endian"]
            Abgr16161616f = 1211384385u32,
            #[doc = "[31:0] X:Y:Cb:Cr 8:8:8:8 little endian"]
            Xyuv8888 = 1448434008u32,
            #[doc = "[23:0] Cr:Cb:Y 8:8:8 little endian"]
            Vuy888 = 875713878u32,
            #[doc = "Y followed by U then V, 10:10:10. Non-linear modifier only"]
            Vuy101010 = 808670550u32,
            #[doc = "[63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels"]
            Y210 = 808530521u32,
            #[doc = "[63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels"]
            Y212 = 842084953u32,
            #[doc = "[63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels"]
            Y216 = 909193817u32,
            #[doc = "[31:0] A:Cr:Y:Cb 2:10:10:10 little endian"]
            Y410 = 808531033u32,
            #[doc = "[63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian"]
            Y412 = 842085465u32,
            #[doc = "[63:0] A:Cr:Y:Cb 16:16:16:16 little endian"]
            Y416 = 909194329u32,
            #[doc = "[31:0] X:Cr:Y:Cb 2:10:10:10 little endian"]
            Xvyu2101010 = 808670808u32,
            #[doc = "[63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian"]
            Xvyu1216161616 = 909334104u32,
            #[doc = "[63:0] X:Cr:Y:Cb 16:16:16:16 little endian"]
            Xvyu16161616 = 942954072u32,
            #[doc = "[63:0]   A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian"]
            Y0l0 = 810299481u32,
            #[doc = "[63:0]   X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian"]
            X0l0 = 810299480u32,
            #[doc = "[63:0]   A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
            Y0l2 = 843853913u32,
            #[doc = "[63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
            X0l2 = 843853912u32,
            Yuv4208bit = 942691673u32,
            Yuv42010bit = 808539481u32,
            Xrgb8888A8 = 943805016u32,
            Xbgr8888A8 = 943800920u32,
            Rgbx8888A8 = 943806546u32,
            Bgrx8888A8 = 943806530u32,
            Rgb888A8 = 943798354u32,
            Bgr888A8 = 943798338u32,
            Rgb565A8 = 943797586u32,
            Bgr565A8 = 943797570u32,
            #[doc = "non-subsampled Cr:Cb plane"]
            Nv24 = 875714126u32,
            #[doc = "non-subsampled Cb:Cr plane"]
            Nv42 = 842290766u32,
            #[doc = "2x1 subsampled Cr:Cb plane, 10 bit per channel"]
            P210 = 808530512u32,
            #[doc = "2x2 subsampled Cr:Cb plane 10 bits per channel"]
            P010 = 808530000u32,
            #[doc = "2x2 subsampled Cr:Cb plane 12 bits per channel"]
            P012 = 842084432u32,
            #[doc = "2x2 subsampled Cr:Cb plane 16 bits per channel"]
            P016 = 909193296u32,
            #[doc = "[63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian"]
            Axbxgxrx106106106106 = 808534593u32,
            #[doc = "2x2 subsampled Cr:Cb plane"]
            Nv15 = 892425806u32,
            Q410 = 808531025u32,
            Q401 = 825242705u32,
            #[doc = "[63:0] x:R:G:B 16:16:16:16 little endian"]
            Xrgb16161616 = 942953048u32,
            #[doc = "[63:0] x:B:G:R 16:16:16:16 little endian"]
            Xbgr16161616 = 942948952u32,
            #[doc = "[63:0] A:R:G:B 16:16:16:16 little endian"]
            Argb16161616 = 942953025u32,
            #[doc = "[63:0] A:B:G:R 16:16:16:16 little endian"]
            Abgr16161616 = 942948929u32,
            #[doc = "[7:0] C0:C1:C2:C3:C4:C5:C6:C7 1:1:1:1:1:1:1:1 eight pixels/byte"]
            C1 = 538980675u32,
            #[doc = "[7:0] C0:C1:C2:C3 2:2:2:2 four pixels/byte"]
            C2 = 538980931u32,
            #[doc = "[7:0] C0:C1 4:4 two pixels/byte"]
            C4 = 538981443u32,
            #[doc = "[7:0] D0:D1:D2:D3:D4:D5:D6:D7 1:1:1:1:1:1:1:1 eight pixels/byte"]
            D1 = 538980676u32,
            #[doc = "[7:0] D0:D1:D2:D3 2:2:2:2 four pixels/byte"]
            D2 = 538980932u32,
            #[doc = "[7:0] D0:D1 4:4 two pixels/byte"]
            D4 = 538981444u32,
            #[doc = "[7:0] D"]
            D8 = 538982468u32,
            #[doc = "[7:0] R0:R1:R2:R3:R4:R5:R6:R7 1:1:1:1:1:1:1:1 eight pixels/byte"]
            R1 = 538980690u32,
            #[doc = "[7:0] R0:R1:R2:R3 2:2:2:2 four pixels/byte"]
            R2 = 538980946u32,
            #[doc = "[7:0] R0:R1 4:4 two pixels/byte"]
            R4 = 538981458u32,
            #[doc = "[15:0] x:R 6:10 little endian"]
            R10 = 540029266u32,
            #[doc = "[15:0] x:R 4:12 little endian"]
            R12 = 540160338u32,
            #[doc = "[31:0] A:Cr:Cb:Y 8:8:8:8 little endian"]
            Avuy8888 = 1498764865u32,
            #[doc = "[31:0] X:Cr:Cb:Y 8:8:8:8 little endian"]
            Xvuy8888 = 1498764888u32,
            #[doc = "2x2 subsampled Cr:Cb plane 10 bits per channel packed"]
            P030 = 808661072u32,
        }
        impl TryFrom<u32> for Format {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Argb8888),
                    1u32 => Ok(Self::Xrgb8888),
                    538982467u32 => Ok(Self::C8),
                    943867730u32 => Ok(Self::Rgb332),
                    944916290u32 => Ok(Self::Bgr233),
                    842093144u32 => Ok(Self::Xrgb4444),
                    842089048u32 => Ok(Self::Xbgr4444),
                    842094674u32 => Ok(Self::Rgbx4444),
                    842094658u32 => Ok(Self::Bgrx4444),
                    842093121u32 => Ok(Self::Argb4444),
                    842089025u32 => Ok(Self::Abgr4444),
                    842088786u32 => Ok(Self::Rgba4444),
                    842088770u32 => Ok(Self::Bgra4444),
                    892424792u32 => Ok(Self::Xrgb1555),
                    892420696u32 => Ok(Self::Xbgr1555),
                    892426322u32 => Ok(Self::Rgbx5551),
                    892426306u32 => Ok(Self::Bgrx5551),
                    892424769u32 => Ok(Self::Argb1555),
                    892420673u32 => Ok(Self::Abgr1555),
                    892420434u32 => Ok(Self::Rgba5551),
                    892420418u32 => Ok(Self::Bgra5551),
                    909199186u32 => Ok(Self::Rgb565),
                    909199170u32 => Ok(Self::Bgr565),
                    875710290u32 => Ok(Self::Rgb888),
                    875710274u32 => Ok(Self::Bgr888),
                    875709016u32 => Ok(Self::Xbgr8888),
                    875714642u32 => Ok(Self::Rgbx8888),
                    875714626u32 => Ok(Self::Bgrx8888),
                    875708993u32 => Ok(Self::Abgr8888),
                    875708754u32 => Ok(Self::Rgba8888),
                    875708738u32 => Ok(Self::Bgra8888),
                    808669784u32 => Ok(Self::Xrgb2101010),
                    808665688u32 => Ok(Self::Xbgr2101010),
                    808671314u32 => Ok(Self::Rgbx1010102),
                    808671298u32 => Ok(Self::Bgrx1010102),
                    808669761u32 => Ok(Self::Argb2101010),
                    808665665u32 => Ok(Self::Abgr2101010),
                    808665426u32 => Ok(Self::Rgba1010102),
                    808665410u32 => Ok(Self::Bgra1010102),
                    1448695129u32 => Ok(Self::Yuyv),
                    1431918169u32 => Ok(Self::Yvyu),
                    1498831189u32 => Ok(Self::Uyvy),
                    1498765654u32 => Ok(Self::Vyuy),
                    1448433985u32 => Ok(Self::Ayuv),
                    842094158u32 => Ok(Self::Nv12),
                    825382478u32 => Ok(Self::Nv21),
                    909203022u32 => Ok(Self::Nv16),
                    825644622u32 => Ok(Self::Nv61),
                    961959257u32 => Ok(Self::Yuv410),
                    961893977u32 => Ok(Self::Yvu410),
                    825316697u32 => Ok(Self::Yuv411),
                    825316953u32 => Ok(Self::Yvu411),
                    842093913u32 => Ok(Self::Yuv420),
                    842094169u32 => Ok(Self::Yvu420),
                    909202777u32 => Ok(Self::Yuv422),
                    909203033u32 => Ok(Self::Yvu422),
                    875713881u32 => Ok(Self::Yuv444),
                    875714137u32 => Ok(Self::Yvu444),
                    538982482u32 => Ok(Self::R8),
                    540422482u32 => Ok(Self::R16),
                    943212370u32 => Ok(Self::Rg88),
                    943215175u32 => Ok(Self::Gr88),
                    842221394u32 => Ok(Self::Rg1616),
                    842224199u32 => Ok(Self::Gr1616),
                    1211388504u32 => Ok(Self::Xrgb16161616f),
                    1211384408u32 => Ok(Self::Xbgr16161616f),
                    1211388481u32 => Ok(Self::Argb16161616f),
                    1211384385u32 => Ok(Self::Abgr16161616f),
                    1448434008u32 => Ok(Self::Xyuv8888),
                    875713878u32 => Ok(Self::Vuy888),
                    808670550u32 => Ok(Self::Vuy101010),
                    808530521u32 => Ok(Self::Y210),
                    842084953u32 => Ok(Self::Y212),
                    909193817u32 => Ok(Self::Y216),
                    808531033u32 => Ok(Self::Y410),
                    842085465u32 => Ok(Self::Y412),
                    909194329u32 => Ok(Self::Y416),
                    808670808u32 => Ok(Self::Xvyu2101010),
                    909334104u32 => Ok(Self::Xvyu1216161616),
                    942954072u32 => Ok(Self::Xvyu16161616),
                    810299481u32 => Ok(Self::Y0l0),
                    810299480u32 => Ok(Self::X0l0),
                    843853913u32 => Ok(Self::Y0l2),
                    843853912u32 => Ok(Self::X0l2),
                    942691673u32 => Ok(Self::Yuv4208bit),
                    808539481u32 => Ok(Self::Yuv42010bit),
                    943805016u32 => Ok(Self::Xrgb8888A8),
                    943800920u32 => Ok(Self::Xbgr8888A8),
                    943806546u32 => Ok(Self::Rgbx8888A8),
                    943806530u32 => Ok(Self::Bgrx8888A8),
                    943798354u32 => Ok(Self::Rgb888A8),
                    943798338u32 => Ok(Self::Bgr888A8),
                    943797586u32 => Ok(Self::Rgb565A8),
                    943797570u32 => Ok(Self::Bgr565A8),
                    875714126u32 => Ok(Self::Nv24),
                    842290766u32 => Ok(Self::Nv42),
                    808530512u32 => Ok(Self::P210),
                    808530000u32 => Ok(Self::P010),
                    842084432u32 => Ok(Self::P012),
                    909193296u32 => Ok(Self::P016),
                    808534593u32 => Ok(Self::Axbxgxrx106106106106),
                    892425806u32 => Ok(Self::Nv15),
                    808531025u32 => Ok(Self::Q410),
                    825242705u32 => Ok(Self::Q401),
                    942953048u32 => Ok(Self::Xrgb16161616),
                    942948952u32 => Ok(Self::Xbgr16161616),
                    942953025u32 => Ok(Self::Argb16161616),
                    942948929u32 => Ok(Self::Abgr16161616),
                    538980675u32 => Ok(Self::C1),
                    538980931u32 => Ok(Self::C2),
                    538981443u32 => Ok(Self::C4),
                    538980676u32 => Ok(Self::D1),
                    538980932u32 => Ok(Self::D2),
                    538981444u32 => Ok(Self::D4),
                    538982468u32 => Ok(Self::D8),
                    538980690u32 => Ok(Self::R1),
                    538980946u32 => Ok(Self::R2),
                    538981458u32 => Ok(Self::R4),
                    540029266u32 => Ok(Self::R10),
                    540160338u32 => Ok(Self::R12),
                    1498764865u32 => Ok(Self::Avuy8888),
                    1498764888u32 => Ok(Self::Xvuy8888),
                    808661072u32 => Ok(Self::P030),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wl_shm interface. See the module level documentation for more info"]
        pub trait WlShm: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_shm";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_shm#{}.create_pool()", object.id);
                        self.create_pool(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.fd()?,
                            message.int()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("wl_shm#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a new wl_shm_pool object."]
            #[doc = ""]
            #[doc = "The pool can be used to create shared memory based buffer"]
            #[doc = "objects.  The server will mmap size bytes of the passed file"]
            #[doc = "descriptor, to use as backing memory for the pool."]
            async fn create_pool(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                fd: rustix::fd::OwnedFd,
                size: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Using this request a client can tell the server that it is not going to"]
            #[doc = "use the shm object anymore."]
            #[doc = ""]
            #[doc = "Objects created via this interface remain unaffected."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Informs the client about a valid pixel format that"]
            #[doc = "can be used for buffers. Known formats include"]
            #[doc = "argb8888 and xrgb8888."]
            async fn format(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                format: Format,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_shm#{}.format()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(format as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A buffer provides the content for a wl_surface. Buffers are"]
    #[doc = "created through factory interfaces such as wl_shm, wp_linux_buffer_params"]
    #[doc = "(from the linux-dmabuf protocol extension) or similar. It has a width and"]
    #[doc = "a height and can be attached to a wl_surface, but the mechanism by which a"]
    #[doc = "client provides and updates the contents is defined by the buffer factory"]
    #[doc = "interface."]
    #[doc = ""]
    #[doc = "Color channels are assumed to be electrical rather than optical (in other"]
    #[doc = "words, encoded with a transfer function) unless otherwise specified. If"]
    #[doc = "the buffer uses a format that has an alpha channel, the alpha channel is"]
    #[doc = "assumed to be premultiplied into the electrical color channel values"]
    #[doc = "(after transfer function encoding) unless otherwise specified."]
    #[doc = ""]
    #[doc = "Note, because wl_buffer objects are created from multiple independent"]
    #[doc = "factory interfaces, the wl_buffer interface is frozen at version 1."]
    pub mod wl_buffer {
        #[doc = "Trait to implement the wl_buffer interface. See the module level documentation for more info"]
        pub trait WlBuffer: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_buffer";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_buffer#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy a buffer. If and how you need to release the backing"]
            #[doc = "storage is defined by the buffer factory interface."]
            #[doc = ""]
            #[doc = "For possible side-effects to a surface, see wl_surface.attach."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sent when this wl_buffer is no longer used by the compositor."]
            #[doc = "The client is now free to reuse or destroy this buffer and its"]
            #[doc = "backing storage."]
            #[doc = ""]
            #[doc = "If a client receives a release event before the frame callback"]
            #[doc = "requested in the same wl_surface.commit that attaches this"]
            #[doc = "wl_buffer to a surface, then the client is immediately free to"]
            #[doc = "reuse the buffer and its backing storage, and does not need a"]
            #[doc = "second buffer for the next surface content update. Typically"]
            #[doc = "this is possible, when the compositor maintains a copy of the"]
            #[doc = "wl_surface contents, e.g. as a GL texture. This is an important"]
            #[doc = "optimization for GL(ES) compositors with wl_shm clients."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_buffer#{}.release()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A wl_data_offer represents a piece of data offered for transfer"]
    #[doc = "by another client (the source client).  It is used by the"]
    #[doc = "copy-and-paste and drag-and-drop mechanisms.  The offer"]
    #[doc = "describes the different mime types that the data can be"]
    #[doc = "converted to and provides the mechanism for transferring the"]
    #[doc = "data directly from the source client."]
    pub mod wl_data_offer {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "finish request was called untimely"]
            InvalidFinish = 0u32,
            #[doc = "action mask contains invalid values"]
            InvalidActionMask = 1u32,
            #[doc = "action argument has an invalid value"]
            InvalidAction = 2u32,
            #[doc = "offer doesn't accept this request"]
            InvalidOffer = 3u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidFinish),
                    1u32 => Ok(Self::InvalidActionMask),
                    2u32 => Ok(Self::InvalidAction),
                    3u32 => Ok(Self::InvalidOffer),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wl_data_offer interface. See the module level documentation for more info"]
        pub trait WlDataOffer: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_data_offer";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_data_offer#{}.accept()", object.id);
                        self.accept(object, client, message.uint()?, message.string()?)
                            .await
                    }
                    1u16 => {
                        tracing::debug!("wl_data_offer#{}.receive()", object.id);
                        self.receive(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.fd()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("wl_data_offer#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    3u16 => {
                        tracing::debug!("wl_data_offer#{}.finish()", object.id);
                        self.finish(object, client).await
                    }
                    4u16 => {
                        tracing::debug!("wl_data_offer#{}.set_actions()", object.id);
                        self.set_actions(
                            object,
                            client,
                            message.uint()?.try_into()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Indicate that the client can accept the given mime type, or"]
            #[doc = "NULL for not accepted."]
            #[doc = ""]
            #[doc = "For objects of version 2 or older, this request is used by the"]
            #[doc = "client to give feedback whether the client can receive the given"]
            #[doc = "mime type, or NULL if none is accepted; the feedback does not"]
            #[doc = "determine whether the drag-and-drop operation succeeds or not."]
            #[doc = ""]
            #[doc = "For objects of version 3 or newer, this request determines the"]
            #[doc = "final result of the drag-and-drop operation. If the end result"]
            #[doc = "is that no mime types were accepted, the drag-and-drop operation"]
            #[doc = "will be cancelled and the corresponding drag source will receive"]
            #[doc = "wl_data_source.cancelled. Clients may still use this event in"]
            #[doc = "conjunction with wl_data_source.action for feedback."]
            async fn accept(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                mime_type: Option<String>,
            ) -> crate::server::Result<()>;
            #[doc = "To transfer the offered data, the client issues this request"]
            #[doc = "and indicates the mime type it wants to receive.  The transfer"]
            #[doc = "happens through the passed file descriptor (typically created"]
            #[doc = "with the pipe system call).  The source client writes the data"]
            #[doc = "in the mime type representation requested and then closes the"]
            #[doc = "file descriptor."]
            #[doc = ""]
            #[doc = "The receiving client reads from the read end of the pipe until"]
            #[doc = "EOF and then closes its end, at which point the transfer is"]
            #[doc = "complete."]
            #[doc = ""]
            #[doc = "This request may happen multiple times for different mime types,"]
            #[doc = "both before and after wl_data_device.drop. Drag-and-drop destination"]
            #[doc = "clients may preemptively fetch data or examine it more closely to"]
            #[doc = "determine acceptance."]
            async fn receive(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
                fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the data offer."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Notifies the compositor that the drag destination successfully"]
            #[doc = "finished the drag-and-drop operation."]
            #[doc = ""]
            #[doc = "Upon receiving this request, the compositor will emit"]
            #[doc = "wl_data_source.dnd_finished on the drag source client."]
            #[doc = ""]
            #[doc = "It is a client error to perform other requests than"]
            #[doc = "wl_data_offer.destroy after this one. It is also an error to perform"]
            #[doc = "this request after a NULL mime type has been set in"]
            #[doc = "wl_data_offer.accept or no action was received through"]
            #[doc = "wl_data_offer.action."]
            #[doc = ""]
            #[doc = "If wl_data_offer.finish request is received for a non drag and drop"]
            #[doc = "operation, the invalid_finish protocol error is raised."]
            async fn finish(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the actions that the destination side client supports for"]
            #[doc = "this operation. This request may trigger the emission of"]
            #[doc = "wl_data_source.action and wl_data_offer.action events if the compositor"]
            #[doc = "needs to change the selected action."]
            #[doc = ""]
            #[doc = "This request can be called multiple times throughout the"]
            #[doc = "drag-and-drop operation, typically in response to wl_data_device.enter"]
            #[doc = "or wl_data_device.motion events."]
            #[doc = ""]
            #[doc = "This request determines the final result of the drag-and-drop"]
            #[doc = "operation. If the end result is that no action is accepted,"]
            #[doc = "the drag source will receive wl_data_source.cancelled."]
            #[doc = ""]
            #[doc = "The dnd_actions argument must contain only values expressed in the"]
            #[doc = "wl_data_device_manager.dnd_actions enum, and the preferred_action"]
            #[doc = "argument must only contain one of those values set, otherwise it"]
            #[doc = "will result in a protocol error."]
            #[doc = ""]
            #[doc = "While managing an \"ask\" action, the destination drag-and-drop client"]
            #[doc = "may perform further wl_data_offer.receive requests, and is expected"]
            #[doc = "to perform one last wl_data_offer.set_actions request with a preferred"]
            #[doc = "action other than \"ask\" (and optionally wl_data_offer.accept) before"]
            #[doc = "requesting wl_data_offer.finish, in order to convey the action selected"]
            #[doc = "by the user. If the preferred action is not in the"]
            #[doc = "wl_data_offer.source_actions mask, an error will be raised."]
            #[doc = ""]
            #[doc = "If the \"ask\" action is dismissed (e.g. user cancellation), the client"]
            #[doc = "is expected to perform wl_data_offer.destroy right away."]
            #[doc = ""]
            #[doc = "This request can only be made on drag-and-drop offers, a protocol error"]
            #[doc = "will be raised otherwise."]
            async fn set_actions(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                dnd_actions: super::super::wayland::wl_data_device_manager::DndAction,
                preferred_action: super::super::wayland::wl_data_device_manager::DndAction,
            ) -> crate::server::Result<()>;
            #[doc = "Sent immediately after creating the wl_data_offer object.  One"]
            #[doc = "event per offered mime type."]
            async fn offer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_offer#{}.offer()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(mime_type))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates the actions offered by the data source. It"]
            #[doc = "will be sent immediately after creating the wl_data_offer object,"]
            #[doc = "or anytime the source side changes its offered actions through"]
            #[doc = "wl_data_source.set_actions."]
            async fn source_actions(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                source_actions: super::super::wayland::wl_data_device_manager::DndAction,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_offer#{}.source_actions()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(source_actions.bits())
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates the action selected by the compositor after"]
            #[doc = "matching the source/destination side actions. Only one action (or"]
            #[doc = "none) will be offered here."]
            #[doc = ""]
            #[doc = "This event can be emitted multiple times during the drag-and-drop"]
            #[doc = "operation in response to destination side action changes through"]
            #[doc = "wl_data_offer.set_actions."]
            #[doc = ""]
            #[doc = "This event will no longer be emitted after wl_data_device.drop"]
            #[doc = "happened on the drag-and-drop destination, the client must"]
            #[doc = "honor the last action received, or the last preferred one set"]
            #[doc = "through wl_data_offer.set_actions when handling an \"ask\" action."]
            #[doc = ""]
            #[doc = "Compositors may also change the selected action on the fly, mainly"]
            #[doc = "in response to keyboard modifier changes during the drag-and-drop"]
            #[doc = "operation."]
            #[doc = ""]
            #[doc = "The most recent action received is always the valid one. Prior to"]
            #[doc = "receiving wl_data_device.drop, the chosen action may change (e.g."]
            #[doc = "due to keyboard modifiers being pressed). At the time of receiving"]
            #[doc = "wl_data_device.drop the drag-and-drop destination must honor the"]
            #[doc = "last action received."]
            #[doc = ""]
            #[doc = "Action changes may still happen after wl_data_device.drop,"]
            #[doc = "especially on \"ask\" actions, where the drag-and-drop destination"]
            #[doc = "may choose another action afterwards. Action changes happening"]
            #[doc = "at this stage are always the result of inter-client negotiation, the"]
            #[doc = "compositor shall no longer be able to induce a different action."]
            #[doc = ""]
            #[doc = "Upon \"ask\" actions, it is expected that the drag-and-drop destination"]
            #[doc = "may potentially choose a different action and/or mime type,"]
            #[doc = "based on wl_data_offer.source_actions and finally chosen by the"]
            #[doc = "user (e.g. popping up a menu with the available options). The"]
            #[doc = "final wl_data_offer.set_actions and wl_data_offer.accept requests"]
            #[doc = "must happen before the call to wl_data_offer.finish."]
            async fn action(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                dnd_action: super::super::wayland::wl_data_device_manager::DndAction,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_offer#{}.action()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(dnd_action.bits())
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "The wl_data_source object is the source side of a wl_data_offer."]
    #[doc = "It is created by the source client in a data transfer and"]
    #[doc = "provides a way to describe the offered data and a way to respond"]
    #[doc = "to requests to transfer the data."]
    pub mod wl_data_source {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "action mask contains invalid values"]
            InvalidActionMask = 0u32,
            #[doc = "source doesn't accept this request"]
            InvalidSource = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidActionMask),
                    1u32 => Ok(Self::InvalidSource),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wl_data_source interface. See the module level documentation for more info"]
        pub trait WlDataSource: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_data_source";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_data_source#{}.offer()", object.id);
                        self.offer(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("wl_data_source#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    2u16 => {
                        tracing::debug!("wl_data_source#{}.set_actions()", object.id);
                        self.set_actions(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request adds a mime type to the set of mime types"]
            #[doc = "advertised to targets.  Can be called several times to offer"]
            #[doc = "multiple types."]
            async fn offer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the data source."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the actions that the source side client supports for this"]
            #[doc = "operation. This request may trigger wl_data_source.action and"]
            #[doc = "wl_data_offer.action events if the compositor needs to change the"]
            #[doc = "selected action."]
            #[doc = ""]
            #[doc = "The dnd_actions argument must contain only values expressed in the"]
            #[doc = "wl_data_device_manager.dnd_actions enum, otherwise it will result"]
            #[doc = "in a protocol error."]
            #[doc = ""]
            #[doc = "This request must be made once only, and can only be made on sources"]
            #[doc = "used in drag-and-drop, so it must be performed before"]
            #[doc = "wl_data_device.start_drag. Attempting to use the source other than"]
            #[doc = "for drag-and-drop will raise a protocol error."]
            async fn set_actions(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                dnd_actions: super::super::wayland::wl_data_device_manager::DndAction,
            ) -> crate::server::Result<()>;
            #[doc = "Sent when a target accepts pointer_focus or motion events.  If"]
            #[doc = "a target does not accept any of the offered types, type is NULL."]
            #[doc = ""]
            #[doc = "Used for feedback during drag-and-drop."]
            async fn target(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: Option<String>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_source#{}.target()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(mime_type)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Request for data from the client.  Send the data as the"]
            #[doc = "specified mime type over the passed file descriptor, then"]
            #[doc = "close it."]
            async fn send(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
                fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_source#{}.send()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(mime_type))
                    .put_fd(fd)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This data source is no longer valid. There are several reasons why"]
            #[doc = "this could happen:"]
            #[doc = ""]
            #[doc = "- The data source has been replaced by another data source."]
            #[doc = "- The drag-and-drop operation was performed, but the drop destination"]
            #[doc = "did not accept any of the mime types offered through"]
            #[doc = "wl_data_source.target."]
            #[doc = "- The drag-and-drop operation was performed, but the drop destination"]
            #[doc = "did not select any of the actions present in the mask offered through"]
            #[doc = "wl_data_source.action."]
            #[doc = "- The drag-and-drop operation was performed but didn't happen over a"]
            #[doc = "surface."]
            #[doc = "- The compositor cancelled the drag-and-drop operation (e.g. compositor"]
            #[doc = "dependent timeouts to avoid stale drag-and-drop transfers)."]
            #[doc = ""]
            #[doc = "The client should clean up and destroy this data source."]
            #[doc = ""]
            #[doc = "For objects of version 2 or older, wl_data_source.cancelled will"]
            #[doc = "only be emitted if the data source was replaced by another data"]
            #[doc = "source."]
            async fn cancelled(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_source#{}.cancelled()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The user performed the drop action. This event does not indicate"]
            #[doc = "acceptance, wl_data_source.cancelled may still be emitted afterwards"]
            #[doc = "if the drop destination does not accept any mime type."]
            #[doc = ""]
            #[doc = "However, this event might however not be received if the compositor"]
            #[doc = "cancelled the drag-and-drop operation before this event could happen."]
            #[doc = ""]
            #[doc = "Note that the data_source may still be used in the future and should"]
            #[doc = "not be destroyed here."]
            async fn dnd_drop_performed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_source#{}.dnd_drop_performed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The drop destination finished interoperating with this data"]
            #[doc = "source, so the client is now free to destroy this data source and"]
            #[doc = "free all associated data."]
            #[doc = ""]
            #[doc = "If the action used to perform the operation was \"move\", the"]
            #[doc = "source can now delete the transferred data."]
            async fn dnd_finished(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_source#{}.dnd_finished()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates the action selected by the compositor after"]
            #[doc = "matching the source/destination side actions. Only one action (or"]
            #[doc = "none) will be offered here."]
            #[doc = ""]
            #[doc = "This event can be emitted multiple times during the drag-and-drop"]
            #[doc = "operation, mainly in response to destination side changes through"]
            #[doc = "wl_data_offer.set_actions, and as the data device enters/leaves"]
            #[doc = "surfaces."]
            #[doc = ""]
            #[doc = "It is only possible to receive this event after"]
            #[doc = "wl_data_source.dnd_drop_performed if the drag-and-drop operation"]
            #[doc = "ended in an \"ask\" action, in which case the final wl_data_source.action"]
            #[doc = "event will happen immediately before wl_data_source.dnd_finished."]
            #[doc = ""]
            #[doc = "Compositors may also change the selected action on the fly, mainly"]
            #[doc = "in response to keyboard modifier changes during the drag-and-drop"]
            #[doc = "operation."]
            #[doc = ""]
            #[doc = "The most recent action received is always the valid one. The chosen"]
            #[doc = "action may change alongside negotiation (e.g. an \"ask\" action can turn"]
            #[doc = "into a \"move\" operation), so the effects of the final action must"]
            #[doc = "always be applied in wl_data_offer.dnd_finished."]
            #[doc = ""]
            #[doc = "Clients can trigger cursor surface changes from this point, so"]
            #[doc = "they reflect the current action."]
            async fn action(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                dnd_action: super::super::wayland::wl_data_device_manager::DndAction,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_source#{}.action()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(dnd_action.bits())
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "There is one wl_data_device per seat which can be obtained"]
    #[doc = "from the global wl_data_device_manager singleton."]
    #[doc = ""]
    #[doc = "A wl_data_device provides access to inter-client data transfer"]
    #[doc = "mechanisms such as copy-and-paste and drag-and-drop."]
    pub mod wl_data_device {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "given wl_surface has another role"]
            Role = 0u32,
            #[doc = "source has already been used"]
            UsedSource = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Role),
                    1u32 => Ok(Self::UsedSource),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wl_data_device interface. See the module level documentation for more info"]
        pub trait WlDataDevice: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_data_device";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_data_device#{}.start_drag()", object.id);
                        self.start_drag(
                            object,
                            client,
                            message.object()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.object()?,
                            message.uint()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("wl_data_device#{}.set_selection()", object.id);
                        self.set_selection(object, client, message.object()?, message.uint()?)
                            .await
                    }
                    2u16 => {
                        tracing::debug!("wl_data_device#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request asks the compositor to start a drag-and-drop"]
            #[doc = "operation on behalf of the client."]
            #[doc = ""]
            #[doc = "The source argument is the data source that provides the data"]
            #[doc = "for the eventual data transfer. If source is NULL, enter, leave"]
            #[doc = "and motion events are sent only to the client that initiated the"]
            #[doc = "drag and the client is expected to handle the data passing"]
            #[doc = "internally. If source is destroyed, the drag-and-drop session will be"]
            #[doc = "cancelled."]
            #[doc = ""]
            #[doc = "The origin surface is the surface where the drag originates and"]
            #[doc = "the client must have an active implicit grab that matches the"]
            #[doc = "serial."]
            #[doc = ""]
            #[doc = "The icon surface is an optional (can be NULL) surface that"]
            #[doc = "provides an icon to be moved around with the cursor.  Initially,"]
            #[doc = "the top-left corner of the icon surface is placed at the cursor"]
            #[doc = "hotspot, but subsequent wl_surface.offset requests can move the"]
            #[doc = "relative position. Attach requests must be confirmed with"]
            #[doc = "wl_surface.commit as usual. The icon surface is given the role of"]
            #[doc = "a drag-and-drop icon. If the icon surface already has another role,"]
            #[doc = "it raises a protocol error."]
            #[doc = ""]
            #[doc = "The input region is ignored for wl_surfaces with the role of a"]
            #[doc = "drag-and-drop icon."]
            #[doc = ""]
            #[doc = "The given source may not be used in any further set_selection or"]
            #[doc = "start_drag requests. Attempting to reuse a previously-used source"]
            #[doc = "may send a used_source error."]
            async fn start_drag(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: Option<crate::wire::ObjectId>,
                origin: crate::wire::ObjectId,
                icon: Option<crate::wire::ObjectId>,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This request asks the compositor to set the selection"]
            #[doc = "to the data from the source on behalf of the client."]
            #[doc = ""]
            #[doc = "To unset the selection, set the source to NULL."]
            #[doc = ""]
            #[doc = "The given source may not be used in any further set_selection or"]
            #[doc = "start_drag requests. Attempting to reuse a previously-used source"]
            #[doc = "may send a used_source error."]
            async fn set_selection(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: Option<crate::wire::ObjectId>,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This request destroys the data device."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The data_offer event introduces a new wl_data_offer object,"]
            #[doc = "which will subsequently be used in either the"]
            #[doc = "data_device.enter event (for drag-and-drop) or the"]
            #[doc = "data_device.selection event (for selections).  Immediately"]
            #[doc = "following the data_device.data_offer event, the new data_offer"]
            #[doc = "object will send out data_offer.offer events to describe the"]
            #[doc = "mime types it offers."]
            async fn data_offer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_device#{}.data_offer()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent when an active drag-and-drop pointer enters"]
            #[doc = "a surface owned by the client.  The position of the pointer at"]
            #[doc = "enter time is provided by the x and y arguments, in surface-local"]
            #[doc = "coordinates."]
            async fn enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: crate::wire::ObjectId,
                x: crate::wire::Fixed,
                y: crate::wire::Fixed,
                id: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_device#{}.enter()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(surface))
                    .put_fixed(x)
                    .put_fixed(y)
                    .put_object(id)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent when the drag-and-drop pointer leaves the"]
            #[doc = "surface and the session ends.  The client must destroy the"]
            #[doc = "wl_data_offer introduced at enter time at this point."]
            async fn leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_device#{}.leave()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent when the drag-and-drop pointer moves within"]
            #[doc = "the currently focused surface. The new position of the pointer"]
            #[doc = "is provided by the x and y arguments, in surface-local"]
            #[doc = "coordinates."]
            async fn motion(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                x: crate::wire::Fixed,
                y: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_device#{}.motion()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_fixed(x)
                    .put_fixed(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The event is sent when a drag-and-drop operation is ended"]
            #[doc = "because the implicit grab is removed."]
            #[doc = ""]
            #[doc = "The drag-and-drop destination is expected to honor the last action"]
            #[doc = "received through wl_data_offer.action, if the resulting action is"]
            #[doc = "\"copy\" or \"move\", the destination can still perform"]
            #[doc = "wl_data_offer.receive requests, and is expected to end all"]
            #[doc = "transfers with a wl_data_offer.finish request."]
            #[doc = ""]
            #[doc = "If the resulting action is \"ask\", the action will not be considered"]
            #[doc = "final. The drag-and-drop destination is expected to perform one last"]
            #[doc = "wl_data_offer.set_actions request, or wl_data_offer.destroy in order"]
            #[doc = "to cancel the operation."]
            async fn drop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_device#{}.drop()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The selection event is sent out to notify the client of a new"]
            #[doc = "wl_data_offer for the selection for this device.  The"]
            #[doc = "data_device.data_offer and the data_offer.offer events are"]
            #[doc = "sent out immediately before this event to introduce the data"]
            #[doc = "offer object.  The selection event is sent to a client"]
            #[doc = "immediately before receiving keyboard focus and when a new"]
            #[doc = "selection is set while the client has keyboard focus.  The"]
            #[doc = "data_offer is valid until a new data_offer or NULL is received"]
            #[doc = "or until the client loses keyboard focus.  Switching surface with"]
            #[doc = "keyboard focus within the same client doesn't mean a new selection"]
            #[doc = "will be sent.  The client must destroy the previous selection"]
            #[doc = "data_offer, if any, upon receiving this event."]
            async fn selection(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_device#{}.selection()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_object(id).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "The wl_data_device_manager is a singleton global object that"]
    #[doc = "provides access to inter-client data transfer mechanisms such as"]
    #[doc = "copy-and-paste and drag-and-drop.  These mechanisms are tied to"]
    #[doc = "a wl_seat and this interface lets a client get a wl_data_device"]
    #[doc = "corresponding to a wl_seat."]
    #[doc = ""]
    #[doc = "Depending on the version bound, the objects created from the bound"]
    #[doc = "wl_data_device_manager object will have different requirements for"]
    #[doc = "functioning properly. See wl_data_source.set_actions,"]
    #[doc = "wl_data_offer.accept and wl_data_offer.finish for details."]
    pub mod wl_data_device_manager {
        bitflags::bitflags! { # [doc = "This is a bitmask of the available/preferred actions in a"] # [doc = "drag-and-drop operation."] # [doc = ""] # [doc = "In the compositor, the selected action is a result of matching the"] # [doc = "actions offered by the source and destination sides.  \"action\" events"] # [doc = "with a \"none\" action will be sent to both source and destination if"] # [doc = "there is no match. All further checks will effectively happen on"] # [doc = "(source actions ∩ destination actions)."] # [doc = ""] # [doc = "In addition, compositors may also pick different actions in"] # [doc = "reaction to key modifiers being pressed. One common design that"] # [doc = "is used in major toolkits (and the behavior recommended for"] # [doc = "compositors) is:"] # [doc = ""] # [doc = "- If no modifiers are pressed, the first match (in bit order)"] # [doc = "will be used."] # [doc = "- Pressing Shift selects \"move\", if enabled in the mask."] # [doc = "- Pressing Control selects \"copy\", if enabled in the mask."] # [doc = ""] # [doc = "Behavior beyond that is considered implementation-dependent."] # [doc = "Compositors may for example bind other modifiers (like Alt/Meta)"] # [doc = "or drags initiated with other buttons than BTN_LEFT to specific"] # [doc = "actions (e.g. \"ask\")."] # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct DndAction : u32 { # [doc = "no action"] const None = 0u32 ; # [doc = "copy action"] const Copy = 1u32 ; # [doc = "move action"] const Move = 2u32 ; # [doc = "ask action"] const Ask = 4u32 ; } }
        impl TryFrom<u32> for DndAction {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "Trait to implement the wl_data_device_manager interface. See the module level documentation for more info"]
        pub trait WlDataDeviceManager: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_data_device_manager";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "wl_data_device_manager#{}.create_data_source()",
                            object.id
                        );
                        self.create_data_source(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("wl_data_device_manager#{}.get_data_device()", object.id);
                        self.get_data_device(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a new data source."]
            async fn create_data_source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Create a new data device for a given seat."]
            async fn get_data_device(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "This interface is implemented by servers that provide"]
    #[doc = "desktop-style user interfaces."]
    #[doc = ""]
    #[doc = "It allows clients to associate a wl_shell_surface with"]
    #[doc = "a basic surface."]
    #[doc = ""]
    #[doc = "Note! This protocol is deprecated and not intended for production use."]
    #[doc = "For desktop-style user interfaces, use xdg_shell. Compositors and clients"]
    #[doc = "should not implement this interface."]
    pub mod wl_shell {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "given wl_surface has another role"]
            Role = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Role),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wl_shell interface. See the module level documentation for more info"]
        pub trait WlShell: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_shell";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_shell#{}.get_shell_surface()", object.id);
                        self.get_shell_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a shell surface for an existing surface. This gives"]
            #[doc = "the wl_surface the role of a shell surface. If the wl_surface"]
            #[doc = "already has another role, it raises a protocol error."]
            #[doc = ""]
            #[doc = "Only one shell surface can be associated with a given surface."]
            async fn get_shell_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "An interface that may be implemented by a wl_surface, for"]
    #[doc = "implementations that provide a desktop-style user interface."]
    #[doc = ""]
    #[doc = "It provides requests to treat surfaces like toplevel, fullscreen"]
    #[doc = "or popup windows, move, resize or maximize them, associate"]
    #[doc = "metadata like title and class, etc."]
    #[doc = ""]
    #[doc = "On the server side the object is automatically destroyed when"]
    #[doc = "the related wl_surface is destroyed. On the client side,"]
    #[doc = "wl_shell_surface_destroy() must be called before destroying"]
    #[doc = "the wl_surface object."]
    pub mod wl_shell_surface {
        bitflags::bitflags! { # [doc = "These values are used to indicate which edge of a surface"] # [doc = "is being dragged in a resize operation. The server may"] # [doc = "use this information to adapt its behavior, e.g. choose"] # [doc = "an appropriate cursor image."] # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Resize : u32 { # [doc = "no edge"] const None = 0u32 ; # [doc = "top edge"] const Top = 1u32 ; # [doc = "bottom edge"] const Bottom = 2u32 ; # [doc = "left edge"] const Left = 4u32 ; # [doc = "top and left edges"] const TopLeft = 5u32 ; # [doc = "bottom and left edges"] const BottomLeft = 6u32 ; # [doc = "right edge"] const Right = 8u32 ; # [doc = "top and right edges"] const TopRight = 9u32 ; # [doc = "bottom and right edges"] const BottomRight = 10u32 ; } }
        impl TryFrom<u32> for Resize {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        bitflags::bitflags! { # [doc = "These flags specify details of the expected behaviour"] # [doc = "of transient surfaces. Used in the set_transient request."] # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Transient : u32 { # [doc = "do not set keyboard focus"] const Inactive = 1u32 ; } }
        impl TryFrom<u32> for Transient {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "Hints to indicate to the compositor how to deal with a conflict"]
        #[doc = "between the dimensions of the surface and the dimensions of the"]
        #[doc = "output. The compositor is free to ignore this parameter."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum FullscreenMethod {
            #[doc = "no preference, apply default policy"]
            Default = 0u32,
            #[doc = "scale, preserve the surface's aspect ratio and center on output"]
            Scale = 1u32,
            #[doc = "switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch"]
            Driver = 2u32,
            #[doc = "no upscaling, center on output and add black borders to compensate size mismatch"]
            Fill = 3u32,
        }
        impl TryFrom<u32> for FullscreenMethod {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Default),
                    1u32 => Ok(Self::Scale),
                    2u32 => Ok(Self::Driver),
                    3u32 => Ok(Self::Fill),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wl_shell_surface interface. See the module level documentation for more info"]
        pub trait WlShellSurface: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_shell_surface";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_shell_surface#{}.pong()", object.id);
                        self.pong(object, client, message.uint()?).await
                    }
                    1u16 => {
                        tracing::debug!("wl_shell_surface#{}.move()", object.id);
                        self.r#move(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("wl_shell_surface#{}.resize()", object.id);
                        self.resize(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("wl_shell_surface#{}.set_toplevel()", object.id);
                        self.set_toplevel(object, client).await
                    }
                    4u16 => {
                        tracing::debug!("wl_shell_surface#{}.set_transient()", object.id);
                        self.set_transient(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    5u16 => {
                        tracing::debug!("wl_shell_surface#{}.set_fullscreen()", object.id);
                        self.set_fullscreen(
                            object,
                            client,
                            message.uint()?.try_into()?,
                            message.uint()?,
                            message.object()?,
                        )
                        .await
                    }
                    6u16 => {
                        tracing::debug!("wl_shell_surface#{}.set_popup()", object.id);
                        self.set_popup(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    7u16 => {
                        tracing::debug!("wl_shell_surface#{}.set_maximized()", object.id);
                        self.set_maximized(object, client, message.object()?).await
                    }
                    8u16 => {
                        tracing::debug!("wl_shell_surface#{}.set_title()", object.id);
                        self.set_title(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    9u16 => {
                        tracing::debug!("wl_shell_surface#{}.set_class()", object.id);
                        self.set_class(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "A client must respond to a ping event with a pong request or"]
            #[doc = "the client may be deemed unresponsive."]
            async fn pong(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Start a pointer-driven move of the surface."]
            #[doc = ""]
            #[doc = "This request must be used in response to a button press event."]
            #[doc = "The server may ignore move requests depending on the state of"]
            #[doc = "the surface (e.g. fullscreen or maximized)."]
            async fn r#move(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Start a pointer-driven resizing of the surface."]
            #[doc = ""]
            #[doc = "This request must be used in response to a button press event."]
            #[doc = "The server may ignore resize requests depending on the state of"]
            #[doc = "the surface (e.g. fullscreen or maximized)."]
            async fn resize(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
                edges: Resize,
            ) -> crate::server::Result<()>;
            #[doc = "Map the surface as a toplevel surface."]
            #[doc = ""]
            #[doc = "A toplevel surface is not fullscreen, maximized or transient."]
            async fn set_toplevel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Map the surface relative to an existing surface."]
            #[doc = ""]
            #[doc = "The x and y arguments specify the location of the upper left"]
            #[doc = "corner of the surface relative to the upper left corner of the"]
            #[doc = "parent surface, in surface-local coordinates."]
            #[doc = ""]
            #[doc = "The flags argument controls details of the transient behaviour."]
            async fn set_transient(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                parent: crate::wire::ObjectId,
                x: i32,
                y: i32,
                flags: Transient,
            ) -> crate::server::Result<()>;
            #[doc = "Map the surface as a fullscreen surface."]
            #[doc = ""]
            #[doc = "If an output parameter is given then the surface will be made"]
            #[doc = "fullscreen on that output. If the client does not specify the"]
            #[doc = "output then the compositor will apply its policy - usually"]
            #[doc = "choosing the output on which the surface has the biggest surface"]
            #[doc = "area."]
            #[doc = ""]
            #[doc = "The client may specify a method to resolve a size conflict"]
            #[doc = "between the output size and the surface size - this is provided"]
            #[doc = "through the method parameter."]
            #[doc = ""]
            #[doc = "The framerate parameter is used only when the method is set"]
            #[doc = "to \"driver\", to indicate the preferred framerate. A value of 0"]
            #[doc = "indicates that the client does not care about framerate.  The"]
            #[doc = "framerate is specified in mHz, that is framerate of 60000 is 60Hz."]
            #[doc = ""]
            #[doc = "A method of \"scale\" or \"driver\" implies a scaling operation of"]
            #[doc = "the surface, either via a direct scaling operation or a change of"]
            #[doc = "the output mode. This will override any kind of output scaling, so"]
            #[doc = "that mapping a surface with a buffer size equal to the mode can"]
            #[doc = "fill the screen independent of buffer_scale."]
            #[doc = ""]
            #[doc = "A method of \"fill\" means we don't scale up the buffer, however"]
            #[doc = "any output scale is applied. This means that you may run into"]
            #[doc = "an edge case where the application maps a buffer with the same"]
            #[doc = "size of the output mode but buffer_scale 1 (thus making a"]
            #[doc = "surface larger than the output). In this case it is allowed to"]
            #[doc = "downscale the results to fit the screen."]
            #[doc = ""]
            #[doc = "The compositor must reply to this request with a configure event"]
            #[doc = "with the dimensions for the output on which the surface will"]
            #[doc = "be made fullscreen."]
            async fn set_fullscreen(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                method: FullscreenMethod,
                framerate: u32,
                output: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Map the surface as a popup."]
            #[doc = ""]
            #[doc = "A popup surface is a transient surface with an added pointer"]
            #[doc = "grab."]
            #[doc = ""]
            #[doc = "An existing implicit grab will be changed to owner-events mode,"]
            #[doc = "and the popup grab will continue after the implicit grab ends"]
            #[doc = "(i.e. releasing the mouse button does not cause the popup to"]
            #[doc = "be unmapped)."]
            #[doc = ""]
            #[doc = "The popup grab continues until the window is destroyed or a"]
            #[doc = "mouse button is pressed in any other client's window. A click"]
            #[doc = "in any of the client's surfaces is reported as normal, however,"]
            #[doc = "clicks in other clients' surfaces will be discarded and trigger"]
            #[doc = "the callback."]
            #[doc = ""]
            #[doc = "The x and y arguments specify the location of the upper left"]
            #[doc = "corner of the surface relative to the upper left corner of the"]
            #[doc = "parent surface, in surface-local coordinates."]
            async fn set_popup(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
                parent: crate::wire::ObjectId,
                x: i32,
                y: i32,
                flags: Transient,
            ) -> crate::server::Result<()>;
            #[doc = "Map the surface as a maximized surface."]
            #[doc = ""]
            #[doc = "If an output parameter is given then the surface will be"]
            #[doc = "maximized on that output. If the client does not specify the"]
            #[doc = "output then the compositor will apply its policy - usually"]
            #[doc = "choosing the output on which the surface has the biggest surface"]
            #[doc = "area."]
            #[doc = ""]
            #[doc = "The compositor will reply with a configure event telling"]
            #[doc = "the expected new surface size. The operation is completed"]
            #[doc = "on the next buffer attach to this surface."]
            #[doc = ""]
            #[doc = "A maximized surface typically fills the entire output it is"]
            #[doc = "bound to, except for desktop elements such as panels. This is"]
            #[doc = "the main difference between a maximized shell surface and a"]
            #[doc = "fullscreen shell surface."]
            #[doc = ""]
            #[doc = "The details depend on the compositor implementation."]
            async fn set_maximized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Set a short title for the surface."]
            #[doc = ""]
            #[doc = "This string may be used to identify the surface in a task bar,"]
            #[doc = "window list, or other user interface elements provided by the"]
            #[doc = "compositor."]
            #[doc = ""]
            #[doc = "The string must be encoded in UTF-8."]
            async fn set_title(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                title: String,
            ) -> crate::server::Result<()>;
            #[doc = "Set a class for the surface."]
            #[doc = ""]
            #[doc = "The surface class identifies the general class of applications"]
            #[doc = "to which the surface belongs. A common convention is to use the"]
            #[doc = "file name (or the full path if it is a non-standard location) of"]
            #[doc = "the application's .desktop file as the class."]
            async fn set_class(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                class: String,
            ) -> crate::server::Result<()>;
            #[doc = "Ping a client to check if it is receiving events and sending"]
            #[doc = "requests. A client is expected to reply with a pong request."]
            async fn ping(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_shell_surface#{}.ping()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The configure event asks the client to resize its surface."]
            #[doc = ""]
            #[doc = "The size is a hint, in the sense that the client is free to"]
            #[doc = "ignore it if it doesn't resize, pick a smaller size (to"]
            #[doc = "satisfy aspect ratio or resize in steps of NxM pixels)."]
            #[doc = ""]
            #[doc = "The edges parameter provides a hint about how the surface"]
            #[doc = "was resized. The client may use this information to decide"]
            #[doc = "how to adjust its content to the new size (e.g. a scrolling"]
            #[doc = "area might adjust its content position to leave the viewable"]
            #[doc = "content unmoved)."]
            #[doc = ""]
            #[doc = "The client is free to dismiss all but the last configure"]
            #[doc = "event it received."]
            #[doc = ""]
            #[doc = "The width and height arguments specify the size of the window"]
            #[doc = "in surface-local coordinates."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                edges: Resize,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_shell_surface#{}.configure()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(edges.bits())
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The popup_done event is sent out when a popup grab is broken,"]
            #[doc = "that is, when the user clicks a surface that doesn't belong"]
            #[doc = "to the client owning the popup surface."]
            async fn popup_done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_shell_surface#{}.popup_done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A surface is a rectangular area that may be displayed on zero"]
    #[doc = "or more outputs, and shown any number of times at the compositor's"]
    #[doc = "discretion. They can present wl_buffers, receive user input, and"]
    #[doc = "define a local coordinate system."]
    #[doc = ""]
    #[doc = "The size of a surface (and relative positions on it) is described"]
    #[doc = "in surface-local coordinates, which may differ from the buffer"]
    #[doc = "coordinates of the pixel content, in case a buffer_transform"]
    #[doc = "or a buffer_scale is used."]
    #[doc = ""]
    #[doc = "A surface without a \"role\" is fairly useless: a compositor does"]
    #[doc = "not know where, when or how to present it. The role is the"]
    #[doc = "purpose of a wl_surface. Examples of roles are a cursor for a"]
    #[doc = "pointer (as set by wl_pointer.set_cursor), a drag icon"]
    #[doc = "(wl_data_device.start_drag), a sub-surface"]
    #[doc = "(wl_subcompositor.get_subsurface), and a window as defined by a"]
    #[doc = "shell protocol (e.g. wl_shell.get_shell_surface)."]
    #[doc = ""]
    #[doc = "A surface can have only one role at a time. Initially a"]
    #[doc = "wl_surface does not have a role. Once a wl_surface is given a"]
    #[doc = "role, it is set permanently for the whole lifetime of the"]
    #[doc = "wl_surface object. Giving the current role again is allowed,"]
    #[doc = "unless explicitly forbidden by the relevant interface"]
    #[doc = "specification."]
    #[doc = ""]
    #[doc = "Surface roles are given by requests in other interfaces such as"]
    #[doc = "wl_pointer.set_cursor. The request should explicitly mention"]
    #[doc = "that this request gives a role to a wl_surface. Often, this"]
    #[doc = "request also creates a new protocol object that represents the"]
    #[doc = "role and adds additional functionality to wl_surface. When a"]
    #[doc = "client wants to destroy a wl_surface, they must destroy this role"]
    #[doc = "object before the wl_surface, otherwise a defunct_role_object error is"]
    #[doc = "sent."]
    #[doc = ""]
    #[doc = "Destroying the role object does not remove the role from the"]
    #[doc = "wl_surface, but it may stop the wl_surface from \"playing the role\"."]
    #[doc = "For instance, if a wl_subsurface object is destroyed, the wl_surface"]
    #[doc = "it was created for will be unmapped and forget its position and"]
    #[doc = "z-order. It is allowed to create a wl_subsurface for the same"]
    #[doc = "wl_surface again, but it is not allowed to use the wl_surface as"]
    #[doc = "a cursor (cursor is a different role than sub-surface, and role"]
    #[doc = "switching is not allowed)."]
    pub mod wl_surface {
        #[doc = "These errors can be emitted in response to wl_surface requests."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "buffer scale value is invalid"]
            InvalidScale = 0u32,
            #[doc = "buffer transform value is invalid"]
            InvalidTransform = 1u32,
            #[doc = "buffer size is invalid"]
            InvalidSize = 2u32,
            #[doc = "buffer offset is invalid"]
            InvalidOffset = 3u32,
            #[doc = "surface was destroyed before its role object"]
            DefunctRoleObject = 4u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidScale),
                    1u32 => Ok(Self::InvalidTransform),
                    2u32 => Ok(Self::InvalidSize),
                    3u32 => Ok(Self::InvalidOffset),
                    4u32 => Ok(Self::DefunctRoleObject),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wl_surface interface. See the module level documentation for more info"]
        pub trait WlSurface: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_surface";
            const VERSION: u32 = 6u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_surface#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("wl_surface#{}.attach()", object.id);
                        self.attach(
                            object,
                            client,
                            message.object()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("wl_surface#{}.damage()", object.id);
                        self.damage(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("wl_surface#{}.frame()", object.id);
                        self.frame(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("wl_surface#{}.set_opaque_region()", object.id);
                        self.set_opaque_region(object, client, message.object()?)
                            .await
                    }
                    5u16 => {
                        tracing::debug!("wl_surface#{}.set_input_region()", object.id);
                        self.set_input_region(object, client, message.object()?)
                            .await
                    }
                    6u16 => {
                        tracing::debug!("wl_surface#{}.commit()", object.id);
                        self.commit(object, client).await
                    }
                    7u16 => {
                        tracing::debug!("wl_surface#{}.set_buffer_transform()", object.id);
                        self.set_buffer_transform(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    8u16 => {
                        tracing::debug!("wl_surface#{}.set_buffer_scale()", object.id);
                        self.set_buffer_scale(object, client, message.int()?).await
                    }
                    9u16 => {
                        tracing::debug!("wl_surface#{}.damage_buffer()", object.id);
                        self.damage_buffer(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    10u16 => {
                        tracing::debug!("wl_surface#{}.offset()", object.id);
                        self.offset(object, client, message.int()?, message.int()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Deletes the surface and invalidates its object ID."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set a buffer as the content of this surface."]
            #[doc = ""]
            #[doc = "The new size of the surface is calculated based on the buffer"]
            #[doc = "size transformed by the inverse buffer_transform and the"]
            #[doc = "inverse buffer_scale. This means that at commit time the supplied"]
            #[doc = "buffer size must be an integer multiple of the buffer_scale. If"]
            #[doc = "that's not the case, an invalid_size error is sent."]
            #[doc = ""]
            #[doc = "The x and y arguments specify the location of the new pending"]
            #[doc = "buffer's upper left corner, relative to the current buffer's upper"]
            #[doc = "left corner, in surface-local coordinates. In other words, the"]
            #[doc = "x and y, combined with the new surface size define in which"]
            #[doc = "directions the surface's size changes. Setting anything other than 0"]
            #[doc = "as x and y arguments is discouraged, and should instead be replaced"]
            #[doc = "with using the separate wl_surface.offset request."]
            #[doc = ""]
            #[doc = "When the bound wl_surface version is 5 or higher, passing any"]
            #[doc = "non-zero x or y is a protocol violation, and will result in an"]
            #[doc = "'invalid_offset' error being raised. The x and y arguments are ignored"]
            #[doc = "and do not change the pending state. To achieve equivalent semantics,"]
            #[doc = "use wl_surface.offset."]
            #[doc = ""]
            #[doc = "Surface contents are double-buffered state, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "The initial surface contents are void; there is no content."]
            #[doc = "wl_surface.attach assigns the given wl_buffer as the pending"]
            #[doc = "wl_buffer. wl_surface.commit makes the pending wl_buffer the new"]
            #[doc = "surface contents, and the size of the surface becomes the size"]
            #[doc = "calculated from the wl_buffer, as described above. After commit,"]
            #[doc = "there is no pending buffer until the next attach."]
            #[doc = ""]
            #[doc = "Committing a pending wl_buffer allows the compositor to read the"]
            #[doc = "pixels in the wl_buffer. The compositor may access the pixels at"]
            #[doc = "any time after the wl_surface.commit request. When the compositor"]
            #[doc = "will not access the pixels anymore, it will send the"]
            #[doc = "wl_buffer.release event. Only after receiving wl_buffer.release,"]
            #[doc = "the client may reuse the wl_buffer. A wl_buffer that has been"]
            #[doc = "attached and then replaced by another attach instead of committed"]
            #[doc = "will not receive a release event, and is not used by the"]
            #[doc = "compositor."]
            #[doc = ""]
            #[doc = "If a pending wl_buffer has been committed to more than one wl_surface,"]
            #[doc = "the delivery of wl_buffer.release events becomes undefined. A well"]
            #[doc = "behaved client should not rely on wl_buffer.release events in this"]
            #[doc = "case. Alternatively, a client could create multiple wl_buffer objects"]
            #[doc = "from the same backing storage or use wp_linux_buffer_release."]
            #[doc = ""]
            #[doc = "Destroying the wl_buffer after wl_buffer.release does not change"]
            #[doc = "the surface contents. Destroying the wl_buffer before wl_buffer.release"]
            #[doc = "is allowed as long as the underlying buffer storage isn't re-used (this"]
            #[doc = "can happen e.g. on client process termination). However, if the client"]
            #[doc = "destroys the wl_buffer before receiving the wl_buffer.release event and"]
            #[doc = "mutates the underlying buffer storage, the surface contents become"]
            #[doc = "undefined immediately."]
            #[doc = ""]
            #[doc = "If wl_surface.attach is sent with a NULL wl_buffer, the"]
            #[doc = "following wl_surface.commit will remove the surface content."]
            #[doc = ""]
            #[doc = "If a pending wl_buffer has been destroyed, the result is not specified."]
            #[doc = "Many compositors are known to remove the surface content on the following"]
            #[doc = "wl_surface.commit, but this behaviour is not universal. Clients seeking to"]
            #[doc = "maximise compatibility should not destroy pending buffers and should"]
            #[doc = "ensure that they explicitly remove content from surfaces, even after"]
            #[doc = "destroying buffers."]
            async fn attach(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer: Option<crate::wire::ObjectId>,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "This request is used to describe the regions where the pending"]
            #[doc = "buffer is different from the current surface contents, and where"]
            #[doc = "the surface therefore needs to be repainted. The compositor"]
            #[doc = "ignores the parts of the damage that fall outside of the surface."]
            #[doc = ""]
            #[doc = "Damage is double-buffered state, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "The damage rectangle is specified in surface-local coordinates,"]
            #[doc = "where x and y specify the upper left corner of the damage rectangle."]
            #[doc = ""]
            #[doc = "The initial value for pending damage is empty: no damage."]
            #[doc = "wl_surface.damage adds pending damage: the new pending damage"]
            #[doc = "is the union of old pending damage and the given rectangle."]
            #[doc = ""]
            #[doc = "wl_surface.commit assigns pending damage as the current damage,"]
            #[doc = "and clears pending damage. The server will clear the current"]
            #[doc = "damage as it repaints the surface."]
            #[doc = ""]
            #[doc = "Note! New clients should not use this request. Instead damage can be"]
            #[doc = "posted with wl_surface.damage_buffer which uses buffer coordinates"]
            #[doc = "instead of surface coordinates."]
            async fn damage(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Request a notification when it is a good time to start drawing a new"]
            #[doc = "frame, by creating a frame callback. This is useful for throttling"]
            #[doc = "redrawing operations, and driving animations."]
            #[doc = ""]
            #[doc = "When a client is animating on a wl_surface, it can use the 'frame'"]
            #[doc = "request to get notified when it is a good time to draw and commit the"]
            #[doc = "next frame of animation. If the client commits an update earlier than"]
            #[doc = "that, it is likely that some updates will not make it to the display,"]
            #[doc = "and the client is wasting resources by drawing too often."]
            #[doc = ""]
            #[doc = "The frame request will take effect on the next wl_surface.commit."]
            #[doc = "The notification will only be posted for one frame unless"]
            #[doc = "requested again. For a wl_surface, the notifications are posted in"]
            #[doc = "the order the frame requests were committed."]
            #[doc = ""]
            #[doc = "The server must send the notifications so that a client"]
            #[doc = "will not send excessive updates, while still allowing"]
            #[doc = "the highest possible update rate for clients that wait for the reply"]
            #[doc = "before drawing again. The server should give some time for the client"]
            #[doc = "to draw and commit after sending the frame callback events to let it"]
            #[doc = "hit the next output refresh."]
            #[doc = ""]
            #[doc = "A server should avoid signaling the frame callbacks if the"]
            #[doc = "surface is not visible in any way, e.g. the surface is off-screen,"]
            #[doc = "or completely obscured by other opaque surfaces."]
            #[doc = ""]
            #[doc = "The object returned by this request will be destroyed by the"]
            #[doc = "compositor after the callback is fired and as such the client must not"]
            #[doc = "attempt to use it after that point."]
            #[doc = ""]
            #[doc = "The callback_data passed in the callback is the current time, in"]
            #[doc = "milliseconds, with an undefined base."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                callback: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This request sets the region of the surface that contains"]
            #[doc = "opaque content."]
            #[doc = ""]
            #[doc = "The opaque region is an optimization hint for the compositor"]
            #[doc = "that lets it optimize the redrawing of content behind opaque"]
            #[doc = "regions.  Setting an opaque region is not required for correct"]
            #[doc = "behaviour, but marking transparent content as opaque will result"]
            #[doc = "in repaint artifacts."]
            #[doc = ""]
            #[doc = "The opaque region is specified in surface-local coordinates."]
            #[doc = ""]
            #[doc = "The compositor ignores the parts of the opaque region that fall"]
            #[doc = "outside of the surface."]
            #[doc = ""]
            #[doc = "Opaque region is double-buffered state, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "wl_surface.set_opaque_region changes the pending opaque region."]
            #[doc = "wl_surface.commit copies the pending region to the current region."]
            #[doc = "Otherwise, the pending and current regions are never changed."]
            #[doc = ""]
            #[doc = "The initial value for an opaque region is empty. Setting the pending"]
            #[doc = "opaque region has copy semantics, and the wl_region object can be"]
            #[doc = "destroyed immediately. A NULL wl_region causes the pending opaque"]
            #[doc = "region to be set to empty."]
            async fn set_opaque_region(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                region: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "This request sets the region of the surface that can receive"]
            #[doc = "pointer and touch events."]
            #[doc = ""]
            #[doc = "Input events happening outside of this region will try the next"]
            #[doc = "surface in the server surface stack. The compositor ignores the"]
            #[doc = "parts of the input region that fall outside of the surface."]
            #[doc = ""]
            #[doc = "The input region is specified in surface-local coordinates."]
            #[doc = ""]
            #[doc = "Input region is double-buffered state, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "wl_surface.set_input_region changes the pending input region."]
            #[doc = "wl_surface.commit copies the pending region to the current region."]
            #[doc = "Otherwise the pending and current regions are never changed,"]
            #[doc = "except cursor and icon surfaces are special cases, see"]
            #[doc = "wl_pointer.set_cursor and wl_data_device.start_drag."]
            #[doc = ""]
            #[doc = "The initial value for an input region is infinite. That means the"]
            #[doc = "whole surface will accept input. Setting the pending input region"]
            #[doc = "has copy semantics, and the wl_region object can be destroyed"]
            #[doc = "immediately. A NULL wl_region causes the input region to be set"]
            #[doc = "to infinite."]
            async fn set_input_region(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                region: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Surface state (input, opaque, and damage regions, attached buffers,"]
            #[doc = "etc.) is double-buffered. Protocol requests modify the pending state,"]
            #[doc = "as opposed to the active state in use by the compositor."]
            #[doc = ""]
            #[doc = "A commit request atomically creates a content update from the pending"]
            #[doc = "state, even if the pending state has not been touched. The content"]
            #[doc = "update is placed in a queue until it becomes active. After commit, the"]
            #[doc = "new pending state is as documented for each related request."]
            #[doc = ""]
            #[doc = "When the content update is applied, the wl_buffer is applied before all"]
            #[doc = "other state. This means that all coordinates in double-buffered state"]
            #[doc = "are relative to the newly attached wl_buffers, except for"]
            #[doc = "wl_surface.attach itself. If there is no newly attached wl_buffer, the"]
            #[doc = "coordinates are relative to the previous content update."]
            #[doc = ""]
            #[doc = "All requests that need a commit to become effective are documented"]
            #[doc = "to affect double-buffered state."]
            #[doc = ""]
            #[doc = "Other interfaces may add further double-buffered surface state."]
            async fn commit(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This request sets the transformation that the client has already applied"]
            #[doc = "to the content of the buffer. The accepted values for the transform"]
            #[doc = "parameter are the values for wl_output.transform."]
            #[doc = ""]
            #[doc = "The compositor applies the inverse of this transformation whenever it"]
            #[doc = "uses the buffer contents."]
            #[doc = ""]
            #[doc = "Buffer transform is double-buffered state, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "A newly created surface has its buffer transformation set to normal."]
            #[doc = ""]
            #[doc = "wl_surface.set_buffer_transform changes the pending buffer"]
            #[doc = "transformation. wl_surface.commit copies the pending buffer"]
            #[doc = "transformation to the current one. Otherwise, the pending and current"]
            #[doc = "values are never changed."]
            #[doc = ""]
            #[doc = "The purpose of this request is to allow clients to render content"]
            #[doc = "according to the output transform, thus permitting the compositor to"]
            #[doc = "use certain optimizations even if the display is rotated. Using"]
            #[doc = "hardware overlays and scanning out a client buffer for fullscreen"]
            #[doc = "surfaces are examples of such optimizations. Those optimizations are"]
            #[doc = "highly dependent on the compositor implementation, so the use of this"]
            #[doc = "request should be considered on a case-by-case basis."]
            #[doc = ""]
            #[doc = "Note that if the transform value includes 90 or 270 degree rotation,"]
            #[doc = "the width of the buffer will become the surface height and the height"]
            #[doc = "of the buffer will become the surface width."]
            #[doc = ""]
            #[doc = "If transform is not one of the values from the"]
            #[doc = "wl_output.transform enum the invalid_transform protocol error"]
            #[doc = "is raised."]
            async fn set_buffer_transform(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                transform: super::super::wayland::wl_output::Transform,
            ) -> crate::server::Result<()>;
            #[doc = "This request sets an optional scaling factor on how the compositor"]
            #[doc = "interprets the contents of the buffer attached to the window."]
            #[doc = ""]
            #[doc = "Buffer scale is double-buffered state, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "A newly created surface has its buffer scale set to 1."]
            #[doc = ""]
            #[doc = "wl_surface.set_buffer_scale changes the pending buffer scale."]
            #[doc = "wl_surface.commit copies the pending buffer scale to the current one."]
            #[doc = "Otherwise, the pending and current values are never changed."]
            #[doc = ""]
            #[doc = "The purpose of this request is to allow clients to supply higher"]
            #[doc = "resolution buffer data for use on high resolution outputs. It is"]
            #[doc = "intended that you pick the same buffer scale as the scale of the"]
            #[doc = "output that the surface is displayed on. This means the compositor"]
            #[doc = "can avoid scaling when rendering the surface on that output."]
            #[doc = ""]
            #[doc = "Note that if the scale is larger than 1, then you have to attach"]
            #[doc = "a buffer that is larger (by a factor of scale in each dimension)"]
            #[doc = "than the desired surface size."]
            #[doc = ""]
            #[doc = "If scale is not greater than 0 the invalid_scale protocol error is"]
            #[doc = "raised."]
            async fn set_buffer_scale(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                scale: i32,
            ) -> crate::server::Result<()>;
            #[doc = "This request is used to describe the regions where the pending"]
            #[doc = "buffer is different from the current surface contents, and where"]
            #[doc = "the surface therefore needs to be repainted. The compositor"]
            #[doc = "ignores the parts of the damage that fall outside of the surface."]
            #[doc = ""]
            #[doc = "Damage is double-buffered state, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "The damage rectangle is specified in buffer coordinates,"]
            #[doc = "where x and y specify the upper left corner of the damage rectangle."]
            #[doc = ""]
            #[doc = "The initial value for pending damage is empty: no damage."]
            #[doc = "wl_surface.damage_buffer adds pending damage: the new pending"]
            #[doc = "damage is the union of old pending damage and the given rectangle."]
            #[doc = ""]
            #[doc = "wl_surface.commit assigns pending damage as the current damage,"]
            #[doc = "and clears pending damage. The server will clear the current"]
            #[doc = "damage as it repaints the surface."]
            #[doc = ""]
            #[doc = "This request differs from wl_surface.damage in only one way - it"]
            #[doc = "takes damage in buffer coordinates instead of surface-local"]
            #[doc = "coordinates. While this generally is more intuitive than surface"]
            #[doc = "coordinates, it is especially desirable when using wp_viewport"]
            #[doc = "or when a drawing library (like EGL) is unaware of buffer scale"]
            #[doc = "and buffer transform."]
            #[doc = ""]
            #[doc = "Note: Because buffer transformation changes and damage requests may"]
            #[doc = "be interleaved in the protocol stream, it is impossible to determine"]
            #[doc = "the actual mapping between surface and buffer damage until"]
            #[doc = "wl_surface.commit time. Therefore, compositors wishing to take both"]
            #[doc = "kinds of damage into account will have to accumulate damage from the"]
            #[doc = "two requests separately and only transform from one to the other"]
            #[doc = "after receiving the wl_surface.commit."]
            async fn damage_buffer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "The x and y arguments specify the location of the new pending"]
            #[doc = "buffer's upper left corner, relative to the current buffer's upper"]
            #[doc = "left corner, in surface-local coordinates. In other words, the"]
            #[doc = "x and y, combined with the new surface size define in which"]
            #[doc = "directions the surface's size changes."]
            #[doc = ""]
            #[doc = "Surface location offset is double-buffered state, see"]
            #[doc = "wl_surface.commit."]
            #[doc = ""]
            #[doc = "This request is semantically equivalent to and the replaces the x and y"]
            #[doc = "arguments in the wl_surface.attach request in wl_surface versions prior"]
            #[doc = "to 5. See wl_surface.attach for details."]
            async fn offset(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "This is emitted whenever a surface's creation, movement, or resizing"]
            #[doc = "results in some part of it being within the scanout region of an"]
            #[doc = "output."]
            #[doc = ""]
            #[doc = "Note that a surface may be overlapping with zero or more outputs."]
            async fn enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_surface#{}.enter()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(output))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This is emitted whenever a surface's creation, movement, or resizing"]
            #[doc = "results in it no longer having any part of it within the scanout region"]
            #[doc = "of an output."]
            #[doc = ""]
            #[doc = "Clients should not use the number of outputs the surface is on for frame"]
            #[doc = "throttling purposes. The surface might be hidden even if no leave event"]
            #[doc = "has been sent, and the compositor might expect new surface content"]
            #[doc = "updates even if no enter event has been sent. The frame event should be"]
            #[doc = "used instead."]
            async fn leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_surface#{}.leave()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(output))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates the preferred buffer scale for this surface. It is"]
            #[doc = "sent whenever the compositor's preference changes."]
            #[doc = ""]
            #[doc = "Before receiving this event the preferred buffer scale for this surface"]
            #[doc = "is 1."]
            #[doc = ""]
            #[doc = "It is intended that scaling aware clients use this event to scale their"]
            #[doc = "content and use wl_surface.set_buffer_scale to indicate the scale they"]
            #[doc = "have rendered with. This allows clients to supply a higher detail"]
            #[doc = "buffer."]
            #[doc = ""]
            #[doc = "The compositor shall emit a scale value greater than 0."]
            async fn preferred_buffer_scale(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                factor: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_surface#{}.preferred_buffer_scale()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(factor).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates the preferred buffer transform for this surface."]
            #[doc = "It is sent whenever the compositor's preference changes."]
            #[doc = ""]
            #[doc = "Before receiving this event the preferred buffer transform for this"]
            #[doc = "surface is normal."]
            #[doc = ""]
            #[doc = "Applying this transformation to the surface buffer contents and using"]
            #[doc = "wl_surface.set_buffer_transform might allow the compositor to use the"]
            #[doc = "surface buffer more efficiently."]
            async fn preferred_buffer_transform(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                transform: super::super::wayland::wl_output::Transform,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_surface#{}.preferred_buffer_transform()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(transform as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A seat is a group of keyboards, pointer and touch devices. This"]
    #[doc = "object is published as a global during start up, or when such a"]
    #[doc = "device is hot plugged.  A seat typically has a pointer and"]
    #[doc = "maintains a keyboard focus and a pointer focus."]
    pub mod wl_seat {
        bitflags::bitflags! { # [doc = "This is a bitmask of capabilities this seat has; if a member is"] # [doc = "set, then it is present on the seat."] # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Capability : u32 { # [doc = "the seat has pointer devices"] const Pointer = 1u32 ; # [doc = "the seat has one or more keyboards"] const Keyboard = 2u32 ; # [doc = "the seat has touch devices"] const Touch = 4u32 ; } }
        impl TryFrom<u32> for Capability {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "These errors can be emitted in response to wl_seat requests."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "get_pointer, get_keyboard or get_touch called on seat without the matching capability"]
            MissingCapability = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::MissingCapability),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wl_seat interface. See the module level documentation for more info"]
        pub trait WlSeat: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_seat";
            const VERSION: u32 = 9u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_seat#{}.get_pointer()", object.id);
                        self.get_pointer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("wl_seat#{}.get_keyboard()", object.id);
                        self.get_keyboard(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("wl_seat#{}.get_touch()", object.id);
                        self.get_touch(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("wl_seat#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "The ID provided will be initialized to the wl_pointer interface"]
            #[doc = "for this seat."]
            #[doc = ""]
            #[doc = "This request only takes effect if the seat has the pointer"]
            #[doc = "capability, or has had the pointer capability in the past."]
            #[doc = "It is a protocol violation to issue this request on a seat that has"]
            #[doc = "never had the pointer capability. The missing_capability error will"]
            #[doc = "be sent in this case."]
            async fn get_pointer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "The ID provided will be initialized to the wl_keyboard interface"]
            #[doc = "for this seat."]
            #[doc = ""]
            #[doc = "This request only takes effect if the seat has the keyboard"]
            #[doc = "capability, or has had the keyboard capability in the past."]
            #[doc = "It is a protocol violation to issue this request on a seat that has"]
            #[doc = "never had the keyboard capability. The missing_capability error will"]
            #[doc = "be sent in this case."]
            async fn get_keyboard(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "The ID provided will be initialized to the wl_touch interface"]
            #[doc = "for this seat."]
            #[doc = ""]
            #[doc = "This request only takes effect if the seat has the touch"]
            #[doc = "capability, or has had the touch capability in the past."]
            #[doc = "It is a protocol violation to issue this request on a seat that has"]
            #[doc = "never had the touch capability. The missing_capability error will"]
            #[doc = "be sent in this case."]
            async fn get_touch(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Using this request a client can tell the server that it is not going to"]
            #[doc = "use the seat object anymore."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This is emitted whenever a seat gains or loses the pointer,"]
            #[doc = "keyboard or touch capabilities.  The argument is a capability"]
            #[doc = "enum containing the complete set of capabilities this seat has."]
            #[doc = ""]
            #[doc = "When the pointer capability is added, a client may create a"]
            #[doc = "wl_pointer object using the wl_seat.get_pointer request. This object"]
            #[doc = "will receive pointer events until the capability is removed in the"]
            #[doc = "future."]
            #[doc = ""]
            #[doc = "When the pointer capability is removed, a client should destroy the"]
            #[doc = "wl_pointer objects associated with the seat where the capability was"]
            #[doc = "removed, using the wl_pointer.release request. No further pointer"]
            #[doc = "events will be received on these objects."]
            #[doc = ""]
            #[doc = "In some compositors, if a seat regains the pointer capability and a"]
            #[doc = "client has a previously obtained wl_pointer object of version 4 or"]
            #[doc = "less, that object may start sending pointer events again. This"]
            #[doc = "behavior is considered a misinterpretation of the intended behavior"]
            #[doc = "and must not be relied upon by the client. wl_pointer objects of"]
            #[doc = "version 5 or later must not send events if created before the most"]
            #[doc = "recent event notifying the client of an added pointer capability."]
            #[doc = ""]
            #[doc = "The above behavior also applies to wl_keyboard and wl_touch with the"]
            #[doc = "keyboard and touch capabilities, respectively."]
            async fn capabilities(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                capabilities: Capability,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_seat#{}.capabilities()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(capabilities.bits())
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "In a multi-seat configuration the seat name can be used by clients to"]
            #[doc = "help identify which physical devices the seat represents."]
            #[doc = ""]
            #[doc = "The seat name is a UTF-8 string with no convention defined for its"]
            #[doc = "contents. Each name is unique among all wl_seat globals. The name is"]
            #[doc = "only guaranteed to be unique for the current compositor instance."]
            #[doc = ""]
            #[doc = "The same seat names are used for all clients. Thus, the name can be"]
            #[doc = "shared across processes to refer to a specific wl_seat global."]
            #[doc = ""]
            #[doc = "The name event is sent after binding to the seat global. This event is"]
            #[doc = "only sent once per seat object, and the name does not change over the"]
            #[doc = "lifetime of the wl_seat global."]
            #[doc = ""]
            #[doc = "Compositors may re-use the same seat name if the wl_seat global is"]
            #[doc = "destroyed and re-created later."]
            async fn name(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_seat#{}.name()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(name))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "The wl_pointer interface represents one or more input devices,"]
    #[doc = "such as mice, which control the pointer location and pointer_focus"]
    #[doc = "of a seat."]
    #[doc = ""]
    #[doc = "The wl_pointer interface generates motion, enter and leave"]
    #[doc = "events for the surfaces that the pointer is located over,"]
    #[doc = "and button and axis events for button presses, button releases"]
    #[doc = "and scrolling."]
    pub mod wl_pointer {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "given wl_surface has another role"]
            Role = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Role),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Describes the physical state of a button that produced the button"]
        #[doc = "event."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ButtonState {
            #[doc = "the button is not pressed"]
            Released = 0u32,
            #[doc = "the button is pressed"]
            Pressed = 1u32,
        }
        impl TryFrom<u32> for ButtonState {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Released),
                    1u32 => Ok(Self::Pressed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Describes the axis types of scroll events."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Axis {
            #[doc = "vertical axis"]
            VerticalScroll = 0u32,
            #[doc = "horizontal axis"]
            HorizontalScroll = 1u32,
        }
        impl TryFrom<u32> for Axis {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::VerticalScroll),
                    1u32 => Ok(Self::HorizontalScroll),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Describes the source types for axis events. This indicates to the"]
        #[doc = "client how an axis event was physically generated; a client may"]
        #[doc = "adjust the user interface accordingly. For example, scroll events"]
        #[doc = "from a \"finger\" source may be in a smooth coordinate space with"]
        #[doc = "kinetic scrolling whereas a \"wheel\" source may be in discrete steps"]
        #[doc = "of a number of lines."]
        #[doc = ""]
        #[doc = "The \"continuous\" axis source is a device generating events in a"]
        #[doc = "continuous coordinate space, but using something other than a"]
        #[doc = "finger. One example for this source is button-based scrolling where"]
        #[doc = "the vertical motion of a device is converted to scroll events while"]
        #[doc = "a button is held down."]
        #[doc = ""]
        #[doc = "The \"wheel tilt\" axis source indicates that the actual device is a"]
        #[doc = "wheel but the scroll event is not caused by a rotation but a"]
        #[doc = "(usually sideways) tilt of the wheel."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum AxisSource {
            #[doc = "a physical wheel rotation"]
            Wheel = 0u32,
            #[doc = "finger on a touch surface"]
            Finger = 1u32,
            #[doc = "continuous coordinate space"]
            Continuous = 2u32,
            #[doc = "a physical wheel tilt"]
            WheelTilt = 3u32,
        }
        impl TryFrom<u32> for AxisSource {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Wheel),
                    1u32 => Ok(Self::Finger),
                    2u32 => Ok(Self::Continuous),
                    3u32 => Ok(Self::WheelTilt),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This specifies the direction of the physical motion that caused a"]
        #[doc = "wl_pointer.axis event, relative to the wl_pointer.axis direction."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum AxisRelativeDirection {
            #[doc = "physical motion matches axis direction"]
            Identical = 0u32,
            #[doc = "physical motion is the inverse of the axis direction"]
            Inverted = 1u32,
        }
        impl TryFrom<u32> for AxisRelativeDirection {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Identical),
                    1u32 => Ok(Self::Inverted),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wl_pointer interface. See the module level documentation for more info"]
        pub trait WlPointer: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_pointer";
            const VERSION: u32 = 9u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_pointer#{}.set_cursor()", object.id);
                        self.set_cursor(
                            object,
                            client,
                            message.uint()?,
                            message.object()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("wl_pointer#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Set the pointer surface, i.e., the surface that contains the"]
            #[doc = "pointer image (cursor). This request gives the surface the role"]
            #[doc = "of a cursor. If the surface already has another role, it raises"]
            #[doc = "a protocol error."]
            #[doc = ""]
            #[doc = "The cursor actually changes only if the pointer"]
            #[doc = "focus for this device is one of the requesting client's surfaces"]
            #[doc = "or the surface parameter is the current pointer surface. If"]
            #[doc = "there was a previous surface set with this request it is"]
            #[doc = "replaced. If surface is NULL, the pointer image is hidden."]
            #[doc = ""]
            #[doc = "The parameters hotspot_x and hotspot_y define the position of"]
            #[doc = "the pointer surface relative to the pointer location. Its"]
            #[doc = "top-left corner is always at (x, y) - (hotspot_x, hotspot_y),"]
            #[doc = "where (x, y) are the coordinates of the pointer location, in"]
            #[doc = "surface-local coordinates."]
            #[doc = ""]
            #[doc = "On wl_surface.offset requests to the pointer surface, hotspot_x"]
            #[doc = "and hotspot_y are decremented by the x and y parameters"]
            #[doc = "passed to the request. The offset must be applied by"]
            #[doc = "wl_surface.commit as usual."]
            #[doc = ""]
            #[doc = "The hotspot can also be updated by passing the currently set"]
            #[doc = "pointer surface to this request with new values for hotspot_x"]
            #[doc = "and hotspot_y."]
            #[doc = ""]
            #[doc = "The input region is ignored for wl_surfaces with the role of"]
            #[doc = "a cursor. When the use as a cursor ends, the wl_surface is"]
            #[doc = "unmapped."]
            #[doc = ""]
            #[doc = "The serial parameter must match the latest wl_pointer.enter"]
            #[doc = "serial number sent to the client. Otherwise the request will be"]
            #[doc = "ignored."]
            async fn set_cursor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: Option<crate::wire::ObjectId>,
                hotspot_x: i32,
                hotspot_y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Using this request a client can tell the server that it is not going to"]
            #[doc = "use the pointer object anymore."]
            #[doc = ""]
            #[doc = "This request destroys the pointer proxy object, so clients must not call"]
            #[doc = "wl_pointer_destroy() after using this request."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Notification that this seat's pointer is focused on a certain"]
            #[doc = "surface."]
            #[doc = ""]
            #[doc = "When a seat's focus enters a surface, the pointer image"]
            #[doc = "is undefined and a client should respond to this event by setting"]
            #[doc = "an appropriate pointer image with the set_cursor request."]
            async fn enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: crate::wire::ObjectId,
                surface_x: crate::wire::Fixed,
                surface_y: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_pointer#{}.enter()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(surface))
                    .put_fixed(surface_x)
                    .put_fixed(surface_y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notification that this seat's pointer is no longer focused on"]
            #[doc = "a certain surface."]
            #[doc = ""]
            #[doc = "The leave notification is sent before the enter notification"]
            #[doc = "for the new focus."]
            async fn leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_pointer#{}.leave()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notification of pointer location change. The arguments"]
            #[doc = "surface_x and surface_y are the location relative to the"]
            #[doc = "focused surface."]
            async fn motion(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                surface_x: crate::wire::Fixed,
                surface_y: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_pointer#{}.motion()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_fixed(surface_x)
                    .put_fixed(surface_y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Mouse button click and release notifications."]
            #[doc = ""]
            #[doc = "The location of the click is given by the last motion or"]
            #[doc = "enter event."]
            #[doc = "The time argument is a timestamp with millisecond"]
            #[doc = "granularity, with an undefined base."]
            #[doc = ""]
            #[doc = "The button is a button code as defined in the Linux kernel's"]
            #[doc = "linux/input-event-codes.h header file, e.g. BTN_LEFT."]
            #[doc = ""]
            #[doc = "Any 16-bit button code value is reserved for future additions to the"]
            #[doc = "kernel's event code list. All other button codes above 0xFFFF are"]
            #[doc = "currently undefined but may be used in future versions of this"]
            #[doc = "protocol."]
            async fn button(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                button: u32,
                state: ButtonState,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_pointer#{}.button()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(time)
                    .put_uint(button)
                    .put_uint(state as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Scroll and other axis notifications."]
            #[doc = ""]
            #[doc = "For scroll events (vertical and horizontal scroll axes), the"]
            #[doc = "value parameter is the length of a vector along the specified"]
            #[doc = "axis in a coordinate space identical to those of motion events,"]
            #[doc = "representing a relative movement along the specified axis."]
            #[doc = ""]
            #[doc = "For devices that support movements non-parallel to axes multiple"]
            #[doc = "axis events will be emitted."]
            #[doc = ""]
            #[doc = "When applicable, for example for touch pads, the server can"]
            #[doc = "choose to emit scroll events where the motion vector is"]
            #[doc = "equivalent to a motion event vector."]
            #[doc = ""]
            #[doc = "When applicable, a client can transform its content relative to the"]
            #[doc = "scroll distance."]
            async fn axis(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                axis: Axis,
                value: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_pointer#{}.axis()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_uint(axis as u32)
                    .put_fixed(value)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Indicates the end of a set of events that logically belong together."]
            #[doc = "A client is expected to accumulate the data in all events within the"]
            #[doc = "frame before proceeding."]
            #[doc = ""]
            #[doc = "All wl_pointer events before a wl_pointer.frame event belong"]
            #[doc = "logically together. For example, in a diagonal scroll motion the"]
            #[doc = "compositor will send an optional wl_pointer.axis_source event, two"]
            #[doc = "wl_pointer.axis events (horizontal and vertical) and finally a"]
            #[doc = "wl_pointer.frame event. The client may use this information to"]
            #[doc = "calculate a diagonal vector for scrolling."]
            #[doc = ""]
            #[doc = "When multiple wl_pointer.axis events occur within the same frame,"]
            #[doc = "the motion vector is the combined motion of all events."]
            #[doc = "When a wl_pointer.axis and a wl_pointer.axis_stop event occur within"]
            #[doc = "the same frame, this indicates that axis movement in one axis has"]
            #[doc = "stopped but continues in the other axis."]
            #[doc = "When multiple wl_pointer.axis_stop events occur within the same"]
            #[doc = "frame, this indicates that these axes stopped in the same instance."]
            #[doc = ""]
            #[doc = "A wl_pointer.frame event is sent for every logical event group,"]
            #[doc = "even if the group only contains a single wl_pointer event."]
            #[doc = "Specifically, a client may get a sequence: motion, frame, button,"]
            #[doc = "frame, axis, frame, axis_stop, frame."]
            #[doc = ""]
            #[doc = "The wl_pointer.enter and wl_pointer.leave events are logical events"]
            #[doc = "generated by the compositor and not the hardware. These events are"]
            #[doc = "also grouped by a wl_pointer.frame. When a pointer moves from one"]
            #[doc = "surface to another, a compositor should group the"]
            #[doc = "wl_pointer.leave event within the same wl_pointer.frame."]
            #[doc = "However, a client must not rely on wl_pointer.leave and"]
            #[doc = "wl_pointer.enter being in the same wl_pointer.frame."]
            #[doc = "Compositor-specific policies may require the wl_pointer.leave and"]
            #[doc = "wl_pointer.enter event being split across multiple wl_pointer.frame"]
            #[doc = "groups."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_pointer#{}.frame()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Source information for scroll and other axes."]
            #[doc = ""]
            #[doc = "This event does not occur on its own. It is sent before a"]
            #[doc = "wl_pointer.frame event and carries the source information for"]
            #[doc = "all events within that frame."]
            #[doc = ""]
            #[doc = "The source specifies how this event was generated. If the source is"]
            #[doc = "wl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be"]
            #[doc = "sent when the user lifts the finger off the device."]
            #[doc = ""]
            #[doc = "If the source is wl_pointer.axis_source.wheel,"]
            #[doc = "wl_pointer.axis_source.wheel_tilt or"]
            #[doc = "wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may"]
            #[doc = "or may not be sent. Whether a compositor sends an axis_stop event"]
            #[doc = "for these sources is hardware-specific and implementation-dependent;"]
            #[doc = "clients must not rely on receiving an axis_stop event for these"]
            #[doc = "scroll sources and should treat scroll sequences from these scroll"]
            #[doc = "sources as unterminated by default."]
            #[doc = ""]
            #[doc = "This event is optional. If the source is unknown for a particular"]
            #[doc = "axis event sequence, no event is sent."]
            #[doc = "Only one wl_pointer.axis_source event is permitted per frame."]
            #[doc = ""]
            #[doc = "The order of wl_pointer.axis_discrete and wl_pointer.axis_source is"]
            #[doc = "not guaranteed."]
            async fn axis_source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                axis_source: AxisSource,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_pointer#{}.axis_source()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(axis_source as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 6u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Stop notification for scroll and other axes."]
            #[doc = ""]
            #[doc = "For some wl_pointer.axis_source types, a wl_pointer.axis_stop event"]
            #[doc = "is sent to notify a client that the axis sequence has terminated."]
            #[doc = "This enables the client to implement kinetic scrolling."]
            #[doc = "See the wl_pointer.axis_source documentation for information on when"]
            #[doc = "this event may be generated."]
            #[doc = ""]
            #[doc = "Any wl_pointer.axis events with the same axis_source after this"]
            #[doc = "event should be considered as the start of a new axis motion."]
            #[doc = ""]
            #[doc = "The timestamp is to be interpreted identical to the timestamp in the"]
            #[doc = "wl_pointer.axis event. The timestamp value may be the same as a"]
            #[doc = "preceding wl_pointer.axis event."]
            async fn axis_stop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                axis: Axis,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_pointer#{}.axis_stop()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_uint(axis as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 7u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Discrete step information for scroll and other axes."]
            #[doc = ""]
            #[doc = "This event carries the axis value of the wl_pointer.axis event in"]
            #[doc = "discrete steps (e.g. mouse wheel clicks)."]
            #[doc = ""]
            #[doc = "This event is deprecated with wl_pointer version 8 - this event is not"]
            #[doc = "sent to clients supporting version 8 or later."]
            #[doc = ""]
            #[doc = "This event does not occur on its own, it is coupled with a"]
            #[doc = "wl_pointer.axis event that represents this axis value on a"]
            #[doc = "continuous scale. The protocol guarantees that each axis_discrete"]
            #[doc = "event is always followed by exactly one axis event with the same"]
            #[doc = "axis number within the same wl_pointer.frame. Note that the protocol"]
            #[doc = "allows for other events to occur between the axis_discrete and"]
            #[doc = "its coupled axis event, including other axis_discrete or axis"]
            #[doc = "events. A wl_pointer.frame must not contain more than one axis_discrete"]
            #[doc = "event per axis type."]
            #[doc = ""]
            #[doc = "This event is optional; continuous scrolling devices"]
            #[doc = "like two-finger scrolling on touchpads do not have discrete"]
            #[doc = "steps and do not generate this event."]
            #[doc = ""]
            #[doc = "The discrete value carries the directional information. e.g. a value"]
            #[doc = "of -2 is two steps towards the negative direction of this axis."]
            #[doc = ""]
            #[doc = "The axis number is identical to the axis number in the associated"]
            #[doc = "axis event."]
            #[doc = ""]
            #[doc = "The order of wl_pointer.axis_discrete and wl_pointer.axis_source is"]
            #[doc = "not guaranteed."]
            async fn axis_discrete(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                axis: Axis,
                discrete: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_pointer#{}.axis_discrete()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(axis as u32)
                    .put_int(discrete)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 8u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Discrete high-resolution scroll information."]
            #[doc = ""]
            #[doc = "This event carries high-resolution wheel scroll information,"]
            #[doc = "with each multiple of 120 representing one logical scroll step"]
            #[doc = "(a wheel detent). For example, an axis_value120 of 30 is one quarter of"]
            #[doc = "a logical scroll step in the positive direction, a value120 of"]
            #[doc = "-240 are two logical scroll steps in the negative direction within the"]
            #[doc = "same hardware event."]
            #[doc = "Clients that rely on discrete scrolling should accumulate the"]
            #[doc = "value120 to multiples of 120 before processing the event."]
            #[doc = ""]
            #[doc = "The value120 must not be zero."]
            #[doc = ""]
            #[doc = "This event replaces the wl_pointer.axis_discrete event in clients"]
            #[doc = "supporting wl_pointer version 8 or later."]
            #[doc = ""]
            #[doc = "Where a wl_pointer.axis_source event occurs in the same"]
            #[doc = "wl_pointer.frame, the axis source applies to this event."]
            #[doc = ""]
            #[doc = "The order of wl_pointer.axis_value120 and wl_pointer.axis_source is"]
            #[doc = "not guaranteed."]
            async fn axis_value120(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                axis: Axis,
                value120: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_pointer#{}.axis_value120()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(axis as u32)
                    .put_int(value120)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 9u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Relative directional information of the entity causing the axis"]
            #[doc = "motion."]
            #[doc = ""]
            #[doc = "For a wl_pointer.axis event, the wl_pointer.axis_relative_direction"]
            #[doc = "event specifies the movement direction of the entity causing the"]
            #[doc = "wl_pointer.axis event. For example:"]
            #[doc = "- if a user's fingers on a touchpad move down and this"]
            #[doc = "causes a wl_pointer.axis vertical_scroll down event, the physical"]
            #[doc = "direction is 'identical'"]
            #[doc = "- if a user's fingers on a touchpad move down and this causes a"]
            #[doc = "wl_pointer.axis vertical_scroll up scroll up event ('natural"]
            #[doc = "scrolling'), the physical direction is 'inverted'."]
            #[doc = ""]
            #[doc = "A client may use this information to adjust scroll motion of"]
            #[doc = "components. Specifically, enabling natural scrolling causes the"]
            #[doc = "content to change direction compared to traditional scrolling."]
            #[doc = "Some widgets like volume control sliders should usually match the"]
            #[doc = "physical direction regardless of whether natural scrolling is"]
            #[doc = "active. This event enables clients to match the scroll direction of"]
            #[doc = "a widget to the physical direction."]
            #[doc = ""]
            #[doc = "This event does not occur on its own, it is coupled with a"]
            #[doc = "wl_pointer.axis event that represents this axis value."]
            #[doc = "The protocol guarantees that each axis_relative_direction event is"]
            #[doc = "always followed by exactly one axis event with the same"]
            #[doc = "axis number within the same wl_pointer.frame. Note that the protocol"]
            #[doc = "allows for other events to occur between the axis_relative_direction"]
            #[doc = "and its coupled axis event."]
            #[doc = ""]
            #[doc = "The axis number is identical to the axis number in the associated"]
            #[doc = "axis event."]
            #[doc = ""]
            #[doc = "The order of wl_pointer.axis_relative_direction,"]
            #[doc = "wl_pointer.axis_discrete and wl_pointer.axis_source is not"]
            #[doc = "guaranteed."]
            async fn axis_relative_direction(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                axis: Axis,
                direction: AxisRelativeDirection,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_pointer#{}.axis_relative_direction()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(axis as u32)
                    .put_uint(direction as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 10u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "The wl_keyboard interface represents one or more keyboards"]
    #[doc = "associated with a seat."]
    #[doc = ""]
    #[doc = "Each wl_keyboard has the following logical state:"]
    #[doc = ""]
    #[doc = "- an active surface (possibly null),"]
    #[doc = "- the keys currently logically down,"]
    #[doc = "- the active modifiers,"]
    #[doc = "- the active group."]
    #[doc = ""]
    #[doc = "By default, the active surface is null, the keys currently logically down"]
    #[doc = "are empty, the active modifiers and the active group are 0."]
    pub mod wl_keyboard {
        #[doc = "This specifies the format of the keymap provided to the"]
        #[doc = "client with the wl_keyboard.keymap event."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum KeymapFormat {
            #[doc = "no keymap; client must understand how to interpret the raw keycode"]
            NoKeymap = 0u32,
            #[doc = "libxkbcommon compatible, null-terminated string; to determine the xkb keycode, clients must add 8 to the key event keycode"]
            XkbV1 = 1u32,
        }
        impl TryFrom<u32> for KeymapFormat {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::NoKeymap),
                    1u32 => Ok(Self::XkbV1),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Describes the physical state of a key that produced the key event."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum KeyState {
            #[doc = "key is not pressed"]
            Released = 0u32,
            #[doc = "key is pressed"]
            Pressed = 1u32,
        }
        impl TryFrom<u32> for KeyState {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Released),
                    1u32 => Ok(Self::Pressed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wl_keyboard interface. See the module level documentation for more info"]
        pub trait WlKeyboard: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_keyboard";
            const VERSION: u32 = 9u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_keyboard#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event provides a file descriptor to the client which can be"]
            #[doc = "memory-mapped in read-only mode to provide a keyboard mapping"]
            #[doc = "description."]
            #[doc = ""]
            #[doc = "From version 7 onwards, the fd must be mapped with MAP_PRIVATE by"]
            #[doc = "the recipient, as MAP_SHARED may fail."]
            async fn keymap(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                format: KeymapFormat,
                fd: rustix::fd::OwnedFd,
                size: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_keyboard#{}.keymap()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(format as u32)
                    .put_fd(fd)
                    .put_uint(size)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notification that this seat's keyboard focus is on a certain"]
            #[doc = "surface."]
            #[doc = ""]
            #[doc = "The compositor must send the wl_keyboard.modifiers event after this"]
            #[doc = "event."]
            #[doc = ""]
            #[doc = "In the wl_keyboard logical state, this event sets the active surface to"]
            #[doc = "the surface argument and the keys currently logically down to the keys"]
            #[doc = "in the keys argument. The compositor must not send this event if the"]
            #[doc = "wl_keyboard already had an active surface immediately before this event."]
            async fn enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: crate::wire::ObjectId,
                keys: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_keyboard#{}.enter()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(surface))
                    .put_array(keys)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notification that this seat's keyboard focus is no longer on"]
            #[doc = "a certain surface."]
            #[doc = ""]
            #[doc = "The leave notification is sent before the enter notification"]
            #[doc = "for the new focus."]
            #[doc = ""]
            #[doc = "In the wl_keyboard logical state, this event resets all values to their"]
            #[doc = "defaults. The compositor must not send this event if the active surface"]
            #[doc = "of the wl_keyboard was not equal to the surface argument immediately"]
            #[doc = "before this event."]
            async fn leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_keyboard#{}.leave()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "A key was pressed or released."]
            #[doc = "The time argument is a timestamp with millisecond"]
            #[doc = "granularity, with an undefined base."]
            #[doc = ""]
            #[doc = "The key is a platform-specific key code that can be interpreted"]
            #[doc = "by feeding it to the keyboard mapping (see the keymap event)."]
            #[doc = ""]
            #[doc = "If this event produces a change in modifiers, then the resulting"]
            #[doc = "wl_keyboard.modifiers event must be sent after this event."]
            #[doc = ""]
            #[doc = "In the wl_keyboard logical state, this event adds the key to the keys"]
            #[doc = "currently logically down (if the state argument is pressed) or removes"]
            #[doc = "the key from the keys currently logically down (if the state argument is"]
            #[doc = "released). The compositor must not send this event if the wl_keyboard"]
            #[doc = "did not have an active surface immediately before this event. The"]
            #[doc = "compositor must not send this event if state is pressed (resp. released)"]
            #[doc = "and the key was already logically down (resp. was not logically down)"]
            #[doc = "immediately before this event."]
            async fn key(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                key: u32,
                state: KeyState,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_keyboard#{}.key()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(time)
                    .put_uint(key)
                    .put_uint(state as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notifies clients that the modifier and/or group state has"]
            #[doc = "changed, and it should update its local state."]
            #[doc = ""]
            #[doc = "The compositor may send this event without a surface of the client"]
            #[doc = "having keyboard focus, for example to tie modifier information to"]
            #[doc = "pointer focus instead. If a modifier event with pressed modifiers is sent"]
            #[doc = "without a prior enter event, the client can assume the modifier state is"]
            #[doc = "valid until it receives the next wl_keyboard.modifiers event. In order to"]
            #[doc = "reset the modifier state again, the compositor can send a"]
            #[doc = "wl_keyboard.modifiers event with no pressed modifiers."]
            #[doc = ""]
            #[doc = "In the wl_keyboard logical state, this event updates the modifiers and"]
            #[doc = "group."]
            async fn modifiers(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                mods_depressed: u32,
                mods_latched: u32,
                mods_locked: u32,
                group: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_keyboard#{}.modifiers()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(mods_depressed)
                    .put_uint(mods_latched)
                    .put_uint(mods_locked)
                    .put_uint(group)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Informs the client about the keyboard's repeat rate and delay."]
            #[doc = ""]
            #[doc = "This event is sent as soon as the wl_keyboard object has been created,"]
            #[doc = "and is guaranteed to be received by the client before any key press"]
            #[doc = "event."]
            #[doc = ""]
            #[doc = "Negative values for either rate or delay are illegal. A rate of zero"]
            #[doc = "will disable any repeating (regardless of the value of delay)."]
            #[doc = ""]
            #[doc = "This event can be sent later on as well with a new value if necessary,"]
            #[doc = "so clients should continue listening for the event past the creation"]
            #[doc = "of wl_keyboard."]
            async fn repeat_info(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                rate: i32,
                delay: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_keyboard#{}.repeat_info()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(rate)
                    .put_int(delay)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "The wl_touch interface represents a touchscreen"]
    #[doc = "associated with a seat."]
    #[doc = ""]
    #[doc = "Touch interactions can consist of one or more contacts."]
    #[doc = "For each contact, a series of events is generated, starting"]
    #[doc = "with a down event, followed by zero or more motion events,"]
    #[doc = "and ending with an up event. Events relating to the same"]
    #[doc = "contact point can be identified by the ID of the sequence."]
    pub mod wl_touch {
        #[doc = "Trait to implement the wl_touch interface. See the module level documentation for more info"]
        pub trait WlTouch: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_touch";
            const VERSION: u32 = 9u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_touch#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "A new touch point has appeared on the surface. This touch point is"]
            #[doc = "assigned a unique ID. Future events from this touch point reference"]
            #[doc = "this ID. The ID ceases to be valid after a touch up event and may be"]
            #[doc = "reused in the future."]
            async fn down(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                surface: crate::wire::ObjectId,
                id: i32,
                x: crate::wire::Fixed,
                y: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_touch#{}.down()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(time)
                    .put_object(Some(surface))
                    .put_int(id)
                    .put_fixed(x)
                    .put_fixed(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The touch point has disappeared. No further events will be sent for"]
            #[doc = "this touch point and the touch point's ID is released and may be"]
            #[doc = "reused in a future touch down event."]
            async fn up(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                id: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_touch#{}.up()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(time)
                    .put_int(id)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "A touch point has changed coordinates."]
            async fn motion(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                id: i32,
                x: crate::wire::Fixed,
                y: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_touch#{}.motion()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_int(id)
                    .put_fixed(x)
                    .put_fixed(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Indicates the end of a set of events that logically belong together."]
            #[doc = "A client is expected to accumulate the data in all events within the"]
            #[doc = "frame before proceeding."]
            #[doc = ""]
            #[doc = "A wl_touch.frame terminates at least one event but otherwise no"]
            #[doc = "guarantee is provided about the set of events within a frame. A client"]
            #[doc = "must assume that any state not updated in a frame is unchanged from the"]
            #[doc = "previously known state."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_touch#{}.frame()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent if the compositor decides the touch stream is a global"]
            #[doc = "gesture. No further events are sent to the clients from that"]
            #[doc = "particular gesture. Touch cancellation applies to all touch points"]
            #[doc = "currently active on this client's surface. The client is"]
            #[doc = "responsible for finalizing the touch points, future touch points on"]
            #[doc = "this surface may reuse the touch point ID."]
            #[doc = ""]
            #[doc = "No frame event is required after the cancel event."]
            async fn cancel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_touch#{}.cancel()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent when a touchpoint has changed its shape."]
            #[doc = ""]
            #[doc = "This event does not occur on its own. It is sent before a"]
            #[doc = "wl_touch.frame event and carries the new shape information for"]
            #[doc = "any previously reported, or new touch points of that frame."]
            #[doc = ""]
            #[doc = "Other events describing the touch point such as wl_touch.down,"]
            #[doc = "wl_touch.motion or wl_touch.orientation may be sent within the"]
            #[doc = "same wl_touch.frame. A client should treat these events as a single"]
            #[doc = "logical touch point update. The order of wl_touch.shape,"]
            #[doc = "wl_touch.orientation and wl_touch.motion is not guaranteed."]
            #[doc = "A wl_touch.down event is guaranteed to occur before the first"]
            #[doc = "wl_touch.shape event for this touch ID but both events may occur within"]
            #[doc = "the same wl_touch.frame."]
            #[doc = ""]
            #[doc = "A touchpoint shape is approximated by an ellipse through the major and"]
            #[doc = "minor axis length. The major axis length describes the longer diameter"]
            #[doc = "of the ellipse, while the minor axis length describes the shorter"]
            #[doc = "diameter. Major and minor are orthogonal and both are specified in"]
            #[doc = "surface-local coordinates. The center of the ellipse is always at the"]
            #[doc = "touchpoint location as reported by wl_touch.down or wl_touch.move."]
            #[doc = ""]
            #[doc = "This event is only sent by the compositor if the touch device supports"]
            #[doc = "shape reports. The client has to make reasonable assumptions about the"]
            #[doc = "shape if it did not receive this event."]
            async fn shape(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: i32,
                major: crate::wire::Fixed,
                minor: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_touch#{}.shape()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(id)
                    .put_fixed(major)
                    .put_fixed(minor)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent when a touchpoint has changed its orientation."]
            #[doc = ""]
            #[doc = "This event does not occur on its own. It is sent before a"]
            #[doc = "wl_touch.frame event and carries the new shape information for"]
            #[doc = "any previously reported, or new touch points of that frame."]
            #[doc = ""]
            #[doc = "Other events describing the touch point such as wl_touch.down,"]
            #[doc = "wl_touch.motion or wl_touch.shape may be sent within the"]
            #[doc = "same wl_touch.frame. A client should treat these events as a single"]
            #[doc = "logical touch point update. The order of wl_touch.shape,"]
            #[doc = "wl_touch.orientation and wl_touch.motion is not guaranteed."]
            #[doc = "A wl_touch.down event is guaranteed to occur before the first"]
            #[doc = "wl_touch.orientation event for this touch ID but both events may occur"]
            #[doc = "within the same wl_touch.frame."]
            #[doc = ""]
            #[doc = "The orientation describes the clockwise angle of a touchpoint's major"]
            #[doc = "axis to the positive surface y-axis and is normalized to the -180 to"]
            #[doc = "+180 degree range. The granularity of orientation depends on the touch"]
            #[doc = "device, some devices only support binary rotation values between 0 and"]
            #[doc = "90 degrees."]
            #[doc = ""]
            #[doc = "This event is only sent by the compositor if the touch device supports"]
            #[doc = "orientation reports."]
            async fn orientation(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: i32,
                orientation: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_touch#{}.orientation()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(id)
                    .put_fixed(orientation)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 6u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "An output describes part of the compositor geometry.  The"]
    #[doc = "compositor works in the 'compositor coordinate system' and an"]
    #[doc = "output corresponds to a rectangular area in that space that is"]
    #[doc = "actually visible.  This typically corresponds to a monitor that"]
    #[doc = "displays part of the compositor space.  This object is published"]
    #[doc = "as global during start up, or when a monitor is hotplugged."]
    pub mod wl_output {
        #[doc = "This enumeration describes how the physical"]
        #[doc = "pixels on an output are laid out."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Subpixel {
            #[doc = "unknown geometry"]
            Unknown = 0u32,
            #[doc = "no geometry"]
            None = 1u32,
            #[doc = "horizontal RGB"]
            HorizontalRgb = 2u32,
            #[doc = "horizontal BGR"]
            HorizontalBgr = 3u32,
            #[doc = "vertical RGB"]
            VerticalRgb = 4u32,
            #[doc = "vertical BGR"]
            VerticalBgr = 5u32,
        }
        impl TryFrom<u32> for Subpixel {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Unknown),
                    1u32 => Ok(Self::None),
                    2u32 => Ok(Self::HorizontalRgb),
                    3u32 => Ok(Self::HorizontalBgr),
                    4u32 => Ok(Self::VerticalRgb),
                    5u32 => Ok(Self::VerticalBgr),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This describes transformations that clients and compositors apply to"]
        #[doc = "buffer contents."]
        #[doc = ""]
        #[doc = "The flipped values correspond to an initial flip around a"]
        #[doc = "vertical axis followed by rotation."]
        #[doc = ""]
        #[doc = "The purpose is mainly to allow clients to render accordingly and"]
        #[doc = "tell the compositor, so that for fullscreen surfaces, the"]
        #[doc = "compositor will still be able to scan out directly from client"]
        #[doc = "surfaces."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Transform {
            #[doc = "no transform"]
            Normal = 0u32,
            #[doc = "90 degrees counter-clockwise"]
            _90 = 1u32,
            #[doc = "180 degrees counter-clockwise"]
            _180 = 2u32,
            #[doc = "270 degrees counter-clockwise"]
            _270 = 3u32,
            #[doc = "180 degree flip around a vertical axis"]
            Flipped = 4u32,
            #[doc = "flip and rotate 90 degrees counter-clockwise"]
            Flipped90 = 5u32,
            #[doc = "flip and rotate 180 degrees counter-clockwise"]
            Flipped180 = 6u32,
            #[doc = "flip and rotate 270 degrees counter-clockwise"]
            Flipped270 = 7u32,
        }
        impl TryFrom<u32> for Transform {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Normal),
                    1u32 => Ok(Self::_90),
                    2u32 => Ok(Self::_180),
                    3u32 => Ok(Self::_270),
                    4u32 => Ok(Self::Flipped),
                    5u32 => Ok(Self::Flipped90),
                    6u32 => Ok(Self::Flipped180),
                    7u32 => Ok(Self::Flipped270),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! { # [doc = "These flags describe properties of an output mode."] # [doc = "They are used in the flags bitfield of the mode event."] # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Mode : u32 { # [doc = "indicates this is the current mode"] const Current = 1u32 ; # [doc = "indicates this is the preferred mode"] const Preferred = 2u32 ; } }
        impl TryFrom<u32> for Mode {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "Trait to implement the wl_output interface. See the module level documentation for more info"]
        pub trait WlOutput: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_output";
            const VERSION: u32 = 4u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_output#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Using this request a client can tell the server that it is not going to"]
            #[doc = "use the output object anymore."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The geometry event describes geometric properties of the output."]
            #[doc = "The event is sent when binding to the output object and whenever"]
            #[doc = "any of the properties change."]
            #[doc = ""]
            #[doc = "The physical size can be set to zero if it doesn't make sense for this"]
            #[doc = "output (e.g. for projectors or virtual outputs)."]
            #[doc = ""]
            #[doc = "The geometry event will be followed by a done event (starting from"]
            #[doc = "version 2)."]
            #[doc = ""]
            #[doc = "Clients should use wl_surface.preferred_buffer_transform instead of the"]
            #[doc = "transform advertised by this event to find the preferred buffer"]
            #[doc = "transform to use for a surface."]
            #[doc = ""]
            #[doc = "Note: wl_output only advertises partial information about the output"]
            #[doc = "position and identification. Some compositors, for instance those not"]
            #[doc = "implementing a desktop-style output layout or those exposing virtual"]
            #[doc = "outputs, might fake this information. Instead of using x and y, clients"]
            #[doc = "should use xdg_output.logical_position. Instead of using make and model,"]
            #[doc = "clients should use name and description."]
            async fn geometry(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                physical_width: i32,
                physical_height: i32,
                subpixel: Subpixel,
                make: String,
                model: String,
                transform: Transform,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_output#{}.geometry()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(x)
                    .put_int(y)
                    .put_int(physical_width)
                    .put_int(physical_height)
                    .put_uint(subpixel as u32)
                    .put_string(Some(make))
                    .put_string(Some(model))
                    .put_uint(transform as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The mode event describes an available mode for the output."]
            #[doc = ""]
            #[doc = "The event is sent when binding to the output object and there"]
            #[doc = "will always be one mode, the current mode.  The event is sent"]
            #[doc = "again if an output changes mode, for the mode that is now"]
            #[doc = "current.  In other words, the current mode is always the last"]
            #[doc = "mode that was received with the current flag set."]
            #[doc = ""]
            #[doc = "Non-current modes are deprecated. A compositor can decide to only"]
            #[doc = "advertise the current mode and never send other modes. Clients"]
            #[doc = "should not rely on non-current modes."]
            #[doc = ""]
            #[doc = "The size of a mode is given in physical hardware units of"]
            #[doc = "the output device. This is not necessarily the same as"]
            #[doc = "the output size in the global compositor space. For instance,"]
            #[doc = "the output may be scaled, as described in wl_output.scale,"]
            #[doc = "or transformed, as described in wl_output.transform. Clients"]
            #[doc = "willing to retrieve the output size in the global compositor"]
            #[doc = "space should use xdg_output.logical_size instead."]
            #[doc = ""]
            #[doc = "The vertical refresh rate can be set to zero if it doesn't make"]
            #[doc = "sense for this output (e.g. for virtual outputs)."]
            #[doc = ""]
            #[doc = "The mode event will be followed by a done event (starting from"]
            #[doc = "version 2)."]
            #[doc = ""]
            #[doc = "Clients should not use the refresh rate to schedule frames. Instead,"]
            #[doc = "they should use the wl_surface.frame event or the presentation-time"]
            #[doc = "protocol."]
            #[doc = ""]
            #[doc = "Note: this information is not always meaningful for all outputs. Some"]
            #[doc = "compositors, such as those exposing virtual outputs, might fake the"]
            #[doc = "refresh rate or the size."]
            async fn mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                flags: Mode,
                width: i32,
                height: i32,
                refresh: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_output#{}.mode()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(flags.bits())
                    .put_int(width)
                    .put_int(height)
                    .put_int(refresh)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent after all other properties have been"]
            #[doc = "sent after binding to the output object and after any"]
            #[doc = "other property changes done after that. This allows"]
            #[doc = "changes to the output properties to be seen as"]
            #[doc = "atomic, even if they happen via multiple events."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_output#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event contains scaling geometry information"]
            #[doc = "that is not in the geometry event. It may be sent after"]
            #[doc = "binding the output object or if the output scale changes"]
            #[doc = "later. The compositor will emit a non-zero, positive"]
            #[doc = "value for scale. If it is not sent, the client should"]
            #[doc = "assume a scale of 1."]
            #[doc = ""]
            #[doc = "A scale larger than 1 means that the compositor will"]
            #[doc = "automatically scale surface buffers by this amount"]
            #[doc = "when rendering. This is used for very high resolution"]
            #[doc = "displays where applications rendering at the native"]
            #[doc = "resolution would be too small to be legible."]
            #[doc = ""]
            #[doc = "Clients should use wl_surface.preferred_buffer_scale"]
            #[doc = "instead of this event to find the preferred buffer"]
            #[doc = "scale to use for a surface."]
            #[doc = ""]
            #[doc = "The scale event will be followed by a done event."]
            async fn scale(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                factor: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_output#{}.scale()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(factor).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Many compositors will assign user-friendly names to their outputs, show"]
            #[doc = "them to the user, allow the user to refer to an output, etc. The client"]
            #[doc = "may wish to know this name as well to offer the user similar behaviors."]
            #[doc = ""]
            #[doc = "The name is a UTF-8 string with no convention defined for its contents."]
            #[doc = "Each name is unique among all wl_output globals. The name is only"]
            #[doc = "guaranteed to be unique for the compositor instance."]
            #[doc = ""]
            #[doc = "The same output name is used for all clients for a given wl_output"]
            #[doc = "global. Thus, the name can be shared across processes to refer to a"]
            #[doc = "specific wl_output global."]
            #[doc = ""]
            #[doc = "The name is not guaranteed to be persistent across sessions, thus cannot"]
            #[doc = "be used to reliably identify an output in e.g. configuration files."]
            #[doc = ""]
            #[doc = "Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do"]
            #[doc = "not assume that the name is a reflection of an underlying DRM connector,"]
            #[doc = "X11 connection, etc."]
            #[doc = ""]
            #[doc = "The name event is sent after binding the output object. This event is"]
            #[doc = "only sent once per output object, and the name does not change over the"]
            #[doc = "lifetime of the wl_output global."]
            #[doc = ""]
            #[doc = "Compositors may re-use the same output name if the wl_output global is"]
            #[doc = "destroyed and re-created later. Compositors should avoid re-using the"]
            #[doc = "same name if possible."]
            #[doc = ""]
            #[doc = "The name event will be followed by a done event."]
            async fn name(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_output#{}.name()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(name))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Many compositors can produce human-readable descriptions of their"]
            #[doc = "outputs. The client may wish to know this description as well, e.g. for"]
            #[doc = "output selection purposes."]
            #[doc = ""]
            #[doc = "The description is a UTF-8 string with no convention defined for its"]
            #[doc = "contents. The description is not guaranteed to be unique among all"]
            #[doc = "wl_output globals. Examples might include 'Foocorp 11\" Display' or"]
            #[doc = "'Virtual X11 output via :1'."]
            #[doc = ""]
            #[doc = "The description event is sent after binding the output object and"]
            #[doc = "whenever the description changes. The description is optional, and may"]
            #[doc = "not be sent at all."]
            #[doc = ""]
            #[doc = "The description event will be followed by a done event."]
            async fn description(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                description: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_output#{}.description()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(description))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A region object describes an area."]
    #[doc = ""]
    #[doc = "Region objects are used to describe the opaque and input"]
    #[doc = "regions of a surface."]
    pub mod wl_region {
        #[doc = "Trait to implement the wl_region interface. See the module level documentation for more info"]
        pub trait WlRegion: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_region";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_region#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("wl_region#{}.add()", object.id);
                        self.add(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("wl_region#{}.subtract()", object.id);
                        self.subtract(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the region.  This will invalidate the object ID."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Add the specified rectangle to the region."]
            async fn add(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Subtract the specified rectangle from the region."]
            async fn subtract(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "The global interface exposing sub-surface compositing capabilities."]
    #[doc = "A wl_surface, that has sub-surfaces associated, is called the"]
    #[doc = "parent surface. Sub-surfaces can be arbitrarily nested and create"]
    #[doc = "a tree of sub-surfaces."]
    #[doc = ""]
    #[doc = "The root surface in a tree of sub-surfaces is the main"]
    #[doc = "surface. The main surface cannot be a sub-surface, because"]
    #[doc = "sub-surfaces must always have a parent."]
    #[doc = ""]
    #[doc = "A main surface with its sub-surfaces forms a (compound) window."]
    #[doc = "For window management purposes, this set of wl_surface objects is"]
    #[doc = "to be considered as a single window, and it should also behave as"]
    #[doc = "such."]
    #[doc = ""]
    #[doc = "The aim of sub-surfaces is to offload some of the compositing work"]
    #[doc = "within a window from clients to the compositor. A prime example is"]
    #[doc = "a video player with decorations and video in separate wl_surface"]
    #[doc = "objects. This should allow the compositor to pass YUV video buffer"]
    #[doc = "processing to dedicated overlay hardware when possible."]
    pub mod wl_subcompositor {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "the to-be sub-surface is invalid"]
            BadSurface = 0u32,
            #[doc = "the to-be sub-surface parent is invalid"]
            BadParent = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::BadSurface),
                    1u32 => Ok(Self::BadParent),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wl_subcompositor interface. See the module level documentation for more info"]
        pub trait WlSubcompositor: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_subcompositor";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_subcompositor#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("wl_subcompositor#{}.get_subsurface()", object.id);
                        self.get_subsurface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Informs the server that the client will not be using this"]
            #[doc = "protocol object anymore. This does not affect any other"]
            #[doc = "objects, wl_subsurface objects included."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a sub-surface interface for the given surface, and"]
            #[doc = "associate it with the given parent surface. This turns a"]
            #[doc = "plain wl_surface into a sub-surface."]
            #[doc = ""]
            #[doc = "The to-be sub-surface must not already have another role, and it"]
            #[doc = "must not have an existing wl_subsurface object. Otherwise the"]
            #[doc = "bad_surface protocol error is raised."]
            #[doc = ""]
            #[doc = "Adding sub-surfaces to a parent is a double-buffered operation on the"]
            #[doc = "parent (see wl_surface.commit). The effect of adding a sub-surface"]
            #[doc = "becomes visible on the next time the state of the parent surface is"]
            #[doc = "applied."]
            #[doc = ""]
            #[doc = "The parent surface must not be one of the child surface's descendants,"]
            #[doc = "and the parent must be different from the child surface, otherwise the"]
            #[doc = "bad_parent protocol error is raised."]
            #[doc = ""]
            #[doc = "This request modifies the behaviour of wl_surface.commit request on"]
            #[doc = "the sub-surface, see the documentation on wl_subsurface interface."]
            async fn get_subsurface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
                parent: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "An additional interface to a wl_surface object, which has been"]
    #[doc = "made a sub-surface. A sub-surface has one parent surface. A"]
    #[doc = "sub-surface's size and position are not limited to that of the parent."]
    #[doc = "Particularly, a sub-surface is not automatically clipped to its"]
    #[doc = "parent's area."]
    #[doc = ""]
    #[doc = "A sub-surface becomes mapped, when a non-NULL wl_buffer is applied"]
    #[doc = "and the parent surface is mapped. The order of which one happens"]
    #[doc = "first is irrelevant. A sub-surface is hidden if the parent becomes"]
    #[doc = "hidden, or if a NULL wl_buffer is applied. These rules apply"]
    #[doc = "recursively through the tree of surfaces."]
    #[doc = ""]
    #[doc = "The behaviour of a wl_surface.commit request on a sub-surface"]
    #[doc = "depends on the sub-surface's mode. The possible modes are"]
    #[doc = "synchronized and desynchronized, see methods"]
    #[doc = "wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized"]
    #[doc = "mode caches the wl_surface state to be applied when the parent's"]
    #[doc = "state gets applied, and desynchronized mode applies the pending"]
    #[doc = "wl_surface state directly. A sub-surface is initially in the"]
    #[doc = "synchronized mode."]
    #[doc = ""]
    #[doc = "Sub-surfaces also have another kind of state, which is managed by"]
    #[doc = "wl_subsurface requests, as opposed to wl_surface requests. This"]
    #[doc = "state includes the sub-surface position relative to the parent"]
    #[doc = "surface (wl_subsurface.set_position), and the stacking order of"]
    #[doc = "the parent and its sub-surfaces (wl_subsurface.place_above and"]
    #[doc = ".place_below). This state is applied when the parent surface's"]
    #[doc = "wl_surface state is applied, regardless of the sub-surface's mode."]
    #[doc = "As the exception, set_sync and set_desync are effective immediately."]
    #[doc = ""]
    #[doc = "The main surface can be thought to be always in desynchronized mode,"]
    #[doc = "since it does not have a parent in the sub-surfaces sense."]
    #[doc = ""]
    #[doc = "Even if a sub-surface is in desynchronized mode, it will behave as"]
    #[doc = "in synchronized mode, if its parent surface behaves as in"]
    #[doc = "synchronized mode. This rule is applied recursively throughout the"]
    #[doc = "tree of surfaces. This means, that one can set a sub-surface into"]
    #[doc = "synchronized mode, and then assume that all its child and grand-child"]
    #[doc = "sub-surfaces are synchronized, too, without explicitly setting them."]
    #[doc = ""]
    #[doc = "Destroying a sub-surface takes effect immediately. If you need to"]
    #[doc = "synchronize the removal of a sub-surface to the parent surface update,"]
    #[doc = "unmap the sub-surface first by attaching a NULL wl_buffer, update parent,"]
    #[doc = "and then destroy the sub-surface."]
    #[doc = ""]
    #[doc = "If the parent wl_surface object is destroyed, the sub-surface is"]
    #[doc = "unmapped."]
    #[doc = ""]
    #[doc = "A sub-surface never has the keyboard focus of any seat."]
    #[doc = ""]
    #[doc = "The wl_surface.offset request is ignored: clients must use set_position"]
    #[doc = "instead to move the sub-surface."]
    pub mod wl_subsurface {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "wl_surface is not a sibling or the parent"]
            BadSurface = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::BadSurface),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wl_subsurface interface. See the module level documentation for more info"]
        pub trait WlSubsurface: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_subsurface";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_subsurface#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("wl_subsurface#{}.set_position()", object.id);
                        self.set_position(object, client, message.int()?, message.int()?)
                            .await
                    }
                    2u16 => {
                        tracing::debug!("wl_subsurface#{}.place_above()", object.id);
                        self.place_above(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("wl_subsurface#{}.place_below()", object.id);
                        self.place_below(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("wl_subsurface#{}.set_sync()", object.id);
                        self.set_sync(object, client).await
                    }
                    5u16 => {
                        tracing::debug!("wl_subsurface#{}.set_desync()", object.id);
                        self.set_desync(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "The sub-surface interface is removed from the wl_surface object"]
            #[doc = "that was turned into a sub-surface with a"]
            #[doc = "wl_subcompositor.get_subsurface request. The wl_surface's association"]
            #[doc = "to the parent is deleted. The wl_surface is unmapped immediately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This schedules a sub-surface position change."]
            #[doc = "The sub-surface will be moved so that its origin (top left"]
            #[doc = "corner pixel) will be at the location x, y of the parent surface"]
            #[doc = "coordinate system. The coordinates are not restricted to the parent"]
            #[doc = "surface area. Negative values are allowed."]
            #[doc = ""]
            #[doc = "The scheduled coordinates will take effect whenever the state of the"]
            #[doc = "parent surface is applied."]
            #[doc = ""]
            #[doc = "If more than one set_position request is invoked by the client before"]
            #[doc = "the commit of the parent surface, the position of a new request always"]
            #[doc = "replaces the scheduled position from any previous request."]
            #[doc = ""]
            #[doc = "The initial position is 0, 0."]
            async fn set_position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "This sub-surface is taken from the stack, and put back just"]
            #[doc = "above the reference surface, changing the z-order of the sub-surfaces."]
            #[doc = "The reference surface must be one of the sibling surfaces, or the"]
            #[doc = "parent surface. Using any other surface, including this sub-surface,"]
            #[doc = "will cause a protocol error."]
            #[doc = ""]
            #[doc = "The z-order is double-buffered. Requests are handled in order and"]
            #[doc = "applied immediately to a pending state. The final pending state is"]
            #[doc = "copied to the active state the next time the state of the parent"]
            #[doc = "surface is applied."]
            #[doc = ""]
            #[doc = "A new sub-surface is initially added as the top-most in the stack"]
            #[doc = "of its siblings and parent."]
            async fn place_above(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                sibling: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "The sub-surface is placed just below the reference surface."]
            #[doc = "See wl_subsurface.place_above."]
            async fn place_below(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                sibling: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Change the commit behaviour of the sub-surface to synchronized"]
            #[doc = "mode, also described as the parent dependent mode."]
            #[doc = ""]
            #[doc = "In synchronized mode, wl_surface.commit on a sub-surface will"]
            #[doc = "accumulate the committed state in a cache, but the state will"]
            #[doc = "not be applied and hence will not change the compositor output."]
            #[doc = "The cached state is applied to the sub-surface immediately after"]
            #[doc = "the parent surface's state is applied. This ensures atomic"]
            #[doc = "updates of the parent and all its synchronized sub-surfaces."]
            #[doc = "Applying the cached state will invalidate the cache, so further"]
            #[doc = "parent surface commits do not (re-)apply old state."]
            #[doc = ""]
            #[doc = "See wl_subsurface for the recursive effect of this mode."]
            async fn set_sync(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Change the commit behaviour of the sub-surface to desynchronized"]
            #[doc = "mode, also described as independent or freely running mode."]
            #[doc = ""]
            #[doc = "In desynchronized mode, wl_surface.commit on a sub-surface will"]
            #[doc = "apply the pending state directly, without caching, as happens"]
            #[doc = "normally with a wl_surface. Calling wl_surface.commit on the"]
            #[doc = "parent surface has no effect on the sub-surface's wl_surface"]
            #[doc = "state. This mode allows a sub-surface to be updated on its own."]
            #[doc = ""]
            #[doc = "If cached state exists when wl_surface.commit is called in"]
            #[doc = "desynchronized mode, the pending state is added to the cached"]
            #[doc = "state, and applied as a whole. This invalidates the cache."]
            #[doc = ""]
            #[doc = "Note: even if a sub-surface is set to desynchronized, a parent"]
            #[doc = "sub-surface may override it to behave as synchronized. For details,"]
            #[doc = "see wl_subsurface."]
            #[doc = ""]
            #[doc = "If a surface's parent surface behaves as desynchronized, then"]
            #[doc = "the cached state is applied on set_desync."]
            async fn set_desync(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod linux_dmabuf_v1 {
    #[doc = "Following the interfaces from:"]
    #[doc = "https://www.khronos.org/registry/egl/extensions/EXT/EGL_EXT_image_dma_buf_import.txt"]
    #[doc = "https://www.khronos.org/registry/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import_modifiers.txt"]
    #[doc = "and the Linux DRM sub-system's AddFb2 ioctl."]
    #[doc = ""]
    #[doc = "This interface offers ways to create generic dmabuf-based wl_buffers."]
    #[doc = ""]
    #[doc = "Clients can use the get_surface_feedback request to get dmabuf feedback"]
    #[doc = "for a particular surface. If the client wants to retrieve feedback not"]
    #[doc = "tied to a surface, they can use the get_default_feedback request."]
    #[doc = ""]
    #[doc = "The following are required from clients:"]
    #[doc = ""]
    #[doc = "- Clients must ensure that either all data in the dma-buf is"]
    #[doc = "coherent for all subsequent read access or that coherency is"]
    #[doc = "correctly handled by the underlying kernel-side dma-buf"]
    #[doc = "implementation."]
    #[doc = ""]
    #[doc = "- Don't make any more attachments after sending the buffer to the"]
    #[doc = "compositor. Making more attachments later increases the risk of"]
    #[doc = "the compositor not being able to use (re-import) an existing"]
    #[doc = "dmabuf-based wl_buffer."]
    #[doc = ""]
    #[doc = "The underlying graphics stack must ensure the following:"]
    #[doc = ""]
    #[doc = "- The dmabuf file descriptors relayed to the server will stay valid"]
    #[doc = "for the whole lifetime of the wl_buffer. This means the server may"]
    #[doc = "at any time use those fds to import the dmabuf into any kernel"]
    #[doc = "sub-system that might accept it."]
    #[doc = ""]
    #[doc = "However, when the underlying graphics stack fails to deliver the"]
    #[doc = "promise, because of e.g. a device hot-unplug which raises internal"]
    #[doc = "errors, after the wl_buffer has been successfully created the"]
    #[doc = "compositor must not raise protocol errors to the client when dmabuf"]
    #[doc = "import later fails."]
    #[doc = ""]
    #[doc = "To create a wl_buffer from one or more dmabufs, a client creates a"]
    #[doc = "zwp_linux_dmabuf_params_v1 object with a zwp_linux_dmabuf_v1.create_params"]
    #[doc = "request. All planes required by the intended format are added with"]
    #[doc = "the 'add' request. Finally, a 'create' or 'create_immed' request is"]
    #[doc = "issued, which has the following outcome depending on the import success."]
    #[doc = ""]
    #[doc = "The 'create' request,"]
    #[doc = "- on success, triggers a 'created' event which provides the final"]
    #[doc = "wl_buffer to the client."]
    #[doc = "- on failure, triggers a 'failed' event to convey that the server"]
    #[doc = "cannot use the dmabufs received from the client."]
    #[doc = ""]
    #[doc = "For the 'create_immed' request,"]
    #[doc = "- on success, the server immediately imports the added dmabufs to"]
    #[doc = "create a wl_buffer. No event is sent from the server in this case."]
    #[doc = "- on failure, the server can choose to either:"]
    #[doc = "- terminate the client by raising a fatal error."]
    #[doc = "- mark the wl_buffer as failed, and send a 'failed' event to the"]
    #[doc = "client. If the client uses a failed wl_buffer as an argument to any"]
    #[doc = "request, the behaviour is compositor implementation-defined."]
    #[doc = ""]
    #[doc = "For all DRM formats and unless specified in another protocol extension,"]
    #[doc = "pre-multiplied alpha is used for pixel values."]
    #[doc = ""]
    #[doc = "Unless specified otherwise in another protocol extension, implicit"]
    #[doc = "synchronization is used. In other words, compositors and clients must"]
    #[doc = "wait and signal fences implicitly passed via the DMA-BUF's reservation"]
    #[doc = "mechanism."]
    pub mod zwp_linux_dmabuf_v1 {
        #[doc = "Trait to implement the zwp_linux_dmabuf_v1 interface. See the module level documentation for more info"]
        pub trait ZwpLinuxDmabufV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_dmabuf_v1";
            const VERSION: u32 = 5u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.create_params()", object.id);
                        self.create_params(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.get_default_feedback()", object.id);
                        self.get_default_feedback(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.get_surface_feedback()", object.id);
                        self.get_surface_feedback(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Objects created through this interface, especially wl_buffers, will"]
            #[doc = "remain valid."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This temporary object is used to collect multiple dmabuf handles into"]
            #[doc = "a single batch to create a wl_buffer. It can only be used once and"]
            #[doc = "should be destroyed after a 'created' or 'failed' event has been"]
            #[doc = "received."]
            async fn create_params(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                params_id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This request creates a new wp_linux_dmabuf_feedback object not bound"]
            #[doc = "to a particular surface. This object will deliver feedback about dmabuf"]
            #[doc = "parameters to use if the client doesn't support per-surface feedback"]
            #[doc = "(see get_surface_feedback)."]
            async fn get_default_feedback(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This request creates a new wp_linux_dmabuf_feedback object for the"]
            #[doc = "specified wl_surface. This object will deliver feedback about dmabuf"]
            #[doc = "parameters to use for buffers attached to this surface."]
            #[doc = ""]
            #[doc = "If the surface is destroyed before the wp_linux_dmabuf_feedback object,"]
            #[doc = "the feedback object becomes inert."]
            async fn get_surface_feedback(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This event advertises one buffer format that the server supports."]
            #[doc = "All the supported formats are advertised once when the client"]
            #[doc = "binds to this interface. A roundtrip after binding guarantees"]
            #[doc = "that the client has received all supported formats."]
            #[doc = ""]
            #[doc = "For the definition of the format codes, see the"]
            #[doc = "zwp_linux_buffer_params_v1::create request."]
            #[doc = ""]
            #[doc = "Starting version 4, the format event is deprecated and must not be"]
            #[doc = "sent by compositors. Instead, use get_default_feedback or"]
            #[doc = "get_surface_feedback."]
            async fn format(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                format: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_linux_dmabuf_v1#{}.format()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(format).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event advertises the formats that the server supports, along with"]
            #[doc = "the modifiers supported for each format. All the supported modifiers"]
            #[doc = "for all the supported formats are advertised once when the client"]
            #[doc = "binds to this interface. A roundtrip after binding guarantees that"]
            #[doc = "the client has received all supported format-modifier pairs."]
            #[doc = ""]
            #[doc = "For legacy support, DRM_FORMAT_MOD_INVALID (that is, modifier_hi =="]
            #[doc = "0x00ffffff and modifier_lo == 0xffffffff) is allowed in this event."]
            #[doc = "It indicates that the server can support the format with an implicit"]
            #[doc = "modifier. When a plane has DRM_FORMAT_MOD_INVALID as its modifier, it"]
            #[doc = "is as if no explicit modifier is specified. The effective modifier"]
            #[doc = "will be derived from the dmabuf."]
            #[doc = ""]
            #[doc = "A compositor that sends valid modifiers and DRM_FORMAT_MOD_INVALID for"]
            #[doc = "a given format supports both explicit modifiers and implicit modifiers."]
            #[doc = ""]
            #[doc = "For the definition of the format and modifier codes, see the"]
            #[doc = "zwp_linux_buffer_params_v1::create and zwp_linux_buffer_params_v1::add"]
            #[doc = "requests."]
            #[doc = ""]
            #[doc = "Starting version 4, the modifier event is deprecated and must not be"]
            #[doc = "sent by compositors. Instead, use get_default_feedback or"]
            #[doc = "get_surface_feedback."]
            async fn modifier(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                format: u32,
                modifier_hi: u32,
                modifier_lo: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_linux_dmabuf_v1#{}.modifier()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(format)
                    .put_uint(modifier_hi)
                    .put_uint(modifier_lo)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "This temporary object is a collection of dmabufs and other"]
    #[doc = "parameters that together form a single logical buffer. The temporary"]
    #[doc = "object may eventually create one wl_buffer unless cancelled by"]
    #[doc = "destroying it before requesting 'create'."]
    #[doc = ""]
    #[doc = "Single-planar formats only require one dmabuf, however"]
    #[doc = "multi-planar formats may require more than one dmabuf. For all"]
    #[doc = "formats, an 'add' request must be called once per plane (even if the"]
    #[doc = "underlying dmabuf fd is identical)."]
    #[doc = ""]
    #[doc = "You must use consecutive plane indices ('plane_idx' argument for 'add')"]
    #[doc = "from zero to the number of planes used by the drm_fourcc format code."]
    #[doc = "All planes required by the format must be given exactly once, but can"]
    #[doc = "be given in any order. Each plane index can be set only once."]
    pub mod zwp_linux_buffer_params_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "the dmabuf_batch object has already been used to create a wl_buffer"]
            AlreadyUsed = 0u32,
            #[doc = "plane index out of bounds"]
            PlaneIdx = 1u32,
            #[doc = "the plane index was already set"]
            PlaneSet = 2u32,
            #[doc = "missing or too many planes to create a buffer"]
            Incomplete = 3u32,
            #[doc = "format not supported"]
            InvalidFormat = 4u32,
            #[doc = "invalid width or height"]
            InvalidDimensions = 5u32,
            #[doc = "offset + stride * height goes out of dmabuf bounds"]
            OutOfBounds = 6u32,
            #[doc = "invalid wl_buffer resulted from importing dmabufs via"]
            #[doc = "the create_immed request on given buffer_params"]
            InvalidWlBuffer = 7u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::AlreadyUsed),
                    1u32 => Ok(Self::PlaneIdx),
                    2u32 => Ok(Self::PlaneSet),
                    3u32 => Ok(Self::Incomplete),
                    4u32 => Ok(Self::InvalidFormat),
                    5u32 => Ok(Self::InvalidDimensions),
                    6u32 => Ok(Self::OutOfBounds),
                    7u32 => Ok(Self::InvalidWlBuffer),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! { # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Flags : u32 { # [doc = "contents are y-inverted"] const YInvert = 1u32 ; # [doc = "content is interlaced"] const Interlaced = 2u32 ; # [doc = "bottom field first"] const BottomFirst = 4u32 ; } }
        impl TryFrom<u32> for Flags {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "Trait to implement the zwp_linux_buffer_params_v1 interface. See the module level documentation for more info"]
        pub trait ZwpLinuxBufferParamsV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_buffer_params_v1";
            const VERSION: u32 = 5u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.add()", object.id);
                        self.add(
                            object,
                            client,
                            message.fd()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.create()", object.id);
                        self.create(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.uint()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.create_immed()", object.id);
                        self.create_immed(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.uint()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Cleans up the temporary data sent to the server for dmabuf-based"]
            #[doc = "wl_buffer creation."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This request adds one dmabuf to the set in this"]
            #[doc = "zwp_linux_buffer_params_v1."]
            #[doc = ""]
            #[doc = "The 64-bit unsigned value combined from modifier_hi and modifier_lo"]
            #[doc = "is the dmabuf layout modifier. DRM AddFB2 ioctl calls this the"]
            #[doc = "fb modifier, which is defined in drm_mode.h of Linux UAPI."]
            #[doc = "This is an opaque token. Drivers use this token to express tiling,"]
            #[doc = "compression, etc. driver-specific modifications to the base format"]
            #[doc = "defined by the DRM fourcc code."]
            #[doc = ""]
            #[doc = "Starting from version 4, the invalid_format protocol error is sent if"]
            #[doc = "the format + modifier pair was not advertised as supported."]
            #[doc = ""]
            #[doc = "Starting from version 5, the invalid_format protocol error is sent if"]
            #[doc = "all planes don't use the same modifier."]
            #[doc = ""]
            #[doc = "This request raises the PLANE_IDX error if plane_idx is too large."]
            #[doc = "The error PLANE_SET is raised if attempting to set a plane that"]
            #[doc = "was already set."]
            async fn add(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                fd: rustix::fd::OwnedFd,
                plane_idx: u32,
                offset: u32,
                stride: u32,
                modifier_hi: u32,
                modifier_lo: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This asks for creation of a wl_buffer from the added dmabuf"]
            #[doc = "buffers. The wl_buffer is not created immediately but returned via"]
            #[doc = "the 'created' event if the dmabuf sharing succeeds. The sharing"]
            #[doc = "may fail at runtime for reasons a client cannot predict, in"]
            #[doc = "which case the 'failed' event is triggered."]
            #[doc = ""]
            #[doc = "The 'format' argument is a DRM_FORMAT code, as defined by the"]
            #[doc = "libdrm's drm_fourcc.h. The Linux kernel's DRM sub-system is the"]
            #[doc = "authoritative source on how the format codes should work."]
            #[doc = ""]
            #[doc = "The 'flags' is a bitfield of the flags defined in enum \"flags\"."]
            #[doc = "'y_invert' means the that the image needs to be y-flipped."]
            #[doc = ""]
            #[doc = "Flag 'interlaced' means that the frame in the buffer is not"]
            #[doc = "progressive as usual, but interlaced. An interlaced buffer as"]
            #[doc = "supported here must always contain both top and bottom fields."]
            #[doc = "The top field always begins on the first pixel row. The temporal"]
            #[doc = "ordering between the two fields is top field first, unless"]
            #[doc = "'bottom_first' is specified. It is undefined whether 'bottom_first'"]
            #[doc = "is ignored if 'interlaced' is not set."]
            #[doc = ""]
            #[doc = "This protocol does not convey any information about field rate,"]
            #[doc = "duration, or timing, other than the relative ordering between the"]
            #[doc = "two fields in one buffer. A compositor may have to estimate the"]
            #[doc = "intended field rate from the incoming buffer rate. It is undefined"]
            #[doc = "whether the time of receiving wl_surface.commit with a new buffer"]
            #[doc = "attached, applying the wl_surface state, wl_surface.frame callback"]
            #[doc = "trigger, presentation, or any other point in the compositor cycle"]
            #[doc = "is used to measure the frame or field times. There is no support"]
            #[doc = "for detecting missed or late frames/fields/buffers either, and"]
            #[doc = "there is no support whatsoever for cooperating with interlaced"]
            #[doc = "compositor output."]
            #[doc = ""]
            #[doc = "The composited image quality resulting from the use of interlaced"]
            #[doc = "buffers is explicitly undefined. A compositor may use elaborate"]
            #[doc = "hardware features or software to deinterlace and create progressive"]
            #[doc = "output frames from a sequence of interlaced input buffers, or it"]
            #[doc = "may produce substandard image quality. However, compositors that"]
            #[doc = "cannot guarantee reasonable image quality in all cases are recommended"]
            #[doc = "to just reject all interlaced buffers."]
            #[doc = ""]
            #[doc = "Any argument errors, including non-positive width or height,"]
            #[doc = "mismatch between the number of planes and the format, bad"]
            #[doc = "format, bad offset or stride, may be indicated by fatal protocol"]
            #[doc = "errors: INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS,"]
            #[doc = "OUT_OF_BOUNDS."]
            #[doc = ""]
            #[doc = "Dmabuf import errors in the server that are not obvious client"]
            #[doc = "bugs are returned via the 'failed' event as non-fatal. This"]
            #[doc = "allows attempting dmabuf sharing and falling back in the client"]
            #[doc = "if it fails."]
            #[doc = ""]
            #[doc = "This request can be sent only once in the object's lifetime, after"]
            #[doc = "which the only legal request is destroy. This object should be"]
            #[doc = "destroyed after issuing a 'create' request. Attempting to use this"]
            #[doc = "object after issuing 'create' raises ALREADY_USED protocol error."]
            #[doc = ""]
            #[doc = "It is not mandatory to issue 'create'. If a client wants to"]
            #[doc = "cancel the buffer creation, it can just destroy this object."]
            async fn create(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
                format: u32,
                flags: Flags,
            ) -> crate::server::Result<()>;
            #[doc = "This asks for immediate creation of a wl_buffer by importing the"]
            #[doc = "added dmabufs."]
            #[doc = ""]
            #[doc = "In case of import success, no event is sent from the server, and the"]
            #[doc = "wl_buffer is ready to be used by the client."]
            #[doc = ""]
            #[doc = "Upon import failure, either of the following may happen, as seen fit"]
            #[doc = "by the implementation:"]
            #[doc = "- the client is terminated with one of the following fatal protocol"]
            #[doc = "errors:"]
            #[doc = "- INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS, OUT_OF_BOUNDS,"]
            #[doc = "in case of argument errors such as mismatch between the number"]
            #[doc = "of planes and the format, bad format, non-positive width or"]
            #[doc = "height, or bad offset or stride."]
            #[doc = "- INVALID_WL_BUFFER, in case the cause for failure is unknown or"]
            #[doc = "platform specific."]
            #[doc = "- the server creates an invalid wl_buffer, marks it as failed and"]
            #[doc = "sends a 'failed' event to the client. The result of using this"]
            #[doc = "invalid wl_buffer as an argument in any request by the client is"]
            #[doc = "defined by the compositor implementation."]
            #[doc = ""]
            #[doc = "This takes the same arguments as a 'create' request, and obeys the"]
            #[doc = "same restrictions."]
            async fn create_immed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer_id: crate::wire::ObjectId,
                width: i32,
                height: i32,
                format: u32,
                flags: Flags,
            ) -> crate::server::Result<()>;
            #[doc = "This event indicates that the attempted buffer creation was"]
            #[doc = "successful. It provides the new wl_buffer referencing the dmabuf(s)."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy the"]
            #[doc = "zwp_linux_buffer_params_v1 object."]
            async fn created(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_linux_buffer_params_v1#{}.created()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(buffer))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates that the attempted buffer creation has"]
            #[doc = "failed. It usually means that one of the dmabuf constraints"]
            #[doc = "has not been fulfilled."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy the"]
            #[doc = "zwp_linux_buffer_params_v1 object."]
            async fn failed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_linux_buffer_params_v1#{}.failed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "This object advertises dmabuf parameters feedback. This includes the"]
    #[doc = "preferred devices and the supported formats/modifiers."]
    #[doc = ""]
    #[doc = "The parameters are sent once when this object is created and whenever they"]
    #[doc = "change. The done event is always sent once after all parameters have been"]
    #[doc = "sent. When a single parameter changes, all parameters are re-sent by the"]
    #[doc = "compositor."]
    #[doc = ""]
    #[doc = "Compositors can re-send the parameters when the current client buffer"]
    #[doc = "allocations are sub-optimal. Compositors should not re-send the"]
    #[doc = "parameters if re-allocating the buffers would not result in a more optimal"]
    #[doc = "configuration. In particular, compositors should avoid sending the exact"]
    #[doc = "same parameters multiple times in a row."]
    #[doc = ""]
    #[doc = "The tranche_target_device and tranche_formats events are grouped by"]
    #[doc = "tranches of preference. For each tranche, a tranche_target_device, one"]
    #[doc = "tranche_flags and one or more tranche_formats events are sent, followed"]
    #[doc = "by a tranche_done event finishing the list. The tranches are sent in"]
    #[doc = "descending order of preference. All formats and modifiers in the same"]
    #[doc = "tranche have the same preference."]
    #[doc = ""]
    #[doc = "To send parameters, the compositor sends one main_device event, tranches"]
    #[doc = "(each consisting of one tranche_target_device event, one tranche_flags"]
    #[doc = "event, tranche_formats events and then a tranche_done event), then one"]
    #[doc = "done event."]
    pub mod zwp_linux_dmabuf_feedback_v1 {
        bitflags::bitflags! { # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct TrancheFlags : u32 { # [doc = "direct scan-out tranche"] const Scanout = 1u32 ; } }
        impl TryFrom<u32> for TrancheFlags {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "Trait to implement the zwp_linux_dmabuf_feedback_v1 interface. See the module level documentation for more info"]
        pub trait ZwpLinuxDmabufFeedbackV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_dmabuf_feedback_v1";
            const VERSION: u32 = 5u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_linux_dmabuf_feedback_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Using this request a client can tell the server that it is not going to"]
            #[doc = "use the wp_linux_dmabuf_feedback object anymore."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent after all parameters of a wp_linux_dmabuf_feedback"]
            #[doc = "object have been sent."]
            #[doc = ""]
            #[doc = "This allows changes to the wp_linux_dmabuf_feedback parameters to be"]
            #[doc = "seen as atomic, even if they happen via multiple events."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_linux_dmabuf_feedback_v1#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event provides a file descriptor which can be memory-mapped to"]
            #[doc = "access the format and modifier table."]
            #[doc = ""]
            #[doc = "The table contains a tightly packed array of consecutive format +"]
            #[doc = "modifier pairs. Each pair is 16 bytes wide. It contains a format as a"]
            #[doc = "32-bit unsigned integer, followed by 4 bytes of unused padding, and a"]
            #[doc = "modifier as a 64-bit unsigned integer. The native endianness is used."]
            #[doc = ""]
            #[doc = "The client must map the file descriptor in read-only private mode."]
            #[doc = ""]
            #[doc = "Compositors are not allowed to mutate the table file contents once this"]
            #[doc = "event has been sent. Instead, compositors must create a new, separate"]
            #[doc = "table file and re-send feedback parameters. Compositors are allowed to"]
            #[doc = "store duplicate format + modifier pairs in the table."]
            async fn format_table(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                fd: rustix::fd::OwnedFd,
                size: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.format_table()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fd(fd)
                    .put_uint(size)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event advertises the main device that the server prefers to use"]
            #[doc = "when direct scan-out to the target device isn't possible. The"]
            #[doc = "advertised main device may be different for each"]
            #[doc = "wp_linux_dmabuf_feedback object, and may change over time."]
            #[doc = ""]
            #[doc = "There is exactly one main device. The compositor must send at least"]
            #[doc = "one preference tranche with tranche_target_device equal to main_device."]
            #[doc = ""]
            #[doc = "Clients need to create buffers that the main device can import and"]
            #[doc = "read from, otherwise creating the dmabuf wl_buffer will fail (see the"]
            #[doc = "wp_linux_buffer_params.create and create_immed requests for details)."]
            #[doc = "The main device will also likely be kept active by the compositor,"]
            #[doc = "so clients can use it instead of waking up another device for power"]
            #[doc = "savings."]
            #[doc = ""]
            #[doc = "In general the device is a DRM node. The DRM node type (primary vs."]
            #[doc = "render) is unspecified. Clients must not rely on the compositor sending"]
            #[doc = "a particular node type. Clients cannot check two devices for equality"]
            #[doc = "by comparing the dev_t value."]
            #[doc = ""]
            #[doc = "If explicit modifiers are not supported and the client performs buffer"]
            #[doc = "allocations on a different device than the main device, then the client"]
            #[doc = "must force the buffer to have a linear layout."]
            async fn main_device(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                device: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.main_device()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_array(device).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event splits tranche_target_device and tranche_formats events in"]
            #[doc = "preference tranches. It is sent after a set of tranche_target_device"]
            #[doc = "and tranche_formats events; it represents the end of a tranche. The"]
            #[doc = "next tranche will have a lower preference."]
            async fn tranche_done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.tranche_done()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event advertises the target device that the server prefers to use"]
            #[doc = "for a buffer created given this tranche. The advertised target device"]
            #[doc = "may be different for each preference tranche, and may change over time."]
            #[doc = ""]
            #[doc = "There is exactly one target device per tranche."]
            #[doc = ""]
            #[doc = "The target device may be a scan-out device, for example if the"]
            #[doc = "compositor prefers to directly scan-out a buffer created given this"]
            #[doc = "tranche. The target device may be a rendering device, for example if"]
            #[doc = "the compositor prefers to texture from said buffer."]
            #[doc = ""]
            #[doc = "The client can use this hint to allocate the buffer in a way that makes"]
            #[doc = "it accessible from the target device, ideally directly. The buffer must"]
            #[doc = "still be accessible from the main device, either through direct import"]
            #[doc = "or through a potentially more expensive fallback path. If the buffer"]
            #[doc = "can't be directly imported from the main device then clients must be"]
            #[doc = "prepared for the compositor changing the tranche priority or making"]
            #[doc = "wl_buffer creation fail (see the wp_linux_buffer_params.create and"]
            #[doc = "create_immed requests for details)."]
            #[doc = ""]
            #[doc = "If the device is a DRM node, the DRM node type (primary vs. render) is"]
            #[doc = "unspecified. Clients must not rely on the compositor sending a"]
            #[doc = "particular node type. Clients cannot check two devices for equality by"]
            #[doc = "comparing the dev_t value."]
            #[doc = ""]
            #[doc = "This event is tied to a preference tranche, see the tranche_done event."]
            async fn tranche_target_device(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                device: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.tranche_target_device()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_array(device).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event advertises the format + modifier combinations that the"]
            #[doc = "compositor supports."]
            #[doc = ""]
            #[doc = "It carries an array of indices, each referring to a format + modifier"]
            #[doc = "pair in the last received format table (see the format_table event)."]
            #[doc = "Each index is a 16-bit unsigned integer in native endianness."]
            #[doc = ""]
            #[doc = "For legacy support, DRM_FORMAT_MOD_INVALID is an allowed modifier."]
            #[doc = "It indicates that the server can support the format with an implicit"]
            #[doc = "modifier. When a buffer has DRM_FORMAT_MOD_INVALID as its modifier, it"]
            #[doc = "is as if no explicit modifier is specified. The effective modifier"]
            #[doc = "will be derived from the dmabuf."]
            #[doc = ""]
            #[doc = "A compositor that sends valid modifiers and DRM_FORMAT_MOD_INVALID for"]
            #[doc = "a given format supports both explicit modifiers and implicit modifiers."]
            #[doc = ""]
            #[doc = "Compositors must not send duplicate format + modifier pairs within the"]
            #[doc = "same tranche or across two different tranches with the same target"]
            #[doc = "device and flags."]
            #[doc = ""]
            #[doc = "This event is tied to a preference tranche, see the tranche_done event."]
            #[doc = ""]
            #[doc = "For the definition of the format and modifier codes, see the"]
            #[doc = "wp_linux_buffer_params.create request."]
            async fn tranche_formats(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                indices: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.tranche_formats()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_array(indices)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event sets tranche-specific flags."]
            #[doc = ""]
            #[doc = "The scanout flag is a hint that direct scan-out may be attempted by the"]
            #[doc = "compositor on the target device if the client appropriately allocates a"]
            #[doc = "buffer. How to allocate a buffer that can be scanned out on the target"]
            #[doc = "device is implementation-defined."]
            #[doc = ""]
            #[doc = "This event is tied to a preference tranche, see the tranche_done event."]
            async fn tranche_flags(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                flags: TrancheFlags,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.tranche_flags()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(flags.bits())
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 6u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod presentation_time {
    #[doc = "The main feature of this interface is accurate presentation"]
    #[doc = "timing feedback to ensure smooth video playback while maintaining"]
    #[doc = "audio/video synchronization. Some features use the concept of a"]
    #[doc = "presentation clock, which is defined in the"]
    #[doc = "presentation.clock_id event."]
    #[doc = ""]
    #[doc = "A content update for a wl_surface is submitted by a"]
    #[doc = "wl_surface.commit request. Request 'feedback' associates with"]
    #[doc = "the wl_surface.commit and provides feedback on the content"]
    #[doc = "update, particularly the final realized presentation time."]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "When the final realized presentation time is available, e.g."]
    #[doc = "after a framebuffer flip completes, the requested"]
    #[doc = "presentation_feedback.presented events are sent. The final"]
    #[doc = "presentation time can differ from the compositor's predicted"]
    #[doc = "display update time and the update's target time, especially"]
    #[doc = "when the compositor misses its target vertical blanking period."]
    pub mod wp_presentation {
        #[doc = "These fatal protocol errors may be emitted in response to"]
        #[doc = "illegal presentation requests."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "invalid value in tv_nsec"]
            InvalidTimestamp = 0u32,
            #[doc = "invalid flag"]
            InvalidFlag = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidTimestamp),
                    1u32 => Ok(Self::InvalidFlag),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wp_presentation interface. See the module level documentation for more info"]
        pub trait WpPresentation: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_presentation";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_presentation#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("wp_presentation#{}.feedback()", object.id);
                        self.feedback(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Informs the server that the client will no longer be using"]
            #[doc = "this protocol object. Existing objects created by this object"]
            #[doc = "are not affected."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Request presentation feedback for the current content submission"]
            #[doc = "on the given surface. This creates a new presentation_feedback"]
            #[doc = "object, which will deliver the feedback information once. If"]
            #[doc = "multiple presentation_feedback objects are created for the same"]
            #[doc = "submission, they will all deliver the same information."]
            #[doc = ""]
            #[doc = "For details on what information is returned, see the"]
            #[doc = "presentation_feedback interface."]
            async fn feedback(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
                callback: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This event tells the client in which clock domain the"]
            #[doc = "compositor interprets the timestamps used by the presentation"]
            #[doc = "extension. This clock is called the presentation clock."]
            #[doc = ""]
            #[doc = "The compositor sends this event when the client binds to the"]
            #[doc = "presentation interface. The presentation clock does not change"]
            #[doc = "during the lifetime of the client connection."]
            #[doc = ""]
            #[doc = "The clock identifier is platform dependent. On POSIX platforms, the"]
            #[doc = "identifier value is one of the clockid_t values accepted by"]
            #[doc = "clock_gettime(). clock_gettime() is defined by POSIX.1-2001."]
            #[doc = ""]
            #[doc = "Timestamps in this clock domain are expressed as tv_sec_hi,"]
            #[doc = "tv_sec_lo, tv_nsec triples, each component being an unsigned"]
            #[doc = "32-bit value. Whole seconds are in tv_sec which is a 64-bit"]
            #[doc = "value combined from tv_sec_hi and tv_sec_lo, and the"]
            #[doc = "additional fractional part in tv_nsec as nanoseconds. Hence,"]
            #[doc = "for valid timestamps tv_nsec must be in [0, 999999999]."]
            #[doc = ""]
            #[doc = "Note that clock_id applies only to the presentation clock,"]
            #[doc = "and implies nothing about e.g. the timestamps used in the"]
            #[doc = "Wayland core protocol input events."]
            #[doc = ""]
            #[doc = "Compositors should prefer a clock which does not jump and is"]
            #[doc = "not slewed e.g. by NTP. The absolute value of the clock is"]
            #[doc = "irrelevant. Precision of one millisecond or better is"]
            #[doc = "recommended. Clients must be able to query the current clock"]
            #[doc = "value directly, not by asking the compositor."]
            async fn clock_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                clk_id: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_presentation#{}.clock_id()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(clk_id).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A presentation_feedback object returns an indication that a"]
    #[doc = "wl_surface content update has become visible to the user."]
    #[doc = "One object corresponds to one content update submission"]
    #[doc = "(wl_surface.commit). There are two possible outcomes: the"]
    #[doc = "content update is presented to the user, and a presentation"]
    #[doc = "timestamp delivered; or, the user did not see the content"]
    #[doc = "update because it was superseded or its surface destroyed,"]
    #[doc = "and the content update is discarded."]
    #[doc = ""]
    #[doc = "Once a presentation_feedback object has delivered a 'presented'"]
    #[doc = "or 'discarded' event it is automatically destroyed."]
    pub mod wp_presentation_feedback {
        bitflags::bitflags! { # [doc = "These flags provide information about how the presentation of"] # [doc = "the related content update was done. The intent is to help"] # [doc = "clients assess the reliability of the feedback and the visual"] # [doc = "quality with respect to possible tearing and timings."] # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Kind : u32 { const Vsync = 1u32 ; const HwClock = 2u32 ; const HwCompletion = 4u32 ; const ZeroCopy = 8u32 ; } }
        impl TryFrom<u32> for Kind {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "Trait to implement the wp_presentation_feedback interface. See the module level documentation for more info"]
        pub trait WpPresentationFeedback: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_presentation_feedback";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "As presentation can be synchronized to only one output at a"]
            #[doc = "time, this event tells which output it was. This event is only"]
            #[doc = "sent prior to the presented event."]
            #[doc = ""]
            #[doc = "As clients may bind to the same global wl_output multiple"]
            #[doc = "times, this event is sent for each bound instance that matches"]
            #[doc = "the synchronized output. If a client has not bound to the"]
            #[doc = "right wl_output global at all, this event is not sent."]
            async fn sync_output(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_presentation_feedback#{}.sync_output()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(output))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The associated content update was displayed to the user at the"]
            #[doc = "indicated time (tv_sec_hi/lo, tv_nsec). For the interpretation of"]
            #[doc = "the timestamp, see presentation.clock_id event."]
            #[doc = ""]
            #[doc = "The timestamp corresponds to the time when the content update"]
            #[doc = "turned into light the first time on the surface's main output."]
            #[doc = "Compositors may approximate this from the framebuffer flip"]
            #[doc = "completion events from the system, and the latency of the"]
            #[doc = "physical display path if known."]
            #[doc = ""]
            #[doc = "This event is preceded by all related sync_output events"]
            #[doc = "telling which output's refresh cycle the feedback corresponds"]
            #[doc = "to, i.e. the main output for the surface. Compositors are"]
            #[doc = "recommended to choose the output containing the largest part"]
            #[doc = "of the wl_surface, or keeping the output they previously"]
            #[doc = "chose. Having a stable presentation output association helps"]
            #[doc = "clients predict future output refreshes (vblank)."]
            #[doc = ""]
            #[doc = "The 'refresh' argument gives the compositor's prediction of how"]
            #[doc = "many nanoseconds after tv_sec, tv_nsec the very next output"]
            #[doc = "refresh may occur. This is to further aid clients in"]
            #[doc = "predicting future refreshes, i.e., estimating the timestamps"]
            #[doc = "targeting the next few vblanks. If such prediction cannot"]
            #[doc = "usefully be done, the argument is zero."]
            #[doc = ""]
            #[doc = "If the output does not have a constant refresh rate, explicit"]
            #[doc = "video mode switches excluded, then the refresh argument must"]
            #[doc = "be zero."]
            #[doc = ""]
            #[doc = "The 64-bit value combined from seq_hi and seq_lo is the value"]
            #[doc = "of the output's vertical retrace counter when the content"]
            #[doc = "update was first scanned out to the display. This value must"]
            #[doc = "be compatible with the definition of MSC in"]
            #[doc = "GLX_OML_sync_control specification. Note, that if the display"]
            #[doc = "path has a non-zero latency, the time instant specified by"]
            #[doc = "this counter may differ from the timestamp's."]
            #[doc = ""]
            #[doc = "If the output does not have a concept of vertical retrace or a"]
            #[doc = "refresh cycle, or the output device is self-refreshing without"]
            #[doc = "a way to query the refresh count, then the arguments seq_hi"]
            #[doc = "and seq_lo must be zero."]
            async fn presented(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tv_sec_hi: u32,
                tv_sec_lo: u32,
                tv_nsec: u32,
                refresh: u32,
                seq_hi: u32,
                seq_lo: u32,
                flags: Kind,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_presentation_feedback#{}.presented()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(tv_sec_hi)
                    .put_uint(tv_sec_lo)
                    .put_uint(tv_nsec)
                    .put_uint(refresh)
                    .put_uint(seq_hi)
                    .put_uint(seq_lo)
                    .put_uint(flags.bits())
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The content update was never displayed to the user."]
            async fn discarded(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_presentation_feedback#{}.discarded()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "This description provides a high-level overview of the interplay between"]
#[doc = "the interfaces defined this protocol. For details, see the protocol"]
#[doc = "specification."]
#[doc = ""]
#[doc = "More than one tablet may exist, and device-specifics matter. Tablets are"]
#[doc = "not represented by a single virtual device like wl_pointer. A client"]
#[doc = "binds to the tablet manager object which is just a proxy object. From"]
#[doc = "that, the client requests wp_tablet_manager.get_tablet_seat(wl_seat)"]
#[doc = "and that returns the actual interface that has all the tablets. With"]
#[doc = "this indirection, we can avoid merging wp_tablet into the actual Wayland"]
#[doc = "protocol, a long-term benefit."]
#[doc = ""]
#[doc = "The wp_tablet_seat sends a \"tablet added\" event for each tablet"]
#[doc = "connected. That event is followed by descriptive events about the"]
#[doc = "hardware; currently that includes events for name, vid/pid and"]
#[doc = "a wp_tablet.path event that describes a local path. This path can be"]
#[doc = "used to uniquely identify a tablet or get more information through"]
#[doc = "libwacom. Emulated or nested tablets can skip any of those, e.g. a"]
#[doc = "virtual tablet may not have a vid/pid. The sequence of descriptive"]
#[doc = "events is terminated by a wp_tablet.done event to signal that a client"]
#[doc = "may now finalize any initialization for that tablet."]
#[doc = ""]
#[doc = "Events from tablets require a tool in proximity. Tools are also managed"]
#[doc = "by the tablet seat; a \"tool added\" event is sent whenever a tool is new"]
#[doc = "to the compositor. That event is followed by a number of descriptive"]
#[doc = "events about the hardware; currently that includes capabilities,"]
#[doc = "hardware id and serial number, and tool type. Similar to the tablet"]
#[doc = "interface, a wp_tablet_tool.done event is sent to terminate that initial"]
#[doc = "sequence."]
#[doc = ""]
#[doc = "Any event from a tool happens on the wp_tablet_tool interface. When the"]
#[doc = "tool gets into proximity of the tablet, a proximity_in event is sent on"]
#[doc = "the wp_tablet_tool interface, listing the tablet and the surface. That"]
#[doc = "event is followed by a motion event with the coordinates. After that,"]
#[doc = "it's the usual motion, axis, button, etc. events. The protocol's"]
#[doc = "serialisation means events are grouped by wp_tablet_tool.frame events."]
#[doc = ""]
#[doc = "Two special events (that don't exist in X) are down and up. They signal"]
#[doc = "\"tip touching the surface\". For tablets without real proximity"]
#[doc = "detection, the sequence is: proximity_in, motion, down, frame."]
#[doc = ""]
#[doc = "When the tool leaves proximity, a proximity_out event is sent. If any"]
#[doc = "button is still down, a button release event is sent before this"]
#[doc = "proximity event. These button events are sent in the same frame as the"]
#[doc = "proximity event to signal to the client that the buttons were held when"]
#[doc = "the tool left proximity."]
#[doc = ""]
#[doc = "If the tool moves out of the surface but stays in proximity (i.e."]
#[doc = "between windows), compositor-specific grab policies apply. This usually"]
#[doc = "means that the proximity-out is delayed until all buttons are released."]
#[doc = ""]
#[doc = "Moving a tool physically from one tablet to the other has no real effect"]
#[doc = "on the protocol, since we already have the tool object from the \"tool"]
#[doc = "added\" event. All the information is already there and the proximity"]
#[doc = "events on both tablets are all a client needs to reconstruct what"]
#[doc = "happened."]
#[doc = ""]
#[doc = "Some extra axes are normalized, i.e. the client knows the range as"]
#[doc = "specified in the protocol (e.g. [0, 65535]), the granularity however is"]
#[doc = "unknown. The current normalized axes are pressure, distance, and slider."]
#[doc = ""]
#[doc = "Other extra axes are in physical units as specified in the protocol."]
#[doc = "The current extra axes with physical units are tilt, rotation and"]
#[doc = "wheel rotation."]
#[doc = ""]
#[doc = "Since tablets work independently of the pointer controlled by the mouse,"]
#[doc = "the focus handling is independent too and controlled by proximity."]
#[doc = "The wp_tablet_tool.set_cursor request sets a tool-specific cursor."]
#[doc = "This cursor surface may be the same as the mouse cursor, and it may be"]
#[doc = "the same across tools but it is possible to be more fine-grained. For"]
#[doc = "example, a client may set different cursors for the pen and eraser."]
#[doc = ""]
#[doc = "Tools are generally independent of tablets and it is"]
#[doc = "compositor-specific policy when a tool can be removed. Common approaches"]
#[doc = "will likely include some form of removing a tool when all tablets the"]
#[doc = "tool was used on are removed."]
pub mod tablet_v2 {
    #[doc = "An object that provides access to the graphics tablets available on this"]
    #[doc = "system. All tablets are associated with a seat, to get access to the"]
    #[doc = "actual tablets, use wp_tablet_manager.get_tablet_seat."]
    pub mod zwp_tablet_manager_v2 {
        #[doc = "Trait to implement the zwp_tablet_manager_v2 interface. See the module level documentation for more info"]
        pub trait ZwpTabletManagerV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_manager_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_manager_v2#{}.get_tablet_seat()", object.id);
                        self.get_tablet_seat(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_manager_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Get the wp_tablet_seat object for the given seat. This object"]
            #[doc = "provides access to all graphics tablets in this seat."]
            async fn get_tablet_seat(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tablet_seat: crate::wire::ObjectId,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the wp_tablet_manager object. Objects created from this"]
            #[doc = "object are unaffected and should be destroyed separately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "An object that provides access to the graphics tablets available on this"]
    #[doc = "seat. After binding to this interface, the compositor sends a set of"]
    #[doc = "wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events."]
    pub mod zwp_tablet_seat_v2 {
        #[doc = "Trait to implement the zwp_tablet_seat_v2 interface. See the module level documentation for more info"]
        pub trait ZwpTabletSeatV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_seat_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_seat_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the wp_tablet_seat object. Objects created from this"]
            #[doc = "object are unaffected and should be destroyed separately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent whenever a new tablet becomes available on this"]
            #[doc = "seat. This event only provides the object id of the tablet, any"]
            #[doc = "static information about the tablet (device name, vid/pid, etc.) is"]
            #[doc = "sent through the wp_tablet interface."]
            async fn tablet_added(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_seat_v2#{}.tablet_added()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent whenever a tool that has not previously been used"]
            #[doc = "with a tablet comes into use. This event only provides the object id"]
            #[doc = "of the tool; any static information about the tool (capabilities,"]
            #[doc = "type, etc.) is sent through the wp_tablet_tool interface."]
            async fn tool_added(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_seat_v2#{}.tool_added()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent whenever a new pad is known to the system. Typically,"]
            #[doc = "pads are physically attached to tablets and a pad_added event is"]
            #[doc = "sent immediately after the wp_tablet_seat.tablet_added."]
            #[doc = "However, some standalone pad devices logically attach to tablets at"]
            #[doc = "runtime, and the client must wait for wp_tablet_pad.enter to know"]
            #[doc = "the tablet a pad is attached to."]
            #[doc = ""]
            #[doc = "This event only provides the object id of the pad. All further"]
            #[doc = "features (buttons, strips, rings) are sent through the wp_tablet_pad"]
            #[doc = "interface."]
            async fn pad_added(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_seat_v2#{}.pad_added()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "An object that represents a physical tool that has been, or is"]
    #[doc = "currently in use with a tablet in this seat. Each wp_tablet_tool"]
    #[doc = "object stays valid until the client destroys it; the compositor"]
    #[doc = "reuses the wp_tablet_tool object to indicate that the object's"]
    #[doc = "respective physical tool has come into proximity of a tablet again."]
    #[doc = ""]
    #[doc = "A wp_tablet_tool object's relation to a physical tool depends on the"]
    #[doc = "tablet's ability to report serial numbers. If the tablet supports"]
    #[doc = "this capability, then the object represents a specific physical tool"]
    #[doc = "and can be identified even when used on multiple tablets."]
    #[doc = ""]
    #[doc = "A tablet tool has a number of static characteristics, e.g. tool type,"]
    #[doc = "hardware_serial and capabilities. These capabilities are sent in an"]
    #[doc = "event sequence after the wp_tablet_seat.tool_added event before any"]
    #[doc = "actual events from this tool. This initial event sequence is"]
    #[doc = "terminated by a wp_tablet_tool.done event."]
    #[doc = ""]
    #[doc = "Tablet tool events are grouped by wp_tablet_tool.frame events."]
    #[doc = "Any events received before a wp_tablet_tool.frame event should be"]
    #[doc = "considered part of the same hardware state change."]
    pub mod zwp_tablet_tool_v2 {
        #[doc = "Describes the physical type of a tool. The physical type of a tool"]
        #[doc = "generally defines its base usage."]
        #[doc = ""]
        #[doc = "The mouse tool represents a mouse-shaped tool that is not a relative"]
        #[doc = "device but bound to the tablet's surface, providing absolute"]
        #[doc = "coordinates."]
        #[doc = ""]
        #[doc = "The lens tool is a mouse-shaped tool with an attached lens to"]
        #[doc = "provide precision focus."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Type {
            #[doc = "Pen"]
            Pen = 320u32,
            #[doc = "Eraser"]
            Eraser = 321u32,
            #[doc = "Brush"]
            Brush = 322u32,
            #[doc = "Pencil"]
            Pencil = 323u32,
            #[doc = "Airbrush"]
            Airbrush = 324u32,
            #[doc = "Finger"]
            Finger = 325u32,
            #[doc = "Mouse"]
            Mouse = 326u32,
            #[doc = "Lens"]
            Lens = 327u32,
        }
        impl TryFrom<u32> for Type {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    320u32 => Ok(Self::Pen),
                    321u32 => Ok(Self::Eraser),
                    322u32 => Ok(Self::Brush),
                    323u32 => Ok(Self::Pencil),
                    324u32 => Ok(Self::Airbrush),
                    325u32 => Ok(Self::Finger),
                    326u32 => Ok(Self::Mouse),
                    327u32 => Ok(Self::Lens),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Describes extra capabilities on a tablet."]
        #[doc = ""]
        #[doc = "Any tool must provide x and y values, extra axes are"]
        #[doc = "device-specific."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Capability {
            #[doc = "Tilt axes"]
            Tilt = 1u32,
            #[doc = "Pressure axis"]
            Pressure = 2u32,
            #[doc = "Distance axis"]
            Distance = 3u32,
            #[doc = "Z-rotation axis"]
            Rotation = 4u32,
            #[doc = "Slider axis"]
            Slider = 5u32,
            #[doc = "Wheel axis"]
            Wheel = 6u32,
        }
        impl TryFrom<u32> for Capability {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::Tilt),
                    2u32 => Ok(Self::Pressure),
                    3u32 => Ok(Self::Distance),
                    4u32 => Ok(Self::Rotation),
                    5u32 => Ok(Self::Slider),
                    6u32 => Ok(Self::Wheel),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Describes the physical state of a button that produced the button event."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ButtonState {
            #[doc = "button is not pressed"]
            Released = 0u32,
            #[doc = "button is pressed"]
            Pressed = 1u32,
        }
        impl TryFrom<u32> for ButtonState {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Released),
                    1u32 => Ok(Self::Pressed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "given wl_surface has another role"]
            Role = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Role),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwp_tablet_tool_v2 interface. See the module level documentation for more info"]
        pub trait ZwpTabletToolV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_tool_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_tool_v2#{}.set_cursor()", object.id);
                        self.set_cursor(
                            object,
                            client,
                            message.uint()?,
                            message.object()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_tool_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Sets the surface of the cursor used for this tool on the given"]
            #[doc = "tablet. This request only takes effect if the tool is in proximity"]
            #[doc = "of one of the requesting client's surfaces or the surface parameter"]
            #[doc = "is the current pointer surface. If there was a previous surface set"]
            #[doc = "with this request it is replaced. If surface is NULL, the cursor"]
            #[doc = "image is hidden."]
            #[doc = ""]
            #[doc = "The parameters hotspot_x and hotspot_y define the position of the"]
            #[doc = "pointer surface relative to the pointer location. Its top-left corner"]
            #[doc = "is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the"]
            #[doc = "coordinates of the pointer location, in surface-local coordinates."]
            #[doc = ""]
            #[doc = "On surface.attach requests to the pointer surface, hotspot_x and"]
            #[doc = "hotspot_y are decremented by the x and y parameters passed to the"]
            #[doc = "request. Attach must be confirmed by wl_surface.commit as usual."]
            #[doc = ""]
            #[doc = "The hotspot can also be updated by passing the currently set pointer"]
            #[doc = "surface to this request with new values for hotspot_x and hotspot_y."]
            #[doc = ""]
            #[doc = "The current and pending input regions of the wl_surface are cleared,"]
            #[doc = "and wl_surface.set_input_region is ignored until the wl_surface is no"]
            #[doc = "longer used as the cursor. When the use as a cursor ends, the current"]
            #[doc = "and pending input regions become undefined, and the wl_surface is"]
            #[doc = "unmapped."]
            #[doc = ""]
            #[doc = "This request gives the surface the role of a wp_tablet_tool cursor. A"]
            #[doc = "surface may only ever be used as the cursor surface for one"]
            #[doc = "wp_tablet_tool. If the surface already has another role or has"]
            #[doc = "previously been used as cursor surface for a different tool, a"]
            #[doc = "protocol error is raised."]
            async fn set_cursor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: Option<crate::wire::ObjectId>,
                hotspot_x: i32,
                hotspot_y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "This destroys the client's resource for this tool object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The tool type is the high-level type of the tool and usually decides"]
            #[doc = "the interaction expected from this tool."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn r#type(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tool_type: Type,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.type()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(tool_type as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "If the physical tool can be identified by a unique 64-bit serial"]
            #[doc = "number, this event notifies the client of this serial number."]
            #[doc = ""]
            #[doc = "If multiple tablets are available in the same seat and the tool is"]
            #[doc = "uniquely identifiable by the serial number, that tool may move"]
            #[doc = "between tablets."]
            #[doc = ""]
            #[doc = "Otherwise, if the tool has no serial number and this event is"]
            #[doc = "missing, the tool is tied to the tablet it first comes into"]
            #[doc = "proximity with. Even if the physical tool is used on multiple"]
            #[doc = "tablets, separate wp_tablet_tool objects will be created, one per"]
            #[doc = "tablet."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn hardware_serial(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                hardware_serial_hi: u32,
                hardware_serial_lo: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.hardware_serial()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(hardware_serial_hi)
                    .put_uint(hardware_serial_lo)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event notifies the client of a hardware id available on this tool."]
            #[doc = ""]
            #[doc = "The hardware id is a device-specific 64-bit id that provides extra"]
            #[doc = "information about the tool in use, beyond the wl_tool.type"]
            #[doc = "enumeration. The format of the id is specific to tablets made by"]
            #[doc = "Wacom Inc. For example, the hardware id of a Wacom Grip"]
            #[doc = "Pen (a stylus) is 0x802."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn hardware_id_wacom(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                hardware_id_hi: u32,
                hardware_id_lo: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.hardware_id_wacom()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(hardware_id_hi)
                    .put_uint(hardware_id_lo)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event notifies the client of any capabilities of this tool,"]
            #[doc = "beyond the main set of x/y axes and tip up/down detection."]
            #[doc = ""]
            #[doc = "One event is sent for each extra capability available on this tool."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn capability(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                capability: Capability,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.capability()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(capability as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event signals the end of the initial burst of descriptive"]
            #[doc = "events. A client may consider the static description of the tool to"]
            #[doc = "be complete and finalize initialization of the tool."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent when the tool is removed from the system and will"]
            #[doc = "send no further events. Should the physical tool come back into"]
            #[doc = "proximity later, a new wp_tablet_tool object will be created."]
            #[doc = ""]
            #[doc = "It is compositor-dependent when a tool is removed. A compositor may"]
            #[doc = "remove a tool on proximity out, tablet removal or any other reason."]
            #[doc = "A compositor may also keep a tool alive until shutdown."]
            #[doc = ""]
            #[doc = "If the tool is currently in proximity, a proximity_out event will be"]
            #[doc = "sent before the removed event. See wp_tablet_tool.proximity_out for"]
            #[doc = "the handling of any buttons logically down."]
            #[doc = ""]
            #[doc = "When this event is received, the client must wp_tablet_tool.destroy"]
            #[doc = "the object."]
            async fn removed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.removed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notification that this tool is focused on a certain surface."]
            #[doc = ""]
            #[doc = "This event can be received when the tool has moved from one surface to"]
            #[doc = "another, or when the tool has come back into proximity above the"]
            #[doc = "surface."]
            #[doc = ""]
            #[doc = "If any button is logically down when the tool comes into proximity,"]
            #[doc = "the respective button event is sent after the proximity_in event but"]
            #[doc = "within the same frame as the proximity_in event."]
            async fn proximity_in(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                tablet: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.proximity_in()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(tablet))
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 6u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notification that this tool has either left proximity, or is no"]
            #[doc = "longer focused on a certain surface."]
            #[doc = ""]
            #[doc = "When the tablet tool leaves proximity of the tablet, button release"]
            #[doc = "events are sent for each button that was held down at the time of"]
            #[doc = "leaving proximity. These events are sent before the proximity_out"]
            #[doc = "event but within the same wp_tablet.frame."]
            #[doc = ""]
            #[doc = "If the tool stays within proximity of the tablet, but the focus"]
            #[doc = "changes from one surface to another, a button release event may not"]
            #[doc = "be sent until the button is actually released or the tool leaves the"]
            #[doc = "proximity of the tablet."]
            async fn proximity_out(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.proximity_out()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 7u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the tablet tool comes in contact with the surface of the"]
            #[doc = "tablet."]
            #[doc = ""]
            #[doc = "If the tool is already in contact with the tablet when entering the"]
            #[doc = "input region, the client owning said region will receive a"]
            #[doc = "wp_tablet.proximity_in event, followed by a wp_tablet.down"]
            #[doc = "event and a wp_tablet.frame event."]
            #[doc = ""]
            #[doc = "Note that this event describes logical contact, not physical"]
            #[doc = "contact. On some devices, a compositor may not consider a tool in"]
            #[doc = "logical contact until a minimum physical pressure threshold is"]
            #[doc = "exceeded."]
            async fn down(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.down()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 8u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the tablet tool stops making contact with the surface of"]
            #[doc = "the tablet, or when the tablet tool moves out of the input region"]
            #[doc = "and the compositor grab (if any) is dismissed."]
            #[doc = ""]
            #[doc = "If the tablet tool moves out of the input region while in contact"]
            #[doc = "with the surface of the tablet and the compositor does not have an"]
            #[doc = "ongoing grab on the surface, the client owning said region will"]
            #[doc = "receive a wp_tablet.up event, followed by a wp_tablet.proximity_out"]
            #[doc = "event and a wp_tablet.frame event. If the compositor has an ongoing"]
            #[doc = "grab on this device, this event sequence is sent whenever the grab"]
            #[doc = "is dismissed in the future."]
            #[doc = ""]
            #[doc = "Note that this event describes logical contact, not physical"]
            #[doc = "contact. On some devices, a compositor may not consider a tool out"]
            #[doc = "of logical contact until physical pressure falls below a specific"]
            #[doc = "threshold."]
            async fn up(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.up()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 9u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever a tablet tool moves."]
            async fn motion(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: crate::wire::Fixed,
                y: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.motion()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fixed(x)
                    .put_fixed(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 10u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the pressure axis on a tool changes. The value of this"]
            #[doc = "event is normalized to a value between 0 and 65535."]
            #[doc = ""]
            #[doc = "Note that pressure may be nonzero even when a tool is not in logical"]
            #[doc = "contact. See the down and up events for more details."]
            async fn pressure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                pressure: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.pressure()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(pressure)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 11u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the distance axis on a tool changes. The value of this"]
            #[doc = "event is normalized to a value between 0 and 65535."]
            #[doc = ""]
            #[doc = "Note that distance may be nonzero even when a tool is not in logical"]
            #[doc = "contact. See the down and up events for more details."]
            async fn distance(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                distance: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.distance()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(distance)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 12u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever one or both of the tilt axes on a tool change. Each tilt"]
            #[doc = "value is in degrees, relative to the z-axis of the tablet."]
            #[doc = "The angle is positive when the top of a tool tilts along the"]
            #[doc = "positive x or y axis."]
            async fn tilt(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tilt_x: crate::wire::Fixed,
                tilt_y: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.tilt()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fixed(tilt_x)
                    .put_fixed(tilt_y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 13u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the z-rotation axis on the tool changes. The"]
            #[doc = "rotation value is in degrees clockwise from the tool's"]
            #[doc = "logical neutral position."]
            async fn rotation(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                degrees: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.rotation()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fixed(degrees)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 14u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the slider position on the tool changes. The"]
            #[doc = "value is normalized between -65535 and 65535, with 0 as the logical"]
            #[doc = "neutral position of the slider."]
            #[doc = ""]
            #[doc = "The slider is available on e.g. the Wacom Airbrush tool."]
            async fn slider(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                position: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.slider()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(position).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 15u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the wheel on the tool emits an event. This event"]
            #[doc = "contains two values for the same axis change. The degrees value is"]
            #[doc = "in the same orientation as the wl_pointer.vertical_scroll axis. The"]
            #[doc = "clicks value is in discrete logical clicks of the mouse wheel. This"]
            #[doc = "value may be zero if the movement of the wheel was less"]
            #[doc = "than one logical click."]
            #[doc = ""]
            #[doc = "Clients should choose either value and avoid mixing degrees and"]
            #[doc = "clicks. The compositor may accumulate values smaller than a logical"]
            #[doc = "click and emulate click events when a certain threshold is met."]
            #[doc = "Thus, wl_tablet_tool.wheel events with non-zero clicks values may"]
            #[doc = "have different degrees values."]
            async fn wheel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                degrees: crate::wire::Fixed,
                clicks: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.wheel()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fixed(degrees)
                    .put_int(clicks)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 16u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever a button on the tool is pressed or released."]
            #[doc = ""]
            #[doc = "If a button is held down when the tool moves in or out of proximity,"]
            #[doc = "button events are generated by the compositor. See"]
            #[doc = "wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for"]
            #[doc = "details."]
            async fn button(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                button: u32,
                state: ButtonState,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.button()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(button)
                    .put_uint(state as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 17u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Marks the end of a series of axis and/or button updates from the"]
            #[doc = "tablet. The Wayland protocol requires axis updates to be sent"]
            #[doc = "sequentially, however all events within a frame should be considered"]
            #[doc = "one hardware event."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.frame()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(time).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 18u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "The wp_tablet interface represents one graphics tablet device. The"]
    #[doc = "tablet interface itself does not generate events; all events are"]
    #[doc = "generated by wp_tablet_tool objects when in proximity above a tablet."]
    #[doc = ""]
    #[doc = "A tablet has a number of static characteristics, e.g. device name and"]
    #[doc = "pid/vid. These capabilities are sent in an event sequence after the"]
    #[doc = "wp_tablet_seat.tablet_added event. This initial event sequence is"]
    #[doc = "terminated by a wp_tablet.done event."]
    pub mod zwp_tablet_v2 {
        #[doc = "Trait to implement the zwp_tablet_v2 interface. See the module level documentation for more info"]
        pub trait ZwpTabletV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This destroys the client's resource for this tablet object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "A descriptive name for the tablet device."]
            #[doc = ""]
            #[doc = "If the device has no descriptive name, this event is not sent."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet.done event."]
            async fn name(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v2#{}.name()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(name))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The USB vendor and product IDs for the tablet device."]
            #[doc = ""]
            #[doc = "If the device has no USB vendor/product ID, this event is not sent."]
            #[doc = "This can happen for virtual devices or non-USB devices, for instance."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet.done event."]
            async fn id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                vid: u32,
                pid: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v2#{}.id()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(vid)
                    .put_uint(pid)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "A system-specific device path that indicates which device is behind"]
            #[doc = "this wp_tablet. This information may be used to gather additional"]
            #[doc = "information about the device, e.g. through libwacom."]
            #[doc = ""]
            #[doc = "A device may have more than one device path. If so, multiple"]
            #[doc = "wp_tablet.path events are sent. A device may be emulated and not"]
            #[doc = "have a device path, and in that case this event will not be sent."]
            #[doc = ""]
            #[doc = "The format of the path is unspecified, it may be a device node, a"]
            #[doc = "sysfs path, or some other identifier. It is up to the client to"]
            #[doc = "identify the string provided."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet.done event."]
            async fn path(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                path: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v2#{}.path()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(path))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent immediately to signal the end of the initial"]
            #[doc = "burst of descriptive events. A client may consider the static"]
            #[doc = "description of the tablet to be complete and finalize initialization"]
            #[doc = "of the tablet."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v2#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent when the tablet has been removed from the system. When a tablet"]
            #[doc = "is removed, some tools may be removed."]
            #[doc = ""]
            #[doc = "When this event is received, the client must wp_tablet.destroy"]
            #[doc = "the object."]
            async fn removed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v2#{}.removed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A circular interaction area, such as the touch ring on the Wacom Intuos"]
    #[doc = "Pro series tablets."]
    #[doc = ""]
    #[doc = "Events on a ring are logically grouped by the wl_tablet_pad_ring.frame"]
    #[doc = "event."]
    pub mod zwp_tablet_pad_ring_v2 {
        #[doc = "Describes the source types for ring events. This indicates to the"]
        #[doc = "client how a ring event was physically generated; a client may"]
        #[doc = "adjust the user interface accordingly. For example, events"]
        #[doc = "from a \"finger\" source may trigger kinetic scrolling."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Source {
            #[doc = "finger"]
            Finger = 1u32,
        }
        impl TryFrom<u32> for Source {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::Finger),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwp_tablet_pad_ring_v2 interface. See the module level documentation for more info"]
        pub trait ZwpTabletPadRingV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_ring_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_pad_ring_v2#{}.set_feedback()", object.id);
                        self.set_feedback(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_pad_ring_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Request that the compositor use the provided feedback string"]
            #[doc = "associated with this ring. This request should be issued immediately"]
            #[doc = "after a wp_tablet_pad_group.mode_switch event from the corresponding"]
            #[doc = "group is received, or whenever the ring is mapped to a different"]
            #[doc = "action. See wp_tablet_pad_group.mode_switch for more details."]
            #[doc = ""]
            #[doc = "Clients are encouraged to provide context-aware descriptions for"]
            #[doc = "the actions associated with the ring; compositors may use this"]
            #[doc = "information to offer visual feedback about the button layout"]
            #[doc = "(eg. on-screen displays)."]
            #[doc = ""]
            #[doc = "The provided string 'description' is a UTF-8 encoded string to be"]
            #[doc = "associated with this ring, and is considered user-visible; general"]
            #[doc = "internationalization rules apply."]
            #[doc = ""]
            #[doc = "The serial argument will be that of the last"]
            #[doc = "wp_tablet_pad_group.mode_switch event received for the group of this"]
            #[doc = "ring. Requests providing other serials than the most recent one will be"]
            #[doc = "ignored."]
            async fn set_feedback(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                description: String,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This destroys the client's resource for this ring object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Source information for ring events."]
            #[doc = ""]
            #[doc = "This event does not occur on its own. It is sent before a"]
            #[doc = "wp_tablet_pad_ring.frame event and carries the source information"]
            #[doc = "for all events within that frame."]
            #[doc = ""]
            #[doc = "The source specifies how this event was generated. If the source is"]
            #[doc = "wp_tablet_pad_ring.source.finger, a wp_tablet_pad_ring.stop event"]
            #[doc = "will be sent when the user lifts the finger off the device."]
            #[doc = ""]
            #[doc = "This event is optional. If the source is unknown for an interaction,"]
            #[doc = "no event is sent."]
            async fn source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: Source,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_ring_v2#{}.source()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(source as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the angle on a ring changes."]
            #[doc = ""]
            #[doc = "The angle is provided in degrees clockwise from the logical"]
            #[doc = "north of the ring in the pad's current rotation."]
            async fn angle(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                degrees: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_ring_v2#{}.angle()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fixed(degrees)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Stop notification for ring events."]
            #[doc = ""]
            #[doc = "For some wp_tablet_pad_ring.source types, a wp_tablet_pad_ring.stop"]
            #[doc = "event is sent to notify a client that the interaction with the ring"]
            #[doc = "has terminated. This enables the client to implement kinetic scrolling."]
            #[doc = "See the wp_tablet_pad_ring.source documentation for information on"]
            #[doc = "when this event may be generated."]
            #[doc = ""]
            #[doc = "Any wp_tablet_pad_ring.angle events with the same source after this"]
            #[doc = "event should be considered as the start of a new interaction."]
            async fn stop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_ring_v2#{}.stop()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Indicates the end of a set of ring events that logically belong"]
            #[doc = "together. A client is expected to accumulate the data in all events"]
            #[doc = "within the frame before proceeding."]
            #[doc = ""]
            #[doc = "All wp_tablet_pad_ring events before a wp_tablet_pad_ring.frame event belong"]
            #[doc = "logically together. For example, on termination of a finger interaction"]
            #[doc = "on a ring the compositor will send a wp_tablet_pad_ring.source event,"]
            #[doc = "a wp_tablet_pad_ring.stop event and a wp_tablet_pad_ring.frame event."]
            #[doc = ""]
            #[doc = "A wp_tablet_pad_ring.frame event is sent for every logical event"]
            #[doc = "group, even if the group only contains a single wp_tablet_pad_ring"]
            #[doc = "event. Specifically, a client may get a sequence: angle, frame,"]
            #[doc = "angle, frame, etc."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_ring_v2#{}.frame()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(time).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A linear interaction area, such as the strips found in Wacom Cintiq"]
    #[doc = "models."]
    #[doc = ""]
    #[doc = "Events on a strip are logically grouped by the wl_tablet_pad_strip.frame"]
    #[doc = "event."]
    pub mod zwp_tablet_pad_strip_v2 {
        #[doc = "Describes the source types for strip events. This indicates to the"]
        #[doc = "client how a strip event was physically generated; a client may"]
        #[doc = "adjust the user interface accordingly. For example, events"]
        #[doc = "from a \"finger\" source may trigger kinetic scrolling."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Source {
            #[doc = "finger"]
            Finger = 1u32,
        }
        impl TryFrom<u32> for Source {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::Finger),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwp_tablet_pad_strip_v2 interface. See the module level documentation for more info"]
        pub trait ZwpTabletPadStripV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_strip_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_pad_strip_v2#{}.set_feedback()", object.id);
                        self.set_feedback(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_pad_strip_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Requests the compositor to use the provided feedback string"]
            #[doc = "associated with this strip. This request should be issued immediately"]
            #[doc = "after a wp_tablet_pad_group.mode_switch event from the corresponding"]
            #[doc = "group is received, or whenever the strip is mapped to a different"]
            #[doc = "action. See wp_tablet_pad_group.mode_switch for more details."]
            #[doc = ""]
            #[doc = "Clients are encouraged to provide context-aware descriptions for"]
            #[doc = "the actions associated with the strip, and compositors may use this"]
            #[doc = "information to offer visual feedback about the button layout"]
            #[doc = "(eg. on-screen displays)."]
            #[doc = ""]
            #[doc = "The provided string 'description' is a UTF-8 encoded string to be"]
            #[doc = "associated with this ring, and is considered user-visible; general"]
            #[doc = "internationalization rules apply."]
            #[doc = ""]
            #[doc = "The serial argument will be that of the last"]
            #[doc = "wp_tablet_pad_group.mode_switch event received for the group of this"]
            #[doc = "strip. Requests providing other serials than the most recent one will be"]
            #[doc = "ignored."]
            async fn set_feedback(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                description: String,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This destroys the client's resource for this strip object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Source information for strip events."]
            #[doc = ""]
            #[doc = "This event does not occur on its own. It is sent before a"]
            #[doc = "wp_tablet_pad_strip.frame event and carries the source information"]
            #[doc = "for all events within that frame."]
            #[doc = ""]
            #[doc = "The source specifies how this event was generated. If the source is"]
            #[doc = "wp_tablet_pad_strip.source.finger, a wp_tablet_pad_strip.stop event"]
            #[doc = "will be sent when the user lifts their finger off the device."]
            #[doc = ""]
            #[doc = "This event is optional. If the source is unknown for an interaction,"]
            #[doc = "no event is sent."]
            async fn source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: Source,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_strip_v2#{}.source()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(source as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the position on a strip changes."]
            #[doc = ""]
            #[doc = "The position is normalized to a range of [0, 65535], the 0-value"]
            #[doc = "represents the top-most and/or left-most position of the strip in"]
            #[doc = "the pad's current rotation."]
            async fn position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                position: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_strip_v2#{}.position()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(position)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Stop notification for strip events."]
            #[doc = ""]
            #[doc = "For some wp_tablet_pad_strip.source types, a wp_tablet_pad_strip.stop"]
            #[doc = "event is sent to notify a client that the interaction with the strip"]
            #[doc = "has terminated. This enables the client to implement kinetic"]
            #[doc = "scrolling. See the wp_tablet_pad_strip.source documentation for"]
            #[doc = "information on when this event may be generated."]
            #[doc = ""]
            #[doc = "Any wp_tablet_pad_strip.position events with the same source after this"]
            #[doc = "event should be considered as the start of a new interaction."]
            async fn stop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_strip_v2#{}.stop()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Indicates the end of a set of events that represent one logical"]
            #[doc = "hardware strip event. A client is expected to accumulate the data"]
            #[doc = "in all events within the frame before proceeding."]
            #[doc = ""]
            #[doc = "All wp_tablet_pad_strip events before a wp_tablet_pad_strip.frame event belong"]
            #[doc = "logically together. For example, on termination of a finger interaction"]
            #[doc = "on a strip the compositor will send a wp_tablet_pad_strip.source event,"]
            #[doc = "a wp_tablet_pad_strip.stop event and a wp_tablet_pad_strip.frame"]
            #[doc = "event."]
            #[doc = ""]
            #[doc = "A wp_tablet_pad_strip.frame event is sent for every logical event"]
            #[doc = "group, even if the group only contains a single wp_tablet_pad_strip"]
            #[doc = "event. Specifically, a client may get a sequence: position, frame,"]
            #[doc = "position, frame, etc."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_strip_v2#{}.frame()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(time).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A pad group describes a distinct (sub)set of buttons, rings and strips"]
    #[doc = "present in the tablet. The criteria of this grouping is usually positional,"]
    #[doc = "eg. if a tablet has buttons on the left and right side, 2 groups will be"]
    #[doc = "presented. The physical arrangement of groups is undisclosed and may"]
    #[doc = "change on the fly."]
    #[doc = ""]
    #[doc = "Pad groups will announce their features during pad initialization. Between"]
    #[doc = "the corresponding wp_tablet_pad.group event and wp_tablet_pad_group.done, the"]
    #[doc = "pad group will announce the buttons, rings and strips contained in it,"]
    #[doc = "plus the number of supported modes."]
    #[doc = ""]
    #[doc = "Modes are a mechanism to allow multiple groups of actions for every element"]
    #[doc = "in the pad group. The number of groups and available modes in each is"]
    #[doc = "persistent across device plugs. The current mode is user-switchable, it"]
    #[doc = "will be announced through the wp_tablet_pad_group.mode_switch event both"]
    #[doc = "whenever it is switched, and after wp_tablet_pad.enter."]
    #[doc = ""]
    #[doc = "The current mode logically applies to all elements in the pad group,"]
    #[doc = "although it is at clients' discretion whether to actually perform different"]
    #[doc = "actions, and/or issue the respective .set_feedback requests to notify the"]
    #[doc = "compositor. See the wp_tablet_pad_group.mode_switch event for more details."]
    pub mod zwp_tablet_pad_group_v2 {
        #[doc = "Trait to implement the zwp_tablet_pad_group_v2 interface. See the module level documentation for more info"]
        pub trait ZwpTabletPadGroupV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_group_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_pad_group_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the wp_tablet_pad_group object. Objects created from this object"]
            #[doc = "are unaffected and should be destroyed separately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sent on wp_tablet_pad_group initialization to announce the available"]
            #[doc = "buttons in the group. Button indices start at 0, a button may only be"]
            #[doc = "in one group at a time."]
            #[doc = ""]
            #[doc = "This event is first sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad_group.done event."]
            #[doc = ""]
            #[doc = "Some buttons are reserved by the compositor. These buttons may not be"]
            #[doc = "assigned to any wp_tablet_pad_group. Compositors may broadcast this"]
            #[doc = "event in the case of changes to the mapping of these reserved buttons."]
            #[doc = "If the compositor happens to reserve all buttons in a group, this event"]
            #[doc = "will be sent with an empty array."]
            async fn buttons(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buttons: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.buttons()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_array(buttons)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent on wp_tablet_pad_group initialization to announce available rings."]
            #[doc = "One event is sent for each ring available on this pad group."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad_group.done event."]
            async fn ring(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                ring: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.ring()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(ring))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent on wp_tablet_pad initialization to announce available strips."]
            #[doc = "One event is sent for each strip available on this pad group."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad_group.done event."]
            async fn strip(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                strip: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.strip()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(strip))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent on wp_tablet_pad_group initialization to announce that the pad"]
            #[doc = "group may switch between modes. A client may use a mode to store a"]
            #[doc = "specific configuration for buttons, rings and strips and use the"]
            #[doc = "wl_tablet_pad_group.mode_switch event to toggle between these"]
            #[doc = "configurations. Mode indices start at 0."]
            #[doc = ""]
            #[doc = "Switching modes is compositor-dependent. See the"]
            #[doc = "wp_tablet_pad_group.mode_switch event for more details."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad_group.done event. This event is only sent when more than"]
            #[doc = "more than one mode is available."]
            async fn modes(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                modes: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.modes()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(modes).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent immediately to signal the end of the initial"]
            #[doc = "burst of descriptive events. A client may consider the static"]
            #[doc = "description of the tablet to be complete and finalize initialization"]
            #[doc = "of the tablet group."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notification that the mode was switched."]
            #[doc = ""]
            #[doc = "A mode applies to all buttons, rings and strips in a group"]
            #[doc = "simultaneously, but a client is not required to assign different actions"]
            #[doc = "for each mode. For example, a client may have mode-specific button"]
            #[doc = "mappings but map the ring to vertical scrolling in all modes. Mode"]
            #[doc = "indices start at 0."]
            #[doc = ""]
            #[doc = "Switching modes is compositor-dependent. The compositor may provide"]
            #[doc = "visual cues to the user about the mode, e.g. by toggling LEDs on"]
            #[doc = "the tablet device. Mode-switching may be software-controlled or"]
            #[doc = "controlled by one or more physical buttons. For example, on a Wacom"]
            #[doc = "Intuos Pro, the button inside the ring may be assigned to switch"]
            #[doc = "between modes."]
            #[doc = ""]
            #[doc = "The compositor will also send this event after wp_tablet_pad.enter on"]
            #[doc = "each group in order to notify of the current mode. Groups that only"]
            #[doc = "feature one mode will use mode=0 when emitting this event."]
            #[doc = ""]
            #[doc = "If a button action in the new mode differs from the action in the"]
            #[doc = "previous mode, the client should immediately issue a"]
            #[doc = "wp_tablet_pad.set_feedback request for each changed button."]
            #[doc = ""]
            #[doc = "If a ring or strip action in the new mode differs from the action"]
            #[doc = "in the previous mode, the client should immediately issue a"]
            #[doc = "wp_tablet_ring.set_feedback or wp_tablet_strip.set_feedback request"]
            #[doc = "for each changed ring or strip."]
            async fn mode_switch(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                serial: u32,
                mode: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.mode_switch()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_uint(serial)
                    .put_uint(mode)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A pad device is a set of buttons, rings and strips"]
    #[doc = "usually physically present on the tablet device itself. Some"]
    #[doc = "exceptions exist where the pad device is physically detached, e.g. the"]
    #[doc = "Wacom ExpressKey Remote."]
    #[doc = ""]
    #[doc = "Pad devices have no axes that control the cursor and are generally"]
    #[doc = "auxiliary devices to the tool devices used on the tablet surface."]
    #[doc = ""]
    #[doc = "A pad device has a number of static characteristics, e.g. the number"]
    #[doc = "of rings. These capabilities are sent in an event sequence after the"]
    #[doc = "wp_tablet_seat.pad_added event before any actual events from this pad."]
    #[doc = "This initial event sequence is terminated by a wp_tablet_pad.done"]
    #[doc = "event."]
    #[doc = ""]
    #[doc = "All pad features (buttons, rings and strips) are logically divided into"]
    #[doc = "groups and all pads have at least one group. The available groups are"]
    #[doc = "notified through the wp_tablet_pad.group event; the compositor will"]
    #[doc = "emit one event per group before emitting wp_tablet_pad.done."]
    #[doc = ""]
    #[doc = "Groups may have multiple modes. Modes allow clients to map multiple"]
    #[doc = "actions to a single pad feature. Only one mode can be active per group,"]
    #[doc = "although different groups may have different active modes."]
    pub mod zwp_tablet_pad_v2 {
        #[doc = "Describes the physical state of a button that caused the button"]
        #[doc = "event."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ButtonState {
            #[doc = "the button is not pressed"]
            Released = 0u32,
            #[doc = "the button is pressed"]
            Pressed = 1u32,
        }
        impl TryFrom<u32> for ButtonState {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Released),
                    1u32 => Ok(Self::Pressed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwp_tablet_pad_v2 interface. See the module level documentation for more info"]
        pub trait ZwpTabletPadV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_pad_v2#{}.set_feedback()", object.id);
                        self.set_feedback(
                            object,
                            client,
                            message.uint()?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_pad_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Requests the compositor to use the provided feedback string"]
            #[doc = "associated with this button. This request should be issued immediately"]
            #[doc = "after a wp_tablet_pad_group.mode_switch event from the corresponding"]
            #[doc = "group is received, or whenever a button is mapped to a different"]
            #[doc = "action. See wp_tablet_pad_group.mode_switch for more details."]
            #[doc = ""]
            #[doc = "Clients are encouraged to provide context-aware descriptions for"]
            #[doc = "the actions associated with each button, and compositors may use"]
            #[doc = "this information to offer visual feedback on the button layout"]
            #[doc = "(e.g. on-screen displays)."]
            #[doc = ""]
            #[doc = "Button indices start at 0. Setting the feedback string on a button"]
            #[doc = "that is reserved by the compositor (i.e. not belonging to any"]
            #[doc = "wp_tablet_pad_group) does not generate an error but the compositor"]
            #[doc = "is free to ignore the request."]
            #[doc = ""]
            #[doc = "The provided string 'description' is a UTF-8 encoded string to be"]
            #[doc = "associated with this ring, and is considered user-visible; general"]
            #[doc = "internationalization rules apply."]
            #[doc = ""]
            #[doc = "The serial argument will be that of the last"]
            #[doc = "wp_tablet_pad_group.mode_switch event received for the group of this"]
            #[doc = "button. Requests providing other serials than the most recent one will"]
            #[doc = "be ignored."]
            async fn set_feedback(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                button: u32,
                description: String,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the wp_tablet_pad object. Objects created from this object"]
            #[doc = "are unaffected and should be destroyed separately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sent on wp_tablet_pad initialization to announce available groups."]
            #[doc = "One event is sent for each pad group available."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad.done event. At least one group will be announced."]
            async fn group(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                pad_group: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.group()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(pad_group))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "A system-specific device path that indicates which device is behind"]
            #[doc = "this wp_tablet_pad. This information may be used to gather additional"]
            #[doc = "information about the device, e.g. through libwacom."]
            #[doc = ""]
            #[doc = "The format of the path is unspecified, it may be a device node, a"]
            #[doc = "sysfs path, or some other identifier. It is up to the client to"]
            #[doc = "identify the string provided."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad.done event."]
            async fn path(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                path: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.path()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(path))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent on wp_tablet_pad initialization to announce the available"]
            #[doc = "buttons."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad.done event. This event is only sent when at least one"]
            #[doc = "button is available."]
            async fn buttons(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buttons: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.buttons()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(buttons).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event signals the end of the initial burst of descriptive"]
            #[doc = "events. A client may consider the static description of the pad to"]
            #[doc = "be complete and finalize initialization of the pad."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the physical state of a button changes."]
            async fn button(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                button: u32,
                state: ButtonState,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.button()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_uint(button)
                    .put_uint(state as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notification that this pad is focused on the specified surface."]
            async fn enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                tablet: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.enter()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(tablet))
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notification that this pad is no longer focused on the specified"]
            #[doc = "surface."]
            async fn leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.leave()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 6u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent when the pad has been removed from the system. When a tablet"]
            #[doc = "is removed its pad(s) will be removed too."]
            #[doc = ""]
            #[doc = "When this event is received, the client must destroy all rings, strips"]
            #[doc = "and groups that were offered by this pad, and issue wp_tablet_pad.destroy"]
            #[doc = "the pad itself."]
            async fn removed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.removed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 7u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod viewporter {
    #[doc = "The global interface exposing surface cropping and scaling"]
    #[doc = "capabilities is used to instantiate an interface extension for a"]
    #[doc = "wl_surface object. This extended interface will then allow"]
    #[doc = "cropping and scaling the surface contents, effectively"]
    #[doc = "disconnecting the direct relationship between the buffer and the"]
    #[doc = "surface size."]
    pub mod wp_viewporter {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "the surface already has a viewport object associated"]
            ViewportExists = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::ViewportExists),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wp_viewporter interface. See the module level documentation for more info"]
        pub trait WpViewporter: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_viewporter";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_viewporter#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("wp_viewporter#{}.get_viewport()", object.id);
                        self.get_viewport(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Informs the server that the client will not be using this"]
            #[doc = "protocol object anymore. This does not affect any other objects,"]
            #[doc = "wp_viewport objects included."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Instantiate an interface extension for the given wl_surface to"]
            #[doc = "crop and scale its content. If the given wl_surface already has"]
            #[doc = "a wp_viewport object associated, the viewport_exists"]
            #[doc = "protocol error is raised."]
            async fn get_viewport(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "An additional interface to a wl_surface object, which allows the"]
    #[doc = "client to specify the cropping and scaling of the surface"]
    #[doc = "contents."]
    #[doc = ""]
    #[doc = "This interface works with two concepts: the source rectangle (src_x,"]
    #[doc = "src_y, src_width, src_height), and the destination size (dst_width,"]
    #[doc = "dst_height). The contents of the source rectangle are scaled to the"]
    #[doc = "destination size, and content outside the source rectangle is ignored."]
    #[doc = "This state is double-buffered, see wl_surface.commit."]
    #[doc = ""]
    #[doc = "The two parts of crop and scale state are independent: the source"]
    #[doc = "rectangle, and the destination size. Initially both are unset, that"]
    #[doc = "is, no scaling is applied. The whole of the current wl_buffer is"]
    #[doc = "used as the source, and the surface size is as defined in"]
    #[doc = "wl_surface.attach."]
    #[doc = ""]
    #[doc = "If the destination size is set, it causes the surface size to become"]
    #[doc = "dst_width, dst_height. The source (rectangle) is scaled to exactly"]
    #[doc = "this size. This overrides whatever the attached wl_buffer size is,"]
    #[doc = "unless the wl_buffer is NULL. If the wl_buffer is NULL, the surface"]
    #[doc = "has no content and therefore no size. Otherwise, the size is always"]
    #[doc = "at least 1x1 in surface local coordinates."]
    #[doc = ""]
    #[doc = "If the source rectangle is set, it defines what area of the wl_buffer is"]
    #[doc = "taken as the source. If the source rectangle is set and the destination"]
    #[doc = "size is not set, then src_width and src_height must be integers, and the"]
    #[doc = "surface size becomes the source rectangle size. This results in cropping"]
    #[doc = "without scaling. If src_width or src_height are not integers and"]
    #[doc = "destination size is not set, the bad_size protocol error is raised when"]
    #[doc = "the surface state is applied."]
    #[doc = ""]
    #[doc = "The coordinate transformations from buffer pixel coordinates up to"]
    #[doc = "the surface-local coordinates happen in the following order:"]
    #[doc = "1. buffer_transform (wl_surface.set_buffer_transform)"]
    #[doc = "2. buffer_scale (wl_surface.set_buffer_scale)"]
    #[doc = "3. crop and scale (wp_viewport.set*)"]
    #[doc = "This means, that the source rectangle coordinates of crop and scale"]
    #[doc = "are given in the coordinates after the buffer transform and scale,"]
    #[doc = "i.e. in the coordinates that would be the surface-local coordinates"]
    #[doc = "if the crop and scale was not applied."]
    #[doc = ""]
    #[doc = "If src_x or src_y are negative, the bad_value protocol error is raised."]
    #[doc = "Otherwise, if the source rectangle is partially or completely outside of"]
    #[doc = "the non-NULL wl_buffer, then the out_of_buffer protocol error is raised"]
    #[doc = "when the surface state is applied. A NULL wl_buffer does not raise the"]
    #[doc = "out_of_buffer error."]
    #[doc = ""]
    #[doc = "If the wl_surface associated with the wp_viewport is destroyed,"]
    #[doc = "all wp_viewport requests except 'destroy' raise the protocol error"]
    #[doc = "no_surface."]
    #[doc = ""]
    #[doc = "If the wp_viewport object is destroyed, the crop and scale"]
    #[doc = "state is removed from the wl_surface. The change will be applied"]
    #[doc = "on the next wl_surface.commit."]
    pub mod wp_viewport {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "negative or zero values in width or height"]
            BadValue = 0u32,
            #[doc = "destination size is not integer"]
            BadSize = 1u32,
            #[doc = "source rectangle extends outside of the content area"]
            OutOfBuffer = 2u32,
            #[doc = "the wl_surface was destroyed"]
            NoSurface = 3u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::BadValue),
                    1u32 => Ok(Self::BadSize),
                    2u32 => Ok(Self::OutOfBuffer),
                    3u32 => Ok(Self::NoSurface),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wp_viewport interface. See the module level documentation for more info"]
        pub trait WpViewport: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_viewport";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_viewport#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("wp_viewport#{}.set_source()", object.id);
                        self.set_source(
                            object,
                            client,
                            message.fixed()?,
                            message.fixed()?,
                            message.fixed()?,
                            message.fixed()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("wp_viewport#{}.set_destination()", object.id);
                        self.set_destination(object, client, message.int()?, message.int()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "The associated wl_surface's crop and scale state is removed."]
            #[doc = "The change is applied on the next wl_surface.commit."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the source rectangle of the associated wl_surface. See"]
            #[doc = "wp_viewport for the description, and relation to the wl_buffer"]
            #[doc = "size."]
            #[doc = ""]
            #[doc = "If all of x, y, width and height are -1.0, the source rectangle is"]
            #[doc = "unset instead. Any other set of values where width or height are zero"]
            #[doc = "or negative, or x or y are negative, raise the bad_value protocol"]
            #[doc = "error."]
            #[doc = ""]
            #[doc = "The crop and scale state is double-buffered, see wl_surface.commit."]
            async fn set_source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: crate::wire::Fixed,
                y: crate::wire::Fixed,
                width: crate::wire::Fixed,
                height: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            #[doc = "Set the destination size of the associated wl_surface. See"]
            #[doc = "wp_viewport for the description, and relation to the wl_buffer"]
            #[doc = "size."]
            #[doc = ""]
            #[doc = "If width is -1 and height is -1, the destination size is unset"]
            #[doc = "instead. Any other pair of values for width and height that"]
            #[doc = "contains zero or negative values raises the bad_value protocol"]
            #[doc = "error."]
            #[doc = ""]
            #[doc = "The crop and scale state is double-buffered, see wl_surface.commit."]
            async fn set_destination(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod xdg_shell {
    #[doc = "The xdg_wm_base interface is exposed as a global object enabling clients"]
    #[doc = "to turn their wl_surfaces into windows in a desktop environment. It"]
    #[doc = "defines the basic functionality needed for clients and the compositor to"]
    #[doc = "create windows that can be dragged, resized, maximized, etc, as well as"]
    #[doc = "creating transient windows such as popup menus."]
    pub mod xdg_wm_base {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "given wl_surface has another role"]
            Role = 0u32,
            #[doc = "xdg_wm_base was destroyed before children"]
            DefunctSurfaces = 1u32,
            #[doc = "the client tried to map or destroy a non-topmost popup"]
            NotTheTopmostPopup = 2u32,
            #[doc = "the client specified an invalid popup parent surface"]
            InvalidPopupParent = 3u32,
            #[doc = "the client provided an invalid surface state"]
            InvalidSurfaceState = 4u32,
            #[doc = "the client provided an invalid positioner"]
            InvalidPositioner = 5u32,
            #[doc = "the client didn’t respond to a ping event in time"]
            Unresponsive = 6u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Role),
                    1u32 => Ok(Self::DefunctSurfaces),
                    2u32 => Ok(Self::NotTheTopmostPopup),
                    3u32 => Ok(Self::InvalidPopupParent),
                    4u32 => Ok(Self::InvalidSurfaceState),
                    5u32 => Ok(Self::InvalidPositioner),
                    6u32 => Ok(Self::Unresponsive),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the xdg_wm_base interface. See the module level documentation for more info"]
        pub trait XdgWmBase: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_wm_base";
            const VERSION: u32 = 6u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_wm_base#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_wm_base#{}.create_positioner()", object.id);
                        self.create_positioner(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("xdg_wm_base#{}.get_xdg_surface()", object.id);
                        self.get_xdg_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("xdg_wm_base#{}.pong()", object.id);
                        self.pong(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy this xdg_wm_base object."]
            #[doc = ""]
            #[doc = "Destroying a bound xdg_wm_base object while there are surfaces"]
            #[doc = "still alive created by this xdg_wm_base object instance is illegal"]
            #[doc = "and will result in a defunct_surfaces error."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a positioner object. A positioner object is used to position"]
            #[doc = "surfaces relative to some parent surface. See the interface description"]
            #[doc = "and xdg_surface.get_popup for details."]
            async fn create_positioner(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This creates an xdg_surface for the given surface. While xdg_surface"]
            #[doc = "itself is not a role, the corresponding surface may only be assigned"]
            #[doc = "a role extending xdg_surface, such as xdg_toplevel or xdg_popup. It is"]
            #[doc = "illegal to create an xdg_surface for a wl_surface which already has an"]
            #[doc = "assigned role and this will result in a role error."]
            #[doc = ""]
            #[doc = "This creates an xdg_surface for the given surface. An xdg_surface is"]
            #[doc = "used as basis to define a role to a given surface, such as xdg_toplevel"]
            #[doc = "or xdg_popup. It also manages functionality shared between xdg_surface"]
            #[doc = "based surface roles."]
            #[doc = ""]
            #[doc = "See the documentation of xdg_surface for more details about what an"]
            #[doc = "xdg_surface is and how it is used."]
            async fn get_xdg_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "A client must respond to a ping event with a pong request or"]
            #[doc = "the client may be deemed unresponsive. See xdg_wm_base.ping"]
            #[doc = "and xdg_wm_base.error.unresponsive."]
            async fn pong(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "The ping event asks the client if it's still alive. Pass the"]
            #[doc = "serial specified in the event back to the compositor by sending"]
            #[doc = "a \"pong\" request back with the specified serial. See xdg_wm_base.pong."]
            #[doc = ""]
            #[doc = "Compositors can use this to determine if the client is still"]
            #[doc = "alive. It's unspecified what will happen if the client doesn't"]
            #[doc = "respond to the ping request, or in what timeframe. Clients should"]
            #[doc = "try to respond in a reasonable amount of time. The “unresponsive”"]
            #[doc = "error is provided for compositors that wish to disconnect unresponsive"]
            #[doc = "clients."]
            #[doc = ""]
            #[doc = "A compositor is free to ping in any way it wants, but a client must"]
            #[doc = "always respond to any xdg_wm_base object it created."]
            async fn ping(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_wm_base#{}.ping()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "The xdg_positioner provides a collection of rules for the placement of a"]
    #[doc = "child surface relative to a parent surface. Rules can be defined to ensure"]
    #[doc = "the child surface remains within the visible area's borders, and to"]
    #[doc = "specify how the child surface changes its position, such as sliding along"]
    #[doc = "an axis, or flipping around a rectangle. These positioner-created rules are"]
    #[doc = "constrained by the requirement that a child surface must intersect with or"]
    #[doc = "be at least partially adjacent to its parent surface."]
    #[doc = ""]
    #[doc = "See the various requests for details about possible rules."]
    #[doc = ""]
    #[doc = "At the time of the request, the compositor makes a copy of the rules"]
    #[doc = "specified by the xdg_positioner. Thus, after the request is complete the"]
    #[doc = "xdg_positioner object can be destroyed or reused; further changes to the"]
    #[doc = "object will have no effect on previous usages."]
    #[doc = ""]
    #[doc = "For an xdg_positioner object to be considered complete, it must have a"]
    #[doc = "non-zero size set by set_size, and a non-zero anchor rectangle set by"]
    #[doc = "set_anchor_rect. Passing an incomplete xdg_positioner object when"]
    #[doc = "positioning a surface raises an invalid_positioner error."]
    pub mod xdg_positioner {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "invalid input provided"]
            InvalidInput = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidInput),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Anchor {
            None = 0u32,
            Top = 1u32,
            Bottom = 2u32,
            Left = 3u32,
            Right = 4u32,
            TopLeft = 5u32,
            BottomLeft = 6u32,
            TopRight = 7u32,
            BottomRight = 8u32,
        }
        impl TryFrom<u32> for Anchor {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::None),
                    1u32 => Ok(Self::Top),
                    2u32 => Ok(Self::Bottom),
                    3u32 => Ok(Self::Left),
                    4u32 => Ok(Self::Right),
                    5u32 => Ok(Self::TopLeft),
                    6u32 => Ok(Self::BottomLeft),
                    7u32 => Ok(Self::TopRight),
                    8u32 => Ok(Self::BottomRight),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Gravity {
            None = 0u32,
            Top = 1u32,
            Bottom = 2u32,
            Left = 3u32,
            Right = 4u32,
            TopLeft = 5u32,
            BottomLeft = 6u32,
            TopRight = 7u32,
            BottomRight = 8u32,
        }
        impl TryFrom<u32> for Gravity {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::None),
                    1u32 => Ok(Self::Top),
                    2u32 => Ok(Self::Bottom),
                    3u32 => Ok(Self::Left),
                    4u32 => Ok(Self::Right),
                    5u32 => Ok(Self::TopLeft),
                    6u32 => Ok(Self::BottomLeft),
                    7u32 => Ok(Self::TopRight),
                    8u32 => Ok(Self::BottomRight),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! { # [doc = "The constraint adjustment value define ways the compositor will adjust"] # [doc = "the position of the surface, if the unadjusted position would result"] # [doc = "in the surface being partly constrained."] # [doc = ""] # [doc = "Whether a surface is considered 'constrained' is left to the compositor"] # [doc = "to determine. For example, the surface may be partly outside the"] # [doc = "compositor's defined 'work area', thus necessitating the child surface's"] # [doc = "position be adjusted until it is entirely inside the work area."] # [doc = ""] # [doc = "The adjustments can be combined, according to a defined precedence: 1)"] # [doc = "Flip, 2) Slide, 3) Resize."] # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct ConstraintAdjustment : u32 { const None = 0u32 ; const SlideX = 1u32 ; const SlideY = 2u32 ; const FlipX = 4u32 ; const FlipY = 8u32 ; const ResizeX = 16u32 ; const ResizeY = 32u32 ; } }
        impl TryFrom<u32> for ConstraintAdjustment {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "Trait to implement the xdg_positioner interface. See the module level documentation for more info"]
        pub trait XdgPositioner: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_positioner";
            const VERSION: u32 = 6u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_positioner#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_positioner#{}.set_size()", object.id);
                        self.set_size(object, client, message.int()?, message.int()?)
                            .await
                    }
                    2u16 => {
                        tracing::debug!("xdg_positioner#{}.set_anchor_rect()", object.id);
                        self.set_anchor_rect(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("xdg_positioner#{}.set_anchor()", object.id);
                        self.set_anchor(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    4u16 => {
                        tracing::debug!("xdg_positioner#{}.set_gravity()", object.id);
                        self.set_gravity(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    5u16 => {
                        tracing::debug!("xdg_positioner#{}.set_constraint_adjustment()", object.id);
                        self.set_constraint_adjustment(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    6u16 => {
                        tracing::debug!("xdg_positioner#{}.set_offset()", object.id);
                        self.set_offset(object, client, message.int()?, message.int()?)
                            .await
                    }
                    7u16 => {
                        tracing::debug!("xdg_positioner#{}.set_reactive()", object.id);
                        self.set_reactive(object, client).await
                    }
                    8u16 => {
                        tracing::debug!("xdg_positioner#{}.set_parent_size()", object.id);
                        self.set_parent_size(object, client, message.int()?, message.int()?)
                            .await
                    }
                    9u16 => {
                        tracing::debug!("xdg_positioner#{}.set_parent_configure()", object.id);
                        self.set_parent_configure(object, client, message.uint()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Notify the compositor that the xdg_positioner will no longer be used."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the size of the surface that is to be positioned with the positioner"]
            #[doc = "object. The size is in surface-local coordinates and corresponds to the"]
            #[doc = "window geometry. See xdg_surface.set_window_geometry."]
            #[doc = ""]
            #[doc = "If a zero or negative size is set the invalid_input error is raised."]
            async fn set_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Specify the anchor rectangle within the parent surface that the child"]
            #[doc = "surface will be placed relative to. The rectangle is relative to the"]
            #[doc = "window geometry as defined by xdg_surface.set_window_geometry of the"]
            #[doc = "parent surface."]
            #[doc = ""]
            #[doc = "When the xdg_positioner object is used to position a child surface, the"]
            #[doc = "anchor rectangle may not extend outside the window geometry of the"]
            #[doc = "positioned child's parent surface."]
            #[doc = ""]
            #[doc = "If a negative size is set the invalid_input error is raised."]
            async fn set_anchor_rect(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Defines the anchor point for the anchor rectangle. The specified anchor"]
            #[doc = "is used derive an anchor point that the child surface will be"]
            #[doc = "positioned relative to. If a corner anchor is set (e.g. 'top_left' or"]
            #[doc = "'bottom_right'), the anchor point will be at the specified corner;"]
            #[doc = "otherwise, the derived anchor point will be centered on the specified"]
            #[doc = "edge, or in the center of the anchor rectangle if no edge is specified."]
            async fn set_anchor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                anchor: Anchor,
            ) -> crate::server::Result<()>;
            #[doc = "Defines in what direction a surface should be positioned, relative to"]
            #[doc = "the anchor point of the parent surface. If a corner gravity is"]
            #[doc = "specified (e.g. 'bottom_right' or 'top_left'), then the child surface"]
            #[doc = "will be placed towards the specified gravity; otherwise, the child"]
            #[doc = "surface will be centered over the anchor point on any axis that had no"]
            #[doc = "gravity specified. If the gravity is not in the ‘gravity’ enum, an"]
            #[doc = "invalid_input error is raised."]
            async fn set_gravity(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                gravity: Gravity,
            ) -> crate::server::Result<()>;
            #[doc = "Specify how the window should be positioned if the originally intended"]
            #[doc = "position caused the surface to be constrained, meaning at least"]
            #[doc = "partially outside positioning boundaries set by the compositor. The"]
            #[doc = "adjustment is set by constructing a bitmask describing the adjustment to"]
            #[doc = "be made when the surface is constrained on that axis."]
            #[doc = ""]
            #[doc = "If no bit for one axis is set, the compositor will assume that the child"]
            #[doc = "surface should not change its position on that axis when constrained."]
            #[doc = ""]
            #[doc = "If more than one bit for one axis is set, the order of how adjustments"]
            #[doc = "are applied is specified in the corresponding adjustment descriptions."]
            #[doc = ""]
            #[doc = "The default adjustment is none."]
            async fn set_constraint_adjustment(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                constraint_adjustment: ConstraintAdjustment,
            ) -> crate::server::Result<()>;
            #[doc = "Specify the surface position offset relative to the position of the"]
            #[doc = "anchor on the anchor rectangle and the anchor on the surface. For"]
            #[doc = "example if the anchor of the anchor rectangle is at (x, y), the surface"]
            #[doc = "has the gravity bottom|right, and the offset is (ox, oy), the calculated"]
            #[doc = "surface position will be (x + ox, y + oy). The offset position of the"]
            #[doc = "surface is the one used for constraint testing. See"]
            #[doc = "set_constraint_adjustment."]
            #[doc = ""]
            #[doc = "An example use case is placing a popup menu on top of a user interface"]
            #[doc = "element, while aligning the user interface element of the parent surface"]
            #[doc = "with some user interface element placed somewhere in the popup surface."]
            async fn set_offset(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "When set reactive, the surface is reconstrained if the conditions used"]
            #[doc = "for constraining changed, e.g. the parent window moved."]
            #[doc = ""]
            #[doc = "If the conditions changed and the popup was reconstrained, an"]
            #[doc = "xdg_popup.configure event is sent with updated geometry, followed by an"]
            #[doc = "xdg_surface.configure event."]
            async fn set_reactive(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the parent window geometry the compositor should use when"]
            #[doc = "positioning the popup. The compositor may use this information to"]
            #[doc = "determine the future state the popup should be constrained using. If"]
            #[doc = "this doesn't match the dimension of the parent the popup is eventually"]
            #[doc = "positioned against, the behavior is undefined."]
            #[doc = ""]
            #[doc = "The arguments are given in the surface-local coordinate space."]
            async fn set_parent_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                parent_width: i32,
                parent_height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Set the serial of an xdg_surface.configure event this positioner will be"]
            #[doc = "used in response to. The compositor may use this information together"]
            #[doc = "with set_parent_size to determine what future state the popup should be"]
            #[doc = "constrained using."]
            async fn set_parent_configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "An interface that may be implemented by a wl_surface, for"]
    #[doc = "implementations that provide a desktop-style user interface."]
    #[doc = ""]
    #[doc = "It provides a base set of functionality required to construct user"]
    #[doc = "interface elements requiring management by the compositor, such as"]
    #[doc = "toplevel windows, menus, etc. The types of functionality are split into"]
    #[doc = "xdg_surface roles."]
    #[doc = ""]
    #[doc = "Creating an xdg_surface does not set the role for a wl_surface. In order"]
    #[doc = "to map an xdg_surface, the client must create a role-specific object"]
    #[doc = "using, e.g., get_toplevel, get_popup. The wl_surface for any given"]
    #[doc = "xdg_surface can have at most one role, and may not be assigned any role"]
    #[doc = "not based on xdg_surface."]
    #[doc = ""]
    #[doc = "A role must be assigned before any other requests are made to the"]
    #[doc = "xdg_surface object."]
    #[doc = ""]
    #[doc = "The client must call wl_surface.commit on the corresponding wl_surface"]
    #[doc = "for the xdg_surface state to take effect."]
    #[doc = ""]
    #[doc = "Creating an xdg_surface from a wl_surface which has a buffer attached or"]
    #[doc = "committed is a client error, and any attempts by a client to attach or"]
    #[doc = "manipulate a buffer prior to the first xdg_surface.configure call must"]
    #[doc = "also be treated as errors."]
    #[doc = ""]
    #[doc = "After creating a role-specific object and setting it up, the client must"]
    #[doc = "perform an initial commit without any buffer attached. The compositor"]
    #[doc = "will reply with initial wl_surface state such as"]
    #[doc = "wl_surface.preferred_buffer_scale followed by an xdg_surface.configure"]
    #[doc = "event. The client must acknowledge it and is then allowed to attach a"]
    #[doc = "buffer to map the surface."]
    #[doc = ""]
    #[doc = "Mapping an xdg_surface-based role surface is defined as making it"]
    #[doc = "possible for the surface to be shown by the compositor. Note that"]
    #[doc = "a mapped surface is not guaranteed to be visible once it is mapped."]
    #[doc = ""]
    #[doc = "For an xdg_surface to be mapped by the compositor, the following"]
    #[doc = "conditions must be met:"]
    #[doc = "(1) the client has assigned an xdg_surface-based role to the surface"]
    #[doc = "(2) the client has set and committed the xdg_surface state and the"]
    #[doc = "role-dependent state to the surface"]
    #[doc = "(3) the client has committed a buffer to the surface"]
    #[doc = ""]
    #[doc = "A newly-unmapped surface is considered to have met condition (1) out"]
    #[doc = "of the 3 required conditions for mapping a surface if its role surface"]
    #[doc = "has not been destroyed, i.e. the client must perform the initial commit"]
    #[doc = "again before attaching a buffer."]
    pub mod xdg_surface {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "Surface was not fully constructed"]
            NotConstructed = 1u32,
            #[doc = "Surface was already constructed"]
            AlreadyConstructed = 2u32,
            #[doc = "Attaching a buffer to an unconfigured surface"]
            UnconfiguredBuffer = 3u32,
            #[doc = "Invalid serial number when acking a configure event"]
            InvalidSerial = 4u32,
            #[doc = "Width or height was zero or negative"]
            InvalidSize = 5u32,
            #[doc = "Surface was destroyed before its role object"]
            DefunctRoleObject = 6u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::NotConstructed),
                    2u32 => Ok(Self::AlreadyConstructed),
                    3u32 => Ok(Self::UnconfiguredBuffer),
                    4u32 => Ok(Self::InvalidSerial),
                    5u32 => Ok(Self::InvalidSize),
                    6u32 => Ok(Self::DefunctRoleObject),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the xdg_surface interface. See the module level documentation for more info"]
        pub trait XdgSurface: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_surface";
            const VERSION: u32 = 6u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_surface#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_surface#{}.get_toplevel()", object.id);
                        self.get_toplevel(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("xdg_surface#{}.get_popup()", object.id);
                        self.get_popup(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.object()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("xdg_surface#{}.set_window_geometry()", object.id);
                        self.set_window_geometry(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("xdg_surface#{}.ack_configure()", object.id);
                        self.ack_configure(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the xdg_surface object. An xdg_surface must only be destroyed"]
            #[doc = "after its role object has been destroyed, otherwise"]
            #[doc = "a defunct_role_object error is raised."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This creates an xdg_toplevel object for the given xdg_surface and gives"]
            #[doc = "the associated wl_surface the xdg_toplevel role."]
            #[doc = ""]
            #[doc = "See the documentation of xdg_toplevel for more details about what an"]
            #[doc = "xdg_toplevel is and how it is used."]
            async fn get_toplevel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This creates an xdg_popup object for the given xdg_surface and gives"]
            #[doc = "the associated wl_surface the xdg_popup role."]
            #[doc = ""]
            #[doc = "If null is passed as a parent, a parent surface must be specified using"]
            #[doc = "some other protocol, before committing the initial state."]
            #[doc = ""]
            #[doc = "See the documentation of xdg_popup for more details about what an"]
            #[doc = "xdg_popup is and how it is used."]
            async fn get_popup(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                parent: Option<crate::wire::ObjectId>,
                positioner: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "The window geometry of a surface is its \"visible bounds\" from the"]
            #[doc = "user's perspective. Client-side decorations often have invisible"]
            #[doc = "portions like drop-shadows which should be ignored for the"]
            #[doc = "purposes of aligning, placing and constraining windows."]
            #[doc = ""]
            #[doc = "The window geometry is double-buffered state, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "When maintaining a position, the compositor should treat the (x, y)"]
            #[doc = "coordinate of the window geometry as the top left corner of the window."]
            #[doc = "A client changing the (x, y) window geometry coordinate should in"]
            #[doc = "general not alter the position of the window."]
            #[doc = ""]
            #[doc = "Once the window geometry of the surface is set, it is not possible to"]
            #[doc = "unset it, and it will remain the same until set_window_geometry is"]
            #[doc = "called again, even if a new subsurface or buffer is attached."]
            #[doc = ""]
            #[doc = "If never set, the value is the full bounds of the surface,"]
            #[doc = "including any subsurfaces. This updates dynamically on every"]
            #[doc = "commit. This unset is meant for extremely simple clients."]
            #[doc = ""]
            #[doc = "The arguments are given in the surface-local coordinate space of"]
            #[doc = "the wl_surface associated with this xdg_surface, and may extend outside"]
            #[doc = "of the wl_surface itself to mark parts of the subsurface tree as part of"]
            #[doc = "the window geometry."]
            #[doc = ""]
            #[doc = "When applied, the effective window geometry will be the set window"]
            #[doc = "geometry clamped to the bounding rectangle of the combined"]
            #[doc = "geometry of the surface of the xdg_surface and the associated"]
            #[doc = "subsurfaces."]
            #[doc = ""]
            #[doc = "The effective geometry will not be recalculated unless a new call to"]
            #[doc = "set_window_geometry is done and the new pending surface state is"]
            #[doc = "subsequently applied."]
            #[doc = ""]
            #[doc = "The width and height of the effective window geometry must be"]
            #[doc = "greater than zero. Setting an invalid size will raise an"]
            #[doc = "invalid_size error."]
            async fn set_window_geometry(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "When a configure event is received, if a client commits the"]
            #[doc = "surface in response to the configure event, then the client"]
            #[doc = "must make an ack_configure request sometime before the commit"]
            #[doc = "request, passing along the serial of the configure event."]
            #[doc = ""]
            #[doc = "For instance, for toplevel surfaces the compositor might use this"]
            #[doc = "information to move a surface to the top left only when the client has"]
            #[doc = "drawn itself for the maximized or fullscreen state."]
            #[doc = ""]
            #[doc = "If the client receives multiple configure events before it"]
            #[doc = "can respond to one, it only has to ack the last configure event."]
            #[doc = "Acking a configure event that was never sent raises an invalid_serial"]
            #[doc = "error."]
            #[doc = ""]
            #[doc = "A client is not required to commit immediately after sending"]
            #[doc = "an ack_configure request - it may even ack_configure several times"]
            #[doc = "before its next surface commit."]
            #[doc = ""]
            #[doc = "A client may send multiple ack_configure requests before committing, but"]
            #[doc = "only the last request sent before a commit indicates which configure"]
            #[doc = "event the client really is responding to."]
            #[doc = ""]
            #[doc = "Sending an ack_configure request consumes the serial number sent with"]
            #[doc = "the request, as well as serial numbers sent by all configure events"]
            #[doc = "sent on this xdg_surface prior to the configure event referenced by"]
            #[doc = "the committed serial."]
            #[doc = ""]
            #[doc = "It is an error to issue multiple ack_configure requests referencing a"]
            #[doc = "serial from the same configure event, or to issue an ack_configure"]
            #[doc = "request referencing a serial from a configure event issued before the"]
            #[doc = "event identified by the last ack_configure request for the same"]
            #[doc = "xdg_surface. Doing so will raise an invalid_serial error."]
            async fn ack_configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "The configure event marks the end of a configure sequence. A configure"]
            #[doc = "sequence is a set of one or more events configuring the state of the"]
            #[doc = "xdg_surface, including the final xdg_surface.configure event."]
            #[doc = ""]
            #[doc = "Where applicable, xdg_surface surface roles will during a configure"]
            #[doc = "sequence extend this event as a latched state sent as events before the"]
            #[doc = "xdg_surface.configure event. Such events should be considered to make up"]
            #[doc = "a set of atomically applied configuration states, where the"]
            #[doc = "xdg_surface.configure commits the accumulated state."]
            #[doc = ""]
            #[doc = "Clients should arrange their surface for the new states, and then send"]
            #[doc = "an ack_configure request with the serial sent in this configure event at"]
            #[doc = "some point before committing the new surface."]
            #[doc = ""]
            #[doc = "If the client receives multiple configure events before it can respond"]
            #[doc = "to one, it is free to discard all but the last event it received."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_surface#{}.configure()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "This interface defines an xdg_surface role which allows a surface to,"]
    #[doc = "among other things, set window-like properties such as maximize,"]
    #[doc = "fullscreen, and minimize, set application-specific metadata like title and"]
    #[doc = "id, and well as trigger user interactive operations such as interactive"]
    #[doc = "resize and move."]
    #[doc = ""]
    #[doc = "A xdg_toplevel by default is responsible for providing the full intended"]
    #[doc = "visual representation of the toplevel, which depending on the window"]
    #[doc = "state, may mean things like a title bar, window controls and drop shadow."]
    #[doc = ""]
    #[doc = "Unmapping an xdg_toplevel means that the surface cannot be shown"]
    #[doc = "by the compositor until it is explicitly mapped again."]
    #[doc = "All active operations (e.g., move, resize) are canceled and all"]
    #[doc = "attributes (e.g. title, state, stacking, ...) are discarded for"]
    #[doc = "an xdg_toplevel surface when it is unmapped. The xdg_toplevel returns to"]
    #[doc = "the state it had right after xdg_surface.get_toplevel. The client"]
    #[doc = "can re-map the toplevel by performing a commit without any buffer"]
    #[doc = "attached, waiting for a configure event and handling it as usual (see"]
    #[doc = "xdg_surface description)."]
    #[doc = ""]
    #[doc = "Attaching a null buffer to a toplevel unmaps the surface."]
    pub mod xdg_toplevel {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "provided value is"]
            #[doc = "not a valid variant of the resize_edge enum"]
            InvalidResizeEdge = 0u32,
            #[doc = "invalid parent toplevel"]
            InvalidParent = 1u32,
            #[doc = "client provided an invalid min or max size"]
            InvalidSize = 2u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidResizeEdge),
                    1u32 => Ok(Self::InvalidParent),
                    2u32 => Ok(Self::InvalidSize),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "These values are used to indicate which edge of a surface"]
        #[doc = "is being dragged in a resize operation."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ResizeEdge {
            None = 0u32,
            Top = 1u32,
            Bottom = 2u32,
            Left = 4u32,
            TopLeft = 5u32,
            BottomLeft = 6u32,
            Right = 8u32,
            TopRight = 9u32,
            BottomRight = 10u32,
        }
        impl TryFrom<u32> for ResizeEdge {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::None),
                    1u32 => Ok(Self::Top),
                    2u32 => Ok(Self::Bottom),
                    4u32 => Ok(Self::Left),
                    5u32 => Ok(Self::TopLeft),
                    6u32 => Ok(Self::BottomLeft),
                    8u32 => Ok(Self::Right),
                    9u32 => Ok(Self::TopRight),
                    10u32 => Ok(Self::BottomRight),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "The different state values used on the surface. This is designed for"]
        #[doc = "state values like maximized, fullscreen. It is paired with the"]
        #[doc = "configure event to ensure that both the client and the compositor"]
        #[doc = "setting the state can be synchronized."]
        #[doc = ""]
        #[doc = "States set in this way are double-buffered, see wl_surface.commit."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum State {
            #[doc = "the surface is maximized"]
            Maximized = 1u32,
            #[doc = "the surface is fullscreen"]
            Fullscreen = 2u32,
            #[doc = "the surface is being resized"]
            Resizing = 3u32,
            #[doc = "the surface is now activated"]
            Activated = 4u32,
            TiledLeft = 5u32,
            TiledRight = 6u32,
            TiledTop = 7u32,
            TiledBottom = 8u32,
            Suspended = 9u32,
        }
        impl TryFrom<u32> for State {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::Maximized),
                    2u32 => Ok(Self::Fullscreen),
                    3u32 => Ok(Self::Resizing),
                    4u32 => Ok(Self::Activated),
                    5u32 => Ok(Self::TiledLeft),
                    6u32 => Ok(Self::TiledRight),
                    7u32 => Ok(Self::TiledTop),
                    8u32 => Ok(Self::TiledBottom),
                    9u32 => Ok(Self::Suspended),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum WmCapabilities {
            #[doc = "show_window_menu is available"]
            WindowMenu = 1u32,
            #[doc = "set_maximized and unset_maximized are available"]
            Maximize = 2u32,
            #[doc = "set_fullscreen and unset_fullscreen are available"]
            Fullscreen = 3u32,
            #[doc = "set_minimized is available"]
            Minimize = 4u32,
        }
        impl TryFrom<u32> for WmCapabilities {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::WindowMenu),
                    2u32 => Ok(Self::Maximize),
                    3u32 => Ok(Self::Fullscreen),
                    4u32 => Ok(Self::Minimize),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the xdg_toplevel interface. See the module level documentation for more info"]
        pub trait XdgToplevel: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_toplevel";
            const VERSION: u32 = 6u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_toplevel#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_toplevel#{}.set_parent()", object.id);
                        self.set_parent(object, client, message.object()?).await
                    }
                    2u16 => {
                        tracing::debug!("xdg_toplevel#{}.set_title()", object.id);
                        self.set_title(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("xdg_toplevel#{}.set_app_id()", object.id);
                        self.set_app_id(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("xdg_toplevel#{}.show_window_menu()", object.id);
                        self.show_window_menu(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    5u16 => {
                        tracing::debug!("xdg_toplevel#{}.move()", object.id);
                        self.r#move(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    6u16 => {
                        tracing::debug!("xdg_toplevel#{}.resize()", object.id);
                        self.resize(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    7u16 => {
                        tracing::debug!("xdg_toplevel#{}.set_max_size()", object.id);
                        self.set_max_size(object, client, message.int()?, message.int()?)
                            .await
                    }
                    8u16 => {
                        tracing::debug!("xdg_toplevel#{}.set_min_size()", object.id);
                        self.set_min_size(object, client, message.int()?, message.int()?)
                            .await
                    }
                    9u16 => {
                        tracing::debug!("xdg_toplevel#{}.set_maximized()", object.id);
                        self.set_maximized(object, client).await
                    }
                    10u16 => {
                        tracing::debug!("xdg_toplevel#{}.unset_maximized()", object.id);
                        self.unset_maximized(object, client).await
                    }
                    11u16 => {
                        tracing::debug!("xdg_toplevel#{}.set_fullscreen()", object.id);
                        self.set_fullscreen(object, client, message.object()?).await
                    }
                    12u16 => {
                        tracing::debug!("xdg_toplevel#{}.unset_fullscreen()", object.id);
                        self.unset_fullscreen(object, client).await
                    }
                    13u16 => {
                        tracing::debug!("xdg_toplevel#{}.set_minimized()", object.id);
                        self.set_minimized(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request destroys the role surface and unmaps the surface;"]
            #[doc = "see \"Unmapping\" behavior in interface section for details."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the \"parent\" of this surface. This surface should be stacked"]
            #[doc = "above the parent surface and all other ancestor surfaces."]
            #[doc = ""]
            #[doc = "Parent surfaces should be set on dialogs, toolboxes, or other"]
            #[doc = "\"auxiliary\" surfaces, so that the parent is raised when the dialog"]
            #[doc = "is raised."]
            #[doc = ""]
            #[doc = "Setting a null parent for a child surface unsets its parent. Setting"]
            #[doc = "a null parent for a surface which currently has no parent is a no-op."]
            #[doc = ""]
            #[doc = "Only mapped surfaces can have child surfaces. Setting a parent which"]
            #[doc = "is not mapped is equivalent to setting a null parent. If a surface"]
            #[doc = "becomes unmapped, its children's parent is set to the parent of"]
            #[doc = "the now-unmapped surface. If the now-unmapped surface has no parent,"]
            #[doc = "its children's parent is unset. If the now-unmapped surface becomes"]
            #[doc = "mapped again, its parent-child relationship is not restored."]
            #[doc = ""]
            #[doc = "The parent toplevel must not be one of the child toplevel's"]
            #[doc = "descendants, and the parent must be different from the child toplevel,"]
            #[doc = "otherwise the invalid_parent protocol error is raised."]
            async fn set_parent(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                parent: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Set a short title for the surface."]
            #[doc = ""]
            #[doc = "This string may be used to identify the surface in a task bar,"]
            #[doc = "window list, or other user interface elements provided by the"]
            #[doc = "compositor."]
            #[doc = ""]
            #[doc = "The string must be encoded in UTF-8."]
            async fn set_title(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                title: String,
            ) -> crate::server::Result<()>;
            #[doc = "Set an application identifier for the surface."]
            #[doc = ""]
            #[doc = "The app ID identifies the general class of applications to which"]
            #[doc = "the surface belongs. The compositor can use this to group multiple"]
            #[doc = "surfaces together, or to determine how to launch a new application."]
            #[doc = ""]
            #[doc = "For D-Bus activatable applications, the app ID is used as the D-Bus"]
            #[doc = "service name."]
            #[doc = ""]
            #[doc = "The compositor shell will try to group application surfaces together"]
            #[doc = "by their app ID. As a best practice, it is suggested to select app"]
            #[doc = "ID's that match the basename of the application's .desktop file."]
            #[doc = "For example, \"org.freedesktop.FooViewer\" where the .desktop file is"]
            #[doc = "\"org.freedesktop.FooViewer.desktop\"."]
            #[doc = ""]
            #[doc = "Like other properties, a set_app_id request can be sent after the"]
            #[doc = "xdg_toplevel has been mapped to update the property."]
            #[doc = ""]
            #[doc = "See the desktop-entry specification [0] for more details on"]
            #[doc = "application identifiers and how they relate to well-known D-Bus"]
            #[doc = "names and .desktop files."]
            #[doc = ""]
            #[doc = "[0] https://standards.freedesktop.org/desktop-entry-spec/"]
            async fn set_app_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                app_id: String,
            ) -> crate::server::Result<()>;
            #[doc = "Clients implementing client-side decorations might want to show"]
            #[doc = "a context menu when right-clicking on the decorations, giving the"]
            #[doc = "user a menu that they can use to maximize or minimize the window."]
            #[doc = ""]
            #[doc = "This request asks the compositor to pop up such a window menu at"]
            #[doc = "the given position, relative to the local surface coordinates of"]
            #[doc = "the parent surface. There are no guarantees as to what menu items"]
            #[doc = "the window menu contains, or even if a window menu will be drawn"]
            #[doc = "at all."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action"]
            #[doc = "like a button press, key press, or touch down event."]
            async fn show_window_menu(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Start an interactive, user-driven move of the surface."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action"]
            #[doc = "like a button press, key press, or touch down event. The passed"]
            #[doc = "serial is used to determine the type of interactive move (touch,"]
            #[doc = "pointer, etc)."]
            #[doc = ""]
            #[doc = "The server may ignore move requests depending on the state of"]
            #[doc = "the surface (e.g. fullscreen or maximized), or if the passed serial"]
            #[doc = "is no longer valid."]
            #[doc = ""]
            #[doc = "If triggered, the surface will lose the focus of the device"]
            #[doc = "(wl_pointer, wl_touch, etc) used for the move. It is up to the"]
            #[doc = "compositor to visually indicate that the move is taking place, such as"]
            #[doc = "updating a pointer cursor, during the move. There is no guarantee"]
            #[doc = "that the device focus will return when the move is completed."]
            async fn r#move(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Start a user-driven, interactive resize of the surface."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action"]
            #[doc = "like a button press, key press, or touch down event. The passed"]
            #[doc = "serial is used to determine the type of interactive resize (touch,"]
            #[doc = "pointer, etc)."]
            #[doc = ""]
            #[doc = "The server may ignore resize requests depending on the state of"]
            #[doc = "the surface (e.g. fullscreen or maximized)."]
            #[doc = ""]
            #[doc = "If triggered, the client will receive configure events with the"]
            #[doc = "\"resize\" state enum value and the expected sizes. See the \"resize\""]
            #[doc = "enum value for more details about what is required. The client"]
            #[doc = "must also acknowledge configure events using \"ack_configure\". After"]
            #[doc = "the resize is completed, the client will receive another \"configure\""]
            #[doc = "event without the resize state."]
            #[doc = ""]
            #[doc = "If triggered, the surface also will lose the focus of the device"]
            #[doc = "(wl_pointer, wl_touch, etc) used for the resize. It is up to the"]
            #[doc = "compositor to visually indicate that the resize is taking place,"]
            #[doc = "such as updating a pointer cursor, during the resize. There is no"]
            #[doc = "guarantee that the device focus will return when the resize is"]
            #[doc = "completed."]
            #[doc = ""]
            #[doc = "The edges parameter specifies how the surface should be resized, and"]
            #[doc = "is one of the values of the resize_edge enum. Values not matching"]
            #[doc = "a variant of the enum will cause the invalid_resize_edge protocol error."]
            #[doc = "The compositor may use this information to update the surface position"]
            #[doc = "for example when dragging the top left corner. The compositor may also"]
            #[doc = "use this information to adapt its behavior, e.g. choose an appropriate"]
            #[doc = "cursor image."]
            async fn resize(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
                edges: ResizeEdge,
            ) -> crate::server::Result<()>;
            #[doc = "Set a maximum size for the window."]
            #[doc = ""]
            #[doc = "The client can specify a maximum size so that the compositor does"]
            #[doc = "not try to configure the window beyond this size."]
            #[doc = ""]
            #[doc = "The width and height arguments are in window geometry coordinates."]
            #[doc = "See xdg_surface.set_window_geometry."]
            #[doc = ""]
            #[doc = "Values set in this way are double-buffered, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "The compositor can use this information to allow or disallow"]
            #[doc = "different states like maximize or fullscreen and draw accurate"]
            #[doc = "animations."]
            #[doc = ""]
            #[doc = "Similarly, a tiling window manager may use this information to"]
            #[doc = "place and resize client windows in a more effective way."]
            #[doc = ""]
            #[doc = "The client should not rely on the compositor to obey the maximum"]
            #[doc = "size. The compositor may decide to ignore the values set by the"]
            #[doc = "client and request a larger size."]
            #[doc = ""]
            #[doc = "If never set, or a value of zero in the request, means that the"]
            #[doc = "client has no expected maximum size in the given dimension."]
            #[doc = "As a result, a client wishing to reset the maximum size"]
            #[doc = "to an unspecified state can use zero for width and height in the"]
            #[doc = "request."]
            #[doc = ""]
            #[doc = "Requesting a maximum size to be smaller than the minimum size of"]
            #[doc = "a surface is illegal and will result in an invalid_size error."]
            #[doc = ""]
            #[doc = "The width and height must be greater than or equal to zero. Using"]
            #[doc = "strictly negative values for width or height will result in a"]
            #[doc = "invalid_size error."]
            async fn set_max_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Set a minimum size for the window."]
            #[doc = ""]
            #[doc = "The client can specify a minimum size so that the compositor does"]
            #[doc = "not try to configure the window below this size."]
            #[doc = ""]
            #[doc = "The width and height arguments are in window geometry coordinates."]
            #[doc = "See xdg_surface.set_window_geometry."]
            #[doc = ""]
            #[doc = "Values set in this way are double-buffered, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "The compositor can use this information to allow or disallow"]
            #[doc = "different states like maximize or fullscreen and draw accurate"]
            #[doc = "animations."]
            #[doc = ""]
            #[doc = "Similarly, a tiling window manager may use this information to"]
            #[doc = "place and resize client windows in a more effective way."]
            #[doc = ""]
            #[doc = "The client should not rely on the compositor to obey the minimum"]
            #[doc = "size. The compositor may decide to ignore the values set by the"]
            #[doc = "client and request a smaller size."]
            #[doc = ""]
            #[doc = "If never set, or a value of zero in the request, means that the"]
            #[doc = "client has no expected minimum size in the given dimension."]
            #[doc = "As a result, a client wishing to reset the minimum size"]
            #[doc = "to an unspecified state can use zero for width and height in the"]
            #[doc = "request."]
            #[doc = ""]
            #[doc = "Requesting a minimum size to be larger than the maximum size of"]
            #[doc = "a surface is illegal and will result in an invalid_size error."]
            #[doc = ""]
            #[doc = "The width and height must be greater than or equal to zero. Using"]
            #[doc = "strictly negative values for width and height will result in a"]
            #[doc = "invalid_size error."]
            async fn set_min_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Maximize the surface."]
            #[doc = ""]
            #[doc = "After requesting that the surface should be maximized, the compositor"]
            #[doc = "will respond by emitting a configure event. Whether this configure"]
            #[doc = "actually sets the window maximized is subject to compositor policies."]
            #[doc = "The client must then update its content, drawing in the configured"]
            #[doc = "state. The client must also acknowledge the configure when committing"]
            #[doc = "the new content (see ack_configure)."]
            #[doc = ""]
            #[doc = "It is up to the compositor to decide how and where to maximize the"]
            #[doc = "surface, for example which output and what region of the screen should"]
            #[doc = "be used."]
            #[doc = ""]
            #[doc = "If the surface was already maximized, the compositor will still emit"]
            #[doc = "a configure event with the \"maximized\" state."]
            #[doc = ""]
            #[doc = "If the surface is in a fullscreen state, this request has no direct"]
            #[doc = "effect. It may alter the state the surface is returned to when"]
            #[doc = "unmaximized unless overridden by the compositor."]
            async fn set_maximized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Unmaximize the surface."]
            #[doc = ""]
            #[doc = "After requesting that the surface should be unmaximized, the compositor"]
            #[doc = "will respond by emitting a configure event. Whether this actually"]
            #[doc = "un-maximizes the window is subject to compositor policies."]
            #[doc = "If available and applicable, the compositor will include the window"]
            #[doc = "geometry dimensions the window had prior to being maximized in the"]
            #[doc = "configure event. The client must then update its content, drawing it in"]
            #[doc = "the configured state. The client must also acknowledge the configure"]
            #[doc = "when committing the new content (see ack_configure)."]
            #[doc = ""]
            #[doc = "It is up to the compositor to position the surface after it was"]
            #[doc = "unmaximized; usually the position the surface had before maximizing, if"]
            #[doc = "applicable."]
            #[doc = ""]
            #[doc = "If the surface was already not maximized, the compositor will still"]
            #[doc = "emit a configure event without the \"maximized\" state."]
            #[doc = ""]
            #[doc = "If the surface is in a fullscreen state, this request has no direct"]
            #[doc = "effect. It may alter the state the surface is returned to when"]
            #[doc = "unmaximized unless overridden by the compositor."]
            async fn unset_maximized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Make the surface fullscreen."]
            #[doc = ""]
            #[doc = "After requesting that the surface should be fullscreened, the"]
            #[doc = "compositor will respond by emitting a configure event. Whether the"]
            #[doc = "client is actually put into a fullscreen state is subject to compositor"]
            #[doc = "policies. The client must also acknowledge the configure when"]
            #[doc = "committing the new content (see ack_configure)."]
            #[doc = ""]
            #[doc = "The output passed by the request indicates the client's preference as"]
            #[doc = "to which display it should be set fullscreen on. If this value is NULL,"]
            #[doc = "it's up to the compositor to choose which display will be used to map"]
            #[doc = "this surface."]
            #[doc = ""]
            #[doc = "If the surface doesn't cover the whole output, the compositor will"]
            #[doc = "position the surface in the center of the output and compensate with"]
            #[doc = "with border fill covering the rest of the output. The content of the"]
            #[doc = "border fill is undefined, but should be assumed to be in some way that"]
            #[doc = "attempts to blend into the surrounding area (e.g. solid black)."]
            #[doc = ""]
            #[doc = "If the fullscreened surface is not opaque, the compositor must make"]
            #[doc = "sure that other screen content not part of the same surface tree (made"]
            #[doc = "up of subsurfaces, popups or similarly coupled surfaces) are not"]
            #[doc = "visible below the fullscreened surface."]
            async fn set_fullscreen(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Make the surface no longer fullscreen."]
            #[doc = ""]
            #[doc = "After requesting that the surface should be unfullscreened, the"]
            #[doc = "compositor will respond by emitting a configure event."]
            #[doc = "Whether this actually removes the fullscreen state of the client is"]
            #[doc = "subject to compositor policies."]
            #[doc = ""]
            #[doc = "Making a surface unfullscreen sets states for the surface based on the following:"]
            #[doc = "* the state(s) it may have had before becoming fullscreen"]
            #[doc = "* any state(s) decided by the compositor"]
            #[doc = "* any state(s) requested by the client while the surface was fullscreen"]
            #[doc = ""]
            #[doc = "The compositor may include the previous window geometry dimensions in"]
            #[doc = "the configure event, if applicable."]
            #[doc = ""]
            #[doc = "The client must also acknowledge the configure when committing the new"]
            #[doc = "content (see ack_configure)."]
            async fn unset_fullscreen(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Request that the compositor minimize your surface. There is no"]
            #[doc = "way to know if the surface is currently minimized, nor is there"]
            #[doc = "any way to unset minimization on this surface."]
            #[doc = ""]
            #[doc = "If you are looking to throttle redrawing when minimized, please"]
            #[doc = "instead use the wl_surface.frame event for this, as this will"]
            #[doc = "also work with live previews on windows in Alt-Tab, Expose or"]
            #[doc = "similar compositor features."]
            async fn set_minimized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This configure event asks the client to resize its toplevel surface or"]
            #[doc = "to change its state. The configured state should not be applied"]
            #[doc = "immediately. See xdg_surface.configure for details."]
            #[doc = ""]
            #[doc = "The width and height arguments specify a hint to the window"]
            #[doc = "about how its surface should be resized in window geometry"]
            #[doc = "coordinates. See set_window_geometry."]
            #[doc = ""]
            #[doc = "If the width or height arguments are zero, it means the client"]
            #[doc = "should decide its own window dimension. This may happen when the"]
            #[doc = "compositor needs to configure the state of the surface but doesn't"]
            #[doc = "have any information about any previous or expected dimension."]
            #[doc = ""]
            #[doc = "The states listed in the event specify how the width/height"]
            #[doc = "arguments should be interpreted, and possibly how it should be"]
            #[doc = "drawn."]
            #[doc = ""]
            #[doc = "Clients must send an ack_configure in response to this event. See"]
            #[doc = "xdg_surface.configure and xdg_surface.ack_configure for details."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
                states: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_toplevel#{}.configure()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(width)
                    .put_int(height)
                    .put_array(states)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The close event is sent by the compositor when the user"]
            #[doc = "wants the surface to be closed. This should be equivalent to"]
            #[doc = "the user clicking the close button in client-side decorations,"]
            #[doc = "if your application has any."]
            #[doc = ""]
            #[doc = "This is only a request that the user intends to close the"]
            #[doc = "window. The client may choose to ignore this request, or show"]
            #[doc = "a dialog to ask the user to save their data, etc."]
            async fn close(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_toplevel#{}.close()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The configure_bounds event may be sent prior to a xdg_toplevel.configure"]
            #[doc = "event to communicate the bounds a window geometry size is recommended"]
            #[doc = "to constrain to."]
            #[doc = ""]
            #[doc = "The passed width and height are in surface coordinate space. If width"]
            #[doc = "and height are 0, it means bounds is unknown and equivalent to as if no"]
            #[doc = "configure_bounds event was ever sent for this surface."]
            #[doc = ""]
            #[doc = "The bounds can for example correspond to the size of a monitor excluding"]
            #[doc = "any panels or other shell components, so that a surface isn't created in"]
            #[doc = "a way that it cannot fit."]
            #[doc = ""]
            #[doc = "The bounds may change at any point, and in such a case, a new"]
            #[doc = "xdg_toplevel.configure_bounds will be sent, followed by"]
            #[doc = "xdg_toplevel.configure and xdg_surface.configure."]
            async fn configure_bounds(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_toplevel#{}.configure_bounds()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event advertises the capabilities supported by the compositor. If"]
            #[doc = "a capability isn't supported, clients should hide or disable the UI"]
            #[doc = "elements that expose this functionality. For instance, if the"]
            #[doc = "compositor doesn't advertise support for minimized toplevels, a button"]
            #[doc = "triggering the set_minimized request should not be displayed."]
            #[doc = ""]
            #[doc = "The compositor will ignore requests it doesn't support. For instance,"]
            #[doc = "a compositor which doesn't advertise support for minimized will ignore"]
            #[doc = "set_minimized requests."]
            #[doc = ""]
            #[doc = "Compositors must send this event once before the first"]
            #[doc = "xdg_surface.configure event. When the capabilities change, compositors"]
            #[doc = "must send this event again and then send an xdg_surface.configure"]
            #[doc = "event."]
            #[doc = ""]
            #[doc = "The configured state should not be applied immediately. See"]
            #[doc = "xdg_surface.configure for details."]
            #[doc = ""]
            #[doc = "The capabilities are sent as an array of 32-bit unsigned integers in"]
            #[doc = "native endianness."]
            async fn wm_capabilities(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                capabilities: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_toplevel#{}.wm_capabilities()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_array(capabilities)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A popup surface is a short-lived, temporary surface. It can be used to"]
    #[doc = "implement for example menus, popovers, tooltips and other similar user"]
    #[doc = "interface concepts."]
    #[doc = ""]
    #[doc = "A popup can be made to take an explicit grab. See xdg_popup.grab for"]
    #[doc = "details."]
    #[doc = ""]
    #[doc = "When the popup is dismissed, a popup_done event will be sent out, and at"]
    #[doc = "the same time the surface will be unmapped. See the xdg_popup.popup_done"]
    #[doc = "event for details."]
    #[doc = ""]
    #[doc = "Explicitly destroying the xdg_popup object will also dismiss the popup and"]
    #[doc = "unmap the surface. Clients that want to dismiss the popup when another"]
    #[doc = "surface of their own is clicked should dismiss the popup using the destroy"]
    #[doc = "request."]
    #[doc = ""]
    #[doc = "A newly created xdg_popup will be stacked on top of all previously created"]
    #[doc = "xdg_popup surfaces associated with the same xdg_toplevel."]
    #[doc = ""]
    #[doc = "The parent of an xdg_popup must be mapped (see the xdg_surface"]
    #[doc = "description) before the xdg_popup itself."]
    #[doc = ""]
    #[doc = "The client must call wl_surface.commit on the corresponding wl_surface"]
    #[doc = "for the xdg_popup state to take effect."]
    pub mod xdg_popup {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "tried to grab after being mapped"]
            InvalidGrab = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidGrab),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the xdg_popup interface. See the module level documentation for more info"]
        pub trait XdgPopup: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_popup";
            const VERSION: u32 = 6u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_popup#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_popup#{}.grab()", object.id);
                        self.grab(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("xdg_popup#{}.reposition()", object.id);
                        self.reposition(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This destroys the popup. Explicitly destroying the xdg_popup"]
            #[doc = "object will also dismiss the popup, and unmap the surface."]
            #[doc = ""]
            #[doc = "If this xdg_popup is not the \"topmost\" popup, the"]
            #[doc = "xdg_wm_base.not_the_topmost_popup protocol error will be sent."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This request makes the created popup take an explicit grab. An explicit"]
            #[doc = "grab will be dismissed when the user dismisses the popup, or when the"]
            #[doc = "client destroys the xdg_popup. This can be done by the user clicking"]
            #[doc = "outside the surface, using the keyboard, or even locking the screen"]
            #[doc = "through closing the lid or a timeout."]
            #[doc = ""]
            #[doc = "If the compositor denies the grab, the popup will be immediately"]
            #[doc = "dismissed."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action like a"]
            #[doc = "button press, key press, or touch down event. The serial number of the"]
            #[doc = "event should be passed as 'serial'."]
            #[doc = ""]
            #[doc = "The parent of a grabbing popup must either be an xdg_toplevel surface or"]
            #[doc = "another xdg_popup with an explicit grab. If the parent is another"]
            #[doc = "xdg_popup it means that the popups are nested, with this popup now being"]
            #[doc = "the topmost popup."]
            #[doc = ""]
            #[doc = "Nested popups must be destroyed in the reverse order they were created"]
            #[doc = "in, e.g. the only popup you are allowed to destroy at all times is the"]
            #[doc = "topmost one."]
            #[doc = ""]
            #[doc = "When compositors choose to dismiss a popup, they may dismiss every"]
            #[doc = "nested grabbing popup as well. When a compositor dismisses popups, it"]
            #[doc = "will follow the same dismissing order as required from the client."]
            #[doc = ""]
            #[doc = "If the topmost grabbing popup is destroyed, the grab will be returned to"]
            #[doc = "the parent of the popup, if that parent previously had an explicit grab."]
            #[doc = ""]
            #[doc = "If the parent is a grabbing popup which has already been dismissed, this"]
            #[doc = "popup will be immediately dismissed. If the parent is a popup that did"]
            #[doc = "not take an explicit grab, an error will be raised."]
            #[doc = ""]
            #[doc = "During a popup grab, the client owning the grab will receive pointer"]
            #[doc = "and touch events for all their surfaces as normal (similar to an"]
            #[doc = "\"owner-events\" grab in X11 parlance), while the top most grabbing popup"]
            #[doc = "will always have keyboard focus."]
            async fn grab(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Reposition an already-mapped popup. The popup will be placed given the"]
            #[doc = "details in the passed xdg_positioner object, and a"]
            #[doc = "xdg_popup.repositioned followed by xdg_popup.configure and"]
            #[doc = "xdg_surface.configure will be emitted in response. Any parameters set"]
            #[doc = "by the previous positioner will be discarded."]
            #[doc = ""]
            #[doc = "The passed token will be sent in the corresponding"]
            #[doc = "xdg_popup.repositioned event. The new popup position will not take"]
            #[doc = "effect until the corresponding configure event is acknowledged by the"]
            #[doc = "client. See xdg_popup.repositioned for details. The token itself is"]
            #[doc = "opaque, and has no other special meaning."]
            #[doc = ""]
            #[doc = "If multiple reposition requests are sent, the compositor may skip all"]
            #[doc = "but the last one."]
            #[doc = ""]
            #[doc = "If the popup is repositioned in response to a configure event for its"]
            #[doc = "parent, the client should send an xdg_positioner.set_parent_configure"]
            #[doc = "and possibly an xdg_positioner.set_parent_size request to allow the"]
            #[doc = "compositor to properly constrain the popup."]
            #[doc = ""]
            #[doc = "If the popup is repositioned together with a parent that is being"]
            #[doc = "resized, but not in response to a configure event, the client should"]
            #[doc = "send an xdg_positioner.set_parent_size request."]
            async fn reposition(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                positioner: crate::wire::ObjectId,
                token: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This event asks the popup surface to configure itself given the"]
            #[doc = "configuration. The configured state should not be applied immediately."]
            #[doc = "See xdg_surface.configure for details."]
            #[doc = ""]
            #[doc = "The x and y arguments represent the position the popup was placed at"]
            #[doc = "given the xdg_positioner rule, relative to the upper left corner of the"]
            #[doc = "window geometry of the parent surface."]
            #[doc = ""]
            #[doc = "For version 2 or older, the configure event for an xdg_popup is only"]
            #[doc = "ever sent once for the initial configuration. Starting with version 3,"]
            #[doc = "it may be sent again if the popup is setup with an xdg_positioner with"]
            #[doc = "set_reactive requested, or in response to xdg_popup.reposition requests."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_popup#{}.configure()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(x)
                    .put_int(y)
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The popup_done event is sent out when a popup is dismissed by the"]
            #[doc = "compositor. The client should destroy the xdg_popup object at this"]
            #[doc = "point."]
            async fn popup_done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_popup#{}.popup_done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The repositioned event is sent as part of a popup configuration"]
            #[doc = "sequence, together with xdg_popup.configure and lastly"]
            #[doc = "xdg_surface.configure to notify the completion of a reposition request."]
            #[doc = ""]
            #[doc = "The repositioned event is to notify about the completion of a"]
            #[doc = "xdg_popup.reposition request. The token argument is the token passed"]
            #[doc = "in the xdg_popup.reposition request."]
            #[doc = ""]
            #[doc = "Immediately after this event is emitted, xdg_popup.configure and"]
            #[doc = "xdg_surface.configure will be sent with the updated size and position,"]
            #[doc = "as well as a new configure serial."]
            #[doc = ""]
            #[doc = "The client should optionally update the content of the popup, but must"]
            #[doc = "acknowledge the new popup configuration for the new position to take"]
            #[doc = "effect. See xdg_surface.ack_configure for details."]
            async fn repositioned(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                token: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_popup#{}.repositioned()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(token).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod alpha_modifier_v1 {
    #[doc = "This interface allows a client to set a factor for the alpha values on a"]
    #[doc = "surface, which can be used to offload such operations to the compositor,"]
    #[doc = "which can in turn for example offload them to KMS."]
    #[doc = ""]
    #[doc = "Warning! The protocol described in this file is currently in the testing"]
    #[doc = "phase. Backward compatible changes may be added together with the"]
    #[doc = "corresponding interface version bump. Backward incompatible changes can"]
    #[doc = "only be done by creating a new major version of the extension."]
    pub mod wp_alpha_modifier_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "wl_surface already has a alpha modifier object"]
            AlreadyConstructed = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::AlreadyConstructed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wp_alpha_modifier_v1 interface. See the module level documentation for more info"]
        pub trait WpAlphaModifierV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_alpha_modifier_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_alpha_modifier_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("wp_alpha_modifier_v1#{}.get_surface()", object.id);
                        self.get_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the alpha modifier manager. This doesn't destroy objects"]
            #[doc = "created with the manager."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a new alpha modifier surface object associated with the"]
            #[doc = "given wl_surface. If there is already such an object associated with"]
            #[doc = "the wl_surface, the already_constructed error will be raised."]
            async fn get_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "This interface allows the client to set a factor for the alpha values on"]
    #[doc = "a surface, which can be used to offload such operations to the compositor."]
    #[doc = "The default factor is UINT32_MAX."]
    #[doc = ""]
    #[doc = "This object has to be destroyed before the associated wl_surface. Once the"]
    #[doc = "wl_surface is destroyed, all request on this object will raise the"]
    #[doc = "no_surface error."]
    pub mod wp_alpha_modifier_surface_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "wl_surface was destroyed"]
            NoSurface = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::NoSurface),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wp_alpha_modifier_surface_v1 interface. See the module level documentation for more info"]
        pub trait WpAlphaModifierSurfaceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_alpha_modifier_surface_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_alpha_modifier_surface_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "wp_alpha_modifier_surface_v1#{}.set_multiplier()",
                            object.id
                        );
                        self.set_multiplier(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This destroys the object, and is equivalent to set_multiplier with"]
            #[doc = "a value of UINT32_MAX, with the same double-buffered semantics as"]
            #[doc = "set_multiplier."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the alpha multiplier for the surface. The alpha multiplier is"]
            #[doc = "double-buffered state, see wl_surface.commit for details."]
            #[doc = ""]
            #[doc = "This factor is applied in the compositor's blending space, as an"]
            #[doc = "additional step after the processing of per-pixel alpha values for the"]
            #[doc = "wl_surface. The exact meaning of the factor is thus undefined, unless"]
            #[doc = "the blending space is specified in a different extension."]
            #[doc = ""]
            #[doc = "This multiplier is applied even if the buffer attached to the"]
            #[doc = "wl_surface doesn't have an alpha channel; in that case an alpha value"]
            #[doc = "of one is used instead."]
            #[doc = ""]
            #[doc = "Zero means completely transparent, UINT32_MAX means completely opaque."]
            async fn set_multiplier(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                factor: u32,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod content_type_v1 {
    #[doc = "This interface allows a client to describe the kind of content a surface"]
    #[doc = "will display, to allow the compositor to optimize its behavior for it."]
    #[doc = ""]
    #[doc = "Warning! The protocol described in this file is currently in the testing"]
    #[doc = "phase. Backward compatible changes may be added together with the"]
    #[doc = "corresponding interface version bump. Backward incompatible changes can"]
    #[doc = "only be done by creating a new major version of the extension."]
    pub mod wp_content_type_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "wl_surface already has a content type object"]
            AlreadyConstructed = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::AlreadyConstructed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wp_content_type_manager_v1 interface. See the module level documentation for more info"]
        pub trait WpContentTypeManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_content_type_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_content_type_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "wp_content_type_manager_v1#{}.get_surface_content_type()",
                            object.id
                        );
                        self.get_surface_content_type(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the content type manager. This doesn't destroy objects created"]
            #[doc = "with the manager."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a new content type object associated with the given surface."]
            #[doc = ""]
            #[doc = "Creating a wp_content_type_v1 from a wl_surface which already has one"]
            #[doc = "attached is a client error: already_constructed."]
            async fn get_surface_content_type(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "The content type object allows the compositor to optimize for the kind"]
    #[doc = "of content shown on the surface. A compositor may for example use it to"]
    #[doc = "set relevant drm properties like \"content type\"."]
    #[doc = ""]
    #[doc = "The client may request to switch to another content type at any time."]
    #[doc = "When the associated surface gets destroyed, this object becomes inert and"]
    #[doc = "the client should destroy it."]
    pub mod wp_content_type_v1 {
        #[doc = "These values describe the available content types for a surface."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Type {
            None = 0u32,
            Photo = 1u32,
            Video = 2u32,
            Game = 3u32,
        }
        impl TryFrom<u32> for Type {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::None),
                    1u32 => Ok(Self::Photo),
                    2u32 => Ok(Self::Video),
                    3u32 => Ok(Self::Game),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wp_content_type_v1 interface. See the module level documentation for more info"]
        pub trait WpContentTypeV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_content_type_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_content_type_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("wp_content_type_v1#{}.set_content_type()", object.id);
                        self.set_content_type(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Switch back to not specifying the content type of this surface. This is"]
            #[doc = "equivalent to setting the content type to none, including double"]
            #[doc = "buffering semantics. See set_content_type for details."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the surface content type. This informs the compositor that the"]
            #[doc = "client believes it is displaying buffers matching this content type."]
            #[doc = ""]
            #[doc = "This is purely a hint for the compositor, which can be used to adjust"]
            #[doc = "its behavior or hardware settings to fit the presented content best."]
            #[doc = ""]
            #[doc = "The content type is double-buffered state, see wl_surface.commit for"]
            #[doc = "details."]
            async fn set_content_type(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                content_type: Type,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod cursor_shape_v1 {
    #[doc = "This global offers an alternative, optional way to set cursor images. This"]
    #[doc = "new way uses enumerated cursors instead of a wl_surface like"]
    #[doc = "wl_pointer.set_cursor does."]
    #[doc = ""]
    #[doc = "Warning! The protocol described in this file is currently in the testing"]
    #[doc = "phase. Backward compatible changes may be added together with the"]
    #[doc = "corresponding interface version bump. Backward incompatible changes can"]
    #[doc = "only be done by creating a new major version of the extension."]
    pub mod wp_cursor_shape_manager_v1 {
        #[doc = "Trait to implement the wp_cursor_shape_manager_v1 interface. See the module level documentation for more info"]
        pub trait WpCursorShapeManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_cursor_shape_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_cursor_shape_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("wp_cursor_shape_manager_v1#{}.get_pointer()", object.id);
                        self.get_pointer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "wp_cursor_shape_manager_v1#{}.get_tablet_tool_v2()",
                            object.id
                        );
                        self.get_tablet_tool_v2(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the cursor shape manager."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Obtain a wp_cursor_shape_device_v1 for a wl_pointer object."]
            async fn get_pointer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                cursor_shape_device: crate::wire::ObjectId,
                pointer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Obtain a wp_cursor_shape_device_v1 for a zwp_tablet_tool_v2 object."]
            async fn get_tablet_tool_v2(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                cursor_shape_device: crate::wire::ObjectId,
                tablet_tool: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "This interface allows clients to set the cursor shape."]
    pub mod wp_cursor_shape_device_v1 {
        #[doc = "This enum describes cursor shapes."]
        #[doc = ""]
        #[doc = "The names are taken from the CSS W3C specification:"]
        #[doc = "https://w3c.github.io/csswg-drafts/css-ui/#cursor"]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Shape {
            #[doc = "default cursor"]
            Default = 1u32,
            #[doc = "a context menu is available for the object under the cursor"]
            ContextMenu = 2u32,
            #[doc = "help is available for the object under the cursor"]
            Help = 3u32,
            #[doc = "pointer that indicates a link or another interactive element"]
            Pointer = 4u32,
            #[doc = "progress indicator"]
            Progress = 5u32,
            #[doc = "program is busy, user should wait"]
            Wait = 6u32,
            #[doc = "a cell or set of cells may be selected"]
            Cell = 7u32,
            #[doc = "simple crosshair"]
            Crosshair = 8u32,
            #[doc = "text may be selected"]
            Text = 9u32,
            #[doc = "vertical text may be selected"]
            VerticalText = 10u32,
            #[doc = "drag-and-drop: alias of/shortcut to something is to be created"]
            Alias = 11u32,
            #[doc = "drag-and-drop: something is to be copied"]
            Copy = 12u32,
            #[doc = "drag-and-drop: something is to be moved"]
            Move = 13u32,
            #[doc = "drag-and-drop: the dragged item cannot be dropped at the current cursor location"]
            NoDrop = 14u32,
            #[doc = "drag-and-drop: the requested action will not be carried out"]
            NotAllowed = 15u32,
            #[doc = "drag-and-drop: something can be grabbed"]
            Grab = 16u32,
            #[doc = "drag-and-drop: something is being grabbed"]
            Grabbing = 17u32,
            #[doc = "resizing: the east border is to be moved"]
            EResize = 18u32,
            #[doc = "resizing: the north border is to be moved"]
            NResize = 19u32,
            #[doc = "resizing: the north-east corner is to be moved"]
            NeResize = 20u32,
            #[doc = "resizing: the north-west corner is to be moved"]
            NwResize = 21u32,
            #[doc = "resizing: the south border is to be moved"]
            SResize = 22u32,
            #[doc = "resizing: the south-east corner is to be moved"]
            SeResize = 23u32,
            #[doc = "resizing: the south-west corner is to be moved"]
            SwResize = 24u32,
            #[doc = "resizing: the west border is to be moved"]
            WResize = 25u32,
            #[doc = "resizing: the east and west borders are to be moved"]
            EwResize = 26u32,
            #[doc = "resizing: the north and south borders are to be moved"]
            NsResize = 27u32,
            #[doc = "resizing: the north-east and south-west corners are to be moved"]
            NeswResize = 28u32,
            #[doc = "resizing: the north-west and south-east corners are to be moved"]
            NwseResize = 29u32,
            #[doc = "resizing: that the item/column can be resized horizontally"]
            ColResize = 30u32,
            #[doc = "resizing: that the item/row can be resized vertically"]
            RowResize = 31u32,
            #[doc = "something can be scrolled in any direction"]
            AllScroll = 32u32,
            #[doc = "something can be zoomed in"]
            ZoomIn = 33u32,
            #[doc = "something can be zoomed out"]
            ZoomOut = 34u32,
        }
        impl TryFrom<u32> for Shape {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::Default),
                    2u32 => Ok(Self::ContextMenu),
                    3u32 => Ok(Self::Help),
                    4u32 => Ok(Self::Pointer),
                    5u32 => Ok(Self::Progress),
                    6u32 => Ok(Self::Wait),
                    7u32 => Ok(Self::Cell),
                    8u32 => Ok(Self::Crosshair),
                    9u32 => Ok(Self::Text),
                    10u32 => Ok(Self::VerticalText),
                    11u32 => Ok(Self::Alias),
                    12u32 => Ok(Self::Copy),
                    13u32 => Ok(Self::Move),
                    14u32 => Ok(Self::NoDrop),
                    15u32 => Ok(Self::NotAllowed),
                    16u32 => Ok(Self::Grab),
                    17u32 => Ok(Self::Grabbing),
                    18u32 => Ok(Self::EResize),
                    19u32 => Ok(Self::NResize),
                    20u32 => Ok(Self::NeResize),
                    21u32 => Ok(Self::NwResize),
                    22u32 => Ok(Self::SResize),
                    23u32 => Ok(Self::SeResize),
                    24u32 => Ok(Self::SwResize),
                    25u32 => Ok(Self::WResize),
                    26u32 => Ok(Self::EwResize),
                    27u32 => Ok(Self::NsResize),
                    28u32 => Ok(Self::NeswResize),
                    29u32 => Ok(Self::NwseResize),
                    30u32 => Ok(Self::ColResize),
                    31u32 => Ok(Self::RowResize),
                    32u32 => Ok(Self::AllScroll),
                    33u32 => Ok(Self::ZoomIn),
                    34u32 => Ok(Self::ZoomOut),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "the specified shape value is invalid"]
            InvalidShape = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::InvalidShape),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wp_cursor_shape_device_v1 interface. See the module level documentation for more info"]
        pub trait WpCursorShapeDeviceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_cursor_shape_device_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_cursor_shape_device_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("wp_cursor_shape_device_v1#{}.set_shape()", object.id);
                        self.set_shape(object, client, message.uint()?, message.uint()?.try_into()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the cursor shape device."]
            #[doc = ""]
            #[doc = "The device cursor shape remains unchanged."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the device cursor to the specified shape. The compositor will"]
            #[doc = "change the cursor image based on the specified shape."]
            #[doc = ""]
            #[doc = "The cursor actually changes only if the input device focus is one of"]
            #[doc = "the requesting client's surfaces. If any, the previous cursor image"]
            #[doc = "(surface or shape) is replaced."]
            #[doc = ""]
            #[doc = "The \"shape\" argument must be a valid enum entry, otherwise the"]
            #[doc = "invalid_shape protocol error is raised."]
            #[doc = ""]
            #[doc = "This is similar to the wl_pointer.set_cursor and"]
            #[doc = "zwp_tablet_tool_v2.set_cursor requests, but this request accepts a"]
            #[doc = "shape instead of contents in the form of a surface. Clients can mix"]
            #[doc = "set_cursor and set_shape requests."]
            #[doc = ""]
            #[doc = "The serial parameter must match the latest wl_pointer.enter or"]
            #[doc = "zwp_tablet_tool_v2.proximity_in serial number sent to the client."]
            #[doc = "Otherwise the request will be ignored."]
            async fn set_shape(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                shape: Shape,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod drm_lease_v1 {
    #[doc = "This protocol is used by Wayland compositors which act as Direct"]
    #[doc = "Rendering Manager (DRM) masters to lease DRM resources to Wayland"]
    #[doc = "clients."]
    #[doc = ""]
    #[doc = "The compositor will advertise one wp_drm_lease_device_v1 global for each"]
    #[doc = "DRM node. Some time after a client binds to the wp_drm_lease_device_v1"]
    #[doc = "global, the compositor will send a drm_fd event followed by zero, one or"]
    #[doc = "more connector events. After all currently available connectors have been"]
    #[doc = "sent, the compositor will send a wp_drm_lease_device_v1.done event."]
    #[doc = ""]
    #[doc = "When the list of connectors available for lease changes the compositor"]
    #[doc = "will send wp_drm_lease_device_v1.connector events for added connectors and"]
    #[doc = "wp_drm_lease_connector_v1.withdrawn events for removed connectors,"]
    #[doc = "followed by a wp_drm_lease_device_v1.done event."]
    #[doc = ""]
    #[doc = "The compositor will indicate when a device is gone by removing the global"]
    #[doc = "via a wl_registry.global_remove event. Upon receiving this event, the"]
    #[doc = "client should destroy any matching wp_drm_lease_device_v1 object."]
    #[doc = ""]
    #[doc = "To destroy a wp_drm_lease_device_v1 object, the client must first issue"]
    #[doc = "a release request. Upon receiving this request, the compositor will"]
    #[doc = "immediately send a released event and destroy the object. The client must"]
    #[doc = "continue to process and discard drm_fd and connector events until it"]
    #[doc = "receives the released event. Upon receiving the released event, the"]
    #[doc = "client can safely cleanup any client-side resources."]
    #[doc = ""]
    #[doc = "Warning! The protocol described in this file is currently in the testing"]
    #[doc = "phase. Backward compatible changes may be added together with the"]
    #[doc = "corresponding interface version bump. Backward incompatible changes can"]
    #[doc = "only be done by creating a new major version of the extension."]
    pub mod wp_drm_lease_device_v1 {
        #[doc = "Trait to implement the wp_drm_lease_device_v1 interface. See the module level documentation for more info"]
        pub trait WpDrmLeaseDeviceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_drm_lease_device_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "wp_drm_lease_device_v1#{}.create_lease_request()",
                            object.id
                        );
                        self.create_lease_request(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("wp_drm_lease_device_v1#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Creates a lease request object."]
            #[doc = ""]
            #[doc = "See the documentation for wp_drm_lease_request_v1 for details."]
            async fn create_lease_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Indicates the client no longer wishes to use this object. In response"]
            #[doc = "the compositor will immediately send the released event and destroy"]
            #[doc = "this object. It can however not guarantee that the client won't receive"]
            #[doc = "connector events before the released event. The client must not send any"]
            #[doc = "requests after this one, doing so will raise a wl_display error."]
            #[doc = "Existing connectors, lease request and leases will not be affected."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The compositor will send this event when the wp_drm_lease_device_v1"]
            #[doc = "global is bound, although there are no guarantees as to how long this"]
            #[doc = "takes - the compositor might need to wait until regaining DRM master."]
            #[doc = "The included fd is a non-master DRM file descriptor opened for this"]
            #[doc = "device and the compositor must not authenticate it."]
            #[doc = "The purpose of this event is to give the client the ability to"]
            #[doc = "query DRM and discover information which may help them pick the"]
            #[doc = "appropriate DRM device or select the appropriate connectors therein."]
            async fn drm_fd(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_drm_lease_device_v1#{}.drm_fd()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_fd(fd).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The compositor will use this event to advertise connectors available for"]
            #[doc = "lease by clients. This object may be passed into a lease request to"]
            #[doc = "indicate the client would like to lease that connector, see"]
            #[doc = "wp_drm_lease_request_v1.request_connector for details. While the"]
            #[doc = "compositor will make a best effort to not send disconnected connectors,"]
            #[doc = "no guarantees can be made."]
            #[doc = ""]
            #[doc = "The compositor must send the drm_fd event before sending connectors."]
            #[doc = "After the drm_fd event it will send all available connectors but may"]
            #[doc = "send additional connectors at any time."]
            async fn connector(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_drm_lease_device_v1#{}.connector()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The compositor will send this event to indicate that it has sent all"]
            #[doc = "currently available connectors after the client binds to the global or"]
            #[doc = "when it updates the connector list, for example on hotplug, drm master"]
            #[doc = "change or when a leased connector becomes available again. It will"]
            #[doc = "similarly send this event to group wp_drm_lease_connector_v1.withdrawn"]
            #[doc = "events of connectors of this device."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_drm_lease_device_v1#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent in response to the release request and indicates"]
            #[doc = "that the compositor is done sending connector events."]
            #[doc = "The compositor will destroy this object immediately after sending the"]
            #[doc = "event and it will become invalid. The client should release any"]
            #[doc = "resources associated with this device after receiving this event."]
            async fn released(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_drm_lease_device_v1#{}.released()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "Represents a DRM connector which is available for lease. These objects are"]
    #[doc = "created via wp_drm_lease_device_v1.connector events, and should be passed"]
    #[doc = "to lease requests via wp_drm_lease_request_v1.request_connector."]
    #[doc = "Immediately after the wp_drm_lease_connector_v1 object is created the"]
    #[doc = "compositor will send a name, a description, a connector_id and a done"]
    #[doc = "event. When the description is updated the compositor will send a"]
    #[doc = "description event followed by a done event."]
    pub mod wp_drm_lease_connector_v1 {
        #[doc = "Trait to implement the wp_drm_lease_connector_v1 interface. See the module level documentation for more info"]
        pub trait WpDrmLeaseConnectorV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_drm_lease_connector_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_drm_lease_connector_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "The client may send this request to indicate that it will not use this"]
            #[doc = "connector. Clients are encouraged to send this after receiving the"]
            #[doc = "\"withdrawn\" event so that the server can release the resources"]
            #[doc = "associated with this connector offer. Neither existing lease requests"]
            #[doc = "nor leases will be affected."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The compositor sends this event once the connector is created to"]
            #[doc = "indicate the name of this connector. This will not change for the"]
            #[doc = "duration of the Wayland session, but is not guaranteed to be consistent"]
            #[doc = "between sessions."]
            #[doc = ""]
            #[doc = "If the compositor supports wl_output version 4 and this connector"]
            #[doc = "corresponds to a wl_output, the compositor should use the same name as"]
            #[doc = "for the wl_output."]
            async fn name(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_drm_lease_connector_v1#{}.name()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(name))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The compositor sends this event once the connector is created to provide"]
            #[doc = "a human-readable description for this connector, which may be presented"]
            #[doc = "to the user. The compositor may send this event multiple times over the"]
            #[doc = "lifetime of this object to reflect changes in the description."]
            async fn description(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                description: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_drm_lease_connector_v1#{}.description()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(description))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The compositor sends this event once the connector is created to"]
            #[doc = "indicate the DRM object ID which represents the underlying connector"]
            #[doc = "that is being offered. Note that the final lease may include additional"]
            #[doc = "object IDs, such as CRTCs and planes."]
            async fn connector_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                connector_id: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_drm_lease_connector_v1#{}.connector_id()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(connector_id)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent after all properties of a connector have been sent."]
            #[doc = "This allows changes to the properties to be seen as atomic even if they"]
            #[doc = "happen via multiple events."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_drm_lease_connector_v1#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent to indicate that the compositor will no longer honor requests for"]
            #[doc = "DRM leases which include this connector. The client may still issue a"]
            #[doc = "lease request including this connector, but the compositor will send"]
            #[doc = "wp_drm_lease_v1.finished without issuing a lease fd. Compositors are"]
            #[doc = "encouraged to send this event when they lose access to connector, for"]
            #[doc = "example when the connector is hot-unplugged, when the connector gets"]
            #[doc = "leased to a client or when the compositor loses DRM master."]
            async fn withdrawn(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_drm_lease_connector_v1#{}.withdrawn()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A client that wishes to lease DRM resources will attach the list of"]
    #[doc = "connectors advertised with wp_drm_lease_device_v1.connector that they"]
    #[doc = "wish to lease, then use wp_drm_lease_request_v1.submit to submit the"]
    #[doc = "request."]
    pub mod wp_drm_lease_request_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "requested a connector from a different lease device"]
            WrongDevice = 0u32,
            #[doc = "requested a connector twice"]
            DuplicateConnector = 1u32,
            #[doc = "requested a lease without requesting a connector"]
            EmptyLease = 2u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::WrongDevice),
                    1u32 => Ok(Self::DuplicateConnector),
                    2u32 => Ok(Self::EmptyLease),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wp_drm_lease_request_v1 interface. See the module level documentation for more info"]
        pub trait WpDrmLeaseRequestV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_drm_lease_request_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "wp_drm_lease_request_v1#{}.request_connector()",
                            object.id
                        );
                        self.request_connector(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("wp_drm_lease_request_v1#{}.submit()", object.id);
                        self.submit(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Indicates that the client would like to lease the given connector."]
            #[doc = "This is only used as a suggestion, the compositor may choose to"]
            #[doc = "include any resources in the lease it issues, or change the set of"]
            #[doc = "leased resources at any time. Compositors are however encouraged to"]
            #[doc = "include the requested connector and other resources necessary"]
            #[doc = "to drive the connected output in the lease."]
            #[doc = ""]
            #[doc = "Requesting a connector that was created from a different lease device"]
            #[doc = "than this lease request raises the wrong_device error. Requesting a"]
            #[doc = "connector twice will raise the duplicate_connector error."]
            async fn request_connector(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                connector: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Submits the lease request and creates a new wp_drm_lease_v1 object."]
            #[doc = "After calling submit the compositor will immediately destroy this"]
            #[doc = "object, issuing any more requests will cause a wl_display error."]
            #[doc = "The compositor doesn't make any guarantees about the events of the"]
            #[doc = "lease object, clients cannot expect an immediate response."]
            #[doc = "Not requesting any connectors before submitting the lease request"]
            #[doc = "will raise the empty_lease error."]
            async fn submit(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "A DRM lease object is used to transfer the DRM file descriptor to the"]
    #[doc = "client and manage the lifetime of the lease."]
    #[doc = ""]
    #[doc = "Some time after the wp_drm_lease_v1 object is created, the compositor"]
    #[doc = "will reply with the lease request's result. If the lease request is"]
    #[doc = "granted, the compositor will send a lease_fd event. If the lease request"]
    #[doc = "is denied, the compositor will send a finished event without a lease_fd"]
    #[doc = "event."]
    pub mod wp_drm_lease_v1 {
        #[doc = "Trait to implement the wp_drm_lease_v1 interface. See the module level documentation for more info"]
        pub trait WpDrmLeaseV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_drm_lease_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_drm_lease_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "The client should send this to indicate that it no longer wishes to use"]
            #[doc = "this lease. The compositor should use drmModeRevokeLease on the"]
            #[doc = "appropriate file descriptor, if necessary."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event returns a file descriptor suitable for use with DRM-related"]
            #[doc = "ioctls. The client should use drmModeGetLease to enumerate the DRM"]
            #[doc = "objects which have been leased to them. The compositor guarantees it"]
            #[doc = "will not use the leased DRM objects itself until it sends the finished"]
            #[doc = "event. If the compositor cannot or will not grant a lease for the"]
            #[doc = "requested connectors, it will not send this event, instead sending the"]
            #[doc = "finished event."]
            #[doc = ""]
            #[doc = "The compositor will send this event at most once during this objects"]
            #[doc = "lifetime."]
            async fn lease_fd(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                leased_fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_drm_lease_v1#{}.lease_fd()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_fd(leased_fd).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The compositor uses this event to either reject a lease request, or if"]
            #[doc = "it previously sent a lease_fd, to notify the client that the lease has"]
            #[doc = "been revoked. If the client requires a new lease, they should destroy"]
            #[doc = "this object and submit a new lease request. The compositor will send"]
            #[doc = "no further events for this object after sending the finish event."]
            #[doc = "Compositors should revoke the lease when any of the leased resources"]
            #[doc = "become unavailable, namely when a hot-unplug occurs or when the"]
            #[doc = "compositor loses DRM master."]
            async fn finished(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_drm_lease_v1#{}.finished()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "The purpose of this protocol is to provide protocol object handles for"]
#[doc = "toplevels, possibly originating from another client."]
#[doc = ""]
#[doc = "This protocol is intentionally minimalistic and expects additional"]
#[doc = "functionality (e.g. creating a screencopy source from a toplevel handle,"]
#[doc = "getting information about the state of the toplevel) to be implemented"]
#[doc = "in extension protocols."]
#[doc = ""]
#[doc = "The compositor may choose to restrict this protocol to a special client"]
#[doc = "launched by the compositor itself or expose it to all clients,"]
#[doc = "this is compositor policy."]
#[doc = ""]
#[doc = "The key words \"must\", \"must not\", \"required\", \"shall\", \"shall not\","]
#[doc = "\"should\", \"should not\", \"recommended\",  \"may\", and \"optional\" in this"]
#[doc = "document are to be interpreted as described in IETF RFC 2119."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is currently in the testing"]
#[doc = "phase. Backward compatible changes may be added together with the"]
#[doc = "corresponding interface version bump. Backward incompatible changes can"]
#[doc = "only be done by creating a new major version of the extension."]
pub mod ext_foreign_toplevel_list_v1 {
    #[doc = "A toplevel is defined as a surface with a role similar to xdg_toplevel."]
    #[doc = "XWayland surfaces may be treated like toplevels in this protocol."]
    #[doc = ""]
    #[doc = "After a client binds the ext_foreign_toplevel_list_v1, each mapped"]
    #[doc = "toplevel window will be sent using the ext_foreign_toplevel_list_v1.toplevel"]
    #[doc = "event."]
    #[doc = ""]
    #[doc = "Clients which only care about the current state can perform a roundtrip after"]
    #[doc = "binding this global."]
    #[doc = ""]
    #[doc = "For each instance of ext_foreign_toplevel_list_v1, the compositor must"]
    #[doc = "create a new ext_foreign_toplevel_handle_v1 object for each mapped toplevel."]
    #[doc = ""]
    #[doc = "If a compositor implementation sends the ext_foreign_toplevel_list_v1.finished"]
    #[doc = "event after the global is bound, the compositor must not send any"]
    #[doc = "ext_foreign_toplevel_list_v1.toplevel events."]
    pub mod ext_foreign_toplevel_list_v1 {
        #[doc = "Trait to implement the ext_foreign_toplevel_list_v1 interface. See the module level documentation for more info"]
        pub trait ExtForeignToplevelListV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_foreign_toplevel_list_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("ext_foreign_toplevel_list_v1#{}.stop()", object.id);
                        self.stop(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("ext_foreign_toplevel_list_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request indicates that the client no longer wishes to receive"]
            #[doc = "events for new toplevels."]
            #[doc = ""]
            #[doc = "The Wayland protocol is asynchronous, meaning the compositor may send"]
            #[doc = "further toplevel events until the stop request is processed."]
            #[doc = "The client should wait for a ext_foreign_toplevel_list_v1.finished"]
            #[doc = "event before destroying this object."]
            async fn stop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This request should be called either when the client will no longer"]
            #[doc = "use the ext_foreign_toplevel_list_v1 or after the finished event"]
            #[doc = "has been received to allow destruction of the object."]
            #[doc = ""]
            #[doc = "If a client wishes to destroy this object it should send a"]
            #[doc = "ext_foreign_toplevel_list_v1.stop request and wait for a ext_foreign_toplevel_list_v1.finished"]
            #[doc = "event, then destroy the handles and then this object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is emitted whenever a new toplevel window is created. It is"]
            #[doc = "emitted for all toplevels, regardless of the app that has created them."]
            #[doc = ""]
            #[doc = "All initial properties of the toplevel (identifier, title, app_id) will be sent"]
            #[doc = "immediately after this event using the corresponding events for"]
            #[doc = "ext_foreign_toplevel_handle_v1. The compositor will use the"]
            #[doc = "ext_foreign_toplevel_handle_v1.done event to indicate when all data has"]
            #[doc = "been sent."]
            async fn toplevel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                toplevel: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_foreign_toplevel_list_v1#{}.toplevel()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(toplevel))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates that the compositor is done sending events"]
            #[doc = "to this object. The client should destroy the object."]
            #[doc = "See ext_foreign_toplevel_list_v1.destroy for more information."]
            #[doc = ""]
            #[doc = "The compositor must not send any more toplevel events after this event."]
            async fn finished(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_foreign_toplevel_list_v1#{}.finished()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A ext_foreign_toplevel_handle_v1 object represents a mapped toplevel"]
    #[doc = "window. A single app may have multiple mapped toplevels."]
    pub mod ext_foreign_toplevel_handle_v1 {
        #[doc = "Trait to implement the ext_foreign_toplevel_handle_v1 interface. See the module level documentation for more info"]
        pub trait ExtForeignToplevelHandleV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_foreign_toplevel_handle_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("ext_foreign_toplevel_handle_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request should be used when the client will no longer use the handle"]
            #[doc = "or after the closed event has been received to allow destruction of the"]
            #[doc = "object."]
            #[doc = ""]
            #[doc = "When a handle is destroyed, a new handle may not be created by the server"]
            #[doc = "until the toplevel is unmapped and then remapped. Destroying a toplevel handle"]
            #[doc = "is not recommended unless the client is cleaning up child objects"]
            #[doc = "before destroying the ext_foreign_toplevel_list_v1 object, the toplevel"]
            #[doc = "was closed or the toplevel handle will not be used in the future."]
            #[doc = ""]
            #[doc = "Other protocols which extend the ext_foreign_toplevel_handle_v1"]
            #[doc = "interface should require destructors for extension interfaces be"]
            #[doc = "called before allowing the toplevel handle to be destroyed."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The server will emit no further events on the ext_foreign_toplevel_handle_v1"]
            #[doc = "after this event. Any requests received aside from the destroy request must"]
            #[doc = "be ignored. Upon receiving this event, the client should destroy the handle."]
            #[doc = ""]
            #[doc = "Other protocols which extend the ext_foreign_toplevel_handle_v1"]
            #[doc = "interface must also ignore requests other than destructors."]
            async fn closed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_foreign_toplevel_handle_v1#{}.closed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent after all changes in the toplevel state have"]
            #[doc = "been sent."]
            #[doc = ""]
            #[doc = "This allows changes to the ext_foreign_toplevel_handle_v1 properties"]
            #[doc = "to be atomically applied. Other protocols which extend the"]
            #[doc = "ext_foreign_toplevel_handle_v1 interface may use this event to also"]
            #[doc = "atomically apply any pending state."]
            #[doc = ""]
            #[doc = "This event must not be sent after the ext_foreign_toplevel_handle_v1.closed"]
            #[doc = "event."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_foreign_toplevel_handle_v1#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The title of the toplevel has changed."]
            #[doc = ""]
            #[doc = "The configured state must not be applied immediately. See"]
            #[doc = "ext_foreign_toplevel_handle_v1.done for details."]
            async fn title(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                title: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_foreign_toplevel_handle_v1#{}.title()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(title))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The app id of the toplevel has changed."]
            #[doc = ""]
            #[doc = "The configured state must not be applied immediately. See"]
            #[doc = "ext_foreign_toplevel_handle_v1.done for details."]
            async fn app_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                app_id: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_foreign_toplevel_handle_v1#{}.app_id()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(app_id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This identifier is used to check if two or more toplevel handles belong"]
            #[doc = "to the same toplevel."]
            #[doc = ""]
            #[doc = "The identifier is useful for command line tools or privileged clients"]
            #[doc = "which may need to reference an exact toplevel across processes or"]
            #[doc = "instances of the ext_foreign_toplevel_list_v1 global."]
            #[doc = ""]
            #[doc = "The compositor must only send this event when the handle is created."]
            #[doc = ""]
            #[doc = "The identifier must be unique per toplevel and it's handles. Two different"]
            #[doc = "toplevels must not have the same identifier. The identifier is only valid"]
            #[doc = "as long as the toplevel is mapped. If the toplevel is unmapped the identifier"]
            #[doc = "must not be reused. An identifier must not be reused by the compositor to"]
            #[doc = "ensure there are no races when sharing identifiers between processes."]
            #[doc = ""]
            #[doc = "An identifier is a string that contains up to 32 printable ASCII bytes."]
            #[doc = "An identifier must not be an empty string. It is recommended that a"]
            #[doc = "compositor includes an opaque generation value in identifiers. How the"]
            #[doc = "generation value is used when generating the identifier is implementation"]
            #[doc = "dependent."]
            async fn identifier(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                identifier: String,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> ext_foreign_toplevel_handle_v1#{}.identifier()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(identifier))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod ext_idle_notify_v1 {
    #[doc = "This interface allows clients to monitor user idle status."]
    #[doc = ""]
    #[doc = "After binding to this global, clients can create ext_idle_notification_v1"]
    #[doc = "objects to get notified when the user is idle for a given amount of time."]
    pub mod ext_idle_notifier_v1 {
        #[doc = "Trait to implement the ext_idle_notifier_v1 interface. See the module level documentation for more info"]
        pub trait ExtIdleNotifierV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_idle_notifier_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("ext_idle_notifier_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "ext_idle_notifier_v1#{}.get_idle_notification()",
                            object.id
                        );
                        self.get_idle_notification(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the manager object. All objects created via this interface"]
            #[doc = "remain valid."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a new idle notification object."]
            #[doc = ""]
            #[doc = "The notification object has a minimum timeout duration and is tied to a"]
            #[doc = "seat. The client will be notified if the seat is inactive for at least"]
            #[doc = "the provided timeout. See ext_idle_notification_v1 for more details."]
            #[doc = ""]
            #[doc = "A zero timeout is valid and means the client wants to be notified as"]
            #[doc = "soon as possible when the seat is inactive."]
            async fn get_idle_notification(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                timeout: u32,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "This interface is used by the compositor to send idle notification events"]
    #[doc = "to clients."]
    #[doc = ""]
    #[doc = "Initially the notification object is not idle. The notification object"]
    #[doc = "becomes idle when no user activity has happened for at least the timeout"]
    #[doc = "duration, starting from the creation of the notification object. User"]
    #[doc = "activity may include input events or a presence sensor, but is"]
    #[doc = "compositor-specific. If an idle inhibitor is active (e.g. another client"]
    #[doc = "has created a zwp_idle_inhibitor_v1 on a visible surface), the compositor"]
    #[doc = "must not make the notification object idle."]
    #[doc = ""]
    #[doc = "When the notification object becomes idle, an idled event is sent. When"]
    #[doc = "user activity starts again, the notification object stops being idle,"]
    #[doc = "a resumed event is sent and the timeout is restarted."]
    pub mod ext_idle_notification_v1 {
        #[doc = "Trait to implement the ext_idle_notification_v1 interface. See the module level documentation for more info"]
        pub trait ExtIdleNotificationV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_idle_notification_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("ext_idle_notification_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the notification object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent when the notification object becomes idle."]
            #[doc = ""]
            #[doc = "It's a compositor protocol error to send this event twice without a"]
            #[doc = "resumed event in-between."]
            async fn idled(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_idle_notification_v1#{}.idled()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent when the notification object stops being idle."]
            #[doc = ""]
            #[doc = "It's a compositor protocol error to send this event twice without an"]
            #[doc = "idled event in-between. It's a compositor protocol error to send this"]
            #[doc = "event prior to any idled event."]
            async fn resumed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_idle_notification_v1#{}.resumed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "This protocol serves as an intermediary between capturing protocols and"]
#[doc = "potential image capture sources such as outputs and toplevels."]
#[doc = ""]
#[doc = "This protocol may be extended to support more image capture sources in the"]
#[doc = "future, thereby adding those image capture sources to other protocols that"]
#[doc = "use the image capture source object without having to modify those"]
#[doc = "protocols."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is currently in the testing"]
#[doc = "phase. Backward compatible changes may be added together with the"]
#[doc = "corresponding interface version bump. Backward incompatible changes can"]
#[doc = "only be done by creating a new major version of the extension."]
pub mod ext_image_capture_source_v1 {
    #[doc = "The image capture source object is an opaque descriptor for a capturable"]
    #[doc = "resource.  This resource may be any sort of entity from which an image"]
    #[doc = "may be derived."]
    #[doc = ""]
    #[doc = "Note, because ext_image_capture_source_v1 objects are created from multiple"]
    #[doc = "independent factory interfaces, the ext_image_capture_source_v1 interface is"]
    #[doc = "frozen at version 1."]
    pub mod ext_image_capture_source_v1 {
        #[doc = "Trait to implement the ext_image_capture_source_v1 interface. See the module level documentation for more info"]
        pub trait ExtImageCaptureSourceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_image_capture_source_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("ext_image_capture_source_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroys the image capture source. This request may be sent at any time"]
            #[doc = "by the client."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "A manager for creating image capture source objects for wl_output objects."]
    pub mod ext_output_image_capture_source_manager_v1 {
        #[doc = "Trait to implement the ext_output_image_capture_source_manager_v1 interface. See the module level documentation for more info"]
        pub trait ExtOutputImageCaptureSourceManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_output_image_capture_source_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "ext_output_image_capture_source_manager_v1#{}.create_source()",
                            object.id
                        );
                        self.create_source(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "ext_output_image_capture_source_manager_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Creates a source object for an output. Images captured from this source"]
            #[doc = "will show the same content as the output. Some elements may be omitted,"]
            #[doc = "such as cursors and overlays that have been marked as transparent to"]
            #[doc = "capturing."]
            async fn create_source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: crate::wire::ObjectId,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys the manager. This request may be sent at any time by the client"]
            #[doc = "and objects created by the manager will remain valid after its"]
            #[doc = "destruction."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "A manager for creating image capture source objects for"]
    #[doc = "ext_foreign_toplevel_handle_v1 objects."]
    pub mod ext_foreign_toplevel_image_capture_source_manager_v1 {
        #[doc = "Trait to implement the ext_foreign_toplevel_image_capture_source_manager_v1 interface. See the module level documentation for more info"]
        pub trait ExtForeignToplevelImageCaptureSourceManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_foreign_toplevel_image_capture_source_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing :: debug ! ("ext_foreign_toplevel_image_capture_source_manager_v1#{}.create_source()" , object . id);
                        self.create_source(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "ext_foreign_toplevel_image_capture_source_manager_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Creates a source object for a foreign toplevel handle. Images captured"]
            #[doc = "from this source will show the same content as the toplevel."]
            async fn create_source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: crate::wire::ObjectId,
                toplevel_handle: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys the manager. This request may be sent at any time by the client"]
            #[doc = "and objects created by the manager will remain valid after its"]
            #[doc = "destruction."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
#[doc = "This protocol allows clients to ask the compositor to capture image sources"]
#[doc = "such as outputs and toplevels into user submitted buffers."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is currently in the testing"]
#[doc = "phase. Backward compatible changes may be added together with the"]
#[doc = "corresponding interface version bump. Backward incompatible changes can"]
#[doc = "only be done by creating a new major version of the extension."]
pub mod ext_image_copy_capture_v1 {
    #[doc = "This object is a manager which offers requests to start capturing from a"]
    #[doc = "source."]
    pub mod ext_image_copy_capture_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "invalid option flag"]
            InvalidOption = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::InvalidOption),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! { # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Options : u32 { # [doc = "paint cursors onto captured frames"] const PaintCursors = 1u32 ; } }
        impl TryFrom<u32> for Options {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "Trait to implement the ext_image_copy_capture_manager_v1 interface. See the module level documentation for more info"]
        pub trait ExtImageCopyCaptureManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_image_copy_capture_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "ext_image_copy_capture_manager_v1#{}.create_session()",
                            object.id
                        );
                        self.create_session(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "ext_image_copy_capture_manager_v1#{}.create_pointer_cursor_session()",
                            object.id
                        );
                        self.create_pointer_cursor_session(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "ext_image_copy_capture_manager_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a capturing session for an image capture source."]
            #[doc = ""]
            #[doc = "If the paint_cursors option is set, cursors shall be composited onto"]
            #[doc = "the captured frame. The cursor must not be composited onto the frame"]
            #[doc = "if this flag is not set."]
            #[doc = ""]
            #[doc = "If the options bitfield is invalid, the invalid_option protocol error"]
            #[doc = "is sent."]
            async fn create_session(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                session: crate::wire::ObjectId,
                source: crate::wire::ObjectId,
                options: Options,
            ) -> crate::server::Result<()>;
            #[doc = "Create a cursor capturing session for the pointer of an image capture"]
            #[doc = "source."]
            async fn create_pointer_cursor_session(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                session: crate::wire::ObjectId,
                source: crate::wire::ObjectId,
                pointer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the manager object."]
            #[doc = ""]
            #[doc = "Other objects created via this interface are unaffected."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "This object represents an active image copy capture session."]
    #[doc = ""]
    #[doc = "After a capture session is created, buffer constraint events will be"]
    #[doc = "emitted from the compositor to tell the client which buffer types and"]
    #[doc = "formats are supported for reading from the session. The compositor may"]
    #[doc = "re-send buffer constraint events whenever they change."]
    #[doc = ""]
    #[doc = "The advertise buffer constraints, the compositor must send in no"]
    #[doc = "particular order: zero or more shm_format and dmabuf_format events, zero"]
    #[doc = "or one dmabuf_device event, and exactly one buffer_size event. Then the"]
    #[doc = "compositor must send a done event."]
    #[doc = ""]
    #[doc = "When the client has received all the buffer constraints, it can create a"]
    #[doc = "buffer accordingly, attach it to the capture session using the"]
    #[doc = "attach_buffer request, set the buffer damage using the damage_buffer"]
    #[doc = "request and then send the capture request."]
    pub mod ext_image_copy_capture_session_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "create_frame sent before destroying previous frame"]
            DuplicateFrame = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::DuplicateFrame),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the ext_image_copy_capture_session_v1 interface. See the module level documentation for more info"]
        pub trait ExtImageCopyCaptureSessionV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_image_copy_capture_session_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "ext_image_copy_capture_session_v1#{}.create_frame()",
                            object.id
                        );
                        self.create_frame(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "ext_image_copy_capture_session_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a capture frame for this session."]
            #[doc = ""]
            #[doc = "At most one frame object can exist for a given session at any time. If"]
            #[doc = "a client sends a create_frame request before a previous frame object"]
            #[doc = "has been destroyed, the duplicate_frame protocol error is raised."]
            async fn create_frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                frame: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys the session. This request can be sent at any time by the"]
            #[doc = "client."]
            #[doc = ""]
            #[doc = "This request doesn't affect ext_image_copy_capture_frame_v1 objects created by"]
            #[doc = "this object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Provides the dimensions of the source image in buffer pixel coordinates."]
            #[doc = ""]
            #[doc = "The client must attach buffers that match this size."]
            async fn buffer_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: u32,
                height: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> ext_image_copy_capture_session_v1#{}.buffer_size()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(width)
                    .put_uint(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Provides the format that must be used for shared-memory buffers."]
            #[doc = ""]
            #[doc = "This event may be emitted multiple times, in which case the client may"]
            #[doc = "choose any given format."]
            async fn shm_format(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                format: super::super::wayland::wl_shm::Format,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> ext_image_copy_capture_session_v1#{}.shm_format()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(format as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event advertises the device buffers must be allocated on for"]
            #[doc = "dma-buf buffers."]
            #[doc = ""]
            #[doc = "In general the device is a DRM node. The DRM node type (primary vs."]
            #[doc = "render) is unspecified. Clients must not rely on the compositor sending"]
            #[doc = "a particular node type. Clients cannot check two devices for equality"]
            #[doc = "by comparing the dev_t value."]
            async fn dmabuf_device(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                device: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> ext_image_copy_capture_session_v1#{}.dmabuf_device()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_array(device).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Provides the format that must be used for dma-buf buffers."]
            #[doc = ""]
            #[doc = "The client may choose any of the modifiers advertised in the array of"]
            #[doc = "64-bit unsigned integers."]
            #[doc = ""]
            #[doc = "This event may be emitted multiple times, in which case the client may"]
            #[doc = "choose any given format."]
            async fn dmabuf_format(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                format: u32,
                modifiers: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> ext_image_copy_capture_session_v1#{}.dmabuf_format()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(format)
                    .put_array(modifiers)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent once when all buffer constraint events have been"]
            #[doc = "sent."]
            #[doc = ""]
            #[doc = "The compositor must always end a batch of buffer constraint events with"]
            #[doc = "this event, regardless of whether it sends the initial constraints or"]
            #[doc = "an update."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_image_copy_capture_session_v1#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates that the capture session has stopped and is no"]
            #[doc = "longer available. This can happen in a number of cases, e.g. when the"]
            #[doc = "underlying source is destroyed, if the user decides to end the image"]
            #[doc = "capture, or if an unrecoverable runtime error has occurred."]
            #[doc = ""]
            #[doc = "The client should destroy the session after receiving this event."]
            async fn stopped(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> ext_image_copy_capture_session_v1#{}.stopped()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "This object represents an image capture frame."]
    #[doc = ""]
    #[doc = "The client should attach a buffer, damage the buffer, and then send a"]
    #[doc = "capture request."]
    #[doc = ""]
    #[doc = "If the capture is successful, the compositor must send the frame metadata"]
    #[doc = "(transform, damage, presentation_time in any order) followed by the ready"]
    #[doc = "event."]
    #[doc = ""]
    #[doc = "If the capture fails, the compositor must send the failed event."]
    pub mod ext_image_copy_capture_frame_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "capture sent without attach_buffer"]
            NoBuffer = 1u32,
            #[doc = "invalid buffer damage"]
            InvalidBufferDamage = 2u32,
            #[doc = "capture request has been sent"]
            AlreadyCaptured = 3u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::NoBuffer),
                    2u32 => Ok(Self::InvalidBufferDamage),
                    3u32 => Ok(Self::AlreadyCaptured),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum FailureReason {
            Unknown = 0u32,
            BufferConstraints = 1u32,
            Stopped = 2u32,
        }
        impl TryFrom<u32> for FailureReason {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Unknown),
                    1u32 => Ok(Self::BufferConstraints),
                    2u32 => Ok(Self::Stopped),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the ext_image_copy_capture_frame_v1 interface. See the module level documentation for more info"]
        pub trait ExtImageCopyCaptureFrameV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_image_copy_capture_frame_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("ext_image_copy_capture_frame_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "ext_image_copy_capture_frame_v1#{}.attach_buffer()",
                            object.id
                        );
                        self.attach_buffer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "ext_image_copy_capture_frame_v1#{}.damage_buffer()",
                            object.id
                        );
                        self.damage_buffer(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("ext_image_copy_capture_frame_v1#{}.capture()", object.id);
                        self.capture(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroys the session. This request can be sent at any time by the"]
            #[doc = "client."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Attach a buffer to the session."]
            #[doc = ""]
            #[doc = "The wl_buffer.release request is unused."]
            #[doc = ""]
            #[doc = "The new buffer replaces any previously attached buffer."]
            #[doc = ""]
            #[doc = "This request must not be sent after capture, or else the"]
            #[doc = "already_captured protocol error is raised."]
            async fn attach_buffer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Apply damage to the buffer which is to be captured next. This request"]
            #[doc = "may be sent multiple times to describe a region."]
            #[doc = ""]
            #[doc = "The client indicates the accumulated damage since this wl_buffer was"]
            #[doc = "last captured. During capture, the compositor will update the buffer"]
            #[doc = "with at least the union of the region passed by the client and the"]
            #[doc = "region advertised by ext_image_copy_capture_frame_v1.damage."]
            #[doc = ""]
            #[doc = "When a wl_buffer is captured for the first time, or when the client"]
            #[doc = "doesn't track damage, the client must damage the whole buffer."]
            #[doc = ""]
            #[doc = "This is for optimisation purposes. The compositor may use this"]
            #[doc = "information to reduce copying."]
            #[doc = ""]
            #[doc = "These coordinates originate from the upper left corner of the buffer."]
            #[doc = ""]
            #[doc = "If x or y are strictly negative, or if width or height are negative or"]
            #[doc = "zero, the invalid_buffer_damage protocol error is raised."]
            #[doc = ""]
            #[doc = "This request must not be sent after capture, or else the"]
            #[doc = "already_captured protocol error is raised."]
            async fn damage_buffer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Capture a frame."]
            #[doc = ""]
            #[doc = "Unless this is the first successful captured frame performed in this"]
            #[doc = "session, the compositor may wait an indefinite amount of time for the"]
            #[doc = "source content to change before performing the copy."]
            #[doc = ""]
            #[doc = "This request may only be sent once, or else the already_captured"]
            #[doc = "protocol error is raised. A buffer must be attached before this request"]
            #[doc = "is sent, or else the no_buffer protocol error is raised."]
            async fn capture(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent before the ready event and holds the transform that"]
            #[doc = "the compositor has applied to the buffer contents."]
            async fn transform(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                transform: super::super::wayland::wl_output::Transform,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> ext_image_copy_capture_frame_v1#{}.transform()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(transform as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent before the ready event. It may be generated multiple"]
            #[doc = "times to describe a region."]
            #[doc = ""]
            #[doc = "The first captured frame in a session will always carry full damage."]
            #[doc = "Subsequent frames' damaged regions describe which parts of the buffer"]
            #[doc = "have changed since the last ready event."]
            #[doc = ""]
            #[doc = "These coordinates originate in the upper left corner of the buffer."]
            async fn damage(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_image_copy_capture_frame_v1#{}.damage()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(x)
                    .put_int(y)
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates the time at which the frame is presented to the"]
            #[doc = "output in system monotonic time. This event is sent before the ready"]
            #[doc = "event."]
            #[doc = ""]
            #[doc = "The timestamp is expressed as tv_sec_hi, tv_sec_lo, tv_nsec triples,"]
            #[doc = "each component being an unsigned 32-bit value. Whole seconds are in"]
            #[doc = "tv_sec which is a 64-bit value combined from tv_sec_hi and tv_sec_lo,"]
            #[doc = "and the additional fractional part in tv_nsec as nanoseconds. Hence,"]
            #[doc = "for valid timestamps tv_nsec must be in [0, 999999999]."]
            async fn presentation_time(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tv_sec_hi: u32,
                tv_sec_lo: u32,
                tv_nsec: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> ext_image_copy_capture_frame_v1#{}.presentation_time()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(tv_sec_hi)
                    .put_uint(tv_sec_lo)
                    .put_uint(tv_nsec)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Called as soon as the frame is copied, indicating it is available"]
            #[doc = "for reading."]
            #[doc = ""]
            #[doc = "The buffer may be re-used by the client after this event."]
            #[doc = ""]
            #[doc = "After receiving this event, the client must destroy the object."]
            async fn ready(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_image_copy_capture_frame_v1#{}.ready()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates that the attempted frame copy has failed."]
            #[doc = ""]
            #[doc = "After receiving this event, the client must destroy the object."]
            async fn failed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                reason: FailureReason,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_image_copy_capture_frame_v1#{}.failed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(reason as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "This object represents a cursor capture session. It extends the base"]
    #[doc = "capture session with cursor-specific metadata."]
    pub mod ext_image_copy_capture_cursor_session_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "get_captuerer_session sent twice"]
            DuplicateSession = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::DuplicateSession),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the ext_image_copy_capture_cursor_session_v1 interface. See the module level documentation for more info"]
        pub trait ExtImageCopyCaptureCursorSessionV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_image_copy_capture_cursor_session_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "ext_image_copy_capture_cursor_session_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "ext_image_copy_capture_cursor_session_v1#{}.get_capture_session()",
                            object.id
                        );
                        self.get_capture_session(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroys the session. This request can be sent at any time by the"]
            #[doc = "client."]
            #[doc = ""]
            #[doc = "This request doesn't affect ext_image_copy_capture_frame_v1 objects created by"]
            #[doc = "this object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Gets the image copy capture session for this cursor session."]
            #[doc = ""]
            #[doc = "The session will produce frames of the cursor image. The compositor may"]
            #[doc = "pause the session when the cursor leaves the captured area."]
            #[doc = ""]
            #[doc = "This request must not be sent more than once, or else the"]
            #[doc = "duplicate_session protocol error is raised."]
            async fn get_capture_session(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                session: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Sent when a cursor enters the captured area. It shall be generated"]
            #[doc = "before the \"position\" and \"hotspot\" events when and only when a cursor"]
            #[doc = "enters the area."]
            #[doc = ""]
            #[doc = "The cursor enters the captured area when the cursor image intersects"]
            #[doc = "with the captured area. Note, this is different from e.g."]
            #[doc = "wl_pointer.enter."]
            async fn enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> ext_image_copy_capture_cursor_session_v1#{}.enter()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent when a cursor leaves the captured area. No \"position\" or \"hotspot\""]
            #[doc = "event is generated for the cursor until the cursor enters the captured"]
            #[doc = "area again."]
            async fn leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> ext_image_copy_capture_cursor_session_v1#{}.leave()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Cursors outside the image capture source do not get captured and no"]
            #[doc = "event will be generated for them."]
            #[doc = ""]
            #[doc = "The given position is the position of the cursor's hotspot and it is"]
            #[doc = "relative to the main buffer's top left corner in transformed buffer"]
            #[doc = "pixel coordinates. The coordinates may be negative or greater than the"]
            #[doc = "main buffer size."]
            async fn position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> ext_image_copy_capture_cursor_session_v1#{}.position()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(x)
                    .put_int(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The hotspot describes the offset between the cursor image and the"]
            #[doc = "position of the input device."]
            #[doc = ""]
            #[doc = "The given coordinates are the hotspot's offset from the origin in"]
            #[doc = "buffer coordinates."]
            #[doc = ""]
            #[doc = "Clients should not apply the hotspot immediately: the hotspot becomes"]
            #[doc = "effective when the next ext_image_copy_capture_frame_v1.ready event is received."]
            #[doc = ""]
            #[doc = "Compositors may delay this event until the client captures a new frame."]
            async fn hotspot(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> ext_image_copy_capture_cursor_session_v1#{}.hotspot()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(x)
                    .put_int(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "This protocol allows for a privileged Wayland client to lock the session"]
#[doc = "and display arbitrary graphics while the session is locked."]
#[doc = ""]
#[doc = "The compositor may choose to restrict this protocol to a special client"]
#[doc = "launched by the compositor itself or expose it to all privileged clients,"]
#[doc = "this is compositor policy."]
#[doc = ""]
#[doc = "The client is responsible for performing authentication and informing the"]
#[doc = "compositor when the session should be unlocked. If the client dies while"]
#[doc = "the session is locked the session remains locked, possibly permanently"]
#[doc = "depending on compositor policy."]
#[doc = ""]
#[doc = "The key words \"must\", \"must not\", \"required\", \"shall\", \"shall not\","]
#[doc = "\"should\", \"should not\", \"recommended\",  \"may\", and \"optional\" in this"]
#[doc = "document are to be interpreted as described in IETF RFC 2119."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is currently in the"]
#[doc = "testing phase. Backward compatible changes may be added together with"]
#[doc = "the corresponding interface version bump. Backward incompatible changes"]
#[doc = "can only be done by creating a new major version of the extension."]
pub mod ext_session_lock_v1 {
    #[doc = "This interface is used to request that the session be locked."]
    pub mod ext_session_lock_manager_v1 {
        #[doc = "Trait to implement the ext_session_lock_manager_v1 interface. See the module level documentation for more info"]
        pub trait ExtSessionLockManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_session_lock_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("ext_session_lock_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("ext_session_lock_manager_v1#{}.lock()", object.id);
                        self.lock(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This informs the compositor that the session lock manager object will"]
            #[doc = "no longer be used. Existing objects created through this interface"]
            #[doc = "remain valid."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This request creates a session lock and asks the compositor to lock the"]
            #[doc = "session. The compositor will send either the ext_session_lock_v1.locked"]
            #[doc = "or ext_session_lock_v1.finished event on the created object in"]
            #[doc = "response to this request."]
            async fn lock(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "In response to the creation of this object the compositor must send"]
    #[doc = "either the locked or finished event."]
    #[doc = ""]
    #[doc = "The locked event indicates that the session is locked. This means"]
    #[doc = "that the compositor must stop rendering and providing input to normal"]
    #[doc = "clients. Instead the compositor must blank all outputs with an opaque"]
    #[doc = "color such that their normal content is fully hidden."]
    #[doc = ""]
    #[doc = "The only surfaces that should be rendered while the session is locked"]
    #[doc = "are the lock surfaces created through this interface and optionally,"]
    #[doc = "at the compositor's discretion, special privileged surfaces such as"]
    #[doc = "input methods or portions of desktop shell UIs."]
    #[doc = ""]
    #[doc = "The locked event must not be sent until a new \"locked\" frame (either"]
    #[doc = "from a session lock surface or the compositor blanking the output) has"]
    #[doc = "been presented on all outputs and no security sensitive normal/unlocked"]
    #[doc = "content is possibly visible."]
    #[doc = ""]
    #[doc = "The finished event should be sent immediately on creation of this"]
    #[doc = "object if the compositor decides that the locked event will not be sent."]
    #[doc = ""]
    #[doc = "The compositor may wait for the client to create and render session lock"]
    #[doc = "surfaces before sending the locked event to avoid displaying intermediate"]
    #[doc = "blank frames. However, it must impose a reasonable time limit if"]
    #[doc = "waiting and send the locked event as soon as the hard requirements"]
    #[doc = "described above can be met if the time limit expires. Clients should"]
    #[doc = "immediately create lock surfaces for all outputs on creation of this"]
    #[doc = "object to make this possible."]
    #[doc = ""]
    #[doc = "This behavior of the locked event is required in order to prevent"]
    #[doc = "possible race conditions with clients that wish to suspend the system"]
    #[doc = "or similar after locking the session. Without these semantics, clients"]
    #[doc = "triggering a suspend after receiving the locked event would race with"]
    #[doc = "the first \"locked\" frame being presented and normal/unlocked frames"]
    #[doc = "might be briefly visible as the system is resumed if the suspend"]
    #[doc = "operation wins the race."]
    #[doc = ""]
    #[doc = "If the client dies while the session is locked, the compositor must not"]
    #[doc = "unlock the session in response. It is acceptable for the session to be"]
    #[doc = "permanently locked if this happens. The compositor may choose to continue"]
    #[doc = "to display the lock surfaces the client had mapped before it died or"]
    #[doc = "alternatively fall back to a solid color, this is compositor policy."]
    #[doc = ""]
    #[doc = "Compositors may also allow a secure way to recover the session, the"]
    #[doc = "details of this are compositor policy. Compositors may allow a new"]
    #[doc = "client to create a ext_session_lock_v1 object and take responsibility"]
    #[doc = "for unlocking the session, they may even start a new lock client"]
    #[doc = "instance automatically."]
    pub mod ext_session_lock_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "attempted to destroy session lock while locked"]
            InvalidDestroy = 0u32,
            #[doc = "unlock requested but locked event was never sent"]
            InvalidUnlock = 1u32,
            #[doc = "given wl_surface already has a role"]
            Role = 2u32,
            #[doc = "given output already has a lock surface"]
            DuplicateOutput = 3u32,
            #[doc = "given wl_surface has a buffer attached or committed"]
            AlreadyConstructed = 4u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidDestroy),
                    1u32 => Ok(Self::InvalidUnlock),
                    2u32 => Ok(Self::Role),
                    3u32 => Ok(Self::DuplicateOutput),
                    4u32 => Ok(Self::AlreadyConstructed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the ext_session_lock_v1 interface. See the module level documentation for more info"]
        pub trait ExtSessionLockV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_session_lock_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("ext_session_lock_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("ext_session_lock_v1#{}.get_lock_surface()", object.id);
                        self.get_lock_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("ext_session_lock_v1#{}.unlock_and_destroy()", object.id);
                        self.unlock_and_destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This informs the compositor that the lock object will no longer be"]
            #[doc = "used. Existing objects created through this interface remain valid."]
            #[doc = ""]
            #[doc = "After this request is made, lock surfaces created through this object"]
            #[doc = "should be destroyed by the client as they will no longer be used by"]
            #[doc = "the compositor."]
            #[doc = ""]
            #[doc = "It is a protocol error to make this request if the locked event was"]
            #[doc = "sent, the unlock_and_destroy request must be used instead."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The client is expected to create lock surfaces for all outputs"]
            #[doc = "currently present and any new outputs as they are advertised. These"]
            #[doc = "won't be displayed by the compositor unless the lock is successful"]
            #[doc = "and the locked event is sent."]
            #[doc = ""]
            #[doc = "Providing a wl_surface which already has a role or already has a buffer"]
            #[doc = "attached or committed is a protocol error, as is attaching/committing"]
            #[doc = "a buffer before the first ext_session_lock_surface_v1.configure event."]
            #[doc = ""]
            #[doc = "Attempting to create more than one lock surface for a given output"]
            #[doc = "is a duplicate_output protocol error."]
            async fn get_lock_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This request indicates that the session should be unlocked, for"]
            #[doc = "example because the user has entered their password and it has been"]
            #[doc = "verified by the client."]
            #[doc = ""]
            #[doc = "This request also informs the compositor that the lock object will"]
            #[doc = "no longer be used and should be destroyed. Existing objects created"]
            #[doc = "through this interface remain valid."]
            #[doc = ""]
            #[doc = "After this request is made, lock surfaces created through this object"]
            #[doc = "should be destroyed by the client as they will no longer be used by"]
            #[doc = "the compositor."]
            #[doc = ""]
            #[doc = "It is a protocol error to make this request if the locked event has"]
            #[doc = "not been sent. In that case, the lock object must be destroyed using"]
            #[doc = "the destroy request."]
            #[doc = ""]
            #[doc = "Note that a correct client that wishes to exit directly after unlocking"]
            #[doc = "the session must use the wl_display.sync request to ensure the server"]
            #[doc = "receives and processes the unlock_and_destroy request. Otherwise"]
            #[doc = "there is no guarantee that the server has unlocked the session due"]
            #[doc = "to the asynchronous nature of the Wayland protocol. For example,"]
            #[doc = "the server might terminate the client with a protocol error before"]
            #[doc = "it processes the unlock_and_destroy request."]
            async fn unlock_and_destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This client is now responsible for displaying graphics while the"]
            #[doc = "session is locked and deciding when to unlock the session."]
            #[doc = ""]
            #[doc = "The locked event must not be sent until a new \"locked\" frame has been"]
            #[doc = "presented on all outputs and no security sensitive normal/unlocked"]
            #[doc = "content is possibly visible."]
            #[doc = ""]
            #[doc = "If this event is sent, making the destroy request is a protocol error,"]
            #[doc = "the lock object must be destroyed using the unlock_and_destroy request."]
            async fn locked(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_session_lock_v1#{}.locked()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The compositor has decided that the session lock should be destroyed"]
            #[doc = "as it will no longer be used by the compositor. Exactly when this"]
            #[doc = "event is sent is compositor policy, but it must never be sent more"]
            #[doc = "than once for a given session lock object."]
            #[doc = ""]
            #[doc = "This might be sent because there is already another ext_session_lock_v1"]
            #[doc = "object held by a client, or the compositor has decided to deny the"]
            #[doc = "request to lock the session for some other reason. This might also"]
            #[doc = "be sent because the compositor implements some alternative, secure"]
            #[doc = "way to authenticate and unlock the session."]
            #[doc = ""]
            #[doc = "The finished event should be sent immediately on creation of this"]
            #[doc = "object if the compositor decides that the locked event will not"]
            #[doc = "be sent."]
            #[doc = ""]
            #[doc = "If the locked event is sent on creation of this object the finished"]
            #[doc = "event may still be sent at some later time in this object's"]
            #[doc = "lifetime. This is compositor policy."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should make either the destroy"]
            #[doc = "request or the unlock_and_destroy request, depending on whether or"]
            #[doc = "not the locked event was received on this object."]
            async fn finished(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_session_lock_v1#{}.finished()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "The client may use lock surfaces to display a screensaver, render a"]
    #[doc = "dialog to enter a password and unlock the session, or however else it"]
    #[doc = "sees fit."]
    #[doc = ""]
    #[doc = "On binding this interface the compositor will immediately send the"]
    #[doc = "first configure event. After making the ack_configure request in"]
    #[doc = "response to this event the client should attach and commit the first"]
    #[doc = "buffer. Committing the surface before acking the first configure is a"]
    #[doc = "protocol error. Committing the surface with a null buffer at any time"]
    #[doc = "is a protocol error."]
    #[doc = ""]
    #[doc = "The compositor is free to handle keyboard/pointer focus for lock"]
    #[doc = "surfaces however it chooses. A reasonable way to do this would be to"]
    #[doc = "give the first lock surface created keyboard focus and change keyboard"]
    #[doc = "focus if the user clicks on other surfaces."]
    pub mod ext_session_lock_surface_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "surface committed before first ack_configure request"]
            CommitBeforeFirstAck = 0u32,
            #[doc = "surface committed with a null buffer"]
            NullBuffer = 1u32,
            #[doc = "failed to match ack'd width/height"]
            DimensionsMismatch = 2u32,
            #[doc = "serial provided in ack_configure is invalid"]
            InvalidSerial = 3u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::CommitBeforeFirstAck),
                    1u32 => Ok(Self::NullBuffer),
                    2u32 => Ok(Self::DimensionsMismatch),
                    3u32 => Ok(Self::InvalidSerial),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the ext_session_lock_surface_v1 interface. See the module level documentation for more info"]
        pub trait ExtSessionLockSurfaceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_session_lock_surface_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("ext_session_lock_surface_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "ext_session_lock_surface_v1#{}.ack_configure()",
                            object.id
                        );
                        self.ack_configure(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This informs the compositor that the lock surface object will no"]
            #[doc = "longer be used."]
            #[doc = ""]
            #[doc = "It is recommended for a lock client to destroy lock surfaces if"]
            #[doc = "their corresponding wl_output global is removed."]
            #[doc = ""]
            #[doc = "If a lock surface on an active output is destroyed before the"]
            #[doc = "ext_session_lock_v1.unlock_and_destroy event is sent, the compositor"]
            #[doc = "must fall back to rendering a solid color."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "When a configure event is received, if a client commits the surface"]
            #[doc = "in response to the configure event, then the client must make an"]
            #[doc = "ack_configure request sometime before the commit request, passing"]
            #[doc = "along the serial of the configure event."]
            #[doc = ""]
            #[doc = "If the client receives multiple configure events before it can"]
            #[doc = "respond to one, it only has to ack the last configure event."]
            #[doc = ""]
            #[doc = "A client is not required to commit immediately after sending an"]
            #[doc = "ack_configure request - it may even ack_configure several times"]
            #[doc = "before its next surface commit."]
            #[doc = ""]
            #[doc = "A client may send multiple ack_configure requests before committing,"]
            #[doc = "but only the last request sent before a commit indicates which"]
            #[doc = "configure event the client really is responding to."]
            #[doc = ""]
            #[doc = "Sending an ack_configure request consumes the configure event"]
            #[doc = "referenced by the given serial, as well as all older configure events"]
            #[doc = "sent on this object."]
            #[doc = ""]
            #[doc = "It is a protocol error to issue multiple ack_configure requests"]
            #[doc = "referencing the same configure event or to issue an ack_configure"]
            #[doc = "request referencing a configure event older than the last configure"]
            #[doc = "event acked for a given lock surface."]
            async fn ack_configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent once on binding the interface and may be sent again"]
            #[doc = "at the compositor's discretion, for example if output geometry changes."]
            #[doc = ""]
            #[doc = "The width and height are in surface-local coordinates and are exact"]
            #[doc = "requirements. Failing to match these surface dimensions in the next"]
            #[doc = "commit after acking a configure is a protocol error."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                width: u32,
                height: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_session_lock_surface_v1#{}.configure()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(width)
                    .put_uint(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "The transient seat protocol can be used by privileged clients to create"]
#[doc = "independent seats that will be removed from the compositor when the client"]
#[doc = "destroys its transient seat."]
#[doc = ""]
#[doc = "This protocol is intended for use with virtual input protocols such as"]
#[doc = "\"virtual_keyboard_unstable_v1\" or \"wlr_virtual_pointer_unstable_v1\", both"]
#[doc = "of which allow the user to select a seat."]
#[doc = ""]
#[doc = "The \"wl_seat\" global created by this protocol does not generate input events"]
#[doc = "on its own, or have any capabilities except those assigned to it by other"]
#[doc = "protocol extensions, such as the ones mentioned above."]
#[doc = ""]
#[doc = "For example, a remote desktop server can create a seat with virtual inputs"]
#[doc = "for each remote user by following these steps for each new connection:"]
#[doc = "* Create a transient seat"]
#[doc = "* Wait for the transient seat to be created"]
#[doc = "* Locate a \"wl_seat\" global with a matching name"]
#[doc = "* Create virtual inputs using the resulting \"wl_seat\" global"]
pub mod ext_transient_seat_v1 {
    #[doc = "The transient seat manager creates short-lived seats."]
    pub mod ext_transient_seat_manager_v1 {
        #[doc = "Trait to implement the ext_transient_seat_manager_v1 interface. See the module level documentation for more info"]
        pub trait ExtTransientSeatManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_transient_seat_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("ext_transient_seat_manager_v1#{}.create()", object.id);
                        self.create(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("ext_transient_seat_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a new seat that is removed when the client side transient seat"]
            #[doc = "object is destroyed."]
            #[doc = ""]
            #[doc = "The actual seat may be removed sooner, in which case the transient seat"]
            #[doc = "object shall become inert."]
            async fn create(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the manager."]
            #[doc = ""]
            #[doc = "All objects created by the manager will remain valid until they are"]
            #[doc = "destroyed themselves."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "When the transient seat handle is destroyed, the seat itself will also be"]
    #[doc = "destroyed."]
    pub mod ext_transient_seat_v1 {
        #[doc = "Trait to implement the ext_transient_seat_v1 interface. See the module level documentation for more info"]
        pub trait ExtTransientSeatV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_transient_seat_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("ext_transient_seat_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "When the transient seat object is destroyed by the client, the"]
            #[doc = "associated seat created by the compositor is also destroyed."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event advertises the global name for the wl_seat to be used with"]
            #[doc = "wl_registry_bind."]
            #[doc = ""]
            #[doc = "It is sent exactly once, immediately after the transient seat is created"]
            #[doc = "and the new \"wl_seat\" global is advertised, if and only if the creation"]
            #[doc = "of the transient seat was allowed."]
            async fn ready(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                global_name: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_transient_seat_v1#{}.ready()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(global_name)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The event informs the client that the compositor denied its request to"]
            #[doc = "create a transient seat."]
            #[doc = ""]
            #[doc = "It is sent exactly once, immediately after the transient seat object is"]
            #[doc = "created, if and only if the creation of the transient seat was denied."]
            #[doc = ""]
            #[doc = "After receiving this event, the client should destroy the object."]
            async fn denied(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_transient_seat_v1#{}.denied()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "This protocol allows a compositor to suggest for surfaces to render at"]
#[doc = "fractional scales."]
#[doc = ""]
#[doc = "A client can submit scaled content by utilizing wp_viewport. This is done by"]
#[doc = "creating a wp_viewport object for the surface and setting the destination"]
#[doc = "rectangle to the surface size before the scale factor is applied."]
#[doc = ""]
#[doc = "The buffer size is calculated by multiplying the surface size by the"]
#[doc = "intended scale."]
#[doc = ""]
#[doc = "The wl_surface buffer scale should remain set to 1."]
#[doc = ""]
#[doc = "If a surface has a surface-local size of 100 px by 50 px and wishes to"]
#[doc = "submit buffers with a scale of 1.5, then a buffer of 150px by 75 px should"]
#[doc = "be used and the wp_viewport destination rectangle should be 100 px by 50 px."]
#[doc = ""]
#[doc = "For toplevel surfaces, the size is rounded halfway away from zero. The"]
#[doc = "rounding algorithm for subsurface position and size is not defined."]
pub mod fractional_scale_v1 {
    #[doc = "A global interface for requesting surfaces to use fractional scales."]
    pub mod wp_fractional_scale_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "the surface already has a fractional_scale object associated"]
            FractionalScaleExists = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::FractionalScaleExists),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wp_fractional_scale_manager_v1 interface. See the module level documentation for more info"]
        pub trait WpFractionalScaleManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_fractional_scale_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_fractional_scale_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "wp_fractional_scale_manager_v1#{}.get_fractional_scale()",
                            object.id
                        );
                        self.get_fractional_scale(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Informs the server that the client will not be using this protocol"]
            #[doc = "object anymore. This does not affect any other objects,"]
            #[doc = "wp_fractional_scale_v1 objects included."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create an add-on object for the the wl_surface to let the compositor"]
            #[doc = "request fractional scales. If the given wl_surface already has a"]
            #[doc = "wp_fractional_scale_v1 object associated, the fractional_scale_exists"]
            #[doc = "protocol error is raised."]
            async fn get_fractional_scale(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "An additional interface to a wl_surface object which allows the compositor"]
    #[doc = "to inform the client of the preferred scale."]
    pub mod wp_fractional_scale_v1 {
        #[doc = "Trait to implement the wp_fractional_scale_v1 interface. See the module level documentation for more info"]
        pub trait WpFractionalScaleV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_fractional_scale_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_fractional_scale_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the fractional scale object. When this object is destroyed,"]
            #[doc = "preferred_scale events will no longer be sent."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Notification of a new preferred scale for this surface that the"]
            #[doc = "compositor suggests that the client should use."]
            #[doc = ""]
            #[doc = "The sent scale is the numerator of a fraction with a denominator of 120."]
            async fn preferred_scale(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                scale: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_fractional_scale_v1#{}.preferred_scale()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(scale).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "This protocol allows clients to request explicit synchronization for"]
#[doc = "buffers. It is tied to the Linux DRM synchronization object framework."]
#[doc = ""]
#[doc = "Synchronization refers to co-ordination of pipelined operations performed"]
#[doc = "on buffers. Most GPU clients will schedule an asynchronous operation to"]
#[doc = "render to the buffer, then immediately send the buffer to the compositor"]
#[doc = "to be attached to a surface."]
#[doc = ""]
#[doc = "With implicit synchronization, ensuring that the rendering operation is"]
#[doc = "complete before the compositor displays the buffer is an implementation"]
#[doc = "detail handled by either the kernel or userspace graphics driver."]
#[doc = ""]
#[doc = "By contrast, with explicit synchronization, DRM synchronization object"]
#[doc = "timeline points mark when the asynchronous operations are complete. When"]
#[doc = "submitting a buffer, the client provides a timeline point which will be"]
#[doc = "waited on before the compositor accesses the buffer, and another timeline"]
#[doc = "point that the compositor will signal when it no longer needs to access the"]
#[doc = "buffer contents for the purposes of the surface commit."]
#[doc = ""]
#[doc = "Linux DRM synchronization objects are documented at:"]
#[doc = "https://dri.freedesktop.org/docs/drm/gpu/drm-mm.html#drm-sync-objects"]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is currently in the testing"]
#[doc = "phase. Backward compatible changes may be added together with the"]
#[doc = "corresponding interface version bump. Backward incompatible changes can"]
#[doc = "only be done by creating a new major version of the extension."]
pub mod linux_drm_syncobj_v1 {
    #[doc = "This global is a factory interface, allowing clients to request"]
    #[doc = "explicit synchronization for buffers on a per-surface basis."]
    #[doc = ""]
    #[doc = "See wp_linux_drm_syncobj_surface_v1 for more information."]
    pub mod wp_linux_drm_syncobj_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "the surface already has a synchronization object associated"]
            SurfaceExists = 0u32,
            #[doc = "the timeline object could not be imported"]
            InvalidTimeline = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::SurfaceExists),
                    1u32 => Ok(Self::InvalidTimeline),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wp_linux_drm_syncobj_manager_v1 interface. See the module level documentation for more info"]
        pub trait WpLinuxDrmSyncobjManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_linux_drm_syncobj_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_linux_drm_syncobj_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "wp_linux_drm_syncobj_manager_v1#{}.get_surface()",
                            object.id
                        );
                        self.get_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "wp_linux_drm_syncobj_manager_v1#{}.import_timeline()",
                            object.id
                        );
                        self.import_timeline(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.fd()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy this explicit synchronization factory object. Other objects"]
            #[doc = "shall not be affected by this request."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Instantiate an interface extension for the given wl_surface to provide"]
            #[doc = "explicit synchronization."]
            #[doc = ""]
            #[doc = "If the given wl_surface already has an explicit synchronization object"]
            #[doc = "associated, the surface_exists protocol error is raised."]
            #[doc = ""]
            #[doc = "Graphics APIs, like EGL or Vulkan, that manage the buffer queue and"]
            #[doc = "commits of a wl_surface themselves, are likely to be using this"]
            #[doc = "extension internally. If a client is using such an API for a"]
            #[doc = "wl_surface, it should not directly use this extension on that surface,"]
            #[doc = "to avoid raising a surface_exists protocol error."]
            async fn get_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Import a DRM synchronization object timeline."]
            #[doc = ""]
            #[doc = "If the FD cannot be imported, the invalid_timeline error is raised."]
            async fn import_timeline(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "This object represents an explicit synchronization object timeline"]
    #[doc = "imported by the client to the compositor."]
    pub mod wp_linux_drm_syncobj_timeline_v1 {
        #[doc = "Trait to implement the wp_linux_drm_syncobj_timeline_v1 interface. See the module level documentation for more info"]
        pub trait WpLinuxDrmSyncobjTimelineV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_linux_drm_syncobj_timeline_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_linux_drm_syncobj_timeline_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the synchronization object timeline. Other objects are not"]
            #[doc = "affected by this request, in particular timeline points set by"]
            #[doc = "set_acquire_point and set_release_point are not unset."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "This object is an add-on interface for wl_surface to enable explicit"]
    #[doc = "synchronization."]
    #[doc = ""]
    #[doc = "Each surface can be associated with only one object of this interface at"]
    #[doc = "any time."]
    #[doc = ""]
    #[doc = "Explicit synchronization is guaranteed to be supported for buffers"]
    #[doc = "created with any version of the linux-dmabuf protocol. Compositors are"]
    #[doc = "free to support explicit synchronization for additional buffer types."]
    #[doc = "If at surface commit time the attached buffer does not support explicit"]
    #[doc = "synchronization, an unsupported_buffer error is raised."]
    #[doc = ""]
    #[doc = "As long as the wp_linux_drm_syncobj_surface_v1 object is alive, the"]
    #[doc = "compositor may ignore implicit synchronization for buffers attached and"]
    #[doc = "committed to the wl_surface. The delivery of wl_buffer.release events"]
    #[doc = "for buffers attached to the surface becomes undefined."]
    #[doc = ""]
    #[doc = "Clients must set both acquire and release points if and only if a"]
    #[doc = "non-null buffer is attached in the same surface commit. See the"]
    #[doc = "no_buffer, no_acquire_point and no_release_point protocol errors."]
    #[doc = ""]
    #[doc = "If at surface commit time the acquire and release DRM syncobj timelines"]
    #[doc = "are identical, the acquire point value must be strictly less than the"]
    #[doc = "release point value, or else the conflicting_points protocol error is"]
    #[doc = "raised."]
    pub mod wp_linux_drm_syncobj_surface_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "the associated wl_surface was destroyed"]
            NoSurface = 1u32,
            #[doc = "the buffer does not support explicit synchronization"]
            UnsupportedBuffer = 2u32,
            #[doc = "no buffer was attached"]
            NoBuffer = 3u32,
            #[doc = "no acquire timeline point was set"]
            NoAcquirePoint = 4u32,
            #[doc = "no release timeline point was set"]
            NoReleasePoint = 5u32,
            #[doc = "acquire and release timeline points are in conflict"]
            ConflictingPoints = 6u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::NoSurface),
                    2u32 => Ok(Self::UnsupportedBuffer),
                    3u32 => Ok(Self::NoBuffer),
                    4u32 => Ok(Self::NoAcquirePoint),
                    5u32 => Ok(Self::NoReleasePoint),
                    6u32 => Ok(Self::ConflictingPoints),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wp_linux_drm_syncobj_surface_v1 interface. See the module level documentation for more info"]
        pub trait WpLinuxDrmSyncobjSurfaceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_linux_drm_syncobj_surface_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_linux_drm_syncobj_surface_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "wp_linux_drm_syncobj_surface_v1#{}.set_acquire_point()",
                            object.id
                        );
                        self.set_acquire_point(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "wp_linux_drm_syncobj_surface_v1#{}.set_release_point()",
                            object.id
                        );
                        self.set_release_point(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy this surface synchronization object."]
            #[doc = ""]
            #[doc = "Any timeline point set by this object with set_acquire_point or"]
            #[doc = "set_release_point since the last commit may be discarded by the"]
            #[doc = "compositor. Any timeline point set by this object before the last"]
            #[doc = "commit will not be affected."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the timeline point that must be signalled before the compositor may"]
            #[doc = "sample from the buffer attached with wl_surface.attach."]
            #[doc = ""]
            #[doc = "The 64-bit unsigned value combined from point_hi and point_lo is the"]
            #[doc = "point value."]
            #[doc = ""]
            #[doc = "The acquire point is double-buffered state, and will be applied on the"]
            #[doc = "next wl_surface.commit request for the associated surface. Thus, it"]
            #[doc = "applies only to the buffer that is attached to the surface at commit"]
            #[doc = "time."]
            #[doc = ""]
            #[doc = "If an acquire point has already been attached during the same commit"]
            #[doc = "cycle, the new point replaces the old one."]
            #[doc = ""]
            #[doc = "If the associated wl_surface was destroyed, a no_surface error is"]
            #[doc = "raised."]
            #[doc = ""]
            #[doc = "If at surface commit time there is a pending acquire timeline point set"]
            #[doc = "but no pending buffer attached, a no_buffer error is raised. If at"]
            #[doc = "surface commit time there is a pending buffer attached but no pending"]
            #[doc = "acquire timeline point set, the no_acquire_point protocol error is"]
            #[doc = "raised."]
            async fn set_acquire_point(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                timeline: crate::wire::ObjectId,
                point_hi: u32,
                point_lo: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Set the timeline point that must be signalled by the compositor when it"]
            #[doc = "has finished its usage of the buffer attached with wl_surface.attach"]
            #[doc = "for the relevant commit."]
            #[doc = ""]
            #[doc = "Once the timeline point is signaled, and assuming the associated buffer"]
            #[doc = "is not pending release from other wl_surface.commit requests, no"]
            #[doc = "additional explicit or implicit synchronization with the compositor is"]
            #[doc = "required to safely re-use the buffer."]
            #[doc = ""]
            #[doc = "Note that clients cannot rely on the release point being always"]
            #[doc = "signaled after the acquire point: compositors may release buffers"]
            #[doc = "without ever reading from them. In addition, the compositor may use"]
            #[doc = "different presentation paths for different commits, which may have"]
            #[doc = "different release behavior. As a result, the compositor may signal the"]
            #[doc = "release points in a different order than the client committed them."]
            #[doc = ""]
            #[doc = "Because signaling a timeline point also signals every previous point,"]
            #[doc = "it is generally not safe to use the same timeline object for the"]
            #[doc = "release points of multiple buffers. The out-of-order signaling"]
            #[doc = "described above may lead to a release point being signaled before the"]
            #[doc = "compositor has finished reading. To avoid this, it is strongly"]
            #[doc = "recommended that each buffer should use a separate timeline for its"]
            #[doc = "release points."]
            #[doc = ""]
            #[doc = "The 64-bit unsigned value combined from point_hi and point_lo is the"]
            #[doc = "point value."]
            #[doc = ""]
            #[doc = "The release point is double-buffered state, and will be applied on the"]
            #[doc = "next wl_surface.commit request for the associated surface. Thus, it"]
            #[doc = "applies only to the buffer that is attached to the surface at commit"]
            #[doc = "time."]
            #[doc = ""]
            #[doc = "If a release point has already been attached during the same commit"]
            #[doc = "cycle, the new point replaces the old one."]
            #[doc = ""]
            #[doc = "If the associated wl_surface was destroyed, a no_surface error is"]
            #[doc = "raised."]
            #[doc = ""]
            #[doc = "If at surface commit time there is a pending release timeline point set"]
            #[doc = "but no pending buffer attached, a no_buffer error is raised. If at"]
            #[doc = "surface commit time there is a pending buffer attached but no pending"]
            #[doc = "release timeline point set, the no_release_point protocol error is"]
            #[doc = "raised."]
            async fn set_release_point(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                timeline: crate::wire::ObjectId,
                point_hi: u32,
                point_lo: u32,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod security_context_v1 {
    #[doc = "This interface allows a client to register a new Wayland connection to"]
    #[doc = "the compositor and attach a security context to it."]
    #[doc = ""]
    #[doc = "This is intended to be used by sandboxes. Sandbox engines attach a"]
    #[doc = "security context to all connections coming from inside the sandbox. The"]
    #[doc = "compositor can then restrict the features that the sandboxed connections"]
    #[doc = "can use."]
    #[doc = ""]
    #[doc = "Compositors should forbid nesting multiple security contexts by not"]
    #[doc = "exposing wp_security_context_manager_v1 global to clients with a security"]
    #[doc = "context attached, or by sending the nested protocol error. Nested"]
    #[doc = "security contexts are dangerous because they can potentially allow"]
    #[doc = "privilege escalation of a sandboxed client."]
    #[doc = ""]
    #[doc = "Warning! The protocol described in this file is currently in the testing"]
    #[doc = "phase. Backward compatible changes may be added together with the"]
    #[doc = "corresponding interface version bump. Backward incompatible changes can"]
    #[doc = "only be done by creating a new major version of the extension."]
    pub mod wp_security_context_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "listening socket FD is invalid"]
            InvalidListenFd = 1u32,
            #[doc = "nested security contexts are forbidden"]
            Nested = 2u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::InvalidListenFd),
                    2u32 => Ok(Self::Nested),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wp_security_context_manager_v1 interface. See the module level documentation for more info"]
        pub trait WpSecurityContextManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_security_context_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_security_context_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "wp_security_context_manager_v1#{}.create_listener()",
                            object.id
                        );
                        self.create_listener(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.fd()?,
                            message.fd()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the manager. This doesn't destroy objects created with the"]
            #[doc = "manager."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Creates a new security context with a socket listening FD."]
            #[doc = ""]
            #[doc = "The compositor will accept new client connections on listen_fd."]
            #[doc = "listen_fd must be ready to accept new connections when this request is"]
            #[doc = "sent by the client. In other words, the client must call bind(2) and"]
            #[doc = "listen(2) before sending the FD."]
            #[doc = ""]
            #[doc = "close_fd is a FD closed by the client when the compositor should stop"]
            #[doc = "accepting new connections on listen_fd."]
            #[doc = ""]
            #[doc = "The compositor must continue to accept connections on listen_fd when"]
            #[doc = "the Wayland client which created the security context disconnects."]
            #[doc = ""]
            #[doc = "After sending this request, closing listen_fd and close_fd remains the"]
            #[doc = "only valid operation on them."]
            async fn create_listener(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                listen_fd: rustix::fd::OwnedFd,
                close_fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "The security context allows a client to register a new client and attach"]
    #[doc = "security context metadata to the connections."]
    #[doc = ""]
    #[doc = "When both are set, the combination of the application ID and the sandbox"]
    #[doc = "engine must uniquely identify an application. The same application ID"]
    #[doc = "will be used across instances (e.g. if the application is restarted, or"]
    #[doc = "if the application is started multiple times)."]
    #[doc = ""]
    #[doc = "When both are set, the combination of the instance ID and the sandbox"]
    #[doc = "engine must uniquely identify a running instance of an application."]
    pub mod wp_security_context_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "security context has already been committed"]
            AlreadyUsed = 1u32,
            #[doc = "metadata has already been set"]
            AlreadySet = 2u32,
            #[doc = "metadata is invalid"]
            InvalidMetadata = 3u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::AlreadyUsed),
                    2u32 => Ok(Self::AlreadySet),
                    3u32 => Ok(Self::InvalidMetadata),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wp_security_context_v1 interface. See the module level documentation for more info"]
        pub trait WpSecurityContextV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_security_context_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_security_context_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "wp_security_context_v1#{}.set_sandbox_engine()",
                            object.id
                        );
                        self.set_sandbox_engine(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("wp_security_context_v1#{}.set_app_id()", object.id);
                        self.set_app_id(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("wp_security_context_v1#{}.set_instance_id()", object.id);
                        self.set_instance_id(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("wp_security_context_v1#{}.commit()", object.id);
                        self.commit(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the security context object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Attach a unique sandbox engine name to the security context. The name"]
            #[doc = "should follow the reverse-DNS style (e.g. \"org.flatpak\")."]
            #[doc = ""]
            #[doc = "A list of well-known engines is maintained at:"]
            #[doc = "https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/security-context/engines.md"]
            #[doc = ""]
            #[doc = "It is a protocol error to call this request twice. The already_set"]
            #[doc = "error is sent in this case."]
            async fn set_sandbox_engine(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
            ) -> crate::server::Result<()>;
            #[doc = "Attach an application ID to the security context."]
            #[doc = ""]
            #[doc = "The application ID is an opaque, sandbox-specific identifier for an"]
            #[doc = "application. See the well-known engines document for more details:"]
            #[doc = "https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/security-context/engines.md"]
            #[doc = ""]
            #[doc = "The compositor may use the application ID to group clients belonging to"]
            #[doc = "the same security context application."]
            #[doc = ""]
            #[doc = "Whether this request is optional or not depends on the sandbox engine used."]
            #[doc = ""]
            #[doc = "It is a protocol error to call this request twice. The already_set"]
            #[doc = "error is sent in this case."]
            async fn set_app_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                app_id: String,
            ) -> crate::server::Result<()>;
            #[doc = "Attach an instance ID to the security context."]
            #[doc = ""]
            #[doc = "The instance ID is an opaque, sandbox-specific identifier for a running"]
            #[doc = "instance of an application. See the well-known engines document for"]
            #[doc = "more details:"]
            #[doc = "https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/security-context/engines.md"]
            #[doc = ""]
            #[doc = "Whether this request is optional or not depends on the sandbox engine used."]
            #[doc = ""]
            #[doc = "It is a protocol error to call this request twice. The already_set"]
            #[doc = "error is sent in this case."]
            async fn set_instance_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                instance_id: String,
            ) -> crate::server::Result<()>;
            #[doc = "Atomically register the new client and attach the security context"]
            #[doc = "metadata."]
            #[doc = ""]
            #[doc = "If the provided metadata is inconsistent or does not match with out of"]
            #[doc = "band metadata (see"]
            #[doc = "https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/security-context/engines.md),"]
            #[doc = "the invalid_metadata error may be sent eventually."]
            #[doc = ""]
            #[doc = "It's a protocol error to send any request other than \"destroy\" after"]
            #[doc = "this request. In this case, the already_used error is sent."]
            async fn commit(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
#[doc = "This protocol extension allows clients to create single-pixel buffers."]
#[doc = ""]
#[doc = "Compositors supporting this protocol extension should also support the"]
#[doc = "viewporter protocol extension. Clients may use viewporter to scale a"]
#[doc = "single-pixel buffer to a desired size."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is currently in the testing"]
#[doc = "phase. Backward compatible changes may be added together with the"]
#[doc = "corresponding interface version bump. Backward incompatible changes can"]
#[doc = "only be done by creating a new major version of the extension."]
pub mod single_pixel_buffer_v1 {
    #[doc = "The wp_single_pixel_buffer_manager_v1 interface is a factory for"]
    #[doc = "single-pixel buffers."]
    pub mod wp_single_pixel_buffer_manager_v1 {
        #[doc = "Trait to implement the wp_single_pixel_buffer_manager_v1 interface. See the module level documentation for more info"]
        pub trait WpSinglePixelBufferManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_single_pixel_buffer_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "wp_single_pixel_buffer_manager_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "wp_single_pixel_buffer_manager_v1#{}.create_u32_rgba_buffer()",
                            object.id
                        );
                        self.create_u32_rgba_buffer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the wp_single_pixel_buffer_manager_v1 object."]
            #[doc = ""]
            #[doc = "The child objects created via this interface are unaffected."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a single-pixel buffer from four 32-bit RGBA values."]
            #[doc = ""]
            #[doc = "Unless specified in another protocol extension, the RGBA values use"]
            #[doc = "pre-multiplied alpha."]
            #[doc = ""]
            #[doc = "The width and height of the buffer are 1."]
            async fn create_u32_rgba_buffer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                r: u32,
                g: u32,
                b: u32,
                a: u32,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod tearing_control_v1 {
    #[doc = "For some use cases like games or drawing tablets it can make sense to"]
    #[doc = "reduce latency by accepting tearing with the use of asynchronous page"]
    #[doc = "flips. This global is a factory interface, allowing clients to inform"]
    #[doc = "which type of presentation the content of their surfaces is suitable for."]
    #[doc = ""]
    #[doc = "Graphics APIs like EGL or Vulkan, that manage the buffer queue and commits"]
    #[doc = "of a wl_surface themselves, are likely to be using this extension"]
    #[doc = "internally. If a client is using such an API for a wl_surface, it should"]
    #[doc = "not directly use this extension on that surface, to avoid raising a"]
    #[doc = "tearing_control_exists protocol error."]
    #[doc = ""]
    #[doc = "Warning! The protocol described in this file is currently in the testing"]
    #[doc = "phase. Backward compatible changes may be added together with the"]
    #[doc = "corresponding interface version bump. Backward incompatible changes can"]
    #[doc = "only be done by creating a new major version of the extension."]
    pub mod wp_tearing_control_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "the surface already has a tearing object associated"]
            TearingControlExists = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::TearingControlExists),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wp_tearing_control_manager_v1 interface. See the module level documentation for more info"]
        pub trait WpTearingControlManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_tearing_control_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wp_tearing_control_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "wp_tearing_control_manager_v1#{}.get_tearing_control()",
                            object.id
                        );
                        self.get_tearing_control(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy this tearing control factory object. Other objects, including"]
            #[doc = "wp_tearing_control_v1 objects created by this factory, are not affected"]
            #[doc = "by this request."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Instantiate an interface extension for the given wl_surface to request"]
            #[doc = "asynchronous page flips for presentation."]
            #[doc = ""]
            #[doc = "If the given wl_surface already has a wp_tearing_control_v1 object"]
            #[doc = "associated, the tearing_control_exists protocol error is raised."]
            async fn get_tearing_control(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "An additional interface to a wl_surface object, which allows the client"]
    #[doc = "to hint to the compositor if the content on the surface is suitable for"]
    #[doc = "presentation with tearing."]
    #[doc = "The default presentation hint is vsync. See presentation_hint for more"]
    #[doc = "details."]
    #[doc = ""]
    #[doc = "If the associated wl_surface is destroyed, this object becomes inert and"]
    #[doc = "should be destroyed."]
    pub mod wp_tearing_control_v1 {
        #[doc = "This enum provides information for if submitted frames from the client"]
        #[doc = "may be presented with tearing."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum PresentationHint {
            Vsync = 0u32,
            Async = 1u32,
        }
        impl TryFrom<u32> for PresentationHint {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Vsync),
                    1u32 => Ok(Self::Async),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wp_tearing_control_v1 interface. See the module level documentation for more info"]
        pub trait WpTearingControlV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_tearing_control_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "wp_tearing_control_v1#{}.set_presentation_hint()",
                            object.id
                        );
                        self.set_presentation_hint(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    1u16 => {
                        tracing::debug!("wp_tearing_control_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Set the presentation hint for the associated wl_surface. This state is"]
            #[doc = "double-buffered, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "The compositor is free to dynamically respect or ignore this hint based"]
            #[doc = "on various conditions like hardware capabilities, surface state and"]
            #[doc = "user preferences."]
            async fn set_presentation_hint(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                hint: PresentationHint,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy this surface tearing object and revert the presentation hint to"]
            #[doc = "vsync. The change will be applied on the next wl_surface.commit."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
#[doc = "The way for a client to pass focus to another toplevel is as follows."]
#[doc = ""]
#[doc = "The client that intends to activate another toplevel uses the"]
#[doc = "xdg_activation_v1.get_activation_token request to get an activation token."]
#[doc = "This token is then forwarded to the client, which is supposed to activate"]
#[doc = "one of its surfaces, through a separate band of communication."]
#[doc = ""]
#[doc = "One established way of doing this is through the XDG_ACTIVATION_TOKEN"]
#[doc = "environment variable of a newly launched child process. The child process"]
#[doc = "should unset the environment variable again right after reading it out in"]
#[doc = "order to avoid propagating it to other child processes."]
#[doc = ""]
#[doc = "Another established way exists for Applications implementing the D-Bus"]
#[doc = "interface org.freedesktop.Application, which should get their token under"]
#[doc = "activation-token on their platform_data."]
#[doc = ""]
#[doc = "In general activation tokens may be transferred across clients through"]
#[doc = "means not described in this protocol."]
#[doc = ""]
#[doc = "The client to be activated will then pass the token"]
#[doc = "it received to the xdg_activation_v1.activate request. The compositor can"]
#[doc = "then use this token to decide how to react to the activation request."]
#[doc = ""]
#[doc = "The token the activating client gets may be ineffective either already at"]
#[doc = "the time it receives it, for example if it was not focused, for focus"]
#[doc = "stealing prevention. The activating client will have no way to discover"]
#[doc = "the validity of the token, and may still forward it to the to be activated"]
#[doc = "client."]
#[doc = ""]
#[doc = "The created activation token may optionally get information attached to it"]
#[doc = "that can be used by the compositor to identify the application that we"]
#[doc = "intend to activate. This can for example be used to display a visual hint"]
#[doc = "about what application is being started."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is currently in the testing"]
#[doc = "phase. Backward compatible changes may be added together with the"]
#[doc = "corresponding interface version bump. Backward incompatible changes can"]
#[doc = "only be done by creating a new major version of the extension."]
pub mod xdg_activation_v1 {
    #[doc = "A global interface used for informing the compositor about applications"]
    #[doc = "being activated or started, or for applications to request to be"]
    #[doc = "activated."]
    pub mod xdg_activation_v1 {
        #[doc = "Trait to implement the xdg_activation_v1 interface. See the module level documentation for more info"]
        pub trait XdgActivationV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_activation_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_activation_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_activation_v1#{}.get_activation_token()", object.id);
                        self.get_activation_token(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("xdg_activation_v1#{}.activate()", object.id);
                        self.activate(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Notify the compositor that the xdg_activation object will no longer be"]
            #[doc = "used."]
            #[doc = ""]
            #[doc = "The child objects created via this interface are unaffected and should"]
            #[doc = "be destroyed separately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Creates an xdg_activation_token_v1 object that will provide"]
            #[doc = "the initiating client with a unique token for this activation. This"]
            #[doc = "token should be offered to the clients to be activated."]
            async fn get_activation_token(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Requests surface activation. It's up to the compositor to display"]
            #[doc = "this information as desired, for example by placing the surface above"]
            #[doc = "the rest."]
            #[doc = ""]
            #[doc = "The compositor may know who requested this by checking the activation"]
            #[doc = "token and might decide not to follow through with the activation if it's"]
            #[doc = "considered unwanted."]
            #[doc = ""]
            #[doc = "Compositors can ignore unknown activation tokens when an invalid"]
            #[doc = "token is passed."]
            async fn activate(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                token: String,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "An object for setting up a token and receiving a token handle that can"]
    #[doc = "be passed as an activation token to another client."]
    #[doc = ""]
    #[doc = "The object is created using the xdg_activation_v1.get_activation_token"]
    #[doc = "request. This object should then be populated with the app_id, surface"]
    #[doc = "and serial information and committed. The compositor shall then issue a"]
    #[doc = "done event with the token. In case the request's parameters are invalid,"]
    #[doc = "the compositor will provide an invalid token."]
    pub mod xdg_activation_token_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "The token has already been used previously"]
            AlreadyUsed = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::AlreadyUsed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the xdg_activation_token_v1 interface. See the module level documentation for more info"]
        pub trait XdgActivationTokenV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_activation_token_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_activation_token_v1#{}.set_serial()", object.id);
                        self.set_serial(
                            object,
                            client,
                            message.uint()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("xdg_activation_token_v1#{}.set_app_id()", object.id);
                        self.set_app_id(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("xdg_activation_token_v1#{}.set_surface()", object.id);
                        self.set_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("xdg_activation_token_v1#{}.commit()", object.id);
                        self.commit(object, client).await
                    }
                    4u16 => {
                        tracing::debug!("xdg_activation_token_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Provides information about the seat and serial event that requested the"]
            #[doc = "token."]
            #[doc = ""]
            #[doc = "The serial can come from an input or focus event. For instance, if a"]
            #[doc = "click triggers the launch of a third-party client, the launcher client"]
            #[doc = "should send a set_serial request with the serial and seat from the"]
            #[doc = "wl_pointer.button event."]
            #[doc = ""]
            #[doc = "Some compositors might refuse to activate toplevels when the token"]
            #[doc = "doesn't have a valid and recent enough event serial."]
            #[doc = ""]
            #[doc = "Must be sent before commit. This information is optional."]
            async fn set_serial(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "The requesting client can specify an app_id to associate the token"]
            #[doc = "being created with it."]
            #[doc = ""]
            #[doc = "Must be sent before commit. This information is optional."]
            async fn set_app_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                app_id: String,
            ) -> crate::server::Result<()>;
            #[doc = "This request sets the surface requesting the activation. Note, this is"]
            #[doc = "different from the surface that will be activated."]
            #[doc = ""]
            #[doc = "Some compositors might refuse to activate toplevels when the token"]
            #[doc = "doesn't have a requesting surface."]
            #[doc = ""]
            #[doc = "Must be sent before commit. This information is optional."]
            async fn set_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Requests an activation token based on the different parameters that"]
            #[doc = "have been offered through set_serial, set_surface and set_app_id."]
            async fn commit(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Notify the compositor that the xdg_activation_token_v1 object will no"]
            #[doc = "longer be used. The received token stays valid."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The 'done' event contains the unique token of this activation request"]
            #[doc = "and notifies that the provider is done."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                token: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_activation_token_v1#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(token))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod xdg_dialog_v1 {
    #[doc = "The xdg_wm_dialog_v1 interface is exposed as a global object allowing"]
    #[doc = "to register surfaces with a xdg_toplevel role as \"dialogs\" relative to"]
    #[doc = "another toplevel."]
    #[doc = ""]
    #[doc = "The compositor may let this relation influence how the surface is"]
    #[doc = "placed, displayed or interacted with."]
    #[doc = ""]
    #[doc = "Warning! The protocol described in this file is currently in the testing"]
    #[doc = "phase. Backward compatible changes may be added together with the"]
    #[doc = "corresponding interface version bump. Backward incompatible changes can"]
    #[doc = "only be done by creating a new major version of the extension."]
    pub mod xdg_wm_dialog_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "the xdg_toplevel object has already been used to create a xdg_dialog_v1"]
            AlreadyUsed = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::AlreadyUsed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the xdg_wm_dialog_v1 interface. See the module level documentation for more info"]
        pub trait XdgWmDialogV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_wm_dialog_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_wm_dialog_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_wm_dialog_v1#{}.get_xdg_dialog()", object.id);
                        self.get_xdg_dialog(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroys the xdg_wm_dialog_v1 object. This does not affect"]
            #[doc = "the xdg_dialog_v1 objects generated through it."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Creates a xdg_dialog_v1 object for the given toplevel. See the interface"]
            #[doc = "description for more details."]
            #[doc = ""]
            #[doc = "Compositors must raise an already_used error if clients attempt to"]
            #[doc = "create multiple xdg_dialog_v1 objects for the same xdg_toplevel."]
            async fn get_xdg_dialog(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                toplevel: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "A xdg_dialog_v1 object is an ancillary object tied to a xdg_toplevel. Its"]
    #[doc = "purpose is hinting the compositor that the toplevel is a \"dialog\" (e.g. a"]
    #[doc = "temporary window) relative to another toplevel (see"]
    #[doc = "xdg_toplevel.set_parent). If the xdg_toplevel is destroyed, the xdg_dialog_v1"]
    #[doc = "becomes inert."]
    #[doc = ""]
    #[doc = "Through this object, the client may provide additional hints about"]
    #[doc = "the purpose of the secondary toplevel. This interface has no effect"]
    #[doc = "on toplevels that are not attached to a parent toplevel."]
    pub mod xdg_dialog_v1 {
        #[doc = "Trait to implement the xdg_dialog_v1 interface. See the module level documentation for more info"]
        pub trait XdgDialogV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_dialog_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_dialog_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_dialog_v1#{}.set_modal()", object.id);
                        self.set_modal(object, client).await
                    }
                    2u16 => {
                        tracing::debug!("xdg_dialog_v1#{}.unset_modal()", object.id);
                        self.unset_modal(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroys the xdg_dialog_v1 object. If this object is destroyed"]
            #[doc = "before the related xdg_toplevel, the compositor should unapply its"]
            #[doc = "effects."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Hints that the dialog has \"modal\" behavior. Modal dialogs typically"]
            #[doc = "require to be fully addressed by the user (i.e. closed) before resuming"]
            #[doc = "interaction with the parent toplevel, and may require a distinct"]
            #[doc = "presentation."]
            #[doc = ""]
            #[doc = "Clients must implement the logic to filter events in the parent"]
            #[doc = "toplevel on their own."]
            #[doc = ""]
            #[doc = "Compositors may choose any policy in event delivery to the parent"]
            #[doc = "toplevel, from delivering all events unfiltered to using them for"]
            #[doc = "internal consumption."]
            async fn set_modal(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Drops the hint that this dialog has \"modal\" behavior. See"]
            #[doc = "xdg_dialog_v1.set_modal for more details."]
            async fn unset_modal(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod xdg_toplevel_drag_v1 {
    #[doc = "This protocol enhances normal drag and drop with the ability to move a"]
    #[doc = "window at the same time. This allows having detachable parts of a window"]
    #[doc = "that when dragged out of it become a new window and can be dragged over"]
    #[doc = "an existing window to be reattached."]
    #[doc = ""]
    #[doc = "A typical workflow would be when the user starts dragging on top of a"]
    #[doc = "detachable part of a window, the client would create a wl_data_source and"]
    #[doc = "a xdg_toplevel_drag_v1 object and start the drag as normal via"]
    #[doc = "wl_data_device.start_drag. Once the client determines that the detachable"]
    #[doc = "window contents should be detached from the originating window, it creates"]
    #[doc = "a new xdg_toplevel with these contents and issues a"]
    #[doc = "xdg_toplevel_drag_v1.attach request before mapping it. From now on the new"]
    #[doc = "window is moved by the compositor during the drag as if the client called"]
    #[doc = "xdg_toplevel.move."]
    #[doc = ""]
    #[doc = "Dragging an existing window is similar. The client creates a"]
    #[doc = "xdg_toplevel_drag_v1 object and attaches the existing toplevel before"]
    #[doc = "starting the drag."]
    #[doc = ""]
    #[doc = "Clients use the existing drag and drop mechanism to detect when a window"]
    #[doc = "can be docked or undocked. If the client wants to snap a window into a"]
    #[doc = "parent window it should delete or unmap the dragged top-level. If the"]
    #[doc = "contents should be detached again it attaches a new toplevel as described"]
    #[doc = "above. If a drag operation is cancelled without being dropped, clients"]
    #[doc = "should revert to the previous state, deleting any newly created windows"]
    #[doc = "as appropriate. When a drag operation ends as indicated by"]
    #[doc = "wl_data_source.dnd_drop_performed the dragged toplevel window's final"]
    #[doc = "position is determined as if a xdg_toplevel_move operation ended."]
    #[doc = ""]
    #[doc = "Warning! The protocol described in this file is currently in the testing"]
    #[doc = "phase. Backward compatible changes may be added together with the"]
    #[doc = "corresponding interface version bump. Backward incompatible changes can"]
    #[doc = "only be done by creating a new major version of the extension."]
    pub mod xdg_toplevel_drag_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "data_source already used for toplevel drag"]
            InvalidSource = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidSource),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the xdg_toplevel_drag_manager_v1 interface. See the module level documentation for more info"]
        pub trait XdgToplevelDragManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_toplevel_drag_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_toplevel_drag_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "xdg_toplevel_drag_manager_v1#{}.get_xdg_toplevel_drag()",
                            object.id
                        );
                        self.get_xdg_toplevel_drag(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy this xdg_toplevel_drag_manager_v1 object. Other objects,"]
            #[doc = "including xdg_toplevel_drag_v1 objects created by this factory, are not"]
            #[doc = "affected by this request."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create an xdg_toplevel_drag for a drag and drop operation that is going"]
            #[doc = "to be started with data_source."]
            #[doc = ""]
            #[doc = "This request can only be made on sources used in drag-and-drop, so it"]
            #[doc = "must be performed before wl_data_device.start_drag. Attempting to use"]
            #[doc = "the source other than for drag-and-drop such as in"]
            #[doc = "wl_data_device.set_selection will raise an invalid_source error."]
            #[doc = ""]
            #[doc = "Destroying data_source while a toplevel is attached to the"]
            #[doc = "xdg_toplevel_drag is undefined."]
            async fn get_xdg_toplevel_drag(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                data_source: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod xdg_toplevel_drag_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "valid toplevel already attached"]
            ToplevelAttached = 0u32,
            #[doc = "drag has not ended"]
            OngoingDrag = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::ToplevelAttached),
                    1u32 => Ok(Self::OngoingDrag),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the xdg_toplevel_drag_v1 interface. See the module level documentation for more info"]
        pub trait XdgToplevelDragV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_toplevel_drag_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_toplevel_drag_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_toplevel_drag_v1#{}.attach()", object.id);
                        self.attach(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy this xdg_toplevel_drag_v1 object. This request must only be"]
            #[doc = "called after the underlying wl_data_source drag has ended, as indicated"]
            #[doc = "by the dnd_drop_performed or cancelled events. In any other case an"]
            #[doc = "ongoing_drag error is raised."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Request that the window will be moved with the cursor during the drag"]
            #[doc = "operation. The offset is a hint to the compositor how the toplevel"]
            #[doc = "should be positioned relative to the cursor hotspot in surface local"]
            #[doc = "coordinates. For example it might only be used when an unmapped window"]
            #[doc = "is attached. The attached window does not participate in the selection"]
            #[doc = "of the drag target."]
            #[doc = ""]
            #[doc = "If the toplevel is unmapped while it is attached, it is automatically"]
            #[doc = "detached from the drag. In this case this request has to be called again"]
            #[doc = "if the window should be attached after it is remapped."]
            #[doc = ""]
            #[doc = "This request can be called multiple times but issuing it while a"]
            #[doc = "toplevel with an active role is attached raises a toplevel_attached"]
            #[doc = "error."]
            async fn attach(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                toplevel: crate::wire::ObjectId,
                x_offset: i32,
                y_offset: i32,
            ) -> crate::server::Result<()>;
        }
    }
}
#[doc = "This protocol allows clients to set icons for their toplevel surfaces"]
#[doc = "either via the XDG icon stock (using an icon name), or from pixel data."]
#[doc = ""]
#[doc = "A toplevel icon represents the individual toplevel (unlike the application"]
#[doc = "or launcher icon, which represents the application as a whole), and may be"]
#[doc = "shown in window switchers, window overviews and taskbars that list"]
#[doc = "individual windows."]
#[doc = ""]
#[doc = "This document adheres to RFC 2119 when using words like \"must\","]
#[doc = "\"should\", \"may\", etc."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is currently in the testing"]
#[doc = "phase. Backward compatible changes may be added together with the"]
#[doc = "corresponding interface version bump. Backward incompatible changes can"]
#[doc = "only be done by creating a new major version of the extension."]
pub mod xdg_toplevel_icon_v1 {
    #[doc = "This interface allows clients to create toplevel window icons and set"]
    #[doc = "them on toplevel windows to be displayed to the user."]
    pub mod xdg_toplevel_icon_manager_v1 {
        #[doc = "Trait to implement the xdg_toplevel_icon_manager_v1 interface. See the module level documentation for more info"]
        pub trait XdgToplevelIconManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_toplevel_icon_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_toplevel_icon_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_toplevel_icon_manager_v1#{}.create_icon()", object.id);
                        self.create_icon(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("xdg_toplevel_icon_manager_v1#{}.set_icon()", object.id);
                        self.set_icon(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.object()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the toplevel icon manager."]
            #[doc = "This does not destroy objects created with the manager."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Creates a new icon object. This icon can then be attached to a"]
            #[doc = "xdg_toplevel via the 'set_icon' request."]
            async fn create_icon(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This request assigns the icon 'icon' to 'toplevel', or clears the"]
            #[doc = "toplevel icon if 'icon' was null."]
            #[doc = "This state is double-buffered and is applied on the next"]
            #[doc = "wl_surface.commit of the toplevel."]
            #[doc = ""]
            #[doc = "After making this call, the xdg_toplevel_icon_v1 provided as 'icon'"]
            #[doc = "can be destroyed by the client without 'toplevel' losing its icon."]
            #[doc = "The xdg_toplevel_icon_v1 is immutable from this point, and any"]
            #[doc = "future attempts to change it must raise the"]
            #[doc = "'xdg_toplevel_icon_v1.immutable' protocol error."]
            #[doc = ""]
            #[doc = "The compositor must set the toplevel icon from either the pixel data"]
            #[doc = "the icon provides, or by loading a stock icon using the icon name."]
            #[doc = "See the description of 'xdg_toplevel_icon_v1' for details."]
            #[doc = ""]
            #[doc = "If 'icon' is set to null, the icon of the respective toplevel is reset"]
            #[doc = "to its default icon (usually the icon of the application, derived from"]
            #[doc = "its desktop-entry file, or a placeholder icon)."]
            #[doc = "If this request is passed an icon with no pixel buffers or icon name"]
            #[doc = "assigned, the icon must be reset just like if 'icon' was null."]
            async fn set_icon(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                toplevel: crate::wire::ObjectId,
                icon: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "This event indicates an icon size the compositor prefers to be"]
            #[doc = "available if the client has scalable icons and can render to any size."]
            #[doc = ""]
            #[doc = "When the 'xdg_toplevel_icon_manager_v1' object is created, the"]
            #[doc = "compositor may send one or more 'icon_size' events to describe the list"]
            #[doc = "of preferred icon sizes. If the compositor has no size preference, it"]
            #[doc = "may not send any 'icon_size' event, and it is up to the client to"]
            #[doc = "decide a suitable icon size."]
            #[doc = ""]
            #[doc = "A sequence of 'icon_size' events must be finished with a 'done' event."]
            #[doc = "If the compositor has no size preferences, it must still send the"]
            #[doc = "'done' event, without any preceding 'icon_size' events."]
            async fn icon_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                size: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_toplevel_icon_manager_v1#{}.icon_size()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(size).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent after all 'icon_size' events have been sent."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_toplevel_icon_manager_v1#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "This interface defines a toplevel icon."]
    #[doc = "An icon can have a name, and multiple buffers."]
    #[doc = "In order to be applied, the icon must have either a name, or at least"]
    #[doc = "one buffer assigned. Applying an empty icon (with no buffer or name) to"]
    #[doc = "a toplevel should reset its icon to the default icon."]
    #[doc = ""]
    #[doc = "It is up to compositor policy whether to prefer using a buffer or loading"]
    #[doc = "an icon via its name. See 'set_name' and 'add_buffer' for details."]
    pub mod xdg_toplevel_icon_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "the provided buffer does not satisfy requirements"]
            InvalidBuffer = 1u32,
            #[doc = "the icon has already been assigned to a toplevel and must not be changed"]
            Immutable = 2u32,
            #[doc = "the provided buffer has been destroyed before the toplevel icon"]
            NoBuffer = 3u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::InvalidBuffer),
                    2u32 => Ok(Self::Immutable),
                    3u32 => Ok(Self::NoBuffer),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the xdg_toplevel_icon_v1 interface. See the module level documentation for more info"]
        pub trait XdgToplevelIconV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_toplevel_icon_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_toplevel_icon_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_toplevel_icon_v1#{}.set_name()", object.id);
                        self.set_name(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("xdg_toplevel_icon_v1#{}.add_buffer()", object.id);
                        self.add_buffer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroys the 'xdg_toplevel_icon_v1' object."]
            #[doc = "The icon must still remain set on every toplevel it was assigned to,"]
            #[doc = "until the toplevel icon is reset explicitly."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This request assigns an icon name to this icon."]
            #[doc = "Any previously set name is overridden."]
            #[doc = ""]
            #[doc = "The compositor must resolve 'icon_name' according to the lookup rules"]
            #[doc = "described in the XDG icon theme specification[1] using the"]
            #[doc = "environment's current icon theme."]
            #[doc = ""]
            #[doc = "If the compositor does not support icon names or cannot resolve"]
            #[doc = "'icon_name' according to the XDG icon theme specification it must"]
            #[doc = "fall back to using pixel buffer data instead."]
            #[doc = ""]
            #[doc = "If this request is made after the icon has been assigned to a toplevel"]
            #[doc = "via 'set_icon', a 'immutable' error must be raised."]
            #[doc = ""]
            #[doc = "[1]: https://specifications.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html"]
            async fn set_name(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                icon_name: String,
            ) -> crate::server::Result<()>;
            #[doc = "This request adds pixel data supplied as wl_buffer to the icon."]
            #[doc = ""]
            #[doc = "The client should add pixel data for all icon sizes and scales that"]
            #[doc = "it can provide, or which are explicitly requested by the compositor"]
            #[doc = "via 'icon_size' events on xdg_toplevel_icon_manager_v1."]
            #[doc = ""]
            #[doc = "The wl_buffer supplying pixel data as 'buffer' must be backed by wl_shm"]
            #[doc = "and must be a square (width and height being equal)."]
            #[doc = "If any of these buffer requirements are not fulfilled, a 'invalid_buffer'"]
            #[doc = "error must be raised."]
            #[doc = ""]
            #[doc = "If this icon instance already has a buffer of the same size and scale"]
            #[doc = "from a previous 'add_buffer' request, data from the last request"]
            #[doc = "overrides the preexisting pixel data."]
            #[doc = ""]
            #[doc = "The wl_buffer must be kept alive for as long as the xdg_toplevel_icon"]
            #[doc = "it is associated with is not destroyed, otherwise a 'no_buffer' error"]
            #[doc = "is raised. The buffer contents must not be modified after it was"]
            #[doc = "assigned to the icon."]
            #[doc = ""]
            #[doc = "If this request is made after the icon has been assigned to a toplevel"]
            #[doc = "via 'set_icon', a 'immutable' error must be raised."]
            async fn add_buffer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer: crate::wire::ObjectId,
                scale: i32,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod fullscreen_shell_unstable_v1 {
    #[doc = "Displays a single surface per output."]
    #[doc = ""]
    #[doc = "This interface provides a mechanism for a single client to display"]
    #[doc = "simple full-screen surfaces.  While there technically may be multiple"]
    #[doc = "clients bound to this interface, only one of those clients should be"]
    #[doc = "shown at a time."]
    #[doc = ""]
    #[doc = "To present a surface, the client uses either the present_surface or"]
    #[doc = "present_surface_for_mode requests.  Presenting a surface takes effect"]
    #[doc = "on the next wl_surface.commit.  See the individual requests for"]
    #[doc = "details about scaling and mode switches."]
    #[doc = ""]
    #[doc = "The client can have at most one surface per output at any time."]
    #[doc = "Requesting a surface to be presented on an output that already has a"]
    #[doc = "surface replaces the previously presented surface.  Presenting a null"]
    #[doc = "surface removes its content and effectively disables the output."]
    #[doc = "Exactly what happens when an output is \"disabled\" is"]
    #[doc = "compositor-specific.  The same surface may be presented on multiple"]
    #[doc = "outputs simultaneously."]
    #[doc = ""]
    #[doc = "Once a surface is presented on an output, it stays on that output"]
    #[doc = "until either the client removes it or the compositor destroys the"]
    #[doc = "output.  This way, the client can update the output's contents by"]
    #[doc = "simply attaching a new buffer."]
    #[doc = ""]
    #[doc = "Warning! The protocol described in this file is experimental and"]
    #[doc = "backward incompatible changes may be made. Backward compatible changes"]
    #[doc = "may be added together with the corresponding interface version bump."]
    #[doc = "Backward incompatible changes are done by bumping the version number in"]
    #[doc = "the protocol and interface names and resetting the interface version."]
    #[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
    #[doc = "version number in the protocol and interface names are removed and the"]
    #[doc = "interface version number is reset."]
    pub mod zwp_fullscreen_shell_v1 {
        #[doc = "Various capabilities that can be advertised by the compositor.  They"]
        #[doc = "are advertised one-at-a-time when the wl_fullscreen_shell interface is"]
        #[doc = "bound.  See the wl_fullscreen_shell.capability event for more details."]
        #[doc = ""]
        #[doc = "ARBITRARY_MODES:"]
        #[doc = "This is a hint to the client that indicates that the compositor is"]
        #[doc = "capable of setting practically any mode on its outputs.  If this"]
        #[doc = "capability is provided, wl_fullscreen_shell.present_surface_for_mode"]
        #[doc = "will almost never fail and clients should feel free to set whatever"]
        #[doc = "mode they like.  If the compositor does not advertise this, it may"]
        #[doc = "still support some modes that are not advertised through wl_global.mode"]
        #[doc = "but it is less likely."]
        #[doc = ""]
        #[doc = "CURSOR_PLANE:"]
        #[doc = "This is a hint to the client that indicates that the compositor can"]
        #[doc = "handle a cursor surface from the client without actually compositing."]
        #[doc = "This may be because of a hardware cursor plane or some other mechanism."]
        #[doc = "If the compositor does not advertise this capability then setting"]
        #[doc = "wl_pointer.cursor may degrade performance or be ignored entirely.  If"]
        #[doc = "CURSOR_PLANE is not advertised, it is recommended that the client draw"]
        #[doc = "its own cursor and set wl_pointer.cursor(NULL)."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Capability {
            #[doc = "compositor is capable of almost any output mode"]
            ArbitraryModes = 1u32,
            #[doc = "compositor has a separate cursor plane"]
            CursorPlane = 2u32,
        }
        impl TryFrom<u32> for Capability {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::ArbitraryModes),
                    2u32 => Ok(Self::CursorPlane),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Hints to indicate to the compositor how to deal with a conflict"]
        #[doc = "between the dimensions of the surface and the dimensions of the"]
        #[doc = "output. The compositor is free to ignore this parameter."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum PresentMethod {
            #[doc = "no preference, apply default policy"]
            Default = 0u32,
            #[doc = "center the surface on the output"]
            Center = 1u32,
            #[doc = "scale the surface, preserving aspect ratio, to the largest size that will fit on the output"]
            Zoom = 2u32,
            #[doc = "scale the surface, preserving aspect ratio, to fully fill the output cropping if needed"]
            ZoomCrop = 3u32,
            #[doc = "scale the surface to the size of the output ignoring aspect ratio"]
            Stretch = 4u32,
        }
        impl TryFrom<u32> for PresentMethod {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Default),
                    1u32 => Ok(Self::Center),
                    2u32 => Ok(Self::Zoom),
                    3u32 => Ok(Self::ZoomCrop),
                    4u32 => Ok(Self::Stretch),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "These errors can be emitted in response to wl_fullscreen_shell requests."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "present_method is not known"]
            InvalidMethod = 0u32,
            #[doc = "given wl_surface has another role"]
            Role = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidMethod),
                    1u32 => Ok(Self::Role),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwp_fullscreen_shell_v1 interface. See the module level documentation for more info"]
        pub trait ZwpFullscreenShellV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_fullscreen_shell_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_fullscreen_shell_v1#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zwp_fullscreen_shell_v1#{}.present_surface()", object.id);
                        self.present_surface(
                            object,
                            client,
                            message.object()?,
                            message.uint()?.try_into()?,
                            message.object()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "zwp_fullscreen_shell_v1#{}.present_surface_for_mode()",
                            object.id
                        );
                        self.present_surface_for_mode(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Release the binding from the wl_fullscreen_shell interface."]
            #[doc = ""]
            #[doc = "This destroys the server-side object and frees this binding.  If"]
            #[doc = "the client binds to wl_fullscreen_shell multiple times, it may wish"]
            #[doc = "to free some of those bindings."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Present a surface on the given output."]
            #[doc = ""]
            #[doc = "If the output is null, the compositor will present the surface on"]
            #[doc = "whatever display (or displays) it thinks best.  In particular, this"]
            #[doc = "may replace any or all surfaces currently presented so it should"]
            #[doc = "not be used in combination with placing surfaces on specific"]
            #[doc = "outputs."]
            #[doc = ""]
            #[doc = "The method parameter is a hint to the compositor for how the surface"]
            #[doc = "is to be presented.  In particular, it tells the compositor how to"]
            #[doc = "handle a size mismatch between the presented surface and the"]
            #[doc = "output.  The compositor is free to ignore this parameter."]
            #[doc = ""]
            #[doc = "The \"zoom\", \"zoom_crop\", and \"stretch\" methods imply a scaling"]
            #[doc = "operation on the surface.  This will override any kind of output"]
            #[doc = "scaling, so the buffer_scale property of the surface is effectively"]
            #[doc = "ignored."]
            #[doc = ""]
            #[doc = "This request gives the surface the role of a fullscreen shell surface."]
            #[doc = "If the surface already has another role, it raises a role protocol"]
            #[doc = "error."]
            async fn present_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: Option<crate::wire::ObjectId>,
                method: PresentMethod,
                output: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Presents a surface on the given output for a particular mode."]
            #[doc = ""]
            #[doc = "If the current size of the output differs from that of the surface,"]
            #[doc = "the compositor will attempt to change the size of the output to"]
            #[doc = "match the surface.  The result of the mode-switch operation will be"]
            #[doc = "returned via the provided wl_fullscreen_shell_mode_feedback object."]
            #[doc = ""]
            #[doc = "If the current output mode matches the one requested or if the"]
            #[doc = "compositor successfully switches the mode to match the surface,"]
            #[doc = "then the mode_successful event will be sent and the output will"]
            #[doc = "contain the contents of the given surface.  If the compositor"]
            #[doc = "cannot match the output size to the surface size, the mode_failed"]
            #[doc = "will be sent and the output will contain the contents of the"]
            #[doc = "previously presented surface (if any).  If another surface is"]
            #[doc = "presented on the given output before either of these has a chance"]
            #[doc = "to happen, the present_cancelled event will be sent."]
            #[doc = ""]
            #[doc = "Due to race conditions and other issues unknown to the client, no"]
            #[doc = "mode-switch operation is guaranteed to succeed.  However, if the"]
            #[doc = "mode is one advertised by wl_output.mode or if the compositor"]
            #[doc = "advertises the ARBITRARY_MODES capability, then the client should"]
            #[doc = "expect that the mode-switch operation will usually succeed."]
            #[doc = ""]
            #[doc = "If the size of the presented surface changes, the resulting output"]
            #[doc = "is undefined.  The compositor may attempt to change the output mode"]
            #[doc = "to compensate.  However, there is no guarantee that a suitable mode"]
            #[doc = "will be found and the client has no way to be notified of success"]
            #[doc = "or failure."]
            #[doc = ""]
            #[doc = "The framerate parameter specifies the desired framerate for the"]
            #[doc = "output in mHz.  The compositor is free to ignore this parameter.  A"]
            #[doc = "value of 0 indicates that the client has no preference."]
            #[doc = ""]
            #[doc = "If the value of wl_output.scale differs from wl_surface.buffer_scale,"]
            #[doc = "then the compositor may choose a mode that matches either the buffer"]
            #[doc = "size or the surface size.  In either case, the surface will fill the"]
            #[doc = "output."]
            #[doc = ""]
            #[doc = "This request gives the surface the role of a fullscreen shell surface."]
            #[doc = "If the surface already has another role, it raises a role protocol"]
            #[doc = "error."]
            async fn present_surface_for_mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
                output: crate::wire::ObjectId,
                framerate: i32,
                feedback: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Advertises a single capability of the compositor."]
            #[doc = ""]
            #[doc = "When the wl_fullscreen_shell interface is bound, this event is emitted"]
            #[doc = "once for each capability advertised.  Valid capabilities are given by"]
            #[doc = "the wl_fullscreen_shell.capability enum.  If clients want to take"]
            #[doc = "advantage of any of these capabilities, they should use a"]
            #[doc = "wl_display.sync request immediately after binding to ensure that they"]
            #[doc = "receive all the capability events."]
            async fn capability(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                capability: Capability,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_fullscreen_shell_v1#{}.capability()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(capability as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_fullscreen_shell_mode_feedback_v1 {
        #[doc = "Trait to implement the zwp_fullscreen_shell_mode_feedback_v1 interface. See the module level documentation for more info"]
        pub trait ZwpFullscreenShellModeFeedbackV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_fullscreen_shell_mode_feedback_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This event indicates that the attempted mode switch operation was"]
            #[doc = "successful.  A surface of the size requested in the mode switch"]
            #[doc = "will fill the output without scaling."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy the"]
            #[doc = "wl_fullscreen_shell_mode_feedback object."]
            async fn mode_successful(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_fullscreen_shell_mode_feedback_v1#{}.mode_successful()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates that the attempted mode switch operation"]
            #[doc = "failed.  This may be because the requested output mode is not"]
            #[doc = "possible or it may mean that the compositor does not want to allow it."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy the"]
            #[doc = "wl_fullscreen_shell_mode_feedback object."]
            async fn mode_failed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_fullscreen_shell_mode_feedback_v1#{}.mode_failed()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates that the attempted mode switch operation was"]
            #[doc = "cancelled.  Most likely this is because the client requested a"]
            #[doc = "second mode switch before the first one completed."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy the"]
            #[doc = "wl_fullscreen_shell_mode_feedback object."]
            async fn present_cancelled(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_fullscreen_shell_mode_feedback_v1#{}.present_cancelled()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod idle_inhibit_unstable_v1 {
    #[doc = "This interface permits inhibiting the idle behavior such as screen"]
    #[doc = "blanking, locking, and screensaving.  The client binds the idle manager"]
    #[doc = "globally, then creates idle-inhibitor objects for each surface."]
    #[doc = ""]
    #[doc = "Warning! The protocol described in this file is experimental and"]
    #[doc = "backward incompatible changes may be made. Backward compatible changes"]
    #[doc = "may be added together with the corresponding interface version bump."]
    #[doc = "Backward incompatible changes are done by bumping the version number in"]
    #[doc = "the protocol and interface names and resetting the interface version."]
    #[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
    #[doc = "version number in the protocol and interface names are removed and the"]
    #[doc = "interface version number is reset."]
    pub mod zwp_idle_inhibit_manager_v1 {
        #[doc = "Trait to implement the zwp_idle_inhibit_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZwpIdleInhibitManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_idle_inhibit_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_idle_inhibit_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwp_idle_inhibit_manager_v1#{}.create_inhibitor()",
                            object.id
                        );
                        self.create_inhibitor(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the inhibit manager."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a new inhibitor object associated with the given surface."]
            async fn create_inhibitor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "An idle inhibitor prevents the output that the associated surface is"]
    #[doc = "visible on from being set to a state where it is not visually usable due"]
    #[doc = "to lack of user interaction (e.g. blanked, dimmed, locked, set to power"]
    #[doc = "save, etc.)  Any screensaver processes are also blocked from displaying."]
    #[doc = ""]
    #[doc = "If the surface is destroyed, unmapped, becomes occluded, loses"]
    #[doc = "visibility, or otherwise becomes not visually relevant for the user, the"]
    #[doc = "idle inhibitor will not be honored by the compositor; if the surface"]
    #[doc = "subsequently regains visibility the inhibitor takes effect once again."]
    #[doc = "Likewise, the inhibitor isn't honored if the system was already idled at"]
    #[doc = "the time the inhibitor was established, although if the system later"]
    #[doc = "de-idles and re-idles the inhibitor will take effect."]
    pub mod zwp_idle_inhibitor_v1 {
        #[doc = "Trait to implement the zwp_idle_inhibitor_v1 interface. See the module level documentation for more info"]
        pub trait ZwpIdleInhibitorV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_idle_inhibitor_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_idle_inhibitor_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Remove the inhibitor effect from the associated wl_surface."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod input_method_unstable_v1 {
    #[doc = "Corresponds to a text input on the input method side. An input method context"]
    #[doc = "is created on text input activation on the input method side. It allows"]
    #[doc = "receiving information about the text input from the application via events."]
    #[doc = "Input method contexts do not keep state after deactivation and should be"]
    #[doc = "destroyed after deactivation is handled."]
    #[doc = ""]
    #[doc = "Text is generally UTF-8 encoded, indices and lengths are in bytes."]
    #[doc = ""]
    #[doc = "Serials are used to synchronize the state between the text input and"]
    #[doc = "an input method. New serials are sent by the text input in the"]
    #[doc = "commit_state request and are used by the input method to indicate"]
    #[doc = "the known text input state in events like preedit_string, commit_string,"]
    #[doc = "and keysym. The text input can then ignore events from the input method"]
    #[doc = "which are based on an outdated state (for example after a reset)."]
    #[doc = ""]
    #[doc = "Warning! The protocol described in this file is experimental and"]
    #[doc = "backward incompatible changes may be made. Backward compatible changes"]
    #[doc = "may be added together with the corresponding interface version bump."]
    #[doc = "Backward incompatible changes are done by bumping the version number in"]
    #[doc = "the protocol and interface names and resetting the interface version."]
    #[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
    #[doc = "version number in the protocol and interface names are removed and the"]
    #[doc = "interface version number is reset."]
    pub mod zwp_input_method_context_v1 {
        #[doc = "Trait to implement the zwp_input_method_context_v1 interface. See the module level documentation for more info"]
        pub trait ZwpInputMethodContextV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_input_method_context_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_input_method_context_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.commit_string()",
                            object.id
                        );
                        self.commit_string(
                            object,
                            client,
                            message.uint()?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.preedit_string()",
                            object.id
                        );
                        self.preedit_string(
                            object,
                            client,
                            message.uint()?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.preedit_styling()",
                            object.id
                        );
                        self.preedit_styling(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.preedit_cursor()",
                            object.id
                        );
                        self.preedit_cursor(object, client, message.int()?).await
                    }
                    5u16 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.delete_surrounding_text()",
                            object.id
                        );
                        self.delete_surrounding_text(
                            object,
                            client,
                            message.int()?,
                            message.uint()?,
                        )
                        .await
                    }
                    6u16 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.cursor_position()",
                            object.id
                        );
                        self.cursor_position(object, client, message.int()?, message.int()?)
                            .await
                    }
                    7u16 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.modifiers_map()",
                            object.id
                        );
                        self.modifiers_map(object, client, message.array()?).await
                    }
                    8u16 => {
                        tracing::debug!("zwp_input_method_context_v1#{}.keysym()", object.id);
                        self.keysym(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    9u16 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.grab_keyboard()",
                            object.id
                        );
                        self.grab_keyboard(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    10u16 => {
                        tracing::debug!("zwp_input_method_context_v1#{}.key()", object.id);
                        self.key(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    11u16 => {
                        tracing::debug!("zwp_input_method_context_v1#{}.modifiers()", object.id);
                        self.modifiers(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    12u16 => {
                        tracing::debug!("zwp_input_method_context_v1#{}.language()", object.id);
                        self.language(
                            object,
                            client,
                            message.uint()?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    13u16 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.text_direction()",
                            object.id
                        );
                        self.text_direction(object, client, message.uint()?, message.uint()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Send the commit string text for insertion to the application."]
            #[doc = ""]
            #[doc = "The text to commit could be either just a single character after a key"]
            #[doc = "press or the result of some composing (pre-edit). It could be also an"]
            #[doc = "empty text when some text should be removed (see"]
            #[doc = "delete_surrounding_text) or when the input cursor should be moved (see"]
            #[doc = "cursor_position)."]
            #[doc = ""]
            #[doc = "Any previously set composing text will be removed."]
            async fn commit_string(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                text: String,
            ) -> crate::server::Result<()>;
            #[doc = "Send the pre-edit string text to the application text input."]
            #[doc = ""]
            #[doc = "The commit text can be used to replace the pre-edit text on reset (for"]
            #[doc = "example on unfocus)."]
            #[doc = ""]
            #[doc = "Previously sent preedit_style and preedit_cursor requests are also"]
            #[doc = "processed by the text_input."]
            async fn preedit_string(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                text: String,
                commit: String,
            ) -> crate::server::Result<()>;
            #[doc = "Set the styling information on composing text. The style is applied for"]
            #[doc = "length in bytes from index relative to the beginning of"]
            #[doc = "the composing text (as byte offset). Multiple styles can"]
            #[doc = "be applied to a composing text."]
            #[doc = ""]
            #[doc = "This request should be sent before sending a preedit_string request."]
            async fn preedit_styling(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: u32,
                length: u32,
                style: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Set the cursor position inside the composing text (as byte offset)"]
            #[doc = "relative to the start of the composing text."]
            #[doc = ""]
            #[doc = "When index is negative no cursor should be displayed."]
            #[doc = ""]
            #[doc = "This request should be sent before sending a preedit_string request."]
            async fn preedit_cursor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Remove the surrounding text."]
            #[doc = ""]
            #[doc = "This request will be handled on the text_input side directly following"]
            #[doc = "a commit_string request."]
            async fn delete_surrounding_text(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: i32,
                length: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Set the cursor and anchor to a new position. Index is the new cursor"]
            #[doc = "position in bytes (when >= 0 this is relative to the end of the inserted text,"]
            #[doc = "otherwise it is relative to the beginning of the inserted text). Anchor is"]
            #[doc = "the new anchor position in bytes (when >= 0 this is relative to the end of the"]
            #[doc = "inserted text, otherwise it is relative to the beginning of the inserted"]
            #[doc = "text). When there should be no selected text, anchor should be the same"]
            #[doc = "as index."]
            #[doc = ""]
            #[doc = "This request will be handled on the text_input side directly following"]
            #[doc = "a commit_string request."]
            async fn cursor_position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: i32,
                anchor: i32,
            ) -> crate::server::Result<()>;
            async fn modifiers_map(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                map: Vec<u8>,
            ) -> crate::server::Result<()>;
            #[doc = "Notify when a key event was sent. Key events should not be used for"]
            #[doc = "normal text input operations, which should be done with commit_string,"]
            #[doc = "delete_surrounding_text, etc. The key event follows the wl_keyboard key"]
            #[doc = "event convention. Sym is an XKB keysym, state is a wl_keyboard key_state."]
            async fn keysym(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                sym: u32,
                state: u32,
                modifiers: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Allow an input method to receive hardware keyboard input and process"]
            #[doc = "key events to generate text events (with pre-edit) over the wire. This"]
            #[doc = "allows input methods which compose multiple key events for inputting"]
            #[doc = "text like it is done for CJK languages."]
            async fn grab_keyboard(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                keyboard: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Forward a wl_keyboard::key event to the client that was not processed"]
            #[doc = "by the input method itself. Should be used when filtering key events"]
            #[doc = "with grab_keyboard.  The arguments should be the ones from the"]
            #[doc = "wl_keyboard::key event."]
            #[doc = ""]
            #[doc = "For generating custom key events use the keysym request instead."]
            async fn key(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                key: u32,
                state: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Forward a wl_keyboard::modifiers event to the client that was not"]
            #[doc = "processed by the input method itself.  Should be used when filtering"]
            #[doc = "key events with grab_keyboard. The arguments should be the ones"]
            #[doc = "from the wl_keyboard::modifiers event."]
            async fn modifiers(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                mods_depressed: u32,
                mods_latched: u32,
                mods_locked: u32,
                group: u32,
            ) -> crate::server::Result<()>;
            async fn language(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                language: String,
            ) -> crate::server::Result<()>;
            async fn text_direction(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                direction: u32,
            ) -> crate::server::Result<()>;
            #[doc = "The plain surrounding text around the input position. Cursor is the"]
            #[doc = "position in bytes within the surrounding text relative to the beginning"]
            #[doc = "of the text. Anchor is the position in bytes of the selection anchor"]
            #[doc = "within the surrounding text relative to the beginning of the text. If"]
            #[doc = "there is no selected text then anchor is the same as cursor."]
            async fn surrounding_text(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                text: String,
                cursor: u32,
                anchor: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_input_method_context_v1#{}.surrounding_text()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(text))
                    .put_uint(cursor)
                    .put_uint(anchor)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn reset(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_input_method_context_v1#{}.reset()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn content_type(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                hint: u32,
                purpose: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_input_method_context_v1#{}.content_type()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(hint)
                    .put_uint(purpose)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn invoke_action(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                button: u32,
                index: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_input_method_context_v1#{}.invoke_action()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(button)
                    .put_uint(index)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn commit_state(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_input_method_context_v1#{}.commit_state()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn preferred_language(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                language: String,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_input_method_context_v1#{}.preferred_language()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(language))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "An input method object is responsible for composing text in response to"]
    #[doc = "input from hardware or virtual keyboards. There is one input method"]
    #[doc = "object per seat. On activate there is a new input method context object"]
    #[doc = "created which allows the input method to communicate with the text input."]
    pub mod zwp_input_method_v1 {
        #[doc = "Trait to implement the zwp_input_method_v1 interface. See the module level documentation for more info"]
        pub trait ZwpInputMethodV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_input_method_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "A text input was activated. Creates an input method context object"]
            #[doc = "which allows communication with the text input."]
            async fn activate(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_input_method_v1#{}.activate()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The text input corresponding to the context argument was deactivated."]
            #[doc = "The input method context should be destroyed after deactivation is"]
            #[doc = "handled."]
            async fn deactivate(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                context: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_input_method_v1#{}.deactivate()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(context))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "Only one client can bind this interface at a time."]
    pub mod zwp_input_panel_v1 {
        #[doc = "Trait to implement the zwp_input_panel_v1 interface. See the module level documentation for more info"]
        pub trait ZwpInputPanelV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_input_panel_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwp_input_panel_v1#{}.get_input_panel_surface()",
                            object.id
                        );
                        self.get_input_panel_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn get_input_panel_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_input_panel_surface_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Position {
            CenterBottom = 0u32,
        }
        impl TryFrom<u32> for Position {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::CenterBottom),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwp_input_panel_surface_v1 interface. See the module level documentation for more info"]
        pub trait ZwpInputPanelSurfaceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_input_panel_surface_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_input_panel_surface_v1#{}.set_toplevel()", object.id);
                        self.set_toplevel(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwp_input_panel_surface_v1#{}.set_overlay_panel()",
                            object.id
                        );
                        self.set_overlay_panel(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Set the input_panel_surface type to keyboard."]
            #[doc = ""]
            #[doc = "A keyboard surface is only shown when a text input is active."]
            async fn set_toplevel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: crate::wire::ObjectId,
                position: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Set the input_panel_surface to be an overlay panel."]
            #[doc = ""]
            #[doc = "This is shown near the input cursor above the application window when"]
            #[doc = "a text input is active."]
            async fn set_overlay_panel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
#[doc = "This protocol specifies a way for a client to request and receive"]
#[doc = "high-resolution timestamps for input events."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and"]
#[doc = "backward incompatible changes may be made. Backward compatible changes"]
#[doc = "may be added together with the corresponding interface version bump."]
#[doc = "Backward incompatible changes are done by bumping the version number in"]
#[doc = "the protocol and interface names and resetting the interface version."]
#[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
#[doc = "version number in the protocol and interface names are removed and the"]
#[doc = "interface version number is reset."]
pub mod input_timestamps_unstable_v1 {
    #[doc = "A global interface used for requesting high-resolution timestamps"]
    #[doc = "for input events."]
    pub mod zwp_input_timestamps_manager_v1 {
        #[doc = "Trait to implement the zwp_input_timestamps_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZwpInputTimestampsManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_input_timestamps_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_input_timestamps_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwp_input_timestamps_manager_v1#{}.get_keyboard_timestamps()",
                            object.id
                        );
                        self.get_keyboard_timestamps(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "zwp_input_timestamps_manager_v1#{}.get_pointer_timestamps()",
                            object.id
                        );
                        self.get_pointer_timestamps(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!(
                            "zwp_input_timestamps_manager_v1#{}.get_touch_timestamps()",
                            object.id
                        );
                        self.get_touch_timestamps(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Informs the server that the client will no longer be using this"]
            #[doc = "protocol object. Existing objects created by this object are not"]
            #[doc = "affected."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Creates a new input timestamps object that represents a subscription"]
            #[doc = "to high-resolution timestamp events for all wl_keyboard events that"]
            #[doc = "carry a timestamp."]
            #[doc = ""]
            #[doc = "If the associated wl_keyboard object is invalidated, either through"]
            #[doc = "client action (e.g. release) or server-side changes, the input"]
            #[doc = "timestamps object becomes inert and the client should destroy it"]
            #[doc = "by calling zwp_input_timestamps_v1.destroy."]
            async fn get_keyboard_timestamps(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                keyboard: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Creates a new input timestamps object that represents a subscription"]
            #[doc = "to high-resolution timestamp events for all wl_pointer events that"]
            #[doc = "carry a timestamp."]
            #[doc = ""]
            #[doc = "If the associated wl_pointer object is invalidated, either through"]
            #[doc = "client action (e.g. release) or server-side changes, the input"]
            #[doc = "timestamps object becomes inert and the client should destroy it"]
            #[doc = "by calling zwp_input_timestamps_v1.destroy."]
            async fn get_pointer_timestamps(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                pointer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Creates a new input timestamps object that represents a subscription"]
            #[doc = "to high-resolution timestamp events for all wl_touch events that"]
            #[doc = "carry a timestamp."]
            #[doc = ""]
            #[doc = "If the associated wl_touch object becomes invalid, either through"]
            #[doc = "client action (e.g. release) or server-side changes, the input"]
            #[doc = "timestamps object becomes inert and the client should destroy it"]
            #[doc = "by calling zwp_input_timestamps_v1.destroy."]
            async fn get_touch_timestamps(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                touch: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "Provides high-resolution timestamp events for a set of subscribed input"]
    #[doc = "events. The set of subscribed input events is determined by the"]
    #[doc = "zwp_input_timestamps_manager_v1 request used to create this object."]
    pub mod zwp_input_timestamps_v1 {
        #[doc = "Trait to implement the zwp_input_timestamps_v1 interface. See the module level documentation for more info"]
        pub trait ZwpInputTimestampsV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_input_timestamps_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_input_timestamps_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Informs the server that the client will no longer be using this"]
            #[doc = "protocol object. After the server processes the request, no more"]
            #[doc = "timestamp events will be emitted."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The timestamp event is associated with the first subsequent input event"]
            #[doc = "carrying a timestamp which belongs to the set of input events this"]
            #[doc = "object is subscribed to."]
            #[doc = ""]
            #[doc = "The timestamp provided by this event is a high-resolution version of"]
            #[doc = "the timestamp argument of the associated input event. The provided"]
            #[doc = "timestamp is in the same clock domain and is at least as accurate as"]
            #[doc = "the associated input event timestamp."]
            #[doc = ""]
            #[doc = "The timestamp is expressed as tv_sec_hi, tv_sec_lo, tv_nsec triples,"]
            #[doc = "each component being an unsigned 32-bit value. Whole seconds are in"]
            #[doc = "tv_sec which is a 64-bit value combined from tv_sec_hi and tv_sec_lo,"]
            #[doc = "and the additional fractional part in tv_nsec as nanoseconds. Hence,"]
            #[doc = "for valid timestamps tv_nsec must be in [0, 999999999]."]
            async fn timestamp(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tv_sec_hi: u32,
                tv_sec_lo: u32,
                tv_nsec: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_input_timestamps_v1#{}.timestamp()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(tv_sec_hi)
                    .put_uint(tv_sec_lo)
                    .put_uint(tv_nsec)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "This protocol specifies a way for a client to request the compositor"]
#[doc = "to ignore its own keyboard shortcuts for a given seat, so that all"]
#[doc = "key events from that seat get forwarded to a surface."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and"]
#[doc = "backward incompatible changes may be made. Backward compatible"]
#[doc = "changes may be added together with the corresponding interface"]
#[doc = "version bump."]
#[doc = "Backward incompatible changes are done by bumping the version"]
#[doc = "number in the protocol and interface names and resetting the"]
#[doc = "interface version. Once the protocol is to be declared stable,"]
#[doc = "the 'z' prefix and the version number in the protocol and"]
#[doc = "interface names are removed and the interface version number is"]
#[doc = "reset."]
pub mod keyboard_shortcuts_inhibit_unstable_v1 {
    #[doc = "A global interface used for inhibiting the compositor keyboard shortcuts."]
    pub mod zwp_keyboard_shortcuts_inhibit_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "the shortcuts are already inhibited for this surface"]
            AlreadyInhibited = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::AlreadyInhibited),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwp_keyboard_shortcuts_inhibit_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZwpKeyboardShortcutsInhibitManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_keyboard_shortcuts_inhibit_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwp_keyboard_shortcuts_inhibit_manager_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwp_keyboard_shortcuts_inhibit_manager_v1#{}.inhibit_shortcuts()",
                            object.id
                        );
                        self.inhibit_shortcuts(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the keyboard shortcuts inhibitor manager."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a new keyboard shortcuts inhibitor object associated with"]
            #[doc = "the given surface for the given seat."]
            #[doc = ""]
            #[doc = "If shortcuts are already inhibited for the specified seat and surface,"]
            #[doc = "a protocol error \"already_inhibited\" is raised by the compositor."]
            async fn inhibit_shortcuts(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "A keyboard shortcuts inhibitor instructs the compositor to ignore"]
    #[doc = "its own keyboard shortcuts when the associated surface has keyboard"]
    #[doc = "focus. As a result, when the surface has keyboard focus on the given"]
    #[doc = "seat, it will receive all key events originating from the specified"]
    #[doc = "seat, even those which would normally be caught by the compositor for"]
    #[doc = "its own shortcuts."]
    #[doc = ""]
    #[doc = "The Wayland compositor is however under no obligation to disable"]
    #[doc = "all of its shortcuts, and may keep some special key combo for its own"]
    #[doc = "use, including but not limited to one allowing the user to forcibly"]
    #[doc = "restore normal keyboard events routing in the case of an unwilling"]
    #[doc = "client. The compositor may also use the same key combo to reactivate"]
    #[doc = "an existing shortcut inhibitor that was previously deactivated on"]
    #[doc = "user request."]
    #[doc = ""]
    #[doc = "When the compositor restores its own keyboard shortcuts, an"]
    #[doc = "\"inactive\" event is emitted to notify the client that the keyboard"]
    #[doc = "shortcuts inhibitor is not effectively active for the surface and"]
    #[doc = "seat any more, and the client should not expect to receive all"]
    #[doc = "keyboard events."]
    #[doc = ""]
    #[doc = "When the keyboard shortcuts inhibitor is inactive, the client has"]
    #[doc = "no way to forcibly reactivate the keyboard shortcuts inhibitor."]
    #[doc = ""]
    #[doc = "The user can chose to re-enable a previously deactivated keyboard"]
    #[doc = "shortcuts inhibitor using any mechanism the compositor may offer,"]
    #[doc = "in which case the compositor will send an \"active\" event to notify"]
    #[doc = "the client."]
    #[doc = ""]
    #[doc = "If the surface is destroyed, unmapped, or loses the seat's keyboard"]
    #[doc = "focus, the keyboard shortcuts inhibitor becomes irrelevant and the"]
    #[doc = "compositor will restore its own keyboard shortcuts but no \"inactive\""]
    #[doc = "event is emitted in this case."]
    pub mod zwp_keyboard_shortcuts_inhibitor_v1 {
        #[doc = "Trait to implement the zwp_keyboard_shortcuts_inhibitor_v1 interface. See the module level documentation for more info"]
        pub trait ZwpKeyboardShortcutsInhibitorV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_keyboard_shortcuts_inhibitor_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwp_keyboard_shortcuts_inhibitor_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Remove the keyboard shortcuts inhibitor from the associated wl_surface."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event indicates that the shortcut inhibitor is active."]
            #[doc = ""]
            #[doc = "The compositor sends this event every time compositor shortcuts"]
            #[doc = "are inhibited on behalf of the surface. When active, the client"]
            #[doc = "may receive input events normally reserved by the compositor"]
            #[doc = "(see zwp_keyboard_shortcuts_inhibitor_v1)."]
            #[doc = ""]
            #[doc = "This occurs typically when the initial request \"inhibit_shortcuts\""]
            #[doc = "first becomes active or when the user instructs the compositor to"]
            #[doc = "re-enable and existing shortcuts inhibitor using any mechanism"]
            #[doc = "offered by the compositor."]
            async fn active(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_keyboard_shortcuts_inhibitor_v1#{}.active()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates that the shortcuts inhibitor is inactive,"]
            #[doc = "normal shortcuts processing is restored by the compositor."]
            async fn inactive(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_keyboard_shortcuts_inhibitor_v1#{}.inactive()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod linux_dmabuf_unstable_v1 {
    #[doc = "Following the interfaces from:"]
    #[doc = "https://www.khronos.org/registry/egl/extensions/EXT/EGL_EXT_image_dma_buf_import.txt"]
    #[doc = "https://www.khronos.org/registry/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import_modifiers.txt"]
    #[doc = "and the Linux DRM sub-system's AddFb2 ioctl."]
    #[doc = ""]
    #[doc = "This interface offers ways to create generic dmabuf-based wl_buffers."]
    #[doc = ""]
    #[doc = "Clients can use the get_surface_feedback request to get dmabuf feedback"]
    #[doc = "for a particular surface. If the client wants to retrieve feedback not"]
    #[doc = "tied to a surface, they can use the get_default_feedback request."]
    #[doc = ""]
    #[doc = "The following are required from clients:"]
    #[doc = ""]
    #[doc = "- Clients must ensure that either all data in the dma-buf is"]
    #[doc = "coherent for all subsequent read access or that coherency is"]
    #[doc = "correctly handled by the underlying kernel-side dma-buf"]
    #[doc = "implementation."]
    #[doc = ""]
    #[doc = "- Don't make any more attachments after sending the buffer to the"]
    #[doc = "compositor. Making more attachments later increases the risk of"]
    #[doc = "the compositor not being able to use (re-import) an existing"]
    #[doc = "dmabuf-based wl_buffer."]
    #[doc = ""]
    #[doc = "The underlying graphics stack must ensure the following:"]
    #[doc = ""]
    #[doc = "- The dmabuf file descriptors relayed to the server will stay valid"]
    #[doc = "for the whole lifetime of the wl_buffer. This means the server may"]
    #[doc = "at any time use those fds to import the dmabuf into any kernel"]
    #[doc = "sub-system that might accept it."]
    #[doc = ""]
    #[doc = "However, when the underlying graphics stack fails to deliver the"]
    #[doc = "promise, because of e.g. a device hot-unplug which raises internal"]
    #[doc = "errors, after the wl_buffer has been successfully created the"]
    #[doc = "compositor must not raise protocol errors to the client when dmabuf"]
    #[doc = "import later fails."]
    #[doc = ""]
    #[doc = "To create a wl_buffer from one or more dmabufs, a client creates a"]
    #[doc = "zwp_linux_dmabuf_params_v1 object with a zwp_linux_dmabuf_v1.create_params"]
    #[doc = "request. All planes required by the intended format are added with"]
    #[doc = "the 'add' request. Finally, a 'create' or 'create_immed' request is"]
    #[doc = "issued, which has the following outcome depending on the import success."]
    #[doc = ""]
    #[doc = "The 'create' request,"]
    #[doc = "- on success, triggers a 'created' event which provides the final"]
    #[doc = "wl_buffer to the client."]
    #[doc = "- on failure, triggers a 'failed' event to convey that the server"]
    #[doc = "cannot use the dmabufs received from the client."]
    #[doc = ""]
    #[doc = "For the 'create_immed' request,"]
    #[doc = "- on success, the server immediately imports the added dmabufs to"]
    #[doc = "create a wl_buffer. No event is sent from the server in this case."]
    #[doc = "- on failure, the server can choose to either:"]
    #[doc = "- terminate the client by raising a fatal error."]
    #[doc = "- mark the wl_buffer as failed, and send a 'failed' event to the"]
    #[doc = "client. If the client uses a failed wl_buffer as an argument to any"]
    #[doc = "request, the behaviour is compositor implementation-defined."]
    #[doc = ""]
    #[doc = "For all DRM formats and unless specified in another protocol extension,"]
    #[doc = "pre-multiplied alpha is used for pixel values."]
    #[doc = ""]
    #[doc = "Unless specified otherwise in another protocol extension, implicit"]
    #[doc = "synchronization is used. In other words, compositors and clients must"]
    #[doc = "wait and signal fences implicitly passed via the DMA-BUF's reservation"]
    #[doc = "mechanism."]
    #[doc = ""]
    #[doc = "Disclaimer: This protocol extension has been marked stable. This copy is"]
    #[doc = "no longer used and only retained for backwards compatibility. The"]
    #[doc = "canonical version can be found in the stable/ directory."]
    pub mod zwp_linux_dmabuf_v1 {
        #[doc = "Trait to implement the zwp_linux_dmabuf_v1 interface. See the module level documentation for more info"]
        pub trait ZwpLinuxDmabufV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_dmabuf_v1";
            const VERSION: u32 = 5u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.create_params()", object.id);
                        self.create_params(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.get_default_feedback()", object.id);
                        self.get_default_feedback(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.get_surface_feedback()", object.id);
                        self.get_surface_feedback(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Objects created through this interface, especially wl_buffers, will"]
            #[doc = "remain valid."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This temporary object is used to collect multiple dmabuf handles into"]
            #[doc = "a single batch to create a wl_buffer. It can only be used once and"]
            #[doc = "should be destroyed after a 'created' or 'failed' event has been"]
            #[doc = "received."]
            async fn create_params(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                params_id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This request creates a new wp_linux_dmabuf_feedback object not bound"]
            #[doc = "to a particular surface. This object will deliver feedback about dmabuf"]
            #[doc = "parameters to use if the client doesn't support per-surface feedback"]
            #[doc = "(see get_surface_feedback)."]
            async fn get_default_feedback(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This request creates a new wp_linux_dmabuf_feedback object for the"]
            #[doc = "specified wl_surface. This object will deliver feedback about dmabuf"]
            #[doc = "parameters to use for buffers attached to this surface."]
            #[doc = ""]
            #[doc = "If the surface is destroyed before the wp_linux_dmabuf_feedback object,"]
            #[doc = "the feedback object becomes inert."]
            async fn get_surface_feedback(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This event advertises one buffer format that the server supports."]
            #[doc = "All the supported formats are advertised once when the client"]
            #[doc = "binds to this interface. A roundtrip after binding guarantees"]
            #[doc = "that the client has received all supported formats."]
            #[doc = ""]
            #[doc = "For the definition of the format codes, see the"]
            #[doc = "zwp_linux_buffer_params_v1::create request."]
            #[doc = ""]
            #[doc = "Starting version 4, the format event is deprecated and must not be"]
            #[doc = "sent by compositors. Instead, use get_default_feedback or"]
            #[doc = "get_surface_feedback."]
            async fn format(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                format: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_linux_dmabuf_v1#{}.format()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(format).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event advertises the formats that the server supports, along with"]
            #[doc = "the modifiers supported for each format. All the supported modifiers"]
            #[doc = "for all the supported formats are advertised once when the client"]
            #[doc = "binds to this interface. A roundtrip after binding guarantees that"]
            #[doc = "the client has received all supported format-modifier pairs."]
            #[doc = ""]
            #[doc = "For legacy support, DRM_FORMAT_MOD_INVALID (that is, modifier_hi =="]
            #[doc = "0x00ffffff and modifier_lo == 0xffffffff) is allowed in this event."]
            #[doc = "It indicates that the server can support the format with an implicit"]
            #[doc = "modifier. When a plane has DRM_FORMAT_MOD_INVALID as its modifier, it"]
            #[doc = "is as if no explicit modifier is specified. The effective modifier"]
            #[doc = "will be derived from the dmabuf."]
            #[doc = ""]
            #[doc = "A compositor that sends valid modifiers and DRM_FORMAT_MOD_INVALID for"]
            #[doc = "a given format supports both explicit modifiers and implicit modifiers."]
            #[doc = ""]
            #[doc = "For the definition of the format and modifier codes, see the"]
            #[doc = "zwp_linux_buffer_params_v1::create and zwp_linux_buffer_params_v1::add"]
            #[doc = "requests."]
            #[doc = ""]
            #[doc = "Starting version 4, the modifier event is deprecated and must not be"]
            #[doc = "sent by compositors. Instead, use get_default_feedback or"]
            #[doc = "get_surface_feedback."]
            async fn modifier(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                format: u32,
                modifier_hi: u32,
                modifier_lo: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_linux_dmabuf_v1#{}.modifier()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(format)
                    .put_uint(modifier_hi)
                    .put_uint(modifier_lo)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "This temporary object is a collection of dmabufs and other"]
    #[doc = "parameters that together form a single logical buffer. The temporary"]
    #[doc = "object may eventually create one wl_buffer unless cancelled by"]
    #[doc = "destroying it before requesting 'create'."]
    #[doc = ""]
    #[doc = "Single-planar formats only require one dmabuf, however"]
    #[doc = "multi-planar formats may require more than one dmabuf. For all"]
    #[doc = "formats, an 'add' request must be called once per plane (even if the"]
    #[doc = "underlying dmabuf fd is identical)."]
    #[doc = ""]
    #[doc = "You must use consecutive plane indices ('plane_idx' argument for 'add')"]
    #[doc = "from zero to the number of planes used by the drm_fourcc format code."]
    #[doc = "All planes required by the format must be given exactly once, but can"]
    #[doc = "be given in any order. Each plane index can be set only once."]
    pub mod zwp_linux_buffer_params_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "the dmabuf_batch object has already been used to create a wl_buffer"]
            AlreadyUsed = 0u32,
            #[doc = "plane index out of bounds"]
            PlaneIdx = 1u32,
            #[doc = "the plane index was already set"]
            PlaneSet = 2u32,
            #[doc = "missing or too many planes to create a buffer"]
            Incomplete = 3u32,
            #[doc = "format not supported"]
            InvalidFormat = 4u32,
            #[doc = "invalid width or height"]
            InvalidDimensions = 5u32,
            #[doc = "offset + stride * height goes out of dmabuf bounds"]
            OutOfBounds = 6u32,
            #[doc = "invalid wl_buffer resulted from importing dmabufs via"]
            #[doc = "the create_immed request on given buffer_params"]
            InvalidWlBuffer = 7u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::AlreadyUsed),
                    1u32 => Ok(Self::PlaneIdx),
                    2u32 => Ok(Self::PlaneSet),
                    3u32 => Ok(Self::Incomplete),
                    4u32 => Ok(Self::InvalidFormat),
                    5u32 => Ok(Self::InvalidDimensions),
                    6u32 => Ok(Self::OutOfBounds),
                    7u32 => Ok(Self::InvalidWlBuffer),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! { # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Flags : u32 { # [doc = "contents are y-inverted"] const YInvert = 1u32 ; # [doc = "content is interlaced"] const Interlaced = 2u32 ; # [doc = "bottom field first"] const BottomFirst = 4u32 ; } }
        impl TryFrom<u32> for Flags {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "Trait to implement the zwp_linux_buffer_params_v1 interface. See the module level documentation for more info"]
        pub trait ZwpLinuxBufferParamsV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_buffer_params_v1";
            const VERSION: u32 = 5u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.add()", object.id);
                        self.add(
                            object,
                            client,
                            message.fd()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.create()", object.id);
                        self.create(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.uint()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.create_immed()", object.id);
                        self.create_immed(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.uint()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Cleans up the temporary data sent to the server for dmabuf-based"]
            #[doc = "wl_buffer creation."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This request adds one dmabuf to the set in this"]
            #[doc = "zwp_linux_buffer_params_v1."]
            #[doc = ""]
            #[doc = "The 64-bit unsigned value combined from modifier_hi and modifier_lo"]
            #[doc = "is the dmabuf layout modifier. DRM AddFB2 ioctl calls this the"]
            #[doc = "fb modifier, which is defined in drm_mode.h of Linux UAPI."]
            #[doc = "This is an opaque token. Drivers use this token to express tiling,"]
            #[doc = "compression, etc. driver-specific modifications to the base format"]
            #[doc = "defined by the DRM fourcc code."]
            #[doc = ""]
            #[doc = "Starting from version 4, the invalid_format protocol error is sent if"]
            #[doc = "the format + modifier pair was not advertised as supported."]
            #[doc = ""]
            #[doc = "Starting from version 5, the invalid_format protocol error is sent if"]
            #[doc = "all planes don't use the same modifier."]
            #[doc = ""]
            #[doc = "This request raises the PLANE_IDX error if plane_idx is too large."]
            #[doc = "The error PLANE_SET is raised if attempting to set a plane that"]
            #[doc = "was already set."]
            async fn add(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                fd: rustix::fd::OwnedFd,
                plane_idx: u32,
                offset: u32,
                stride: u32,
                modifier_hi: u32,
                modifier_lo: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This asks for creation of a wl_buffer from the added dmabuf"]
            #[doc = "buffers. The wl_buffer is not created immediately but returned via"]
            #[doc = "the 'created' event if the dmabuf sharing succeeds. The sharing"]
            #[doc = "may fail at runtime for reasons a client cannot predict, in"]
            #[doc = "which case the 'failed' event is triggered."]
            #[doc = ""]
            #[doc = "The 'format' argument is a DRM_FORMAT code, as defined by the"]
            #[doc = "libdrm's drm_fourcc.h. The Linux kernel's DRM sub-system is the"]
            #[doc = "authoritative source on how the format codes should work."]
            #[doc = ""]
            #[doc = "The 'flags' is a bitfield of the flags defined in enum \"flags\"."]
            #[doc = "'y_invert' means the that the image needs to be y-flipped."]
            #[doc = ""]
            #[doc = "Flag 'interlaced' means that the frame in the buffer is not"]
            #[doc = "progressive as usual, but interlaced. An interlaced buffer as"]
            #[doc = "supported here must always contain both top and bottom fields."]
            #[doc = "The top field always begins on the first pixel row. The temporal"]
            #[doc = "ordering between the two fields is top field first, unless"]
            #[doc = "'bottom_first' is specified. It is undefined whether 'bottom_first'"]
            #[doc = "is ignored if 'interlaced' is not set."]
            #[doc = ""]
            #[doc = "This protocol does not convey any information about field rate,"]
            #[doc = "duration, or timing, other than the relative ordering between the"]
            #[doc = "two fields in one buffer. A compositor may have to estimate the"]
            #[doc = "intended field rate from the incoming buffer rate. It is undefined"]
            #[doc = "whether the time of receiving wl_surface.commit with a new buffer"]
            #[doc = "attached, applying the wl_surface state, wl_surface.frame callback"]
            #[doc = "trigger, presentation, or any other point in the compositor cycle"]
            #[doc = "is used to measure the frame or field times. There is no support"]
            #[doc = "for detecting missed or late frames/fields/buffers either, and"]
            #[doc = "there is no support whatsoever for cooperating with interlaced"]
            #[doc = "compositor output."]
            #[doc = ""]
            #[doc = "The composited image quality resulting from the use of interlaced"]
            #[doc = "buffers is explicitly undefined. A compositor may use elaborate"]
            #[doc = "hardware features or software to deinterlace and create progressive"]
            #[doc = "output frames from a sequence of interlaced input buffers, or it"]
            #[doc = "may produce substandard image quality. However, compositors that"]
            #[doc = "cannot guarantee reasonable image quality in all cases are recommended"]
            #[doc = "to just reject all interlaced buffers."]
            #[doc = ""]
            #[doc = "Any argument errors, including non-positive width or height,"]
            #[doc = "mismatch between the number of planes and the format, bad"]
            #[doc = "format, bad offset or stride, may be indicated by fatal protocol"]
            #[doc = "errors: INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS,"]
            #[doc = "OUT_OF_BOUNDS."]
            #[doc = ""]
            #[doc = "Dmabuf import errors in the server that are not obvious client"]
            #[doc = "bugs are returned via the 'failed' event as non-fatal. This"]
            #[doc = "allows attempting dmabuf sharing and falling back in the client"]
            #[doc = "if it fails."]
            #[doc = ""]
            #[doc = "This request can be sent only once in the object's lifetime, after"]
            #[doc = "which the only legal request is destroy. This object should be"]
            #[doc = "destroyed after issuing a 'create' request. Attempting to use this"]
            #[doc = "object after issuing 'create' raises ALREADY_USED protocol error."]
            #[doc = ""]
            #[doc = "It is not mandatory to issue 'create'. If a client wants to"]
            #[doc = "cancel the buffer creation, it can just destroy this object."]
            async fn create(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
                format: u32,
                flags: Flags,
            ) -> crate::server::Result<()>;
            #[doc = "This asks for immediate creation of a wl_buffer by importing the"]
            #[doc = "added dmabufs."]
            #[doc = ""]
            #[doc = "In case of import success, no event is sent from the server, and the"]
            #[doc = "wl_buffer is ready to be used by the client."]
            #[doc = ""]
            #[doc = "Upon import failure, either of the following may happen, as seen fit"]
            #[doc = "by the implementation:"]
            #[doc = "- the client is terminated with one of the following fatal protocol"]
            #[doc = "errors:"]
            #[doc = "- INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS, OUT_OF_BOUNDS,"]
            #[doc = "in case of argument errors such as mismatch between the number"]
            #[doc = "of planes and the format, bad format, non-positive width or"]
            #[doc = "height, or bad offset or stride."]
            #[doc = "- INVALID_WL_BUFFER, in case the cause for failure is unknown or"]
            #[doc = "platform specific."]
            #[doc = "- the server creates an invalid wl_buffer, marks it as failed and"]
            #[doc = "sends a 'failed' event to the client. The result of using this"]
            #[doc = "invalid wl_buffer as an argument in any request by the client is"]
            #[doc = "defined by the compositor implementation."]
            #[doc = ""]
            #[doc = "This takes the same arguments as a 'create' request, and obeys the"]
            #[doc = "same restrictions."]
            async fn create_immed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer_id: crate::wire::ObjectId,
                width: i32,
                height: i32,
                format: u32,
                flags: Flags,
            ) -> crate::server::Result<()>;
            #[doc = "This event indicates that the attempted buffer creation was"]
            #[doc = "successful. It provides the new wl_buffer referencing the dmabuf(s)."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy the"]
            #[doc = "zwp_linux_buffer_params_v1 object."]
            async fn created(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_linux_buffer_params_v1#{}.created()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(buffer))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates that the attempted buffer creation has"]
            #[doc = "failed. It usually means that one of the dmabuf constraints"]
            #[doc = "has not been fulfilled."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy the"]
            #[doc = "zwp_linux_buffer_params_v1 object."]
            async fn failed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_linux_buffer_params_v1#{}.failed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "This object advertises dmabuf parameters feedback. This includes the"]
    #[doc = "preferred devices and the supported formats/modifiers."]
    #[doc = ""]
    #[doc = "The parameters are sent once when this object is created and whenever they"]
    #[doc = "change. The done event is always sent once after all parameters have been"]
    #[doc = "sent. When a single parameter changes, all parameters are re-sent by the"]
    #[doc = "compositor."]
    #[doc = ""]
    #[doc = "Compositors can re-send the parameters when the current client buffer"]
    #[doc = "allocations are sub-optimal. Compositors should not re-send the"]
    #[doc = "parameters if re-allocating the buffers would not result in a more optimal"]
    #[doc = "configuration. In particular, compositors should avoid sending the exact"]
    #[doc = "same parameters multiple times in a row."]
    #[doc = ""]
    #[doc = "The tranche_target_device and tranche_formats events are grouped by"]
    #[doc = "tranches of preference. For each tranche, a tranche_target_device, one"]
    #[doc = "tranche_flags and one or more tranche_formats events are sent, followed"]
    #[doc = "by a tranche_done event finishing the list. The tranches are sent in"]
    #[doc = "descending order of preference. All formats and modifiers in the same"]
    #[doc = "tranche have the same preference."]
    #[doc = ""]
    #[doc = "To send parameters, the compositor sends one main_device event, tranches"]
    #[doc = "(each consisting of one tranche_target_device event, one tranche_flags"]
    #[doc = "event, tranche_formats events and then a tranche_done event), then one"]
    #[doc = "done event."]
    pub mod zwp_linux_dmabuf_feedback_v1 {
        bitflags::bitflags! { # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct TrancheFlags : u32 { # [doc = "direct scan-out tranche"] const Scanout = 1u32 ; } }
        impl TryFrom<u32> for TrancheFlags {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "Trait to implement the zwp_linux_dmabuf_feedback_v1 interface. See the module level documentation for more info"]
        pub trait ZwpLinuxDmabufFeedbackV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_dmabuf_feedback_v1";
            const VERSION: u32 = 5u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_linux_dmabuf_feedback_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Using this request a client can tell the server that it is not going to"]
            #[doc = "use the wp_linux_dmabuf_feedback object anymore."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent after all parameters of a wp_linux_dmabuf_feedback"]
            #[doc = "object have been sent."]
            #[doc = ""]
            #[doc = "This allows changes to the wp_linux_dmabuf_feedback parameters to be"]
            #[doc = "seen as atomic, even if they happen via multiple events."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_linux_dmabuf_feedback_v1#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event provides a file descriptor which can be memory-mapped to"]
            #[doc = "access the format and modifier table."]
            #[doc = ""]
            #[doc = "The table contains a tightly packed array of consecutive format +"]
            #[doc = "modifier pairs. Each pair is 16 bytes wide. It contains a format as a"]
            #[doc = "32-bit unsigned integer, followed by 4 bytes of unused padding, and a"]
            #[doc = "modifier as a 64-bit unsigned integer. The native endianness is used."]
            #[doc = ""]
            #[doc = "The client must map the file descriptor in read-only private mode."]
            #[doc = ""]
            #[doc = "Compositors are not allowed to mutate the table file contents once this"]
            #[doc = "event has been sent. Instead, compositors must create a new, separate"]
            #[doc = "table file and re-send feedback parameters. Compositors are allowed to"]
            #[doc = "store duplicate format + modifier pairs in the table."]
            async fn format_table(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                fd: rustix::fd::OwnedFd,
                size: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.format_table()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fd(fd)
                    .put_uint(size)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event advertises the main device that the server prefers to use"]
            #[doc = "when direct scan-out to the target device isn't possible. The"]
            #[doc = "advertised main device may be different for each"]
            #[doc = "wp_linux_dmabuf_feedback object, and may change over time."]
            #[doc = ""]
            #[doc = "There is exactly one main device. The compositor must send at least"]
            #[doc = "one preference tranche with tranche_target_device equal to main_device."]
            #[doc = ""]
            #[doc = "Clients need to create buffers that the main device can import and"]
            #[doc = "read from, otherwise creating the dmabuf wl_buffer will fail (see the"]
            #[doc = "wp_linux_buffer_params.create and create_immed requests for details)."]
            #[doc = "The main device will also likely be kept active by the compositor,"]
            #[doc = "so clients can use it instead of waking up another device for power"]
            #[doc = "savings."]
            #[doc = ""]
            #[doc = "In general the device is a DRM node. The DRM node type (primary vs."]
            #[doc = "render) is unspecified. Clients must not rely on the compositor sending"]
            #[doc = "a particular node type. Clients cannot check two devices for equality"]
            #[doc = "by comparing the dev_t value."]
            #[doc = ""]
            #[doc = "If explicit modifiers are not supported and the client performs buffer"]
            #[doc = "allocations on a different device than the main device, then the client"]
            #[doc = "must force the buffer to have a linear layout."]
            async fn main_device(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                device: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.main_device()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_array(device).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event splits tranche_target_device and tranche_formats events in"]
            #[doc = "preference tranches. It is sent after a set of tranche_target_device"]
            #[doc = "and tranche_formats events; it represents the end of a tranche. The"]
            #[doc = "next tranche will have a lower preference."]
            async fn tranche_done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.tranche_done()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event advertises the target device that the server prefers to use"]
            #[doc = "for a buffer created given this tranche. The advertised target device"]
            #[doc = "may be different for each preference tranche, and may change over time."]
            #[doc = ""]
            #[doc = "There is exactly one target device per tranche."]
            #[doc = ""]
            #[doc = "The target device may be a scan-out device, for example if the"]
            #[doc = "compositor prefers to directly scan-out a buffer created given this"]
            #[doc = "tranche. The target device may be a rendering device, for example if"]
            #[doc = "the compositor prefers to texture from said buffer."]
            #[doc = ""]
            #[doc = "The client can use this hint to allocate the buffer in a way that makes"]
            #[doc = "it accessible from the target device, ideally directly. The buffer must"]
            #[doc = "still be accessible from the main device, either through direct import"]
            #[doc = "or through a potentially more expensive fallback path. If the buffer"]
            #[doc = "can't be directly imported from the main device then clients must be"]
            #[doc = "prepared for the compositor changing the tranche priority or making"]
            #[doc = "wl_buffer creation fail (see the wp_linux_buffer_params.create and"]
            #[doc = "create_immed requests for details)."]
            #[doc = ""]
            #[doc = "If the device is a DRM node, the DRM node type (primary vs. render) is"]
            #[doc = "unspecified. Clients must not rely on the compositor sending a"]
            #[doc = "particular node type. Clients cannot check two devices for equality by"]
            #[doc = "comparing the dev_t value."]
            #[doc = ""]
            #[doc = "This event is tied to a preference tranche, see the tranche_done event."]
            async fn tranche_target_device(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                device: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.tranche_target_device()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_array(device).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event advertises the format + modifier combinations that the"]
            #[doc = "compositor supports."]
            #[doc = ""]
            #[doc = "It carries an array of indices, each referring to a format + modifier"]
            #[doc = "pair in the last received format table (see the format_table event)."]
            #[doc = "Each index is a 16-bit unsigned integer in native endianness."]
            #[doc = ""]
            #[doc = "For legacy support, DRM_FORMAT_MOD_INVALID is an allowed modifier."]
            #[doc = "It indicates that the server can support the format with an implicit"]
            #[doc = "modifier. When a buffer has DRM_FORMAT_MOD_INVALID as its modifier, it"]
            #[doc = "is as if no explicit modifier is specified. The effective modifier"]
            #[doc = "will be derived from the dmabuf."]
            #[doc = ""]
            #[doc = "A compositor that sends valid modifiers and DRM_FORMAT_MOD_INVALID for"]
            #[doc = "a given format supports both explicit modifiers and implicit modifiers."]
            #[doc = ""]
            #[doc = "Compositors must not send duplicate format + modifier pairs within the"]
            #[doc = "same tranche or across two different tranches with the same target"]
            #[doc = "device and flags."]
            #[doc = ""]
            #[doc = "This event is tied to a preference tranche, see the tranche_done event."]
            #[doc = ""]
            #[doc = "For the definition of the format and modifier codes, see the"]
            #[doc = "wp_linux_buffer_params.create request."]
            async fn tranche_formats(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                indices: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.tranche_formats()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_array(indices)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event sets tranche-specific flags."]
            #[doc = ""]
            #[doc = "The scanout flag is a hint that direct scan-out may be attempted by the"]
            #[doc = "compositor on the target device if the client appropriately allocates a"]
            #[doc = "buffer. How to allocate a buffer that can be scanned out on the target"]
            #[doc = "device is implementation-defined."]
            #[doc = ""]
            #[doc = "This event is tied to a preference tranche, see the tranche_done event."]
            async fn tranche_flags(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                flags: TrancheFlags,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.tranche_flags()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(flags.bits())
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 6u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod zwp_linux_explicit_synchronization_unstable_v1 {
    #[doc = "This global is a factory interface, allowing clients to request"]
    #[doc = "explicit synchronization for buffers on a per-surface basis."]
    #[doc = ""]
    #[doc = "See zwp_linux_surface_synchronization_v1 for more information."]
    #[doc = ""]
    #[doc = "This interface is derived from Chromium's"]
    #[doc = "zcr_linux_explicit_synchronization_v1."]
    #[doc = ""]
    #[doc = "Note: this protocol is superseded by linux-drm-syncobj."]
    #[doc = ""]
    #[doc = "Warning! The protocol described in this file is experimental and"]
    #[doc = "backward incompatible changes may be made. Backward compatible changes"]
    #[doc = "may be added together with the corresponding interface version bump."]
    #[doc = "Backward incompatible changes are done by bumping the version number in"]
    #[doc = "the protocol and interface names and resetting the interface version."]
    #[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
    #[doc = "version number in the protocol and interface names are removed and the"]
    #[doc = "interface version number is reset."]
    pub mod zwp_linux_explicit_synchronization_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "the surface already has a synchronization object associated"]
            SynchronizationExists = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::SynchronizationExists),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwp_linux_explicit_synchronization_v1 interface. See the module level documentation for more info"]
        pub trait ZwpLinuxExplicitSynchronizationV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_explicit_synchronization_v1";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwp_linux_explicit_synchronization_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwp_linux_explicit_synchronization_v1#{}.get_synchronization()",
                            object.id
                        );
                        self.get_synchronization(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy this explicit synchronization factory object. Other objects,"]
            #[doc = "including zwp_linux_surface_synchronization_v1 objects created by this"]
            #[doc = "factory, shall not be affected by this request."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Instantiate an interface extension for the given wl_surface to provide"]
            #[doc = "explicit synchronization."]
            #[doc = ""]
            #[doc = "If the given wl_surface already has an explicit synchronization object"]
            #[doc = "associated, the synchronization_exists protocol error is raised."]
            #[doc = ""]
            #[doc = "Graphics APIs, like EGL or Vulkan, that manage the buffer queue and"]
            #[doc = "commits of a wl_surface themselves, are likely to be using this"]
            #[doc = "extension internally. If a client is using such an API for a"]
            #[doc = "wl_surface, it should not directly use this extension on that surface,"]
            #[doc = "to avoid raising a synchronization_exists protocol error."]
            async fn get_synchronization(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "This object implements per-surface explicit synchronization."]
    #[doc = ""]
    #[doc = "Synchronization refers to co-ordination of pipelined operations performed"]
    #[doc = "on buffers. Most GPU clients will schedule an asynchronous operation to"]
    #[doc = "render to the buffer, then immediately send the buffer to the compositor"]
    #[doc = "to be attached to a surface."]
    #[doc = ""]
    #[doc = "In implicit synchronization, ensuring that the rendering operation is"]
    #[doc = "complete before the compositor displays the buffer is an implementation"]
    #[doc = "detail handled by either the kernel or userspace graphics driver."]
    #[doc = ""]
    #[doc = "By contrast, in explicit synchronization, dma_fence objects mark when the"]
    #[doc = "asynchronous operations are complete. When submitting a buffer, the"]
    #[doc = "client provides an acquire fence which will be waited on before the"]
    #[doc = "compositor accesses the buffer. The Wayland server, through a"]
    #[doc = "zwp_linux_buffer_release_v1 object, will inform the client with an event"]
    #[doc = "which may be accompanied by a release fence, when the compositor will no"]
    #[doc = "longer access the buffer contents due to the specific commit that"]
    #[doc = "requested the release event."]
    #[doc = ""]
    #[doc = "Each surface can be associated with only one object of this interface at"]
    #[doc = "any time."]
    #[doc = ""]
    #[doc = "In version 1 of this interface, explicit synchronization is only"]
    #[doc = "guaranteed to be supported for buffers created with any version of the"]
    #[doc = "wp_linux_dmabuf buffer factory. Version 2 additionally guarantees"]
    #[doc = "explicit synchronization support for opaque EGL buffers, which is a type"]
    #[doc = "of platform specific buffers described in the EGL_WL_bind_wayland_display"]
    #[doc = "extension. Compositors are free to support explicit synchronization for"]
    #[doc = "additional buffer types."]
    pub mod zwp_linux_surface_synchronization_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "the fence specified by the client could not be imported"]
            InvalidFence = 0u32,
            #[doc = "multiple fences added for a single surface commit"]
            DuplicateFence = 1u32,
            #[doc = "multiple releases added for a single surface commit"]
            DuplicateRelease = 2u32,
            #[doc = "the associated wl_surface was destroyed"]
            NoSurface = 3u32,
            #[doc = "the buffer does not support explicit synchronization"]
            UnsupportedBuffer = 4u32,
            #[doc = "no buffer was attached"]
            NoBuffer = 5u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidFence),
                    1u32 => Ok(Self::DuplicateFence),
                    2u32 => Ok(Self::DuplicateRelease),
                    3u32 => Ok(Self::NoSurface),
                    4u32 => Ok(Self::UnsupportedBuffer),
                    5u32 => Ok(Self::NoBuffer),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwp_linux_surface_synchronization_v1 interface. See the module level documentation for more info"]
        pub trait ZwpLinuxSurfaceSynchronizationV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_surface_synchronization_v1";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwp_linux_surface_synchronization_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwp_linux_surface_synchronization_v1#{}.set_acquire_fence()",
                            object.id
                        );
                        self.set_acquire_fence(object, client, message.fd()?).await
                    }
                    2u16 => {
                        tracing::debug!(
                            "zwp_linux_surface_synchronization_v1#{}.get_release()",
                            object.id
                        );
                        self.get_release(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy this explicit synchronization object."]
            #[doc = ""]
            #[doc = "Any fence set by this object with set_acquire_fence since the last"]
            #[doc = "commit will be discarded by the server. Any fences set by this object"]
            #[doc = "before the last commit are not affected."]
            #[doc = ""]
            #[doc = "zwp_linux_buffer_release_v1 objects created by this object are not"]
            #[doc = "affected by this request."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the acquire fence that must be signaled before the compositor"]
            #[doc = "may sample from the buffer attached with wl_surface.attach. The fence"]
            #[doc = "is a dma_fence kernel object."]
            #[doc = ""]
            #[doc = "The acquire fence is double-buffered state, and will be applied on the"]
            #[doc = "next wl_surface.commit request for the associated surface. Thus, it"]
            #[doc = "applies only to the buffer that is attached to the surface at commit"]
            #[doc = "time."]
            #[doc = ""]
            #[doc = "If the provided fd is not a valid dma_fence fd, then an INVALID_FENCE"]
            #[doc = "error is raised."]
            #[doc = ""]
            #[doc = "If a fence has already been attached during the same commit cycle, a"]
            #[doc = "DUPLICATE_FENCE error is raised."]
            #[doc = ""]
            #[doc = "If the associated wl_surface was destroyed, a NO_SURFACE error is"]
            #[doc = "raised."]
            #[doc = ""]
            #[doc = "If at surface commit time the attached buffer does not support explicit"]
            #[doc = "synchronization, an UNSUPPORTED_BUFFER error is raised."]
            #[doc = ""]
            #[doc = "If at surface commit time there is no buffer attached, a NO_BUFFER"]
            #[doc = "error is raised."]
            async fn set_acquire_fence(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()>;
            #[doc = "Create a listener for the release of the buffer attached by the"]
            #[doc = "client with wl_surface.attach. See zwp_linux_buffer_release_v1"]
            #[doc = "documentation for more information."]
            #[doc = ""]
            #[doc = "The release object is double-buffered state, and will be associated"]
            #[doc = "with the buffer that is attached to the surface at wl_surface.commit"]
            #[doc = "time."]
            #[doc = ""]
            #[doc = "If a zwp_linux_buffer_release_v1 object has already been requested for"]
            #[doc = "the surface in the same commit cycle, a DUPLICATE_RELEASE error is"]
            #[doc = "raised."]
            #[doc = ""]
            #[doc = "If the associated wl_surface was destroyed, a NO_SURFACE error"]
            #[doc = "is raised."]
            #[doc = ""]
            #[doc = "If at surface commit time there is no buffer attached, a NO_BUFFER"]
            #[doc = "error is raised."]
            async fn get_release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                release: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "This object is instantiated in response to a"]
    #[doc = "zwp_linux_surface_synchronization_v1.get_release request."]
    #[doc = ""]
    #[doc = "It provides an alternative to wl_buffer.release events, providing a"]
    #[doc = "unique release from a single wl_surface.commit request. The release event"]
    #[doc = "also supports explicit synchronization, providing a fence FD for the"]
    #[doc = "client to synchronize against."]
    #[doc = ""]
    #[doc = "Exactly one event, either a fenced_release or an immediate_release, will"]
    #[doc = "be emitted for the wl_surface.commit request. The compositor can choose"]
    #[doc = "release by release which event it uses."]
    #[doc = ""]
    #[doc = "This event does not replace wl_buffer.release events; servers are still"]
    #[doc = "required to send those events."]
    #[doc = ""]
    #[doc = "Once a buffer release object has delivered a 'fenced_release' or an"]
    #[doc = "'immediate_release' event it is automatically destroyed."]
    pub mod zwp_linux_buffer_release_v1 {
        #[doc = "Trait to implement the zwp_linux_buffer_release_v1 interface. See the module level documentation for more info"]
        pub trait ZwpLinuxBufferReleaseV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_buffer_release_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Sent when the compositor has finalised its usage of the associated"]
            #[doc = "buffer for the relevant commit, providing a dma_fence which will be"]
            #[doc = "signaled when all operations by the compositor on that buffer for that"]
            #[doc = "commit have finished."]
            #[doc = ""]
            #[doc = "Once the fence has signaled, and assuming the associated buffer is not"]
            #[doc = "pending release from other wl_surface.commit requests, no additional"]
            #[doc = "explicit or implicit synchronization is required to safely reuse or"]
            #[doc = "destroy the buffer."]
            #[doc = ""]
            #[doc = "This event destroys the zwp_linux_buffer_release_v1 object."]
            async fn fenced_release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                fence: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_buffer_release_v1#{}.fenced_release()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_fd(fence).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent when the compositor has finalised its usage of the associated"]
            #[doc = "buffer for the relevant commit, and either performed no operations"]
            #[doc = "using it, or has a guarantee that all its operations on that buffer for"]
            #[doc = "that commit have finished."]
            #[doc = ""]
            #[doc = "Once this event is received, and assuming the associated buffer is not"]
            #[doc = "pending release from other wl_surface.commit requests, no additional"]
            #[doc = "explicit or implicit synchronization is required to safely reuse or"]
            #[doc = "destroy the buffer."]
            #[doc = ""]
            #[doc = "This event destroys the zwp_linux_buffer_release_v1 object."]
            async fn immediate_release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_buffer_release_v1#{}.immediate_release()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "This protocol specifies a set of interfaces used for adding constraints to"]
#[doc = "the motion of a pointer. Possible constraints include confining pointer"]
#[doc = "motions to a given region, or locking it to its current position."]
#[doc = ""]
#[doc = "In order to constrain the pointer, a client must first bind the global"]
#[doc = "interface \"wp_pointer_constraints\" which, if a compositor supports pointer"]
#[doc = "constraints, is exposed by the registry. Using the bound global object, the"]
#[doc = "client uses the request that corresponds to the type of constraint it wants"]
#[doc = "to make. See wp_pointer_constraints for more details."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and backward"]
#[doc = "incompatible changes may be made. Backward compatible changes may be added"]
#[doc = "together with the corresponding interface version bump. Backward"]
#[doc = "incompatible changes are done by bumping the version number in the protocol"]
#[doc = "and interface names and resetting the interface version. Once the protocol"]
#[doc = "is to be declared stable, the 'z' prefix and the version number in the"]
#[doc = "protocol and interface names are removed and the interface version number is"]
#[doc = "reset."]
pub mod pointer_constraints_unstable_v1 {
    #[doc = "The global interface exposing pointer constraining functionality. It"]
    #[doc = "exposes two requests: lock_pointer for locking the pointer to its"]
    #[doc = "position, and confine_pointer for locking the pointer to a region."]
    #[doc = ""]
    #[doc = "The lock_pointer and confine_pointer requests create the objects"]
    #[doc = "wp_locked_pointer and wp_confined_pointer respectively, and the client can"]
    #[doc = "use these objects to interact with the lock."]
    #[doc = ""]
    #[doc = "For any surface, only one lock or confinement may be active across all"]
    #[doc = "wl_pointer objects of the same seat. If a lock or confinement is requested"]
    #[doc = "when another lock or confinement is active or requested on the same surface"]
    #[doc = "and with any of the wl_pointer objects of the same seat, an"]
    #[doc = "'already_constrained' error will be raised."]
    pub mod zwp_pointer_constraints_v1 {
        #[doc = "These errors can be emitted in response to wp_pointer_constraints"]
        #[doc = "requests."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "pointer constraint already requested on that surface"]
            AlreadyConstrained = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::AlreadyConstrained),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "These values represent different lifetime semantics. They are passed"]
        #[doc = "as arguments to the factory requests to specify how the constraint"]
        #[doc = "lifetimes should be managed."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Lifetime {
            Oneshot = 1u32,
            Persistent = 2u32,
        }
        impl TryFrom<u32> for Lifetime {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::Oneshot),
                    2u32 => Ok(Self::Persistent),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwp_pointer_constraints_v1 interface. See the module level documentation for more info"]
        pub trait ZwpPointerConstraintsV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_pointer_constraints_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_pointer_constraints_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zwp_pointer_constraints_v1#{}.lock_pointer()", object.id);
                        self.lock_pointer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.object()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "zwp_pointer_constraints_v1#{}.confine_pointer()",
                            object.id
                        );
                        self.confine_pointer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.object()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Used by the client to notify the server that it will no longer use this"]
            #[doc = "pointer constraints object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The lock_pointer request lets the client request to disable movements of"]
            #[doc = "the virtual pointer (i.e. the cursor), effectively locking the pointer"]
            #[doc = "to a position. This request may not take effect immediately; in the"]
            #[doc = "future, when the compositor deems implementation-specific constraints"]
            #[doc = "are satisfied, the pointer lock will be activated and the compositor"]
            #[doc = "sends a locked event."]
            #[doc = ""]
            #[doc = "The protocol provides no guarantee that the constraints are ever"]
            #[doc = "satisfied, and does not require the compositor to send an error if the"]
            #[doc = "constraints cannot ever be satisfied. It is thus possible to request a"]
            #[doc = "lock that will never activate."]
            #[doc = ""]
            #[doc = "There may not be another pointer constraint of any kind requested or"]
            #[doc = "active on the surface for any of the wl_pointer objects of the seat of"]
            #[doc = "the passed pointer when requesting a lock. If there is, an error will be"]
            #[doc = "raised. See general pointer lock documentation for more details."]
            #[doc = ""]
            #[doc = "The intersection of the region passed with this request and the input"]
            #[doc = "region of the surface is used to determine where the pointer must be"]
            #[doc = "in order for the lock to activate. It is up to the compositor whether to"]
            #[doc = "warp the pointer or require some kind of user interaction for the lock"]
            #[doc = "to activate. If the region is null the surface input region is used."]
            #[doc = ""]
            #[doc = "A surface may receive pointer focus without the lock being activated."]
            #[doc = ""]
            #[doc = "The request creates a new object wp_locked_pointer which is used to"]
            #[doc = "interact with the lock as well as receive updates about its state. See"]
            #[doc = "the the description of wp_locked_pointer for further information."]
            #[doc = ""]
            #[doc = "Note that while a pointer is locked, the wl_pointer objects of the"]
            #[doc = "corresponding seat will not emit any wl_pointer.motion events, but"]
            #[doc = "relative motion events will still be emitted via wp_relative_pointer"]
            #[doc = "objects of the same seat. wl_pointer.axis and wl_pointer.button events"]
            #[doc = "are unaffected."]
            async fn lock_pointer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
                pointer: crate::wire::ObjectId,
                region: Option<crate::wire::ObjectId>,
                lifetime: Lifetime,
            ) -> crate::server::Result<()>;
            #[doc = "The confine_pointer request lets the client request to confine the"]
            #[doc = "pointer cursor to a given region. This request may not take effect"]
            #[doc = "immediately; in the future, when the compositor deems implementation-"]
            #[doc = "specific constraints are satisfied, the pointer confinement will be"]
            #[doc = "activated and the compositor sends a confined event."]
            #[doc = ""]
            #[doc = "The intersection of the region passed with this request and the input"]
            #[doc = "region of the surface is used to determine where the pointer must be"]
            #[doc = "in order for the confinement to activate. It is up to the compositor"]
            #[doc = "whether to warp the pointer or require some kind of user interaction for"]
            #[doc = "the confinement to activate. If the region is null the surface input"]
            #[doc = "region is used."]
            #[doc = ""]
            #[doc = "The request will create a new object wp_confined_pointer which is used"]
            #[doc = "to interact with the confinement as well as receive updates about its"]
            #[doc = "state. See the the description of wp_confined_pointer for further"]
            #[doc = "information."]
            async fn confine_pointer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
                pointer: crate::wire::ObjectId,
                region: Option<crate::wire::ObjectId>,
                lifetime: Lifetime,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "The wp_locked_pointer interface represents a locked pointer state."]
    #[doc = ""]
    #[doc = "While the lock of this object is active, the wl_pointer objects of the"]
    #[doc = "associated seat will not emit any wl_pointer.motion events."]
    #[doc = ""]
    #[doc = "This object will send the event 'locked' when the lock is activated."]
    #[doc = "Whenever the lock is activated, it is guaranteed that the locked surface"]
    #[doc = "will already have received pointer focus and that the pointer will be"]
    #[doc = "within the region passed to the request creating this object."]
    #[doc = ""]
    #[doc = "To unlock the pointer, send the destroy request. This will also destroy"]
    #[doc = "the wp_locked_pointer object."]
    #[doc = ""]
    #[doc = "If the compositor decides to unlock the pointer the unlocked event is"]
    #[doc = "sent. See wp_locked_pointer.unlock for details."]
    #[doc = ""]
    #[doc = "When unlocking, the compositor may warp the cursor position to the set"]
    #[doc = "cursor position hint. If it does, it will not result in any relative"]
    #[doc = "motion events emitted via wp_relative_pointer."]
    #[doc = ""]
    #[doc = "If the surface the lock was requested on is destroyed and the lock is not"]
    #[doc = "yet activated, the wp_locked_pointer object is now defunct and must be"]
    #[doc = "destroyed."]
    pub mod zwp_locked_pointer_v1 {
        #[doc = "Trait to implement the zwp_locked_pointer_v1 interface. See the module level documentation for more info"]
        pub trait ZwpLockedPointerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_locked_pointer_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_locked_pointer_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwp_locked_pointer_v1#{}.set_cursor_position_hint()",
                            object.id
                        );
                        self.set_cursor_position_hint(
                            object,
                            client,
                            message.fixed()?,
                            message.fixed()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zwp_locked_pointer_v1#{}.set_region()", object.id);
                        self.set_region(object, client, message.object()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the locked pointer object. If applicable, the compositor will"]
            #[doc = "unlock the pointer."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the cursor position hint relative to the top left corner of the"]
            #[doc = "surface."]
            #[doc = ""]
            #[doc = "If the client is drawing its own cursor, it should update the position"]
            #[doc = "hint to the position of its own cursor. A compositor may use this"]
            #[doc = "information to warp the pointer upon unlock in order to avoid pointer"]
            #[doc = "jumps."]
            #[doc = ""]
            #[doc = "The cursor position hint is double-buffered state, see"]
            #[doc = "wl_surface.commit."]
            async fn set_cursor_position_hint(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface_x: crate::wire::Fixed,
                surface_y: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            #[doc = "Set a new region used to lock the pointer."]
            #[doc = ""]
            #[doc = "The new lock region is double-buffered, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "For details about the lock region, see wp_locked_pointer."]
            async fn set_region(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                region: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Notification that the pointer lock of the seat's pointer is activated."]
            async fn locked(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_locked_pointer_v1#{}.locked()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notification that the pointer lock of the seat's pointer is no longer"]
            #[doc = "active. If this is a oneshot pointer lock (see"]
            #[doc = "wp_pointer_constraints.lifetime) this object is now defunct and should"]
            #[doc = "be destroyed. If this is a persistent pointer lock (see"]
            #[doc = "wp_pointer_constraints.lifetime) this pointer lock may again"]
            #[doc = "reactivate in the future."]
            async fn unlocked(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_locked_pointer_v1#{}.unlocked()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "The wp_confined_pointer interface represents a confined pointer state."]
    #[doc = ""]
    #[doc = "This object will send the event 'confined' when the confinement is"]
    #[doc = "activated. Whenever the confinement is activated, it is guaranteed that"]
    #[doc = "the surface the pointer is confined to will already have received pointer"]
    #[doc = "focus and that the pointer will be within the region passed to the request"]
    #[doc = "creating this object. It is up to the compositor to decide whether this"]
    #[doc = "requires some user interaction and if the pointer will warp to within the"]
    #[doc = "passed region if outside."]
    #[doc = ""]
    #[doc = "To unconfine the pointer, send the destroy request. This will also destroy"]
    #[doc = "the wp_confined_pointer object."]
    #[doc = ""]
    #[doc = "If the compositor decides to unconfine the pointer the unconfined event is"]
    #[doc = "sent. The wp_confined_pointer object is at this point defunct and should"]
    #[doc = "be destroyed."]
    pub mod zwp_confined_pointer_v1 {
        #[doc = "Trait to implement the zwp_confined_pointer_v1 interface. See the module level documentation for more info"]
        pub trait ZwpConfinedPointerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_confined_pointer_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_confined_pointer_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zwp_confined_pointer_v1#{}.set_region()", object.id);
                        self.set_region(object, client, message.object()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the confined pointer object. If applicable, the compositor will"]
            #[doc = "unconfine the pointer."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set a new region used to confine the pointer."]
            #[doc = ""]
            #[doc = "The new confine region is double-buffered, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "If the confinement is active when the new confinement region is applied"]
            #[doc = "and the pointer ends up outside of newly applied region, the pointer may"]
            #[doc = "warped to a position within the new confinement region. If warped, a"]
            #[doc = "wl_pointer.motion event will be emitted, but no"]
            #[doc = "wp_relative_pointer.relative_motion event."]
            #[doc = ""]
            #[doc = "The compositor may also, instead of using the new region, unconfine the"]
            #[doc = "pointer."]
            #[doc = ""]
            #[doc = "For details about the confine region, see wp_confined_pointer."]
            async fn set_region(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                region: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Notification that the pointer confinement of the seat's pointer is"]
            #[doc = "activated."]
            async fn confined(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_confined_pointer_v1#{}.confined()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notification that the pointer confinement of the seat's pointer is no"]
            #[doc = "longer active. If this is a oneshot pointer confinement (see"]
            #[doc = "wp_pointer_constraints.lifetime) this object is now defunct and should"]
            #[doc = "be destroyed. If this is a persistent pointer confinement (see"]
            #[doc = "wp_pointer_constraints.lifetime) this pointer confinement may again"]
            #[doc = "reactivate in the future."]
            async fn unconfined(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_confined_pointer_v1#{}.unconfined()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod pointer_gestures_unstable_v1 {
    #[doc = "A global interface to provide semantic touchpad gestures for a given"]
    #[doc = "pointer."]
    #[doc = ""]
    #[doc = "Three gestures are currently supported: swipe, pinch, and hold."]
    #[doc = "Pinch and swipe gestures follow a three-stage cycle: begin, update,"]
    #[doc = "end. Hold gestures follow a two-stage cycle: begin and end. All"]
    #[doc = "gestures are identified by a unique id."]
    #[doc = ""]
    #[doc = "Warning! The protocol described in this file is experimental and"]
    #[doc = "backward incompatible changes may be made. Backward compatible changes"]
    #[doc = "may be added together with the corresponding interface version bump."]
    #[doc = "Backward incompatible changes are done by bumping the version number in"]
    #[doc = "the protocol and interface names and resetting the interface version."]
    #[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
    #[doc = "version number in the protocol and interface names are removed and the"]
    #[doc = "interface version number is reset."]
    pub mod zwp_pointer_gestures_v1 {
        #[doc = "Trait to implement the zwp_pointer_gestures_v1 interface. See the module level documentation for more info"]
        pub trait ZwpPointerGesturesV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_pointer_gestures_v1";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwp_pointer_gestures_v1#{}.get_swipe_gesture()",
                            object.id
                        );
                        self.get_swipe_gesture(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwp_pointer_gestures_v1#{}.get_pinch_gesture()",
                            object.id
                        );
                        self.get_pinch_gesture(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zwp_pointer_gestures_v1#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    3u16 => {
                        tracing::debug!("zwp_pointer_gestures_v1#{}.get_hold_gesture()", object.id);
                        self.get_hold_gesture(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a swipe gesture object. See the"]
            #[doc = "wl_pointer_gesture_swipe interface for details."]
            async fn get_swipe_gesture(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                pointer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Create a pinch gesture object. See the"]
            #[doc = "wl_pointer_gesture_pinch interface for details."]
            async fn get_pinch_gesture(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                pointer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the pointer gesture object. Swipe, pinch and hold objects"]
            #[doc = "created via this gesture object remain valid."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a hold gesture object. See the"]
            #[doc = "wl_pointer_gesture_hold interface for details."]
            async fn get_hold_gesture(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                pointer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "A swipe gesture object notifies a client about a multi-finger swipe"]
    #[doc = "gesture detected on an indirect input device such as a touchpad."]
    #[doc = "The gesture is usually initiated by multiple fingers moving in the"]
    #[doc = "same direction but once initiated the direction may change."]
    #[doc = "The precise conditions of when such a gesture is detected are"]
    #[doc = "implementation-dependent."]
    #[doc = ""]
    #[doc = "A gesture consists of three stages: begin, update (optional) and end."]
    #[doc = "There cannot be multiple simultaneous hold, pinch or swipe gestures on a"]
    #[doc = "same pointer/seat, how compositors prevent these situations is"]
    #[doc = "implementation-dependent."]
    #[doc = ""]
    #[doc = "A gesture may be cancelled by the compositor or the hardware."]
    #[doc = "Clients should not consider performing permanent or irreversible"]
    #[doc = "actions until the end of a gesture has been received."]
    pub mod zwp_pointer_gesture_swipe_v1 {
        #[doc = "Trait to implement the zwp_pointer_gesture_swipe_v1 interface. See the module level documentation for more info"]
        pub trait ZwpPointerGestureSwipeV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_pointer_gesture_swipe_v1";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_pointer_gesture_swipe_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent when a multi-finger swipe gesture is detected"]
            #[doc = "on the device."]
            async fn begin(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                surface: crate::wire::ObjectId,
                fingers: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_pointer_gesture_swipe_v1#{}.begin()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(time)
                    .put_object(Some(surface))
                    .put_uint(fingers)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent when a multi-finger swipe gesture changes the"]
            #[doc = "position of the logical center."]
            #[doc = ""]
            #[doc = "The dx and dy coordinates are relative coordinates of the logical"]
            #[doc = "center of the gesture compared to the previous event."]
            async fn update(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                dx: crate::wire::Fixed,
                dy: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_pointer_gesture_swipe_v1#{}.update()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_fixed(dx)
                    .put_fixed(dy)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent when a multi-finger swipe gesture ceases to"]
            #[doc = "be valid. This may happen when one or more fingers are lifted or"]
            #[doc = "the gesture is cancelled."]
            #[doc = ""]
            #[doc = "When a gesture is cancelled, the client should undo state changes"]
            #[doc = "caused by this gesture. What causes a gesture to be cancelled is"]
            #[doc = "implementation-dependent."]
            async fn end(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                cancelled: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_pointer_gesture_swipe_v1#{}.end()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(time)
                    .put_int(cancelled)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A pinch gesture object notifies a client about a multi-finger pinch"]
    #[doc = "gesture detected on an indirect input device such as a touchpad."]
    #[doc = "The gesture is usually initiated by multiple fingers moving towards"]
    #[doc = "each other or away from each other, or by two or more fingers rotating"]
    #[doc = "around a logical center of gravity. The precise conditions of when"]
    #[doc = "such a gesture is detected are implementation-dependent."]
    #[doc = ""]
    #[doc = "A gesture consists of three stages: begin, update (optional) and end."]
    #[doc = "There cannot be multiple simultaneous hold, pinch or swipe gestures on a"]
    #[doc = "same pointer/seat, how compositors prevent these situations is"]
    #[doc = "implementation-dependent."]
    #[doc = ""]
    #[doc = "A gesture may be cancelled by the compositor or the hardware."]
    #[doc = "Clients should not consider performing permanent or irreversible"]
    #[doc = "actions until the end of a gesture has been received."]
    pub mod zwp_pointer_gesture_pinch_v1 {
        #[doc = "Trait to implement the zwp_pointer_gesture_pinch_v1 interface. See the module level documentation for more info"]
        pub trait ZwpPointerGesturePinchV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_pointer_gesture_pinch_v1";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_pointer_gesture_pinch_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent when a multi-finger pinch gesture is detected"]
            #[doc = "on the device."]
            async fn begin(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                surface: crate::wire::ObjectId,
                fingers: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_pointer_gesture_pinch_v1#{}.begin()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(time)
                    .put_object(Some(surface))
                    .put_uint(fingers)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent when a multi-finger pinch gesture changes the"]
            #[doc = "position of the logical center, the rotation or the relative scale."]
            #[doc = ""]
            #[doc = "The dx and dy coordinates are relative coordinates in the"]
            #[doc = "surface coordinate space of the logical center of the gesture."]
            #[doc = ""]
            #[doc = "The scale factor is an absolute scale compared to the"]
            #[doc = "pointer_gesture_pinch.begin event, e.g. a scale of 2 means the fingers"]
            #[doc = "are now twice as far apart as on pointer_gesture_pinch.begin."]
            #[doc = ""]
            #[doc = "The rotation is the relative angle in degrees clockwise compared to the previous"]
            #[doc = "pointer_gesture_pinch.begin or pointer_gesture_pinch.update event."]
            async fn update(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                dx: crate::wire::Fixed,
                dy: crate::wire::Fixed,
                scale: crate::wire::Fixed,
                rotation: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_pointer_gesture_pinch_v1#{}.update()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_fixed(dx)
                    .put_fixed(dy)
                    .put_fixed(scale)
                    .put_fixed(rotation)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent when a multi-finger pinch gesture ceases to"]
            #[doc = "be valid. This may happen when one or more fingers are lifted or"]
            #[doc = "the gesture is cancelled."]
            #[doc = ""]
            #[doc = "When a gesture is cancelled, the client should undo state changes"]
            #[doc = "caused by this gesture. What causes a gesture to be cancelled is"]
            #[doc = "implementation-dependent."]
            async fn end(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                cancelled: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_pointer_gesture_pinch_v1#{}.end()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(time)
                    .put_int(cancelled)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A hold gesture object notifies a client about a single- or"]
    #[doc = "multi-finger hold gesture detected on an indirect input device such as"]
    #[doc = "a touchpad. The gesture is usually initiated by one or more fingers"]
    #[doc = "being held down without significant movement. The precise conditions"]
    #[doc = "of when such a gesture is detected are implementation-dependent."]
    #[doc = ""]
    #[doc = "In particular, this gesture may be used to cancel kinetic scrolling."]
    #[doc = ""]
    #[doc = "A hold gesture consists of two stages: begin and end. Unlike pinch and"]
    #[doc = "swipe there is no update stage."]
    #[doc = "There cannot be multiple simultaneous hold, pinch or swipe gestures on a"]
    #[doc = "same pointer/seat, how compositors prevent these situations is"]
    #[doc = "implementation-dependent."]
    #[doc = ""]
    #[doc = "A gesture may be cancelled by the compositor or the hardware."]
    #[doc = "Clients should not consider performing permanent or irreversible"]
    #[doc = "actions until the end of a gesture has been received."]
    pub mod zwp_pointer_gesture_hold_v1 {
        #[doc = "Trait to implement the zwp_pointer_gesture_hold_v1 interface. See the module level documentation for more info"]
        pub trait ZwpPointerGestureHoldV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_pointer_gesture_hold_v1";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_pointer_gesture_hold_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent when a hold gesture is detected on the device."]
            async fn begin(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                surface: crate::wire::ObjectId,
                fingers: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_pointer_gesture_hold_v1#{}.begin()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(time)
                    .put_object(Some(surface))
                    .put_uint(fingers)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent when a hold gesture ceases to"]
            #[doc = "be valid. This may happen when the holding fingers are lifted or"]
            #[doc = "the gesture is cancelled, for example if the fingers move past an"]
            #[doc = "implementation-defined threshold, the finger count changes or the hold"]
            #[doc = "gesture changes into a different type of gesture."]
            #[doc = ""]
            #[doc = "When a gesture is cancelled, the client may need to undo state changes"]
            #[doc = "caused by this gesture. What causes a gesture to be cancelled is"]
            #[doc = "implementation-dependent."]
            async fn end(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                cancelled: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_pointer_gesture_hold_v1#{}.end()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(time)
                    .put_int(cancelled)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "This protocol provides the ability to have a primary selection device to"]
#[doc = "match that of the X server. This primary selection is a shortcut to the"]
#[doc = "common clipboard selection, where text just needs to be selected in order"]
#[doc = "to allow copying it elsewhere. The de facto way to perform this action"]
#[doc = "is the middle mouse button, although it is not limited to this one."]
#[doc = ""]
#[doc = "Clients wishing to honor primary selection should create a primary"]
#[doc = "selection source and set it as the selection through"]
#[doc = "wp_primary_selection_device.set_selection whenever the text selection"]
#[doc = "changes. In order to minimize calls in pointer-driven text selection,"]
#[doc = "it should happen only once after the operation finished. Similarly,"]
#[doc = "a NULL source should be set when text is unselected."]
#[doc = ""]
#[doc = "wp_primary_selection_offer objects are first announced through the"]
#[doc = "wp_primary_selection_device.data_offer event. Immediately after this event,"]
#[doc = "the primary data offer will emit wp_primary_selection_offer.offer events"]
#[doc = "to let know of the mime types being offered."]
#[doc = ""]
#[doc = "When the primary selection changes, the client with the keyboard focus"]
#[doc = "will receive wp_primary_selection_device.selection events. Only the client"]
#[doc = "with the keyboard focus will receive such events with a non-NULL"]
#[doc = "wp_primary_selection_offer. Across keyboard focus changes, previously"]
#[doc = "focused clients will receive wp_primary_selection_device.events with a"]
#[doc = "NULL wp_primary_selection_offer."]
#[doc = ""]
#[doc = "In order to request the primary selection data, the client must pass"]
#[doc = "a recent serial pertaining to the press event that is triggering the"]
#[doc = "operation, if the compositor deems the serial valid and recent, the"]
#[doc = "wp_primary_selection_source.send event will happen in the other end"]
#[doc = "to let the transfer begin. The client owning the primary selection"]
#[doc = "should write the requested data, and close the file descriptor"]
#[doc = "immediately."]
#[doc = ""]
#[doc = "If the primary selection owner client disappeared during the transfer,"]
#[doc = "the client reading the data will receive a"]
#[doc = "wp_primary_selection_device.selection event with a NULL"]
#[doc = "wp_primary_selection_offer, the client should take this as a hint"]
#[doc = "to finish the reads related to the no longer existing offer."]
#[doc = ""]
#[doc = "The primary selection owner should be checking for errors during"]
#[doc = "writes, merely cancelling the ongoing transfer if any happened."]
pub mod wp_primary_selection_unstable_v1 {
    #[doc = "The primary selection device manager is a singleton global object that"]
    #[doc = "provides access to the primary selection. It allows to create"]
    #[doc = "wp_primary_selection_source objects, as well as retrieving the per-seat"]
    #[doc = "wp_primary_selection_device objects."]
    pub mod zwp_primary_selection_device_manager_v1 {
        #[doc = "Trait to implement the zwp_primary_selection_device_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZwpPrimarySelectionDeviceManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_primary_selection_device_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwp_primary_selection_device_manager_v1#{}.create_source()",
                            object.id
                        );
                        self.create_source(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwp_primary_selection_device_manager_v1#{}.get_device()",
                            object.id
                        );
                        self.get_device(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "zwp_primary_selection_device_manager_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a new primary selection source."]
            async fn create_source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Create a new data device for a given seat."]
            async fn get_device(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the primary selection device manager."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_primary_selection_device_v1 {
        #[doc = "Trait to implement the zwp_primary_selection_device_v1 interface. See the module level documentation for more info"]
        pub trait ZwpPrimarySelectionDeviceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_primary_selection_device_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwp_primary_selection_device_v1#{}.set_selection()",
                            object.id
                        );
                        self.set_selection(object, client, message.object()?, message.uint()?)
                            .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_primary_selection_device_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Replaces the current selection. The previous owner of the primary"]
            #[doc = "selection will receive a wp_primary_selection_source.cancelled event."]
            #[doc = ""]
            #[doc = "To unset the selection, set the source to NULL."]
            async fn set_selection(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: Option<crate::wire::ObjectId>,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the primary selection device."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Introduces a new wp_primary_selection_offer object that may be used"]
            #[doc = "to receive the current primary selection. Immediately following this"]
            #[doc = "event, the new wp_primary_selection_offer object will send"]
            #[doc = "wp_primary_selection_offer.offer events to describe the offered mime"]
            #[doc = "types."]
            async fn data_offer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                offer: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_primary_selection_device_v1#{}.data_offer()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(offer))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The wp_primary_selection_device.selection event is sent to notify the"]
            #[doc = "client of a new primary selection. This event is sent after the"]
            #[doc = "wp_primary_selection.data_offer event introducing this object, and after"]
            #[doc = "the offer has announced its mimetypes through"]
            #[doc = "wp_primary_selection_offer.offer."]
            #[doc = ""]
            #[doc = "The data_offer is valid until a new offer or NULL is received"]
            #[doc = "or until the client loses keyboard focus. The client must destroy the"]
            #[doc = "previous selection data_offer, if any, upon receiving this event."]
            async fn selection(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_primary_selection_device_v1#{}.selection()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_object(id).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A wp_primary_selection_offer represents an offer to transfer the contents"]
    #[doc = "of the primary selection clipboard to the client. Similar to"]
    #[doc = "wl_data_offer, the offer also describes the mime types that the data can"]
    #[doc = "be converted to and provides the mechanisms for transferring the data"]
    #[doc = "directly to the client."]
    pub mod zwp_primary_selection_offer_v1 {
        #[doc = "Trait to implement the zwp_primary_selection_offer_v1 interface. See the module level documentation for more info"]
        pub trait ZwpPrimarySelectionOfferV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_primary_selection_offer_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_primary_selection_offer_v1#{}.receive()", object.id);
                        self.receive(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.fd()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_primary_selection_offer_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "To transfer the contents of the primary selection clipboard, the client"]
            #[doc = "issues this request and indicates the mime type that it wants to"]
            #[doc = "receive. The transfer happens through the passed file descriptor"]
            #[doc = "(typically created with the pipe system call). The source client writes"]
            #[doc = "the data in the mime type representation requested and then closes the"]
            #[doc = "file descriptor."]
            #[doc = ""]
            #[doc = "The receiving client reads from the read end of the pipe until EOF and"]
            #[doc = "closes its end, at which point the transfer is complete."]
            async fn receive(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
                fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the primary selection offer."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sent immediately after creating announcing the"]
            #[doc = "wp_primary_selection_offer through"]
            #[doc = "wp_primary_selection_device.data_offer. One event is sent per offered"]
            #[doc = "mime type."]
            async fn offer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_primary_selection_offer_v1#{}.offer()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(mime_type))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "The source side of a wp_primary_selection_offer, it provides a way to"]
    #[doc = "describe the offered data and respond to requests to transfer the"]
    #[doc = "requested contents of the primary selection clipboard."]
    pub mod zwp_primary_selection_source_v1 {
        #[doc = "Trait to implement the zwp_primary_selection_source_v1 interface. See the module level documentation for more info"]
        pub trait ZwpPrimarySelectionSourceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_primary_selection_source_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_primary_selection_source_v1#{}.offer()", object.id);
                        self.offer(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_primary_selection_source_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request adds a mime type to the set of mime types advertised to"]
            #[doc = "targets. Can be called several times to offer multiple types."]
            async fn offer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the primary selection source."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Request for the current primary selection contents from the client."]
            #[doc = "Send the specified mime type over the passed file descriptor, then"]
            #[doc = "close it."]
            async fn send(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
                fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_primary_selection_source_v1#{}.send()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(mime_type))
                    .put_fd(fd)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This primary selection source is no longer valid. The client should"]
            #[doc = "clean up and destroy this primary selection source."]
            async fn cancelled(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_primary_selection_source_v1#{}.cancelled()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "This protocol specifies a set of interfaces used for making clients able to"]
#[doc = "receive relative pointer events not obstructed by barriers (such as the"]
#[doc = "monitor edge or other pointer barriers)."]
#[doc = ""]
#[doc = "To start receiving relative pointer events, a client must first bind the"]
#[doc = "global interface \"wp_relative_pointer_manager\" which, if a compositor"]
#[doc = "supports relative pointer motion events, is exposed by the registry. After"]
#[doc = "having created the relative pointer manager proxy object, the client uses"]
#[doc = "it to create the actual relative pointer object using the"]
#[doc = "\"get_relative_pointer\" request given a wl_pointer. The relative pointer"]
#[doc = "motion events will then, when applicable, be transmitted via the proxy of"]
#[doc = "the newly created relative pointer object. See the documentation of the"]
#[doc = "relative pointer interface for more details."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and backward"]
#[doc = "incompatible changes may be made. Backward compatible changes may be added"]
#[doc = "together with the corresponding interface version bump. Backward"]
#[doc = "incompatible changes are done by bumping the version number in the protocol"]
#[doc = "and interface names and resetting the interface version. Once the protocol"]
#[doc = "is to be declared stable, the 'z' prefix and the version number in the"]
#[doc = "protocol and interface names are removed and the interface version number is"]
#[doc = "reset."]
pub mod relative_pointer_unstable_v1 {
    #[doc = "A global interface used for getting the relative pointer object for a"]
    #[doc = "given pointer."]
    pub mod zwp_relative_pointer_manager_v1 {
        #[doc = "Trait to implement the zwp_relative_pointer_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZwpRelativePointerManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_relative_pointer_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_relative_pointer_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwp_relative_pointer_manager_v1#{}.get_relative_pointer()",
                            object.id
                        );
                        self.get_relative_pointer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Used by the client to notify the server that it will no longer use this"]
            #[doc = "relative pointer manager object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a relative pointer interface given a wl_pointer object. See the"]
            #[doc = "wp_relative_pointer interface for more details."]
            async fn get_relative_pointer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                pointer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "A wp_relative_pointer object is an extension to the wl_pointer interface"]
    #[doc = "used for emitting relative pointer events. It shares the same focus as"]
    #[doc = "wl_pointer objects of the same seat and will only emit events when it has"]
    #[doc = "focus."]
    pub mod zwp_relative_pointer_v1 {
        #[doc = "Trait to implement the zwp_relative_pointer_v1 interface. See the module level documentation for more info"]
        pub trait ZwpRelativePointerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_relative_pointer_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_relative_pointer_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Relative x/y pointer motion from the pointer of the seat associated with"]
            #[doc = "this object."]
            #[doc = ""]
            #[doc = "A relative motion is in the same dimension as regular wl_pointer motion"]
            #[doc = "events, except they do not represent an absolute position. For example,"]
            #[doc = "moving a pointer from (x, y) to (x', y') would have the equivalent"]
            #[doc = "relative motion (x' - x, y' - y). If a pointer motion caused the"]
            #[doc = "absolute pointer position to be clipped by for example the edge of the"]
            #[doc = "monitor, the relative motion is unaffected by the clipping and will"]
            #[doc = "represent the unclipped motion."]
            #[doc = ""]
            #[doc = "This event also contains non-accelerated motion deltas. The"]
            #[doc = "non-accelerated delta is, when applicable, the regular pointer motion"]
            #[doc = "delta as it was before having applied motion acceleration and other"]
            #[doc = "transformations such as normalization."]
            #[doc = ""]
            #[doc = "Note that the non-accelerated delta does not represent 'raw' events as"]
            #[doc = "they were read from some device. Pointer motion acceleration is device-"]
            #[doc = "and configuration-specific and non-accelerated deltas and accelerated"]
            #[doc = "deltas may have the same value on some devices."]
            #[doc = ""]
            #[doc = "Relative motions are not coupled to wl_pointer.motion events, and can be"]
            #[doc = "sent in combination with such events, but also independently. There may"]
            #[doc = "also be scenarios where wl_pointer.motion is sent, but there is no"]
            #[doc = "relative motion. The order of an absolute and relative motion event"]
            #[doc = "originating from the same physical motion is not guaranteed."]
            #[doc = ""]
            #[doc = "If the client needs button events or focus state, it can receive them"]
            #[doc = "from a wl_pointer object of the same seat that the wp_relative_pointer"]
            #[doc = "object is associated with."]
            async fn relative_motion(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                utime_hi: u32,
                utime_lo: u32,
                dx: crate::wire::Fixed,
                dy: crate::wire::Fixed,
                dx_unaccel: crate::wire::Fixed,
                dy_unaccel: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_relative_pointer_v1#{}.relative_motion()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(utime_hi)
                    .put_uint(utime_lo)
                    .put_fixed(dx)
                    .put_fixed(dy)
                    .put_fixed(dx_unaccel)
                    .put_fixed(dy_unaccel)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "This description provides a high-level overview of the interplay between"]
#[doc = "the interfaces defined this protocol. For details, see the protocol"]
#[doc = "specification."]
#[doc = ""]
#[doc = "More than one tablet may exist, and device-specifics matter. Tablets are"]
#[doc = "not represented by a single virtual device like wl_pointer. A client"]
#[doc = "binds to the tablet manager object which is just a proxy object. From"]
#[doc = "that, the client requests wp_tablet_manager.get_tablet_seat(wl_seat)"]
#[doc = "and that returns the actual interface that has all the tablets. With"]
#[doc = "this indirection, we can avoid merging wp_tablet into the actual Wayland"]
#[doc = "protocol, a long-term benefit."]
#[doc = ""]
#[doc = "The wp_tablet_seat sends a \"tablet added\" event for each tablet"]
#[doc = "connected. That event is followed by descriptive events about the"]
#[doc = "hardware; currently that includes events for name, vid/pid and"]
#[doc = "a wp_tablet.path event that describes a local path. This path can be"]
#[doc = "used to uniquely identify a tablet or get more information through"]
#[doc = "libwacom. Emulated or nested tablets can skip any of those, e.g. a"]
#[doc = "virtual tablet may not have a vid/pid. The sequence of descriptive"]
#[doc = "events is terminated by a wp_tablet.done event to signal that a client"]
#[doc = "may now finalize any initialization for that tablet."]
#[doc = ""]
#[doc = "Events from tablets require a tool in proximity. Tools are also managed"]
#[doc = "by the tablet seat; a \"tool added\" event is sent whenever a tool is new"]
#[doc = "to the compositor. That event is followed by a number of descriptive"]
#[doc = "events about the hardware; currently that includes capabilities,"]
#[doc = "hardware id and serial number, and tool type. Similar to the tablet"]
#[doc = "interface, a wp_tablet_tool.done event is sent to terminate that initial"]
#[doc = "sequence."]
#[doc = ""]
#[doc = "Any event from a tool happens on the wp_tablet_tool interface. When the"]
#[doc = "tool gets into proximity of the tablet, a proximity_in event is sent on"]
#[doc = "the wp_tablet_tool interface, listing the tablet and the surface. That"]
#[doc = "event is followed by a motion event with the coordinates. After that,"]
#[doc = "it's the usual motion, axis, button, etc. events. The protocol's"]
#[doc = "serialisation means events are grouped by wp_tablet_tool.frame events."]
#[doc = ""]
#[doc = "Two special events (that don't exist in X) are down and up. They signal"]
#[doc = "\"tip touching the surface\". For tablets without real proximity"]
#[doc = "detection, the sequence is: proximity_in, motion, down, frame."]
#[doc = ""]
#[doc = "When the tool leaves proximity, a proximity_out event is sent. If any"]
#[doc = "button is still down, a button release event is sent before this"]
#[doc = "proximity event. These button events are sent in the same frame as the"]
#[doc = "proximity event to signal to the client that the buttons were held when"]
#[doc = "the tool left proximity."]
#[doc = ""]
#[doc = "If the tool moves out of the surface but stays in proximity (i.e."]
#[doc = "between windows), compositor-specific grab policies apply. This usually"]
#[doc = "means that the proximity-out is delayed until all buttons are released."]
#[doc = ""]
#[doc = "Moving a tool physically from one tablet to the other has no real effect"]
#[doc = "on the protocol, since we already have the tool object from the \"tool"]
#[doc = "added\" event. All the information is already there and the proximity"]
#[doc = "events on both tablets are all a client needs to reconstruct what"]
#[doc = "happened."]
#[doc = ""]
#[doc = "Some extra axes are normalized, i.e. the client knows the range as"]
#[doc = "specified in the protocol (e.g. [0, 65535]), the granularity however is"]
#[doc = "unknown. The current normalized axes are pressure, distance, and slider."]
#[doc = ""]
#[doc = "Other extra axes are in physical units as specified in the protocol."]
#[doc = "The current extra axes with physical units are tilt, rotation and"]
#[doc = "wheel rotation."]
#[doc = ""]
#[doc = "Since tablets work independently of the pointer controlled by the mouse,"]
#[doc = "the focus handling is independent too and controlled by proximity."]
#[doc = "The wp_tablet_tool.set_cursor request sets a tool-specific cursor."]
#[doc = "This cursor surface may be the same as the mouse cursor, and it may be"]
#[doc = "the same across tools but it is possible to be more fine-grained. For"]
#[doc = "example, a client may set different cursors for the pen and eraser."]
#[doc = ""]
#[doc = "Tools are generally independent of tablets and it is"]
#[doc = "compositor-specific policy when a tool can be removed. Common approaches"]
#[doc = "will likely include some form of removing a tool when all tablets the"]
#[doc = "tool was used on are removed."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and"]
#[doc = "backward incompatible changes may be made. Backward compatible changes"]
#[doc = "may be added together with the corresponding interface version bump."]
#[doc = "Backward incompatible changes are done by bumping the version number in"]
#[doc = "the protocol and interface names and resetting the interface version."]
#[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
#[doc = "version number in the protocol and interface names are removed and the"]
#[doc = "interface version number is reset."]
pub mod tablet_unstable_v1 {
    #[doc = "An object that provides access to the graphics tablets available on this"]
    #[doc = "system. All tablets are associated with a seat, to get access to the"]
    #[doc = "actual tablets, use wp_tablet_manager.get_tablet_seat."]
    pub mod zwp_tablet_manager_v1 {
        #[doc = "Trait to implement the zwp_tablet_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZwpTabletManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_manager_v1#{}.get_tablet_seat()", object.id);
                        self.get_tablet_seat(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Get the wp_tablet_seat object for the given seat. This object"]
            #[doc = "provides access to all graphics tablets in this seat."]
            async fn get_tablet_seat(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tablet_seat: crate::wire::ObjectId,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the wp_tablet_manager object. Objects created from this"]
            #[doc = "object are unaffected and should be destroyed separately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "An object that provides access to the graphics tablets available on this"]
    #[doc = "seat. After binding to this interface, the compositor sends a set of"]
    #[doc = "wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events."]
    pub mod zwp_tablet_seat_v1 {
        #[doc = "Trait to implement the zwp_tablet_seat_v1 interface. See the module level documentation for more info"]
        pub trait ZwpTabletSeatV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_seat_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_seat_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the wp_tablet_seat object. Objects created from this"]
            #[doc = "object are unaffected and should be destroyed separately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent whenever a new tablet becomes available on this"]
            #[doc = "seat. This event only provides the object id of the tablet, any"]
            #[doc = "static information about the tablet (device name, vid/pid, etc.) is"]
            #[doc = "sent through the wp_tablet interface."]
            async fn tablet_added(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_seat_v1#{}.tablet_added()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent whenever a tool that has not previously been used"]
            #[doc = "with a tablet comes into use. This event only provides the object id"]
            #[doc = "of the tool; any static information about the tool (capabilities,"]
            #[doc = "type, etc.) is sent through the wp_tablet_tool interface."]
            async fn tool_added(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_seat_v1#{}.tool_added()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "An object that represents a physical tool that has been, or is"]
    #[doc = "currently in use with a tablet in this seat. Each wp_tablet_tool"]
    #[doc = "object stays valid until the client destroys it; the compositor"]
    #[doc = "reuses the wp_tablet_tool object to indicate that the object's"]
    #[doc = "respective physical tool has come into proximity of a tablet again."]
    #[doc = ""]
    #[doc = "A wp_tablet_tool object's relation to a physical tool depends on the"]
    #[doc = "tablet's ability to report serial numbers. If the tablet supports"]
    #[doc = "this capability, then the object represents a specific physical tool"]
    #[doc = "and can be identified even when used on multiple tablets."]
    #[doc = ""]
    #[doc = "A tablet tool has a number of static characteristics, e.g. tool type,"]
    #[doc = "hardware_serial and capabilities. These capabilities are sent in an"]
    #[doc = "event sequence after the wp_tablet_seat.tool_added event before any"]
    #[doc = "actual events from this tool. This initial event sequence is"]
    #[doc = "terminated by a wp_tablet_tool.done event."]
    #[doc = ""]
    #[doc = "Tablet tool events are grouped by wp_tablet_tool.frame events."]
    #[doc = "Any events received before a wp_tablet_tool.frame event should be"]
    #[doc = "considered part of the same hardware state change."]
    pub mod zwp_tablet_tool_v1 {
        #[doc = "Describes the physical type of a tool. The physical type of a tool"]
        #[doc = "generally defines its base usage."]
        #[doc = ""]
        #[doc = "The mouse tool represents a mouse-shaped tool that is not a relative"]
        #[doc = "device but bound to the tablet's surface, providing absolute"]
        #[doc = "coordinates."]
        #[doc = ""]
        #[doc = "The lens tool is a mouse-shaped tool with an attached lens to"]
        #[doc = "provide precision focus."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Type {
            #[doc = "Pen"]
            Pen = 320u32,
            #[doc = "Eraser"]
            Eraser = 321u32,
            #[doc = "Brush"]
            Brush = 322u32,
            #[doc = "Pencil"]
            Pencil = 323u32,
            #[doc = "Airbrush"]
            Airbrush = 324u32,
            #[doc = "Finger"]
            Finger = 325u32,
            #[doc = "Mouse"]
            Mouse = 326u32,
            #[doc = "Lens"]
            Lens = 327u32,
        }
        impl TryFrom<u32> for Type {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    320u32 => Ok(Self::Pen),
                    321u32 => Ok(Self::Eraser),
                    322u32 => Ok(Self::Brush),
                    323u32 => Ok(Self::Pencil),
                    324u32 => Ok(Self::Airbrush),
                    325u32 => Ok(Self::Finger),
                    326u32 => Ok(Self::Mouse),
                    327u32 => Ok(Self::Lens),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Describes extra capabilities on a tablet."]
        #[doc = ""]
        #[doc = "Any tool must provide x and y values, extra axes are"]
        #[doc = "device-specific."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Capability {
            #[doc = "Tilt axes"]
            Tilt = 1u32,
            #[doc = "Pressure axis"]
            Pressure = 2u32,
            #[doc = "Distance axis"]
            Distance = 3u32,
            #[doc = "Z-rotation axis"]
            Rotation = 4u32,
            #[doc = "Slider axis"]
            Slider = 5u32,
            #[doc = "Wheel axis"]
            Wheel = 6u32,
        }
        impl TryFrom<u32> for Capability {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::Tilt),
                    2u32 => Ok(Self::Pressure),
                    3u32 => Ok(Self::Distance),
                    4u32 => Ok(Self::Rotation),
                    5u32 => Ok(Self::Slider),
                    6u32 => Ok(Self::Wheel),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Describes the physical state of a button that produced the button event."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ButtonState {
            #[doc = "button is not pressed"]
            Released = 0u32,
            #[doc = "button is pressed"]
            Pressed = 1u32,
        }
        impl TryFrom<u32> for ButtonState {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Released),
                    1u32 => Ok(Self::Pressed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "given wl_surface has another role"]
            Role = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Role),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwp_tablet_tool_v1 interface. See the module level documentation for more info"]
        pub trait ZwpTabletToolV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_tool_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_tool_v1#{}.set_cursor()", object.id);
                        self.set_cursor(
                            object,
                            client,
                            message.uint()?,
                            message.object()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_tool_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Sets the surface of the cursor used for this tool on the given"]
            #[doc = "tablet. This request only takes effect if the tool is in proximity"]
            #[doc = "of one of the requesting client's surfaces or the surface parameter"]
            #[doc = "is the current pointer surface. If there was a previous surface set"]
            #[doc = "with this request it is replaced. If surface is NULL, the cursor"]
            #[doc = "image is hidden."]
            #[doc = ""]
            #[doc = "The parameters hotspot_x and hotspot_y define the position of the"]
            #[doc = "pointer surface relative to the pointer location. Its top-left corner"]
            #[doc = "is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the"]
            #[doc = "coordinates of the pointer location, in surface-local coordinates."]
            #[doc = ""]
            #[doc = "On surface.attach requests to the pointer surface, hotspot_x and"]
            #[doc = "hotspot_y are decremented by the x and y parameters passed to the"]
            #[doc = "request. Attach must be confirmed by wl_surface.commit as usual."]
            #[doc = ""]
            #[doc = "The hotspot can also be updated by passing the currently set pointer"]
            #[doc = "surface to this request with new values for hotspot_x and hotspot_y."]
            #[doc = ""]
            #[doc = "The current and pending input regions of the wl_surface are cleared,"]
            #[doc = "and wl_surface.set_input_region is ignored until the wl_surface is no"]
            #[doc = "longer used as the cursor. When the use as a cursor ends, the current"]
            #[doc = "and pending input regions become undefined, and the wl_surface is"]
            #[doc = "unmapped."]
            #[doc = ""]
            #[doc = "This request gives the surface the role of a cursor. The role"]
            #[doc = "assigned by this request is the same as assigned by"]
            #[doc = "wl_pointer.set_cursor meaning the same surface can be"]
            #[doc = "used both as a wl_pointer cursor and a wp_tablet cursor. If the"]
            #[doc = "surface already has another role, it raises a protocol error."]
            #[doc = "The surface may be used on multiple tablets and across multiple"]
            #[doc = "seats."]
            async fn set_cursor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: Option<crate::wire::ObjectId>,
                hotspot_x: i32,
                hotspot_y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "This destroys the client's resource for this tool object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The tool type is the high-level type of the tool and usually decides"]
            #[doc = "the interaction expected from this tool."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn r#type(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tool_type: Type,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.type()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(tool_type as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "If the physical tool can be identified by a unique 64-bit serial"]
            #[doc = "number, this event notifies the client of this serial number."]
            #[doc = ""]
            #[doc = "If multiple tablets are available in the same seat and the tool is"]
            #[doc = "uniquely identifiable by the serial number, that tool may move"]
            #[doc = "between tablets."]
            #[doc = ""]
            #[doc = "Otherwise, if the tool has no serial number and this event is"]
            #[doc = "missing, the tool is tied to the tablet it first comes into"]
            #[doc = "proximity with. Even if the physical tool is used on multiple"]
            #[doc = "tablets, separate wp_tablet_tool objects will be created, one per"]
            #[doc = "tablet."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn hardware_serial(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                hardware_serial_hi: u32,
                hardware_serial_lo: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.hardware_serial()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(hardware_serial_hi)
                    .put_uint(hardware_serial_lo)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event notifies the client of a hardware id available on this tool."]
            #[doc = ""]
            #[doc = "The hardware id is a device-specific 64-bit id that provides extra"]
            #[doc = "information about the tool in use, beyond the wl_tool.type"]
            #[doc = "enumeration. The format of the id is specific to tablets made by"]
            #[doc = "Wacom Inc. For example, the hardware id of a Wacom Grip"]
            #[doc = "Pen (a stylus) is 0x802."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn hardware_id_wacom(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                hardware_id_hi: u32,
                hardware_id_lo: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.hardware_id_wacom()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(hardware_id_hi)
                    .put_uint(hardware_id_lo)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event notifies the client of any capabilities of this tool,"]
            #[doc = "beyond the main set of x/y axes and tip up/down detection."]
            #[doc = ""]
            #[doc = "One event is sent for each extra capability available on this tool."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn capability(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                capability: Capability,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.capability()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(capability as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event signals the end of the initial burst of descriptive"]
            #[doc = "events. A client may consider the static description of the tool to"]
            #[doc = "be complete and finalize initialization of the tool."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent when the tool is removed from the system and will"]
            #[doc = "send no further events. Should the physical tool come back into"]
            #[doc = "proximity later, a new wp_tablet_tool object will be created."]
            #[doc = ""]
            #[doc = "It is compositor-dependent when a tool is removed. A compositor may"]
            #[doc = "remove a tool on proximity out, tablet removal or any other reason."]
            #[doc = "A compositor may also keep a tool alive until shutdown."]
            #[doc = ""]
            #[doc = "If the tool is currently in proximity, a proximity_out event will be"]
            #[doc = "sent before the removed event. See wp_tablet_tool.proximity_out for"]
            #[doc = "the handling of any buttons logically down."]
            #[doc = ""]
            #[doc = "When this event is received, the client must wp_tablet_tool.destroy"]
            #[doc = "the object."]
            async fn removed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.removed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notification that this tool is focused on a certain surface."]
            #[doc = ""]
            #[doc = "This event can be received when the tool has moved from one surface to"]
            #[doc = "another, or when the tool has come back into proximity above the"]
            #[doc = "surface."]
            #[doc = ""]
            #[doc = "If any button is logically down when the tool comes into proximity,"]
            #[doc = "the respective button event is sent after the proximity_in event but"]
            #[doc = "within the same frame as the proximity_in event."]
            async fn proximity_in(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                tablet: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.proximity_in()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(tablet))
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 6u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notification that this tool has either left proximity, or is no"]
            #[doc = "longer focused on a certain surface."]
            #[doc = ""]
            #[doc = "When the tablet tool leaves proximity of the tablet, button release"]
            #[doc = "events are sent for each button that was held down at the time of"]
            #[doc = "leaving proximity. These events are sent before the proximity_out"]
            #[doc = "event but within the same wp_tablet.frame."]
            #[doc = ""]
            #[doc = "If the tool stays within proximity of the tablet, but the focus"]
            #[doc = "changes from one surface to another, a button release event may not"]
            #[doc = "be sent until the button is actually released or the tool leaves the"]
            #[doc = "proximity of the tablet."]
            async fn proximity_out(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.proximity_out()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 7u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the tablet tool comes in contact with the surface of the"]
            #[doc = "tablet."]
            #[doc = ""]
            #[doc = "If the tool is already in contact with the tablet when entering the"]
            #[doc = "input region, the client owning said region will receive a"]
            #[doc = "wp_tablet.proximity_in event, followed by a wp_tablet.down"]
            #[doc = "event and a wp_tablet.frame event."]
            #[doc = ""]
            #[doc = "Note that this event describes logical contact, not physical"]
            #[doc = "contact. On some devices, a compositor may not consider a tool in"]
            #[doc = "logical contact until a minimum physical pressure threshold is"]
            #[doc = "exceeded."]
            async fn down(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.down()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 8u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the tablet tool stops making contact with the surface of"]
            #[doc = "the tablet, or when the tablet tool moves out of the input region"]
            #[doc = "and the compositor grab (if any) is dismissed."]
            #[doc = ""]
            #[doc = "If the tablet tool moves out of the input region while in contact"]
            #[doc = "with the surface of the tablet and the compositor does not have an"]
            #[doc = "ongoing grab on the surface, the client owning said region will"]
            #[doc = "receive a wp_tablet.up event, followed by a wp_tablet.proximity_out"]
            #[doc = "event and a wp_tablet.frame event. If the compositor has an ongoing"]
            #[doc = "grab on this device, this event sequence is sent whenever the grab"]
            #[doc = "is dismissed in the future."]
            #[doc = ""]
            #[doc = "Note that this event describes logical contact, not physical"]
            #[doc = "contact. On some devices, a compositor may not consider a tool out"]
            #[doc = "of logical contact until physical pressure falls below a specific"]
            #[doc = "threshold."]
            async fn up(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.up()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 9u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever a tablet tool moves."]
            async fn motion(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: crate::wire::Fixed,
                y: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.motion()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fixed(x)
                    .put_fixed(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 10u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the pressure axis on a tool changes. The value of this"]
            #[doc = "event is normalized to a value between 0 and 65535."]
            #[doc = ""]
            #[doc = "Note that pressure may be nonzero even when a tool is not in logical"]
            #[doc = "contact. See the down and up events for more details."]
            async fn pressure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                pressure: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.pressure()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(pressure)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 11u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the distance axis on a tool changes. The value of this"]
            #[doc = "event is normalized to a value between 0 and 65535."]
            #[doc = ""]
            #[doc = "Note that distance may be nonzero even when a tool is not in logical"]
            #[doc = "contact. See the down and up events for more details."]
            async fn distance(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                distance: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.distance()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(distance)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 12u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever one or both of the tilt axes on a tool change. Each tilt"]
            #[doc = "value is in 0.01 of a degree, relative to the z-axis of the tablet."]
            #[doc = "The angle is positive when the top of a tool tilts along the"]
            #[doc = "positive x or y axis."]
            async fn tilt(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tilt_x: i32,
                tilt_y: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.tilt()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(tilt_x)
                    .put_int(tilt_y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 13u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the z-rotation axis on the tool changes. The"]
            #[doc = "rotation value is in 0.01 of a degree clockwise from the tool's"]
            #[doc = "logical neutral position."]
            async fn rotation(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                degrees: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.rotation()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(degrees).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 14u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the slider position on the tool changes. The"]
            #[doc = "value is normalized between -65535 and 65535, with 0 as the logical"]
            #[doc = "neutral position of the slider."]
            #[doc = ""]
            #[doc = "The slider is available on e.g. the Wacom Airbrush tool."]
            async fn slider(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                position: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.slider()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(position).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 15u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the wheel on the tool emits an event. This event"]
            #[doc = "contains two values for the same axis change. The degrees value is"]
            #[doc = "in 0.01 of a degree in the same orientation as the"]
            #[doc = "wl_pointer.vertical_scroll axis. The clicks value is in discrete"]
            #[doc = "logical clicks of the mouse wheel. This value may be zero if the"]
            #[doc = "movement of the wheel was less than one logical click."]
            #[doc = ""]
            #[doc = "Clients should choose either value and avoid mixing degrees and"]
            #[doc = "clicks. The compositor may accumulate values smaller than a logical"]
            #[doc = "click and emulate click events when a certain threshold is met."]
            #[doc = "Thus, wl_tablet_tool.wheel events with non-zero clicks values may"]
            #[doc = "have different degrees values."]
            async fn wheel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                degrees: i32,
                clicks: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.wheel()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(degrees)
                    .put_int(clicks)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 16u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever a button on the tool is pressed or released."]
            #[doc = ""]
            #[doc = "If a button is held down when the tool moves in or out of proximity,"]
            #[doc = "button events are generated by the compositor. See"]
            #[doc = "wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for"]
            #[doc = "details."]
            async fn button(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                button: u32,
                state: ButtonState,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.button()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(button)
                    .put_uint(state as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 17u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Marks the end of a series of axis and/or button updates from the"]
            #[doc = "tablet. The Wayland protocol requires axis updates to be sent"]
            #[doc = "sequentially, however all events within a frame should be considered"]
            #[doc = "one hardware event."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.frame()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(time).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 18u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "The wp_tablet interface represents one graphics tablet device. The"]
    #[doc = "tablet interface itself does not generate events; all events are"]
    #[doc = "generated by wp_tablet_tool objects when in proximity above a tablet."]
    #[doc = ""]
    #[doc = "A tablet has a number of static characteristics, e.g. device name and"]
    #[doc = "pid/vid. These capabilities are sent in an event sequence after the"]
    #[doc = "wp_tablet_seat.tablet_added event. This initial event sequence is"]
    #[doc = "terminated by a wp_tablet.done event."]
    pub mod zwp_tablet_v1 {
        #[doc = "Trait to implement the zwp_tablet_v1 interface. See the module level documentation for more info"]
        pub trait ZwpTabletV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This destroys the client's resource for this tablet object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet.done event."]
            async fn name(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v1#{}.name()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(name))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet.done event."]
            async fn id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                vid: u32,
                pid: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v1#{}.id()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(vid)
                    .put_uint(pid)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "A system-specific device path that indicates which device is behind"]
            #[doc = "this wp_tablet. This information may be used to gather additional"]
            #[doc = "information about the device, e.g. through libwacom."]
            #[doc = ""]
            #[doc = "A device may have more than one device path. If so, multiple"]
            #[doc = "wp_tablet.path events are sent. A device may be emulated and not"]
            #[doc = "have a device path, and in that case this event will not be sent."]
            #[doc = ""]
            #[doc = "The format of the path is unspecified, it may be a device node, a"]
            #[doc = "sysfs path, or some other identifier. It is up to the client to"]
            #[doc = "identify the string provided."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet.done event."]
            async fn path(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                path: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v1#{}.path()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(path))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent immediately to signal the end of the initial"]
            #[doc = "burst of descriptive events. A client may consider the static"]
            #[doc = "description of the tablet to be complete and finalize initialization"]
            #[doc = "of the tablet."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v1#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent when the tablet has been removed from the system. When a tablet"]
            #[doc = "is removed, some tools may be removed."]
            #[doc = ""]
            #[doc = "When this event is received, the client must wp_tablet.destroy"]
            #[doc = "the object."]
            async fn removed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v1#{}.removed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "This description provides a high-level overview of the interplay between"]
#[doc = "the interfaces defined this protocol. For details, see the protocol"]
#[doc = "specification."]
#[doc = ""]
#[doc = "More than one tablet may exist, and device-specifics matter. Tablets are"]
#[doc = "not represented by a single virtual device like wl_pointer. A client"]
#[doc = "binds to the tablet manager object which is just a proxy object. From"]
#[doc = "that, the client requests wp_tablet_manager.get_tablet_seat(wl_seat)"]
#[doc = "and that returns the actual interface that has all the tablets. With"]
#[doc = "this indirection, we can avoid merging wp_tablet into the actual Wayland"]
#[doc = "protocol, a long-term benefit."]
#[doc = ""]
#[doc = "The wp_tablet_seat sends a \"tablet added\" event for each tablet"]
#[doc = "connected. That event is followed by descriptive events about the"]
#[doc = "hardware; currently that includes events for name, vid/pid and"]
#[doc = "a wp_tablet.path event that describes a local path. This path can be"]
#[doc = "used to uniquely identify a tablet or get more information through"]
#[doc = "libwacom. Emulated or nested tablets can skip any of those, e.g. a"]
#[doc = "virtual tablet may not have a vid/pid. The sequence of descriptive"]
#[doc = "events is terminated by a wp_tablet.done event to signal that a client"]
#[doc = "may now finalize any initialization for that tablet."]
#[doc = ""]
#[doc = "Events from tablets require a tool in proximity. Tools are also managed"]
#[doc = "by the tablet seat; a \"tool added\" event is sent whenever a tool is new"]
#[doc = "to the compositor. That event is followed by a number of descriptive"]
#[doc = "events about the hardware; currently that includes capabilities,"]
#[doc = "hardware id and serial number, and tool type. Similar to the tablet"]
#[doc = "interface, a wp_tablet_tool.done event is sent to terminate that initial"]
#[doc = "sequence."]
#[doc = ""]
#[doc = "Any event from a tool happens on the wp_tablet_tool interface. When the"]
#[doc = "tool gets into proximity of the tablet, a proximity_in event is sent on"]
#[doc = "the wp_tablet_tool interface, listing the tablet and the surface. That"]
#[doc = "event is followed by a motion event with the coordinates. After that,"]
#[doc = "it's the usual motion, axis, button, etc. events. The protocol's"]
#[doc = "serialisation means events are grouped by wp_tablet_tool.frame events."]
#[doc = ""]
#[doc = "Two special events (that don't exist in X) are down and up. They signal"]
#[doc = "\"tip touching the surface\". For tablets without real proximity"]
#[doc = "detection, the sequence is: proximity_in, motion, down, frame."]
#[doc = ""]
#[doc = "When the tool leaves proximity, a proximity_out event is sent. If any"]
#[doc = "button is still down, a button release event is sent before this"]
#[doc = "proximity event. These button events are sent in the same frame as the"]
#[doc = "proximity event to signal to the client that the buttons were held when"]
#[doc = "the tool left proximity."]
#[doc = ""]
#[doc = "If the tool moves out of the surface but stays in proximity (i.e."]
#[doc = "between windows), compositor-specific grab policies apply. This usually"]
#[doc = "means that the proximity-out is delayed until all buttons are released."]
#[doc = ""]
#[doc = "Moving a tool physically from one tablet to the other has no real effect"]
#[doc = "on the protocol, since we already have the tool object from the \"tool"]
#[doc = "added\" event. All the information is already there and the proximity"]
#[doc = "events on both tablets are all a client needs to reconstruct what"]
#[doc = "happened."]
#[doc = ""]
#[doc = "Some extra axes are normalized, i.e. the client knows the range as"]
#[doc = "specified in the protocol (e.g. [0, 65535]), the granularity however is"]
#[doc = "unknown. The current normalized axes are pressure, distance, and slider."]
#[doc = ""]
#[doc = "Other extra axes are in physical units as specified in the protocol."]
#[doc = "The current extra axes with physical units are tilt, rotation and"]
#[doc = "wheel rotation."]
#[doc = ""]
#[doc = "Since tablets work independently of the pointer controlled by the mouse,"]
#[doc = "the focus handling is independent too and controlled by proximity."]
#[doc = "The wp_tablet_tool.set_cursor request sets a tool-specific cursor."]
#[doc = "This cursor surface may be the same as the mouse cursor, and it may be"]
#[doc = "the same across tools but it is possible to be more fine-grained. For"]
#[doc = "example, a client may set different cursors for the pen and eraser."]
#[doc = ""]
#[doc = "Tools are generally independent of tablets and it is"]
#[doc = "compositor-specific policy when a tool can be removed. Common approaches"]
#[doc = "will likely include some form of removing a tool when all tablets the"]
#[doc = "tool was used on are removed."]
#[doc = ""]
#[doc = "Disclaimer: This protocol extension has been marked stable. This copy is"]
#[doc = "no longer used and only retained for backwards compatibility. The"]
#[doc = "canonical version can be found in the stable/ directory."]
pub mod tablet_unstable_v2 {
    #[doc = "An object that provides access to the graphics tablets available on this"]
    #[doc = "system. All tablets are associated with a seat, to get access to the"]
    #[doc = "actual tablets, use wp_tablet_manager.get_tablet_seat."]
    pub mod zwp_tablet_manager_v2 {
        #[doc = "Trait to implement the zwp_tablet_manager_v2 interface. See the module level documentation for more info"]
        pub trait ZwpTabletManagerV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_manager_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_manager_v2#{}.get_tablet_seat()", object.id);
                        self.get_tablet_seat(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_manager_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Get the wp_tablet_seat object for the given seat. This object"]
            #[doc = "provides access to all graphics tablets in this seat."]
            async fn get_tablet_seat(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tablet_seat: crate::wire::ObjectId,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the wp_tablet_manager object. Objects created from this"]
            #[doc = "object are unaffected and should be destroyed separately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "An object that provides access to the graphics tablets available on this"]
    #[doc = "seat. After binding to this interface, the compositor sends a set of"]
    #[doc = "wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events."]
    pub mod zwp_tablet_seat_v2 {
        #[doc = "Trait to implement the zwp_tablet_seat_v2 interface. See the module level documentation for more info"]
        pub trait ZwpTabletSeatV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_seat_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_seat_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the wp_tablet_seat object. Objects created from this"]
            #[doc = "object are unaffected and should be destroyed separately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent whenever a new tablet becomes available on this"]
            #[doc = "seat. This event only provides the object id of the tablet, any"]
            #[doc = "static information about the tablet (device name, vid/pid, etc.) is"]
            #[doc = "sent through the wp_tablet interface."]
            async fn tablet_added(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_seat_v2#{}.tablet_added()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent whenever a tool that has not previously been used"]
            #[doc = "with a tablet comes into use. This event only provides the object id"]
            #[doc = "of the tool; any static information about the tool (capabilities,"]
            #[doc = "type, etc.) is sent through the wp_tablet_tool interface."]
            async fn tool_added(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_seat_v2#{}.tool_added()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent whenever a new pad is known to the system. Typically,"]
            #[doc = "pads are physically attached to tablets and a pad_added event is"]
            #[doc = "sent immediately after the wp_tablet_seat.tablet_added."]
            #[doc = "However, some standalone pad devices logically attach to tablets at"]
            #[doc = "runtime, and the client must wait for wp_tablet_pad.enter to know"]
            #[doc = "the tablet a pad is attached to."]
            #[doc = ""]
            #[doc = "This event only provides the object id of the pad. All further"]
            #[doc = "features (buttons, strips, rings) are sent through the wp_tablet_pad"]
            #[doc = "interface."]
            async fn pad_added(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_seat_v2#{}.pad_added()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "An object that represents a physical tool that has been, or is"]
    #[doc = "currently in use with a tablet in this seat. Each wp_tablet_tool"]
    #[doc = "object stays valid until the client destroys it; the compositor"]
    #[doc = "reuses the wp_tablet_tool object to indicate that the object's"]
    #[doc = "respective physical tool has come into proximity of a tablet again."]
    #[doc = ""]
    #[doc = "A wp_tablet_tool object's relation to a physical tool depends on the"]
    #[doc = "tablet's ability to report serial numbers. If the tablet supports"]
    #[doc = "this capability, then the object represents a specific physical tool"]
    #[doc = "and can be identified even when used on multiple tablets."]
    #[doc = ""]
    #[doc = "A tablet tool has a number of static characteristics, e.g. tool type,"]
    #[doc = "hardware_serial and capabilities. These capabilities are sent in an"]
    #[doc = "event sequence after the wp_tablet_seat.tool_added event before any"]
    #[doc = "actual events from this tool. This initial event sequence is"]
    #[doc = "terminated by a wp_tablet_tool.done event."]
    #[doc = ""]
    #[doc = "Tablet tool events are grouped by wp_tablet_tool.frame events."]
    #[doc = "Any events received before a wp_tablet_tool.frame event should be"]
    #[doc = "considered part of the same hardware state change."]
    pub mod zwp_tablet_tool_v2 {
        #[doc = "Describes the physical type of a tool. The physical type of a tool"]
        #[doc = "generally defines its base usage."]
        #[doc = ""]
        #[doc = "The mouse tool represents a mouse-shaped tool that is not a relative"]
        #[doc = "device but bound to the tablet's surface, providing absolute"]
        #[doc = "coordinates."]
        #[doc = ""]
        #[doc = "The lens tool is a mouse-shaped tool with an attached lens to"]
        #[doc = "provide precision focus."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Type {
            #[doc = "Pen"]
            Pen = 320u32,
            #[doc = "Eraser"]
            Eraser = 321u32,
            #[doc = "Brush"]
            Brush = 322u32,
            #[doc = "Pencil"]
            Pencil = 323u32,
            #[doc = "Airbrush"]
            Airbrush = 324u32,
            #[doc = "Finger"]
            Finger = 325u32,
            #[doc = "Mouse"]
            Mouse = 326u32,
            #[doc = "Lens"]
            Lens = 327u32,
        }
        impl TryFrom<u32> for Type {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    320u32 => Ok(Self::Pen),
                    321u32 => Ok(Self::Eraser),
                    322u32 => Ok(Self::Brush),
                    323u32 => Ok(Self::Pencil),
                    324u32 => Ok(Self::Airbrush),
                    325u32 => Ok(Self::Finger),
                    326u32 => Ok(Self::Mouse),
                    327u32 => Ok(Self::Lens),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Describes extra capabilities on a tablet."]
        #[doc = ""]
        #[doc = "Any tool must provide x and y values, extra axes are"]
        #[doc = "device-specific."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Capability {
            #[doc = "Tilt axes"]
            Tilt = 1u32,
            #[doc = "Pressure axis"]
            Pressure = 2u32,
            #[doc = "Distance axis"]
            Distance = 3u32,
            #[doc = "Z-rotation axis"]
            Rotation = 4u32,
            #[doc = "Slider axis"]
            Slider = 5u32,
            #[doc = "Wheel axis"]
            Wheel = 6u32,
        }
        impl TryFrom<u32> for Capability {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::Tilt),
                    2u32 => Ok(Self::Pressure),
                    3u32 => Ok(Self::Distance),
                    4u32 => Ok(Self::Rotation),
                    5u32 => Ok(Self::Slider),
                    6u32 => Ok(Self::Wheel),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Describes the physical state of a button that produced the button event."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ButtonState {
            #[doc = "button is not pressed"]
            Released = 0u32,
            #[doc = "button is pressed"]
            Pressed = 1u32,
        }
        impl TryFrom<u32> for ButtonState {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Released),
                    1u32 => Ok(Self::Pressed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "given wl_surface has another role"]
            Role = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Role),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwp_tablet_tool_v2 interface. See the module level documentation for more info"]
        pub trait ZwpTabletToolV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_tool_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_tool_v2#{}.set_cursor()", object.id);
                        self.set_cursor(
                            object,
                            client,
                            message.uint()?,
                            message.object()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_tool_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Sets the surface of the cursor used for this tool on the given"]
            #[doc = "tablet. This request only takes effect if the tool is in proximity"]
            #[doc = "of one of the requesting client's surfaces or the surface parameter"]
            #[doc = "is the current pointer surface. If there was a previous surface set"]
            #[doc = "with this request it is replaced. If surface is NULL, the cursor"]
            #[doc = "image is hidden."]
            #[doc = ""]
            #[doc = "The parameters hotspot_x and hotspot_y define the position of the"]
            #[doc = "pointer surface relative to the pointer location. Its top-left corner"]
            #[doc = "is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the"]
            #[doc = "coordinates of the pointer location, in surface-local coordinates."]
            #[doc = ""]
            #[doc = "On surface.attach requests to the pointer surface, hotspot_x and"]
            #[doc = "hotspot_y are decremented by the x and y parameters passed to the"]
            #[doc = "request. Attach must be confirmed by wl_surface.commit as usual."]
            #[doc = ""]
            #[doc = "The hotspot can also be updated by passing the currently set pointer"]
            #[doc = "surface to this request with new values for hotspot_x and hotspot_y."]
            #[doc = ""]
            #[doc = "The current and pending input regions of the wl_surface are cleared,"]
            #[doc = "and wl_surface.set_input_region is ignored until the wl_surface is no"]
            #[doc = "longer used as the cursor. When the use as a cursor ends, the current"]
            #[doc = "and pending input regions become undefined, and the wl_surface is"]
            #[doc = "unmapped."]
            #[doc = ""]
            #[doc = "This request gives the surface the role of a wp_tablet_tool cursor. A"]
            #[doc = "surface may only ever be used as the cursor surface for one"]
            #[doc = "wp_tablet_tool. If the surface already has another role or has"]
            #[doc = "previously been used as cursor surface for a different tool, a"]
            #[doc = "protocol error is raised."]
            async fn set_cursor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: Option<crate::wire::ObjectId>,
                hotspot_x: i32,
                hotspot_y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "This destroys the client's resource for this tool object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The tool type is the high-level type of the tool and usually decides"]
            #[doc = "the interaction expected from this tool."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn r#type(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tool_type: Type,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.type()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(tool_type as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "If the physical tool can be identified by a unique 64-bit serial"]
            #[doc = "number, this event notifies the client of this serial number."]
            #[doc = ""]
            #[doc = "If multiple tablets are available in the same seat and the tool is"]
            #[doc = "uniquely identifiable by the serial number, that tool may move"]
            #[doc = "between tablets."]
            #[doc = ""]
            #[doc = "Otherwise, if the tool has no serial number and this event is"]
            #[doc = "missing, the tool is tied to the tablet it first comes into"]
            #[doc = "proximity with. Even if the physical tool is used on multiple"]
            #[doc = "tablets, separate wp_tablet_tool objects will be created, one per"]
            #[doc = "tablet."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn hardware_serial(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                hardware_serial_hi: u32,
                hardware_serial_lo: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.hardware_serial()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(hardware_serial_hi)
                    .put_uint(hardware_serial_lo)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event notifies the client of a hardware id available on this tool."]
            #[doc = ""]
            #[doc = "The hardware id is a device-specific 64-bit id that provides extra"]
            #[doc = "information about the tool in use, beyond the wl_tool.type"]
            #[doc = "enumeration. The format of the id is specific to tablets made by"]
            #[doc = "Wacom Inc. For example, the hardware id of a Wacom Grip"]
            #[doc = "Pen (a stylus) is 0x802."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn hardware_id_wacom(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                hardware_id_hi: u32,
                hardware_id_lo: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.hardware_id_wacom()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(hardware_id_hi)
                    .put_uint(hardware_id_lo)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event notifies the client of any capabilities of this tool,"]
            #[doc = "beyond the main set of x/y axes and tip up/down detection."]
            #[doc = ""]
            #[doc = "One event is sent for each extra capability available on this tool."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_tool.done event."]
            async fn capability(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                capability: Capability,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.capability()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(capability as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event signals the end of the initial burst of descriptive"]
            #[doc = "events. A client may consider the static description of the tool to"]
            #[doc = "be complete and finalize initialization of the tool."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent when the tool is removed from the system and will"]
            #[doc = "send no further events. Should the physical tool come back into"]
            #[doc = "proximity later, a new wp_tablet_tool object will be created."]
            #[doc = ""]
            #[doc = "It is compositor-dependent when a tool is removed. A compositor may"]
            #[doc = "remove a tool on proximity out, tablet removal or any other reason."]
            #[doc = "A compositor may also keep a tool alive until shutdown."]
            #[doc = ""]
            #[doc = "If the tool is currently in proximity, a proximity_out event will be"]
            #[doc = "sent before the removed event. See wp_tablet_tool.proximity_out for"]
            #[doc = "the handling of any buttons logically down."]
            #[doc = ""]
            #[doc = "When this event is received, the client must wp_tablet_tool.destroy"]
            #[doc = "the object."]
            async fn removed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.removed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notification that this tool is focused on a certain surface."]
            #[doc = ""]
            #[doc = "This event can be received when the tool has moved from one surface to"]
            #[doc = "another, or when the tool has come back into proximity above the"]
            #[doc = "surface."]
            #[doc = ""]
            #[doc = "If any button is logically down when the tool comes into proximity,"]
            #[doc = "the respective button event is sent after the proximity_in event but"]
            #[doc = "within the same frame as the proximity_in event."]
            async fn proximity_in(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                tablet: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.proximity_in()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(tablet))
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 6u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notification that this tool has either left proximity, or is no"]
            #[doc = "longer focused on a certain surface."]
            #[doc = ""]
            #[doc = "When the tablet tool leaves proximity of the tablet, button release"]
            #[doc = "events are sent for each button that was held down at the time of"]
            #[doc = "leaving proximity. These events are sent before the proximity_out"]
            #[doc = "event but within the same wp_tablet.frame."]
            #[doc = ""]
            #[doc = "If the tool stays within proximity of the tablet, but the focus"]
            #[doc = "changes from one surface to another, a button release event may not"]
            #[doc = "be sent until the button is actually released or the tool leaves the"]
            #[doc = "proximity of the tablet."]
            async fn proximity_out(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.proximity_out()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 7u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the tablet tool comes in contact with the surface of the"]
            #[doc = "tablet."]
            #[doc = ""]
            #[doc = "If the tool is already in contact with the tablet when entering the"]
            #[doc = "input region, the client owning said region will receive a"]
            #[doc = "wp_tablet.proximity_in event, followed by a wp_tablet.down"]
            #[doc = "event and a wp_tablet.frame event."]
            #[doc = ""]
            #[doc = "Note that this event describes logical contact, not physical"]
            #[doc = "contact. On some devices, a compositor may not consider a tool in"]
            #[doc = "logical contact until a minimum physical pressure threshold is"]
            #[doc = "exceeded."]
            async fn down(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.down()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 8u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the tablet tool stops making contact with the surface of"]
            #[doc = "the tablet, or when the tablet tool moves out of the input region"]
            #[doc = "and the compositor grab (if any) is dismissed."]
            #[doc = ""]
            #[doc = "If the tablet tool moves out of the input region while in contact"]
            #[doc = "with the surface of the tablet and the compositor does not have an"]
            #[doc = "ongoing grab on the surface, the client owning said region will"]
            #[doc = "receive a wp_tablet.up event, followed by a wp_tablet.proximity_out"]
            #[doc = "event and a wp_tablet.frame event. If the compositor has an ongoing"]
            #[doc = "grab on this device, this event sequence is sent whenever the grab"]
            #[doc = "is dismissed in the future."]
            #[doc = ""]
            #[doc = "Note that this event describes logical contact, not physical"]
            #[doc = "contact. On some devices, a compositor may not consider a tool out"]
            #[doc = "of logical contact until physical pressure falls below a specific"]
            #[doc = "threshold."]
            async fn up(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.up()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 9u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever a tablet tool moves."]
            async fn motion(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: crate::wire::Fixed,
                y: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.motion()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fixed(x)
                    .put_fixed(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 10u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the pressure axis on a tool changes. The value of this"]
            #[doc = "event is normalized to a value between 0 and 65535."]
            #[doc = ""]
            #[doc = "Note that pressure may be nonzero even when a tool is not in logical"]
            #[doc = "contact. See the down and up events for more details."]
            async fn pressure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                pressure: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.pressure()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(pressure)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 11u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the distance axis on a tool changes. The value of this"]
            #[doc = "event is normalized to a value between 0 and 65535."]
            #[doc = ""]
            #[doc = "Note that distance may be nonzero even when a tool is not in logical"]
            #[doc = "contact. See the down and up events for more details."]
            async fn distance(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                distance: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.distance()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(distance)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 12u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever one or both of the tilt axes on a tool change. Each tilt"]
            #[doc = "value is in degrees, relative to the z-axis of the tablet."]
            #[doc = "The angle is positive when the top of a tool tilts along the"]
            #[doc = "positive x or y axis."]
            async fn tilt(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tilt_x: crate::wire::Fixed,
                tilt_y: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.tilt()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fixed(tilt_x)
                    .put_fixed(tilt_y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 13u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the z-rotation axis on the tool changes. The"]
            #[doc = "rotation value is in degrees clockwise from the tool's"]
            #[doc = "logical neutral position."]
            async fn rotation(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                degrees: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.rotation()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fixed(degrees)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 14u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the slider position on the tool changes. The"]
            #[doc = "value is normalized between -65535 and 65535, with 0 as the logical"]
            #[doc = "neutral position of the slider."]
            #[doc = ""]
            #[doc = "The slider is available on e.g. the Wacom Airbrush tool."]
            async fn slider(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                position: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.slider()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(position).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 15u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the wheel on the tool emits an event. This event"]
            #[doc = "contains two values for the same axis change. The degrees value is"]
            #[doc = "in the same orientation as the wl_pointer.vertical_scroll axis. The"]
            #[doc = "clicks value is in discrete logical clicks of the mouse wheel. This"]
            #[doc = "value may be zero if the movement of the wheel was less"]
            #[doc = "than one logical click."]
            #[doc = ""]
            #[doc = "Clients should choose either value and avoid mixing degrees and"]
            #[doc = "clicks. The compositor may accumulate values smaller than a logical"]
            #[doc = "click and emulate click events when a certain threshold is met."]
            #[doc = "Thus, wl_tablet_tool.wheel events with non-zero clicks values may"]
            #[doc = "have different degrees values."]
            async fn wheel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                degrees: crate::wire::Fixed,
                clicks: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.wheel()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fixed(degrees)
                    .put_int(clicks)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 16u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever a button on the tool is pressed or released."]
            #[doc = ""]
            #[doc = "If a button is held down when the tool moves in or out of proximity,"]
            #[doc = "button events are generated by the compositor. See"]
            #[doc = "wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for"]
            #[doc = "details."]
            async fn button(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                button: u32,
                state: ButtonState,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.button()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(button)
                    .put_uint(state as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 17u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Marks the end of a series of axis and/or button updates from the"]
            #[doc = "tablet. The Wayland protocol requires axis updates to be sent"]
            #[doc = "sequentially, however all events within a frame should be considered"]
            #[doc = "one hardware event."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.frame()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(time).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 18u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "The wp_tablet interface represents one graphics tablet device. The"]
    #[doc = "tablet interface itself does not generate events; all events are"]
    #[doc = "generated by wp_tablet_tool objects when in proximity above a tablet."]
    #[doc = ""]
    #[doc = "A tablet has a number of static characteristics, e.g. device name and"]
    #[doc = "pid/vid. These capabilities are sent in an event sequence after the"]
    #[doc = "wp_tablet_seat.tablet_added event. This initial event sequence is"]
    #[doc = "terminated by a wp_tablet.done event."]
    pub mod zwp_tablet_v2 {
        #[doc = "Trait to implement the zwp_tablet_v2 interface. See the module level documentation for more info"]
        pub trait ZwpTabletV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This destroys the client's resource for this tablet object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "A descriptive name for the tablet device."]
            #[doc = ""]
            #[doc = "If the device has no descriptive name, this event is not sent."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet.done event."]
            async fn name(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v2#{}.name()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(name))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The USB vendor and product IDs for the tablet device."]
            #[doc = ""]
            #[doc = "If the device has no USB vendor/product ID, this event is not sent."]
            #[doc = "This can happen for virtual devices or non-USB devices, for instance."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet.done event."]
            async fn id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                vid: u32,
                pid: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v2#{}.id()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(vid)
                    .put_uint(pid)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "A system-specific device path that indicates which device is behind"]
            #[doc = "this wp_tablet. This information may be used to gather additional"]
            #[doc = "information about the device, e.g. through libwacom."]
            #[doc = ""]
            #[doc = "A device may have more than one device path. If so, multiple"]
            #[doc = "wp_tablet.path events are sent. A device may be emulated and not"]
            #[doc = "have a device path, and in that case this event will not be sent."]
            #[doc = ""]
            #[doc = "The format of the path is unspecified, it may be a device node, a"]
            #[doc = "sysfs path, or some other identifier. It is up to the client to"]
            #[doc = "identify the string provided."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet.done event."]
            async fn path(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                path: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v2#{}.path()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(path))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent immediately to signal the end of the initial"]
            #[doc = "burst of descriptive events. A client may consider the static"]
            #[doc = "description of the tablet to be complete and finalize initialization"]
            #[doc = "of the tablet."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v2#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent when the tablet has been removed from the system. When a tablet"]
            #[doc = "is removed, some tools may be removed."]
            #[doc = ""]
            #[doc = "When this event is received, the client must wp_tablet.destroy"]
            #[doc = "the object."]
            async fn removed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v2#{}.removed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A circular interaction area, such as the touch ring on the Wacom Intuos"]
    #[doc = "Pro series tablets."]
    #[doc = ""]
    #[doc = "Events on a ring are logically grouped by the wl_tablet_pad_ring.frame"]
    #[doc = "event."]
    pub mod zwp_tablet_pad_ring_v2 {
        #[doc = "Describes the source types for ring events. This indicates to the"]
        #[doc = "client how a ring event was physically generated; a client may"]
        #[doc = "adjust the user interface accordingly. For example, events"]
        #[doc = "from a \"finger\" source may trigger kinetic scrolling."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Source {
            #[doc = "finger"]
            Finger = 1u32,
        }
        impl TryFrom<u32> for Source {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::Finger),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwp_tablet_pad_ring_v2 interface. See the module level documentation for more info"]
        pub trait ZwpTabletPadRingV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_ring_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_pad_ring_v2#{}.set_feedback()", object.id);
                        self.set_feedback(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_pad_ring_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Request that the compositor use the provided feedback string"]
            #[doc = "associated with this ring. This request should be issued immediately"]
            #[doc = "after a wp_tablet_pad_group.mode_switch event from the corresponding"]
            #[doc = "group is received, or whenever the ring is mapped to a different"]
            #[doc = "action. See wp_tablet_pad_group.mode_switch for more details."]
            #[doc = ""]
            #[doc = "Clients are encouraged to provide context-aware descriptions for"]
            #[doc = "the actions associated with the ring; compositors may use this"]
            #[doc = "information to offer visual feedback about the button layout"]
            #[doc = "(eg. on-screen displays)."]
            #[doc = ""]
            #[doc = "The provided string 'description' is a UTF-8 encoded string to be"]
            #[doc = "associated with this ring, and is considered user-visible; general"]
            #[doc = "internationalization rules apply."]
            #[doc = ""]
            #[doc = "The serial argument will be that of the last"]
            #[doc = "wp_tablet_pad_group.mode_switch event received for the group of this"]
            #[doc = "ring. Requests providing other serials than the most recent one will be"]
            #[doc = "ignored."]
            async fn set_feedback(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                description: String,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This destroys the client's resource for this ring object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Source information for ring events."]
            #[doc = ""]
            #[doc = "This event does not occur on its own. It is sent before a"]
            #[doc = "wp_tablet_pad_ring.frame event and carries the source information"]
            #[doc = "for all events within that frame."]
            #[doc = ""]
            #[doc = "The source specifies how this event was generated. If the source is"]
            #[doc = "wp_tablet_pad_ring.source.finger, a wp_tablet_pad_ring.stop event"]
            #[doc = "will be sent when the user lifts the finger off the device."]
            #[doc = ""]
            #[doc = "This event is optional. If the source is unknown for an interaction,"]
            #[doc = "no event is sent."]
            async fn source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: Source,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_ring_v2#{}.source()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(source as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the angle on a ring changes."]
            #[doc = ""]
            #[doc = "The angle is provided in degrees clockwise from the logical"]
            #[doc = "north of the ring in the pad's current rotation."]
            async fn angle(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                degrees: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_ring_v2#{}.angle()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fixed(degrees)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Stop notification for ring events."]
            #[doc = ""]
            #[doc = "For some wp_tablet_pad_ring.source types, a wp_tablet_pad_ring.stop"]
            #[doc = "event is sent to notify a client that the interaction with the ring"]
            #[doc = "has terminated. This enables the client to implement kinetic scrolling."]
            #[doc = "See the wp_tablet_pad_ring.source documentation for information on"]
            #[doc = "when this event may be generated."]
            #[doc = ""]
            #[doc = "Any wp_tablet_pad_ring.angle events with the same source after this"]
            #[doc = "event should be considered as the start of a new interaction."]
            async fn stop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_ring_v2#{}.stop()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Indicates the end of a set of ring events that logically belong"]
            #[doc = "together. A client is expected to accumulate the data in all events"]
            #[doc = "within the frame before proceeding."]
            #[doc = ""]
            #[doc = "All wp_tablet_pad_ring events before a wp_tablet_pad_ring.frame event belong"]
            #[doc = "logically together. For example, on termination of a finger interaction"]
            #[doc = "on a ring the compositor will send a wp_tablet_pad_ring.source event,"]
            #[doc = "a wp_tablet_pad_ring.stop event and a wp_tablet_pad_ring.frame event."]
            #[doc = ""]
            #[doc = "A wp_tablet_pad_ring.frame event is sent for every logical event"]
            #[doc = "group, even if the group only contains a single wp_tablet_pad_ring"]
            #[doc = "event. Specifically, a client may get a sequence: angle, frame,"]
            #[doc = "angle, frame, etc."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_ring_v2#{}.frame()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(time).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A linear interaction area, such as the strips found in Wacom Cintiq"]
    #[doc = "models."]
    #[doc = ""]
    #[doc = "Events on a strip are logically grouped by the wl_tablet_pad_strip.frame"]
    #[doc = "event."]
    pub mod zwp_tablet_pad_strip_v2 {
        #[doc = "Describes the source types for strip events. This indicates to the"]
        #[doc = "client how a strip event was physically generated; a client may"]
        #[doc = "adjust the user interface accordingly. For example, events"]
        #[doc = "from a \"finger\" source may trigger kinetic scrolling."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Source {
            #[doc = "finger"]
            Finger = 1u32,
        }
        impl TryFrom<u32> for Source {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::Finger),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwp_tablet_pad_strip_v2 interface. See the module level documentation for more info"]
        pub trait ZwpTabletPadStripV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_strip_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_pad_strip_v2#{}.set_feedback()", object.id);
                        self.set_feedback(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_pad_strip_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Requests the compositor to use the provided feedback string"]
            #[doc = "associated with this strip. This request should be issued immediately"]
            #[doc = "after a wp_tablet_pad_group.mode_switch event from the corresponding"]
            #[doc = "group is received, or whenever the strip is mapped to a different"]
            #[doc = "action. See wp_tablet_pad_group.mode_switch for more details."]
            #[doc = ""]
            #[doc = "Clients are encouraged to provide context-aware descriptions for"]
            #[doc = "the actions associated with the strip, and compositors may use this"]
            #[doc = "information to offer visual feedback about the button layout"]
            #[doc = "(eg. on-screen displays)."]
            #[doc = ""]
            #[doc = "The provided string 'description' is a UTF-8 encoded string to be"]
            #[doc = "associated with this ring, and is considered user-visible; general"]
            #[doc = "internationalization rules apply."]
            #[doc = ""]
            #[doc = "The serial argument will be that of the last"]
            #[doc = "wp_tablet_pad_group.mode_switch event received for the group of this"]
            #[doc = "strip. Requests providing other serials than the most recent one will be"]
            #[doc = "ignored."]
            async fn set_feedback(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                description: String,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This destroys the client's resource for this strip object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Source information for strip events."]
            #[doc = ""]
            #[doc = "This event does not occur on its own. It is sent before a"]
            #[doc = "wp_tablet_pad_strip.frame event and carries the source information"]
            #[doc = "for all events within that frame."]
            #[doc = ""]
            #[doc = "The source specifies how this event was generated. If the source is"]
            #[doc = "wp_tablet_pad_strip.source.finger, a wp_tablet_pad_strip.stop event"]
            #[doc = "will be sent when the user lifts their finger off the device."]
            #[doc = ""]
            #[doc = "This event is optional. If the source is unknown for an interaction,"]
            #[doc = "no event is sent."]
            async fn source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: Source,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_strip_v2#{}.source()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(source as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the position on a strip changes."]
            #[doc = ""]
            #[doc = "The position is normalized to a range of [0, 65535], the 0-value"]
            #[doc = "represents the top-most and/or left-most position of the strip in"]
            #[doc = "the pad's current rotation."]
            async fn position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                position: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_strip_v2#{}.position()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(position)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Stop notification for strip events."]
            #[doc = ""]
            #[doc = "For some wp_tablet_pad_strip.source types, a wp_tablet_pad_strip.stop"]
            #[doc = "event is sent to notify a client that the interaction with the strip"]
            #[doc = "has terminated. This enables the client to implement kinetic"]
            #[doc = "scrolling. See the wp_tablet_pad_strip.source documentation for"]
            #[doc = "information on when this event may be generated."]
            #[doc = ""]
            #[doc = "Any wp_tablet_pad_strip.position events with the same source after this"]
            #[doc = "event should be considered as the start of a new interaction."]
            async fn stop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_strip_v2#{}.stop()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Indicates the end of a set of events that represent one logical"]
            #[doc = "hardware strip event. A client is expected to accumulate the data"]
            #[doc = "in all events within the frame before proceeding."]
            #[doc = ""]
            #[doc = "All wp_tablet_pad_strip events before a wp_tablet_pad_strip.frame event belong"]
            #[doc = "logically together. For example, on termination of a finger interaction"]
            #[doc = "on a strip the compositor will send a wp_tablet_pad_strip.source event,"]
            #[doc = "a wp_tablet_pad_strip.stop event and a wp_tablet_pad_strip.frame"]
            #[doc = "event."]
            #[doc = ""]
            #[doc = "A wp_tablet_pad_strip.frame event is sent for every logical event"]
            #[doc = "group, even if the group only contains a single wp_tablet_pad_strip"]
            #[doc = "event. Specifically, a client may get a sequence: position, frame,"]
            #[doc = "position, frame, etc."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_strip_v2#{}.frame()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(time).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A pad group describes a distinct (sub)set of buttons, rings and strips"]
    #[doc = "present in the tablet. The criteria of this grouping is usually positional,"]
    #[doc = "eg. if a tablet has buttons on the left and right side, 2 groups will be"]
    #[doc = "presented. The physical arrangement of groups is undisclosed and may"]
    #[doc = "change on the fly."]
    #[doc = ""]
    #[doc = "Pad groups will announce their features during pad initialization. Between"]
    #[doc = "the corresponding wp_tablet_pad.group event and wp_tablet_pad_group.done, the"]
    #[doc = "pad group will announce the buttons, rings and strips contained in it,"]
    #[doc = "plus the number of supported modes."]
    #[doc = ""]
    #[doc = "Modes are a mechanism to allow multiple groups of actions for every element"]
    #[doc = "in the pad group. The number of groups and available modes in each is"]
    #[doc = "persistent across device plugs. The current mode is user-switchable, it"]
    #[doc = "will be announced through the wp_tablet_pad_group.mode_switch event both"]
    #[doc = "whenever it is switched, and after wp_tablet_pad.enter."]
    #[doc = ""]
    #[doc = "The current mode logically applies to all elements in the pad group,"]
    #[doc = "although it is at clients' discretion whether to actually perform different"]
    #[doc = "actions, and/or issue the respective .set_feedback requests to notify the"]
    #[doc = "compositor. See the wp_tablet_pad_group.mode_switch event for more details."]
    pub mod zwp_tablet_pad_group_v2 {
        #[doc = "Trait to implement the zwp_tablet_pad_group_v2 interface. See the module level documentation for more info"]
        pub trait ZwpTabletPadGroupV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_group_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_pad_group_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the wp_tablet_pad_group object. Objects created from this object"]
            #[doc = "are unaffected and should be destroyed separately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sent on wp_tablet_pad_group initialization to announce the available"]
            #[doc = "buttons in the group. Button indices start at 0, a button may only be"]
            #[doc = "in one group at a time."]
            #[doc = ""]
            #[doc = "This event is first sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad_group.done event."]
            #[doc = ""]
            #[doc = "Some buttons are reserved by the compositor. These buttons may not be"]
            #[doc = "assigned to any wp_tablet_pad_group. Compositors may broadcast this"]
            #[doc = "event in the case of changes to the mapping of these reserved buttons."]
            #[doc = "If the compositor happens to reserve all buttons in a group, this event"]
            #[doc = "will be sent with an empty array."]
            async fn buttons(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buttons: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.buttons()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_array(buttons)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent on wp_tablet_pad_group initialization to announce available rings."]
            #[doc = "One event is sent for each ring available on this pad group."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad_group.done event."]
            async fn ring(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                ring: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.ring()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(ring))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent on wp_tablet_pad initialization to announce available strips."]
            #[doc = "One event is sent for each strip available on this pad group."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad_group.done event."]
            async fn strip(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                strip: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.strip()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(strip))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent on wp_tablet_pad_group initialization to announce that the pad"]
            #[doc = "group may switch between modes. A client may use a mode to store a"]
            #[doc = "specific configuration for buttons, rings and strips and use the"]
            #[doc = "wl_tablet_pad_group.mode_switch event to toggle between these"]
            #[doc = "configurations. Mode indices start at 0."]
            #[doc = ""]
            #[doc = "Switching modes is compositor-dependent. See the"]
            #[doc = "wp_tablet_pad_group.mode_switch event for more details."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad_group.done event. This event is only sent when more than"]
            #[doc = "more than one mode is available."]
            async fn modes(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                modes: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.modes()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(modes).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent immediately to signal the end of the initial"]
            #[doc = "burst of descriptive events. A client may consider the static"]
            #[doc = "description of the tablet to be complete and finalize initialization"]
            #[doc = "of the tablet group."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notification that the mode was switched."]
            #[doc = ""]
            #[doc = "A mode applies to all buttons, rings and strips in a group"]
            #[doc = "simultaneously, but a client is not required to assign different actions"]
            #[doc = "for each mode. For example, a client may have mode-specific button"]
            #[doc = "mappings but map the ring to vertical scrolling in all modes. Mode"]
            #[doc = "indices start at 0."]
            #[doc = ""]
            #[doc = "Switching modes is compositor-dependent. The compositor may provide"]
            #[doc = "visual cues to the client about the mode, e.g. by toggling LEDs on"]
            #[doc = "the tablet device. Mode-switching may be software-controlled or"]
            #[doc = "controlled by one or more physical buttons. For example, on a Wacom"]
            #[doc = "Intuos Pro, the button inside the ring may be assigned to switch"]
            #[doc = "between modes."]
            #[doc = ""]
            #[doc = "The compositor will also send this event after wp_tablet_pad.enter on"]
            #[doc = "each group in order to notify of the current mode. Groups that only"]
            #[doc = "feature one mode will use mode=0 when emitting this event."]
            #[doc = ""]
            #[doc = "If a button action in the new mode differs from the action in the"]
            #[doc = "previous mode, the client should immediately issue a"]
            #[doc = "wp_tablet_pad.set_feedback request for each changed button."]
            #[doc = ""]
            #[doc = "If a ring or strip action in the new mode differs from the action"]
            #[doc = "in the previous mode, the client should immediately issue a"]
            #[doc = "wp_tablet_ring.set_feedback or wp_tablet_strip.set_feedback request"]
            #[doc = "for each changed ring or strip."]
            async fn mode_switch(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                serial: u32,
                mode: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.mode_switch()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_uint(serial)
                    .put_uint(mode)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A pad device is a set of buttons, rings and strips"]
    #[doc = "usually physically present on the tablet device itself. Some"]
    #[doc = "exceptions exist where the pad device is physically detached, e.g. the"]
    #[doc = "Wacom ExpressKey Remote."]
    #[doc = ""]
    #[doc = "Pad devices have no axes that control the cursor and are generally"]
    #[doc = "auxiliary devices to the tool devices used on the tablet surface."]
    #[doc = ""]
    #[doc = "A pad device has a number of static characteristics, e.g. the number"]
    #[doc = "of rings. These capabilities are sent in an event sequence after the"]
    #[doc = "wp_tablet_seat.pad_added event before any actual events from this pad."]
    #[doc = "This initial event sequence is terminated by a wp_tablet_pad.done"]
    #[doc = "event."]
    #[doc = ""]
    #[doc = "All pad features (buttons, rings and strips) are logically divided into"]
    #[doc = "groups and all pads have at least one group. The available groups are"]
    #[doc = "notified through the wp_tablet_pad.group event; the compositor will"]
    #[doc = "emit one event per group before emitting wp_tablet_pad.done."]
    #[doc = ""]
    #[doc = "Groups may have multiple modes. Modes allow clients to map multiple"]
    #[doc = "actions to a single pad feature. Only one mode can be active per group,"]
    #[doc = "although different groups may have different active modes."]
    pub mod zwp_tablet_pad_v2 {
        #[doc = "Describes the physical state of a button that caused the button"]
        #[doc = "event."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ButtonState {
            #[doc = "the button is not pressed"]
            Released = 0u32,
            #[doc = "the button is pressed"]
            Pressed = 1u32,
        }
        impl TryFrom<u32> for ButtonState {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Released),
                    1u32 => Ok(Self::Pressed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwp_tablet_pad_v2 interface. See the module level documentation for more info"]
        pub trait ZwpTabletPadV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_tablet_pad_v2#{}.set_feedback()", object.id);
                        self.set_feedback(
                            object,
                            client,
                            message.uint()?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_tablet_pad_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Requests the compositor to use the provided feedback string"]
            #[doc = "associated with this button. This request should be issued immediately"]
            #[doc = "after a wp_tablet_pad_group.mode_switch event from the corresponding"]
            #[doc = "group is received, or whenever a button is mapped to a different"]
            #[doc = "action. See wp_tablet_pad_group.mode_switch for more details."]
            #[doc = ""]
            #[doc = "Clients are encouraged to provide context-aware descriptions for"]
            #[doc = "the actions associated with each button, and compositors may use"]
            #[doc = "this information to offer visual feedback on the button layout"]
            #[doc = "(e.g. on-screen displays)."]
            #[doc = ""]
            #[doc = "Button indices start at 0. Setting the feedback string on a button"]
            #[doc = "that is reserved by the compositor (i.e. not belonging to any"]
            #[doc = "wp_tablet_pad_group) does not generate an error but the compositor"]
            #[doc = "is free to ignore the request."]
            #[doc = ""]
            #[doc = "The provided string 'description' is a UTF-8 encoded string to be"]
            #[doc = "associated with this ring, and is considered user-visible; general"]
            #[doc = "internationalization rules apply."]
            #[doc = ""]
            #[doc = "The serial argument will be that of the last"]
            #[doc = "wp_tablet_pad_group.mode_switch event received for the group of this"]
            #[doc = "button. Requests providing other serials than the most recent one will"]
            #[doc = "be ignored."]
            async fn set_feedback(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                button: u32,
                description: String,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the wp_tablet_pad object. Objects created from this object"]
            #[doc = "are unaffected and should be destroyed separately."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sent on wp_tablet_pad initialization to announce available groups."]
            #[doc = "One event is sent for each pad group available."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad.done event. At least one group will be announced."]
            async fn group(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                pad_group: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.group()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(pad_group))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "A system-specific device path that indicates which device is behind"]
            #[doc = "this wp_tablet_pad. This information may be used to gather additional"]
            #[doc = "information about the device, e.g. through libwacom."]
            #[doc = ""]
            #[doc = "The format of the path is unspecified, it may be a device node, a"]
            #[doc = "sysfs path, or some other identifier. It is up to the client to"]
            #[doc = "identify the string provided."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad.done event."]
            async fn path(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                path: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.path()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(path))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent on wp_tablet_pad initialization to announce the available"]
            #[doc = "buttons."]
            #[doc = ""]
            #[doc = "This event is sent in the initial burst of events before the"]
            #[doc = "wp_tablet_pad.done event. This event is only sent when at least one"]
            #[doc = "button is available."]
            async fn buttons(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buttons: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.buttons()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(buttons).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event signals the end of the initial burst of descriptive"]
            #[doc = "events. A client may consider the static description of the pad to"]
            #[doc = "be complete and finalize initialization of the pad."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent whenever the physical state of a button changes."]
            async fn button(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                button: u32,
                state: ButtonState,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.button()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_uint(button)
                    .put_uint(state as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notification that this pad is focused on the specified surface."]
            async fn enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                tablet: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.enter()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(tablet))
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notification that this pad is no longer focused on the specified"]
            #[doc = "surface."]
            async fn leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.leave()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 6u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent when the pad has been removed from the system. When a tablet"]
            #[doc = "is removed its pad(s) will be removed too."]
            #[doc = ""]
            #[doc = "When this event is received, the client must destroy all rings, strips"]
            #[doc = "and groups that were offered by this pad, and issue wp_tablet_pad.destroy"]
            #[doc = "the pad itself."]
            async fn removed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.removed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 7u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod text_input_unstable_v1 {
    #[doc = "An object used for text input. Adds support for text input and input"]
    #[doc = "methods to applications. A text_input object is created from a"]
    #[doc = "wl_text_input_manager and corresponds typically to a text entry in an"]
    #[doc = "application."]
    #[doc = ""]
    #[doc = "Requests are used to activate/deactivate the text_input object and set"]
    #[doc = "state information like surrounding and selected text or the content type."]
    #[doc = "The information about entered text is sent to the text_input object via"]
    #[doc = "the pre-edit and commit events. Using this interface removes the need"]
    #[doc = "for applications to directly process hardware key events and compose text"]
    #[doc = "out of them."]
    #[doc = ""]
    #[doc = "Text is generally UTF-8 encoded, indices and lengths are in bytes."]
    #[doc = ""]
    #[doc = "Serials are used to synchronize the state between the text input and"]
    #[doc = "an input method. New serials are sent by the text input in the"]
    #[doc = "commit_state request and are used by the input method to indicate"]
    #[doc = "the known text input state in events like preedit_string, commit_string,"]
    #[doc = "and keysym. The text input can then ignore events from the input method"]
    #[doc = "which are based on an outdated state (for example after a reset)."]
    #[doc = ""]
    #[doc = "Warning! The protocol described in this file is experimental and"]
    #[doc = "backward incompatible changes may be made. Backward compatible changes"]
    #[doc = "may be added together with the corresponding interface version bump."]
    #[doc = "Backward incompatible changes are done by bumping the version number in"]
    #[doc = "the protocol and interface names and resetting the interface version."]
    #[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
    #[doc = "version number in the protocol and interface names are removed and the"]
    #[doc = "interface version number is reset."]
    pub mod zwp_text_input_v1 {
        bitflags::bitflags! { # [doc = "Content hint is a bitmask to allow to modify the behavior of the text"] # [doc = "input."] # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct ContentHint : u32 { # [doc = "no special behaviour"] const None = 0u32 ; # [doc = "auto completion, correction and capitalization"] const Default = 7u32 ; # [doc = "hidden and sensitive text"] const Password = 192u32 ; # [doc = "suggest word completions"] const AutoCompletion = 1u32 ; # [doc = "suggest word corrections"] const AutoCorrection = 2u32 ; # [doc = "switch to uppercase letters at the start of a sentence"] const AutoCapitalization = 4u32 ; # [doc = "prefer lowercase letters"] const Lowercase = 8u32 ; # [doc = "prefer uppercase letters"] const Uppercase = 16u32 ; # [doc = "prefer casing for titles and headings (can be language dependent)"] const Titlecase = 32u32 ; # [doc = "characters should be hidden"] const HiddenText = 64u32 ; # [doc = "typed text should not be stored"] const SensitiveData = 128u32 ; # [doc = "just latin characters should be entered"] const Latin = 256u32 ; # [doc = "the text input is multiline"] const Multiline = 512u32 ; } }
        impl TryFrom<u32> for ContentHint {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "The content purpose allows to specify the primary purpose of a text"]
        #[doc = "input."]
        #[doc = ""]
        #[doc = "This allows an input method to show special purpose input panels with"]
        #[doc = "extra characters or to disallow some characters."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ContentPurpose {
            #[doc = "default input, allowing all characters"]
            Normal = 0u32,
            #[doc = "allow only alphabetic characters"]
            Alpha = 1u32,
            #[doc = "allow only digits"]
            Digits = 2u32,
            #[doc = "input a number (including decimal separator and sign)"]
            Number = 3u32,
            #[doc = "input a phone number"]
            Phone = 4u32,
            #[doc = "input an URL"]
            Url = 5u32,
            #[doc = "input an email address"]
            Email = 6u32,
            #[doc = "input a name of a person"]
            Name = 7u32,
            #[doc = "input a password (combine with password or sensitive_data hint)"]
            Password = 8u32,
            #[doc = "input a date"]
            Date = 9u32,
            #[doc = "input a time"]
            Time = 10u32,
            #[doc = "input a date and time"]
            Datetime = 11u32,
            #[doc = "input for a terminal"]
            Terminal = 12u32,
        }
        impl TryFrom<u32> for ContentPurpose {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Normal),
                    1u32 => Ok(Self::Alpha),
                    2u32 => Ok(Self::Digits),
                    3u32 => Ok(Self::Number),
                    4u32 => Ok(Self::Phone),
                    5u32 => Ok(Self::Url),
                    6u32 => Ok(Self::Email),
                    7u32 => Ok(Self::Name),
                    8u32 => Ok(Self::Password),
                    9u32 => Ok(Self::Date),
                    10u32 => Ok(Self::Time),
                    11u32 => Ok(Self::Datetime),
                    12u32 => Ok(Self::Terminal),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum PreeditStyle {
            #[doc = "default style for composing text"]
            Default = 0u32,
            #[doc = "style should be the same as in non-composing text"]
            None = 1u32,
            Active = 2u32,
            Inactive = 3u32,
            Highlight = 4u32,
            Underline = 5u32,
            Selection = 6u32,
            Incorrect = 7u32,
        }
        impl TryFrom<u32> for PreeditStyle {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Default),
                    1u32 => Ok(Self::None),
                    2u32 => Ok(Self::Active),
                    3u32 => Ok(Self::Inactive),
                    4u32 => Ok(Self::Highlight),
                    5u32 => Ok(Self::Underline),
                    6u32 => Ok(Self::Selection),
                    7u32 => Ok(Self::Incorrect),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum TextDirection {
            #[doc = "automatic text direction based on text and language"]
            Auto = 0u32,
            #[doc = "left-to-right"]
            Ltr = 1u32,
            #[doc = "right-to-left"]
            Rtl = 2u32,
        }
        impl TryFrom<u32> for TextDirection {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Auto),
                    1u32 => Ok(Self::Ltr),
                    2u32 => Ok(Self::Rtl),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwp_text_input_v1 interface. See the module level documentation for more info"]
        pub trait ZwpTextInputV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_text_input_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_text_input_v1#{}.activate()", object.id);
                        self.activate(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwp_text_input_v1#{}.deactivate()", object.id);
                        self.deactivate(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zwp_text_input_v1#{}.show_input_panel()", object.id);
                        self.show_input_panel(object, client).await
                    }
                    3u16 => {
                        tracing::debug!("zwp_text_input_v1#{}.hide_input_panel()", object.id);
                        self.hide_input_panel(object, client).await
                    }
                    4u16 => {
                        tracing::debug!("zwp_text_input_v1#{}.reset()", object.id);
                        self.reset(object, client).await
                    }
                    5u16 => {
                        tracing::debug!("zwp_text_input_v1#{}.set_surrounding_text()", object.id);
                        self.set_surrounding_text(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    6u16 => {
                        tracing::debug!("zwp_text_input_v1#{}.set_content_type()", object.id);
                        self.set_content_type(
                            object,
                            client,
                            message.uint()?.try_into()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    7u16 => {
                        tracing::debug!("zwp_text_input_v1#{}.set_cursor_rectangle()", object.id);
                        self.set_cursor_rectangle(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    8u16 => {
                        tracing::debug!("zwp_text_input_v1#{}.set_preferred_language()", object.id);
                        self.set_preferred_language(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    9u16 => {
                        tracing::debug!("zwp_text_input_v1#{}.commit_state()", object.id);
                        self.commit_state(object, client, message.uint()?).await
                    }
                    10u16 => {
                        tracing::debug!("zwp_text_input_v1#{}.invoke_action()", object.id);
                        self.invoke_action(object, client, message.uint()?, message.uint()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Requests the text_input object to be activated (typically when the"]
            #[doc = "text entry gets focus)."]
            #[doc = ""]
            #[doc = "The seat argument is a wl_seat which maintains the focus for this"]
            #[doc = "activation. The surface argument is a wl_surface assigned to the"]
            #[doc = "text_input object and tracked for focus lost. The enter event"]
            #[doc = "is emitted on successful activation."]
            async fn activate(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Requests the text_input object to be deactivated (typically when the"]
            #[doc = "text entry lost focus). The seat argument is a wl_seat which was used"]
            #[doc = "for activation."]
            async fn deactivate(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Requests input panels (virtual keyboard) to show."]
            async fn show_input_panel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Requests input panels (virtual keyboard) to hide."]
            async fn hide_input_panel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Should be called by an editor widget when the input state should be"]
            #[doc = "reset, for example after the text was changed outside of the normal"]
            #[doc = "input method flow."]
            async fn reset(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the plain surrounding text around the input position. Text is"]
            #[doc = "UTF-8 encoded. Cursor is the byte offset within the"]
            #[doc = "surrounding text. Anchor is the byte offset of the"]
            #[doc = "selection anchor within the surrounding text. If there is no selected"]
            #[doc = "text anchor, then it is the same as cursor."]
            async fn set_surrounding_text(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                text: String,
                cursor: u32,
                anchor: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the content purpose and content hint. While the purpose is the"]
            #[doc = "basic purpose of an input field, the hint flags allow to modify some"]
            #[doc = "of the behavior."]
            #[doc = ""]
            #[doc = "When no content type is explicitly set, a normal content purpose with"]
            #[doc = "default hints (auto completion, auto correction, auto capitalization)"]
            #[doc = "should be assumed."]
            async fn set_content_type(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                hint: ContentHint,
                purpose: ContentPurpose,
            ) -> crate::server::Result<()>;
            async fn set_cursor_rectangle(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Sets a specific language. This allows for example a virtual keyboard to"]
            #[doc = "show a language specific layout. The \"language\" argument is an RFC-3066"]
            #[doc = "format language tag."]
            #[doc = ""]
            #[doc = "It could be used for example in a word processor to indicate the"]
            #[doc = "language of the currently edited document or in an instant message"]
            #[doc = "application which tracks languages of contacts."]
            async fn set_preferred_language(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                language: String,
            ) -> crate::server::Result<()>;
            async fn commit_state(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()>;
            async fn invoke_action(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                button: u32,
                index: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Notify the text_input object when it received focus. Typically in"]
            #[doc = "response to an activate request."]
            async fn enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.enter()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notify the text_input object when it lost focus. Either in response"]
            #[doc = "to a deactivate request or when the assigned surface lost focus or was"]
            #[doc = "destroyed."]
            async fn leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.leave()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Transfer an array of 0-terminated modifier names. The position in"]
            #[doc = "the array is the index of the modifier as used in the modifiers"]
            #[doc = "bitmask in the keysym event."]
            async fn modifiers_map(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                map: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.modifiers_map()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_array(map).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notify when the visibility state of the input panel changed."]
            async fn input_panel_state(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                state: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.input_panel_state()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(state).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notify when a new composing text (pre-edit) should be set around the"]
            #[doc = "current cursor position. Any previously set composing text should"]
            #[doc = "be removed."]
            #[doc = ""]
            #[doc = "The commit text can be used to replace the preedit text on reset"]
            #[doc = "(for example on unfocus)."]
            #[doc = ""]
            #[doc = "The text input should also handle all preedit_style and preedit_cursor"]
            #[doc = "events occurring directly before preedit_string."]
            async fn preedit_string(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                text: String,
                commit: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.preedit_string()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_string(Some(text))
                    .put_string(Some(commit))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sets styling information on composing text. The style is applied for"]
            #[doc = "length bytes from index relative to the beginning of the composing"]
            #[doc = "text (as byte offset). Multiple styles can"]
            #[doc = "be applied to a composing text by sending multiple preedit_styling"]
            #[doc = "events."]
            #[doc = ""]
            #[doc = "This event is handled as part of a following preedit_string event."]
            async fn preedit_styling(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: u32,
                length: u32,
                style: PreeditStyle,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.preedit_styling()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(index)
                    .put_uint(length)
                    .put_uint(style as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sets the cursor position inside the composing text (as byte"]
            #[doc = "offset) relative to the start of the composing text. When index is a"]
            #[doc = "negative number no cursor is shown."]
            #[doc = ""]
            #[doc = "This event is handled as part of a following preedit_string event."]
            async fn preedit_cursor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.preedit_cursor()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(index).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 6u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notify when text should be inserted into the editor widget. The text to"]
            #[doc = "commit could be either just a single character after a key press or the"]
            #[doc = "result of some composing (pre-edit). It could also be an empty text"]
            #[doc = "when some text should be removed (see delete_surrounding_text) or when"]
            #[doc = "the input cursor should be moved (see cursor_position)."]
            #[doc = ""]
            #[doc = "Any previously set composing text should be removed."]
            async fn commit_string(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                text: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.commit_string()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_string(Some(text))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 7u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notify when the cursor or anchor position should be modified."]
            #[doc = ""]
            #[doc = "This event should be handled as part of a following commit_string"]
            #[doc = "event."]
            async fn cursor_position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: i32,
                anchor: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.cursor_position()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(index)
                    .put_int(anchor)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 8u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notify when the text around the current cursor position should be"]
            #[doc = "deleted."]
            #[doc = ""]
            #[doc = "Index is relative to the current cursor (in bytes)."]
            #[doc = "Length is the length of deleted text (in bytes)."]
            #[doc = ""]
            #[doc = "This event should be handled as part of a following commit_string"]
            #[doc = "event."]
            async fn delete_surrounding_text(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: i32,
                length: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_text_input_v1#{}.delete_surrounding_text()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(index)
                    .put_uint(length)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 9u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notify when a key event was sent. Key events should not be used"]
            #[doc = "for normal text input operations, which should be done with"]
            #[doc = "commit_string, delete_surrounding_text, etc. The key event follows"]
            #[doc = "the wl_keyboard key event convention. Sym is an XKB keysym, state a"]
            #[doc = "wl_keyboard key_state. Modifiers are a mask for effective modifiers"]
            #[doc = "(where the modifier indices are set by the modifiers_map event)"]
            async fn keysym(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                sym: u32,
                state: u32,
                modifiers: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.keysym()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(time)
                    .put_uint(sym)
                    .put_uint(state)
                    .put_uint(modifiers)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 10u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sets the language of the input text. The \"language\" argument is an"]
            #[doc = "RFC-3066 format language tag."]
            async fn language(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                language: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.language()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_string(Some(language))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 11u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sets the text direction of input text."]
            #[doc = ""]
            #[doc = "It is mainly needed for showing an input cursor on the correct side of"]
            #[doc = "the editor when there is no input done yet and making sure neutral"]
            #[doc = "direction text is laid out properly."]
            async fn text_direction(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                direction: TextDirection,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.text_direction()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(direction as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 12u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A factory for text_input objects. This object is a global singleton."]
    pub mod zwp_text_input_manager_v1 {
        #[doc = "Trait to implement the zwp_text_input_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZwpTextInputManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_text_input_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwp_text_input_manager_v1#{}.create_text_input()",
                            object.id
                        );
                        self.create_text_input(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Creates a new text_input object."]
            async fn create_text_input(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
}
#[doc = "This protocol allows compositors to act as input methods and to send text"]
#[doc = "to applications. A text input object is used to manage state of what are"]
#[doc = "typically text entry fields in the application."]
#[doc = ""]
#[doc = "This document adheres to the RFC 2119 when using words like \"must\","]
#[doc = "\"should\", \"may\", etc."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and"]
#[doc = "backward incompatible changes may be made. Backward compatible changes"]
#[doc = "may be added together with the corresponding interface version bump."]
#[doc = "Backward incompatible changes are done by bumping the version number in"]
#[doc = "the protocol and interface names and resetting the interface version."]
#[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
#[doc = "version number in the protocol and interface names are removed and the"]
#[doc = "interface version number is reset."]
pub mod text_input_unstable_v3 {
    #[doc = "The zwp_text_input_v3 interface represents text input and input methods"]
    #[doc = "associated with a seat. It provides enter/leave events to follow the"]
    #[doc = "text input focus for a seat."]
    #[doc = ""]
    #[doc = "Requests are used to enable/disable the text-input object and set"]
    #[doc = "state information like surrounding and selected text or the content type."]
    #[doc = "The information about the entered text is sent to the text-input object"]
    #[doc = "via the preedit_string and commit_string events."]
    #[doc = ""]
    #[doc = "Text is valid UTF-8 encoded, indices and lengths are in bytes. Indices"]
    #[doc = "must not point to middle bytes inside a code point: they must either"]
    #[doc = "point to the first byte of a code point or to the end of the buffer."]
    #[doc = "Lengths must be measured between two valid indices."]
    #[doc = ""]
    #[doc = "Focus moving throughout surfaces will result in the emission of"]
    #[doc = "zwp_text_input_v3.enter and zwp_text_input_v3.leave events. The focused"]
    #[doc = "surface must commit zwp_text_input_v3.enable and"]
    #[doc = "zwp_text_input_v3.disable requests as the keyboard focus moves across"]
    #[doc = "editable and non-editable elements of the UI. Those two requests are not"]
    #[doc = "expected to be paired with each other, the compositor must be able to"]
    #[doc = "handle consecutive series of the same request."]
    #[doc = ""]
    #[doc = "State is sent by the state requests (set_surrounding_text,"]
    #[doc = "set_content_type and set_cursor_rectangle) and a commit request. After an"]
    #[doc = "enter event or disable request all state information is invalidated and"]
    #[doc = "needs to be resent by the client."]
    pub mod zwp_text_input_v3 {
        #[doc = "Reason for the change of surrounding text or cursor posision."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ChangeCause {
            #[doc = "input method caused the change"]
            InputMethod = 0u32,
            #[doc = "something else than the input method caused the change"]
            Other = 1u32,
        }
        impl TryFrom<u32> for ChangeCause {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InputMethod),
                    1u32 => Ok(Self::Other),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! { # [doc = "Content hint is a bitmask to allow to modify the behavior of the text"] # [doc = "input."] # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct ContentHint : u32 { # [doc = "no special behavior"] const None = 0u32 ; # [doc = "suggest word completions"] const Completion = 1u32 ; # [doc = "suggest word corrections"] const Spellcheck = 2u32 ; # [doc = "switch to uppercase letters at the start of a sentence"] const AutoCapitalization = 4u32 ; # [doc = "prefer lowercase letters"] const Lowercase = 8u32 ; # [doc = "prefer uppercase letters"] const Uppercase = 16u32 ; # [doc = "prefer casing for titles and headings (can be language dependent)"] const Titlecase = 32u32 ; # [doc = "characters should be hidden"] const HiddenText = 64u32 ; # [doc = "typed text should not be stored"] const SensitiveData = 128u32 ; # [doc = "just Latin characters should be entered"] const Latin = 256u32 ; # [doc = "the text input is multiline"] const Multiline = 512u32 ; } }
        impl TryFrom<u32> for ContentHint {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "The content purpose allows to specify the primary purpose of a text"]
        #[doc = "input."]
        #[doc = ""]
        #[doc = "This allows an input method to show special purpose input panels with"]
        #[doc = "extra characters or to disallow some characters."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ContentPurpose {
            #[doc = "default input, allowing all characters"]
            Normal = 0u32,
            #[doc = "allow only alphabetic characters"]
            Alpha = 1u32,
            #[doc = "allow only digits"]
            Digits = 2u32,
            #[doc = "input a number (including decimal separator and sign)"]
            Number = 3u32,
            #[doc = "input a phone number"]
            Phone = 4u32,
            #[doc = "input an URL"]
            Url = 5u32,
            #[doc = "input an email address"]
            Email = 6u32,
            #[doc = "input a name of a person"]
            Name = 7u32,
            #[doc = "input a password (combine with sensitive_data hint)"]
            Password = 8u32,
            #[doc = "input is a numeric password (combine with sensitive_data hint)"]
            Pin = 9u32,
            #[doc = "input a date"]
            Date = 10u32,
            #[doc = "input a time"]
            Time = 11u32,
            #[doc = "input a date and time"]
            Datetime = 12u32,
            #[doc = "input for a terminal"]
            Terminal = 13u32,
        }
        impl TryFrom<u32> for ContentPurpose {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Normal),
                    1u32 => Ok(Self::Alpha),
                    2u32 => Ok(Self::Digits),
                    3u32 => Ok(Self::Number),
                    4u32 => Ok(Self::Phone),
                    5u32 => Ok(Self::Url),
                    6u32 => Ok(Self::Email),
                    7u32 => Ok(Self::Name),
                    8u32 => Ok(Self::Password),
                    9u32 => Ok(Self::Pin),
                    10u32 => Ok(Self::Date),
                    11u32 => Ok(Self::Time),
                    12u32 => Ok(Self::Datetime),
                    13u32 => Ok(Self::Terminal),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwp_text_input_v3 interface. See the module level documentation for more info"]
        pub trait ZwpTextInputV3: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_text_input_v3";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_text_input_v3#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zwp_text_input_v3#{}.enable()", object.id);
                        self.enable(object, client).await
                    }
                    2u16 => {
                        tracing::debug!("zwp_text_input_v3#{}.disable()", object.id);
                        self.disable(object, client).await
                    }
                    3u16 => {
                        tracing::debug!("zwp_text_input_v3#{}.set_surrounding_text()", object.id);
                        self.set_surrounding_text(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("zwp_text_input_v3#{}.set_text_change_cause()", object.id);
                        self.set_text_change_cause(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    5u16 => {
                        tracing::debug!("zwp_text_input_v3#{}.set_content_type()", object.id);
                        self.set_content_type(
                            object,
                            client,
                            message.uint()?.try_into()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    6u16 => {
                        tracing::debug!("zwp_text_input_v3#{}.set_cursor_rectangle()", object.id);
                        self.set_cursor_rectangle(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    7u16 => {
                        tracing::debug!("zwp_text_input_v3#{}.commit()", object.id);
                        self.commit(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the wp_text_input object. Also disables all surfaces enabled"]
            #[doc = "through this wp_text_input object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Requests text input on the surface previously obtained from the enter"]
            #[doc = "event."]
            #[doc = ""]
            #[doc = "This request must be issued every time the active text input changes"]
            #[doc = "to a new one, including within the current surface. Use"]
            #[doc = "zwp_text_input_v3.disable when there is no longer any input focus on"]
            #[doc = "the current surface."]
            #[doc = ""]
            #[doc = "Clients must not enable more than one text input on the single seat"]
            #[doc = "and should disable the current text input before enabling the new one."]
            #[doc = "At most one instance of text input may be in enabled state per instance,"]
            #[doc = "Requests to enable the another text input when some text input is active"]
            #[doc = "must be ignored by compositor."]
            #[doc = ""]
            #[doc = "This request resets all state associated with previous enable, disable,"]
            #[doc = "set_surrounding_text, set_text_change_cause, set_content_type, and"]
            #[doc = "set_cursor_rectangle requests, as well as the state associated with"]
            #[doc = "preedit_string, commit_string, and delete_surrounding_text events."]
            #[doc = ""]
            #[doc = "The set_surrounding_text, set_content_type and set_cursor_rectangle"]
            #[doc = "requests must follow if the text input supports the necessary"]
            #[doc = "functionality."]
            #[doc = ""]
            #[doc = "State set with this request is double-buffered. It will get applied on"]
            #[doc = "the next zwp_text_input_v3.commit request, and stay valid until the"]
            #[doc = "next committed enable or disable request."]
            #[doc = ""]
            #[doc = "The changes must be applied by the compositor after issuing a"]
            #[doc = "zwp_text_input_v3.commit request."]
            async fn enable(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Explicitly disable text input on the current surface (typically when"]
            #[doc = "there is no focus on any text entry inside the surface)."]
            #[doc = ""]
            #[doc = "State set with this request is double-buffered. It will get applied on"]
            #[doc = "the next zwp_text_input_v3.commit request."]
            async fn disable(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the surrounding plain text around the input, excluding the preedit"]
            #[doc = "text."]
            #[doc = ""]
            #[doc = "The client should notify the compositor of any changes in any of the"]
            #[doc = "values carried with this request, including changes caused by handling"]
            #[doc = "incoming text-input events as well as changes caused by other"]
            #[doc = "mechanisms like keyboard typing."]
            #[doc = ""]
            #[doc = "If the client is unaware of the text around the cursor, it should not"]
            #[doc = "issue this request, to signify lack of support to the compositor."]
            #[doc = ""]
            #[doc = "Text is UTF-8 encoded, and should include the cursor position, the"]
            #[doc = "complete selection and additional characters before and after them."]
            #[doc = "There is a maximum length of wayland messages, so text can not be"]
            #[doc = "longer than 4000 bytes."]
            #[doc = ""]
            #[doc = "Cursor is the byte offset of the cursor within text buffer."]
            #[doc = ""]
            #[doc = "Anchor is the byte offset of the selection anchor within text buffer."]
            #[doc = "If there is no selected text, anchor is the same as cursor."]
            #[doc = ""]
            #[doc = "If any preedit text is present, it is replaced with a cursor for the"]
            #[doc = "purpose of this event."]
            #[doc = ""]
            #[doc = "Values set with this request are double-buffered. They will get applied"]
            #[doc = "on the next zwp_text_input_v3.commit request, and stay valid until the"]
            #[doc = "next committed enable or disable request."]
            #[doc = ""]
            #[doc = "The initial state for affected fields is empty, meaning that the text"]
            #[doc = "input does not support sending surrounding text. If the empty values"]
            #[doc = "get applied, subsequent attempts to change them may have no effect."]
            async fn set_surrounding_text(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                text: String,
                cursor: i32,
                anchor: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Tells the compositor why the text surrounding the cursor changed."]
            #[doc = ""]
            #[doc = "Whenever the client detects an external change in text, cursor, or"]
            #[doc = "anchor posision, it must issue this request to the compositor. This"]
            #[doc = "request is intended to give the input method a chance to update the"]
            #[doc = "preedit text in an appropriate way, e.g. by removing it when the user"]
            #[doc = "starts typing with a keyboard."]
            #[doc = ""]
            #[doc = "cause describes the source of the change."]
            #[doc = ""]
            #[doc = "The value set with this request is double-buffered. It must be applied"]
            #[doc = "and reset to initial at the next zwp_text_input_v3.commit request."]
            #[doc = ""]
            #[doc = "The initial value of cause is input_method."]
            async fn set_text_change_cause(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                cause: ChangeCause,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the content purpose and content hint. While the purpose is the"]
            #[doc = "basic purpose of an input field, the hint flags allow to modify some of"]
            #[doc = "the behavior."]
            #[doc = ""]
            #[doc = "Values set with this request are double-buffered. They will get applied"]
            #[doc = "on the next zwp_text_input_v3.commit request."]
            #[doc = "Subsequent attempts to update them may have no effect. The values"]
            #[doc = "remain valid until the next committed enable or disable request."]
            #[doc = ""]
            #[doc = "The initial value for hint is none, and the initial value for purpose"]
            #[doc = "is normal."]
            async fn set_content_type(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                hint: ContentHint,
                purpose: ContentPurpose,
            ) -> crate::server::Result<()>;
            #[doc = "Marks an area around the cursor as a x, y, width, height rectangle in"]
            #[doc = "surface local coordinates."]
            #[doc = ""]
            #[doc = "Allows the compositor to put a window with word suggestions near the"]
            #[doc = "cursor, without obstructing the text being input."]
            #[doc = ""]
            #[doc = "If the client is unaware of the position of edited text, it should not"]
            #[doc = "issue this request, to signify lack of support to the compositor."]
            #[doc = ""]
            #[doc = "Values set with this request are double-buffered. They will get applied"]
            #[doc = "on the next zwp_text_input_v3.commit request, and stay valid until the"]
            #[doc = "next committed enable or disable request."]
            #[doc = ""]
            #[doc = "The initial values describing a cursor rectangle are empty. That means"]
            #[doc = "the text input does not support describing the cursor area. If the"]
            #[doc = "empty values get applied, subsequent attempts to change them may have"]
            #[doc = "no effect."]
            async fn set_cursor_rectangle(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Atomically applies state changes recently sent to the compositor."]
            #[doc = ""]
            #[doc = "The commit request establishes and updates the state of the client, and"]
            #[doc = "must be issued after any changes to apply them."]
            #[doc = ""]
            #[doc = "Text input state (enabled status, content purpose, content hint,"]
            #[doc = "surrounding text and change cause, cursor rectangle) is conceptually"]
            #[doc = "double-buffered within the context of a text input, i.e. between a"]
            #[doc = "committed enable request and the following committed enable or disable"]
            #[doc = "request."]
            #[doc = ""]
            #[doc = "Protocol requests modify the pending state, as opposed to the current"]
            #[doc = "state in use by the input method. A commit request atomically applies"]
            #[doc = "all pending state, replacing the current state. After commit, the new"]
            #[doc = "pending state is as documented for each related request."]
            #[doc = ""]
            #[doc = "Requests are applied in the order of arrival."]
            #[doc = ""]
            #[doc = "Neither current nor pending state are modified unless noted otherwise."]
            #[doc = ""]
            #[doc = "The compositor must count the number of commit requests coming from"]
            #[doc = "each zwp_text_input_v3 object and use the count as the serial in done"]
            #[doc = "events."]
            async fn commit(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Notification that this seat's text-input focus is on a certain surface."]
            #[doc = ""]
            #[doc = "If client has created multiple text input objects, compositor must send"]
            #[doc = "this event to all of them."]
            #[doc = ""]
            #[doc = "When the seat has the keyboard capability the text-input focus follows"]
            #[doc = "the keyboard focus. This event sets the current surface for the"]
            #[doc = "text-input object."]
            async fn enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v3#{}.enter()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notification that this seat's text-input focus is no longer on a"]
            #[doc = "certain surface. The client should reset any preedit string previously"]
            #[doc = "set."]
            #[doc = ""]
            #[doc = "The leave notification clears the current surface. It is sent before"]
            #[doc = "the enter notification for the new focus. After leave event, compositor"]
            #[doc = "must ignore requests from any text input instances until next enter"]
            #[doc = "event."]
            #[doc = ""]
            #[doc = "When the seat has the keyboard capability the text-input focus follows"]
            #[doc = "the keyboard focus."]
            async fn leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v3#{}.leave()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notify when a new composing text (pre-edit) should be set at the"]
            #[doc = "current cursor position. Any previously set composing text must be"]
            #[doc = "removed. Any previously existing selected text must be removed."]
            #[doc = ""]
            #[doc = "The argument text contains the pre-edit string buffer."]
            #[doc = ""]
            #[doc = "The parameters cursor_begin and cursor_end are counted in bytes"]
            #[doc = "relative to the beginning of the submitted text buffer. Cursor should"]
            #[doc = "be hidden when both are equal to -1."]
            #[doc = ""]
            #[doc = "They could be represented by the client as a line if both values are"]
            #[doc = "the same, or as a text highlight otherwise."]
            #[doc = ""]
            #[doc = "Values set with this event are double-buffered. They must be applied"]
            #[doc = "and reset to initial on the next zwp_text_input_v3.done event."]
            #[doc = ""]
            #[doc = "The initial value of text is an empty string, and cursor_begin,"]
            #[doc = "cursor_end and cursor_hidden are all 0."]
            async fn preedit_string(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                text: Option<String>,
                cursor_begin: i32,
                cursor_end: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v3#{}.preedit_string()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(text)
                    .put_int(cursor_begin)
                    .put_int(cursor_end)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notify when text should be inserted into the editor widget. The text to"]
            #[doc = "commit could be either just a single character after a key press or the"]
            #[doc = "result of some composing (pre-edit)."]
            #[doc = ""]
            #[doc = "Values set with this event are double-buffered. They must be applied"]
            #[doc = "and reset to initial on the next zwp_text_input_v3.done event."]
            #[doc = ""]
            #[doc = "The initial value of text is an empty string."]
            async fn commit_string(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                text: Option<String>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v3#{}.commit_string()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_string(text).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notify when the text around the current cursor position should be"]
            #[doc = "deleted."]
            #[doc = ""]
            #[doc = "Before_length and after_length are the number of bytes before and after"]
            #[doc = "the current cursor index (excluding the selection) to delete."]
            #[doc = ""]
            #[doc = "If a preedit text is present, in effect before_length is counted from"]
            #[doc = "the beginning of it, and after_length from its end (see done event"]
            #[doc = "sequence)."]
            #[doc = ""]
            #[doc = "Values set with this event are double-buffered. They must be applied"]
            #[doc = "and reset to initial on the next zwp_text_input_v3.done event."]
            #[doc = ""]
            #[doc = "The initial values of both before_length and after_length are 0."]
            async fn delete_surrounding_text(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                before_length: u32,
                after_length: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_text_input_v3#{}.delete_surrounding_text()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(before_length)
                    .put_uint(after_length)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Instruct the application to apply changes to state requested by the"]
            #[doc = "preedit_string, commit_string and delete_surrounding_text events. The"]
            #[doc = "state relating to these events is double-buffered, and each one"]
            #[doc = "modifies the pending state. This event replaces the current state with"]
            #[doc = "the pending state."]
            #[doc = ""]
            #[doc = "The application must proceed by evaluating the changes in the following"]
            #[doc = "order:"]
            #[doc = ""]
            #[doc = "1. Replace existing preedit string with the cursor."]
            #[doc = "2. Delete requested surrounding text."]
            #[doc = "3. Insert commit string with the cursor at its end."]
            #[doc = "4. Calculate surrounding text to send."]
            #[doc = "5. Insert new preedit text in cursor position."]
            #[doc = "6. Place cursor inside preedit text."]
            #[doc = ""]
            #[doc = "The serial number reflects the last state of the zwp_text_input_v3"]
            #[doc = "object known to the compositor. The value of the serial argument must"]
            #[doc = "be equal to the number of commit requests already issued on that object."]
            #[doc = ""]
            #[doc = "When the client receives a done event with a serial different than the"]
            #[doc = "number of past commit requests, it must proceed with evaluating and"]
            #[doc = "applying the changes as normal, except it should not change the current"]
            #[doc = "state of the zwp_text_input_v3 object. All pending state requests"]
            #[doc = "(set_surrounding_text, set_content_type and set_cursor_rectangle) on"]
            #[doc = "the zwp_text_input_v3 object should be sent and committed after"]
            #[doc = "receiving a zwp_text_input_v3.done event with a matching serial."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v3#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A factory for text-input objects. This object is a global singleton."]
    pub mod zwp_text_input_manager_v3 {
        #[doc = "Trait to implement the zwp_text_input_manager_v3 interface. See the module level documentation for more info"]
        pub trait ZwpTextInputManagerV3: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_text_input_manager_v3";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_text_input_manager_v3#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zwp_text_input_manager_v3#{}.get_text_input()", object.id);
                        self.get_text_input(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the wp_text_input_manager object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Creates a new text-input object for a given seat."]
            async fn get_text_input(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod xdg_decoration_unstable_v1 {
    #[doc = "This interface allows a compositor to announce support for server-side"]
    #[doc = "decorations."]
    #[doc = ""]
    #[doc = "A window decoration is a set of window controls as deemed appropriate by"]
    #[doc = "the party managing them, such as user interface components used to move,"]
    #[doc = "resize and change a window's state."]
    #[doc = ""]
    #[doc = "A client can use this protocol to request being decorated by a supporting"]
    #[doc = "compositor."]
    #[doc = ""]
    #[doc = "If compositor and client do not negotiate the use of a server-side"]
    #[doc = "decoration using this protocol, clients continue to self-decorate as they"]
    #[doc = "see fit."]
    #[doc = ""]
    #[doc = "Warning! The protocol described in this file is experimental and"]
    #[doc = "backward incompatible changes may be made. Backward compatible changes"]
    #[doc = "may be added together with the corresponding interface version bump."]
    #[doc = "Backward incompatible changes are done by bumping the version number in"]
    #[doc = "the protocol and interface names and resetting the interface version."]
    #[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
    #[doc = "version number in the protocol and interface names are removed and the"]
    #[doc = "interface version number is reset."]
    pub mod zxdg_decoration_manager_v1 {
        #[doc = "Trait to implement the zxdg_decoration_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZxdgDecorationManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_decoration_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_decoration_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zxdg_decoration_manager_v1#{}.get_toplevel_decoration()",
                            object.id
                        );
                        self.get_toplevel_decoration(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the decoration manager. This doesn't destroy objects created"]
            #[doc = "with the manager."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a new decoration object associated with the given toplevel."]
            #[doc = ""]
            #[doc = "Creating an xdg_toplevel_decoration from an xdg_toplevel which has a"]
            #[doc = "buffer attached or committed is a client error, and any attempts by a"]
            #[doc = "client to attach or manipulate a buffer prior to the first"]
            #[doc = "xdg_toplevel_decoration.configure event must also be treated as"]
            #[doc = "errors."]
            async fn get_toplevel_decoration(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                toplevel: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "The decoration object allows the compositor to toggle server-side window"]
    #[doc = "decorations for a toplevel surface. The client can request to switch to"]
    #[doc = "another mode."]
    #[doc = ""]
    #[doc = "The xdg_toplevel_decoration object must be destroyed before its"]
    #[doc = "xdg_toplevel."]
    pub mod zxdg_toplevel_decoration_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "xdg_toplevel has a buffer attached before configure"]
            UnconfiguredBuffer = 0u32,
            #[doc = "xdg_toplevel already has a decoration object"]
            AlreadyConstructed = 1u32,
            #[doc = "xdg_toplevel destroyed before the decoration object"]
            Orphaned = 2u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::UnconfiguredBuffer),
                    1u32 => Ok(Self::AlreadyConstructed),
                    2u32 => Ok(Self::Orphaned),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "These values describe window decoration modes."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Mode {
            #[doc = "no server-side window decoration"]
            ClientSide = 1u32,
            #[doc = "server-side window decoration"]
            ServerSide = 2u32,
        }
        impl TryFrom<u32> for Mode {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::ClientSide),
                    2u32 => Ok(Self::ServerSide),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zxdg_toplevel_decoration_v1 interface. See the module level documentation for more info"]
        pub trait ZxdgToplevelDecorationV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_toplevel_decoration_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_toplevel_decoration_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_toplevel_decoration_v1#{}.set_mode()", object.id);
                        self.set_mode(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    2u16 => {
                        tracing::debug!("zxdg_toplevel_decoration_v1#{}.unset_mode()", object.id);
                        self.unset_mode(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Switch back to a mode without any server-side decorations at the next"]
            #[doc = "commit."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the toplevel surface decoration mode. This informs the compositor"]
            #[doc = "that the client prefers the provided decoration mode."]
            #[doc = ""]
            #[doc = "After requesting a decoration mode, the compositor will respond by"]
            #[doc = "emitting an xdg_surface.configure event. The client should then update"]
            #[doc = "its content, drawing it without decorations if the received mode is"]
            #[doc = "server-side decorations. The client must also acknowledge the configure"]
            #[doc = "when committing the new content (see xdg_surface.ack_configure)."]
            #[doc = ""]
            #[doc = "The compositor can decide not to use the client's mode and enforce a"]
            #[doc = "different mode instead."]
            #[doc = ""]
            #[doc = "Clients whose decoration mode depend on the xdg_toplevel state may send"]
            #[doc = "a set_mode request in response to an xdg_surface.configure event and wait"]
            #[doc = "for the next xdg_surface.configure event to prevent unwanted state."]
            #[doc = "Such clients are responsible for preventing configure loops and must"]
            #[doc = "make sure not to send multiple successive set_mode requests with the"]
            #[doc = "same decoration mode."]
            async fn set_mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mode: Mode,
            ) -> crate::server::Result<()>;
            #[doc = "Unset the toplevel surface decoration mode. This informs the compositor"]
            #[doc = "that the client doesn't prefer a particular decoration mode."]
            #[doc = ""]
            #[doc = "This request has the same semantics as set_mode."]
            async fn unset_mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The configure event configures the effective decoration mode. The"]
            #[doc = "configured state should not be applied immediately. Clients must send an"]
            #[doc = "ack_configure in response to this event. See xdg_surface.configure and"]
            #[doc = "xdg_surface.ack_configure for details."]
            #[doc = ""]
            #[doc = "A configure event can be sent at any time. The specified mode must be"]
            #[doc = "obeyed by the client."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mode: Mode,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_toplevel_decoration_v1#{}.configure()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(mode as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "This protocol specifies a way for making it possible to reference a surface"]
#[doc = "of a different client. With such a reference, a client can, by using the"]
#[doc = "interfaces provided by this protocol, manipulate the relationship between"]
#[doc = "its own surfaces and the surface of some other client. For example, stack"]
#[doc = "some of its own surface above the other clients surface."]
#[doc = ""]
#[doc = "In order for a client A to get a reference of a surface of client B, client"]
#[doc = "B must first export its surface using xdg_exporter.export. Upon doing this,"]
#[doc = "client B will receive a handle (a unique string) that it may share with"]
#[doc = "client A in some way (for example D-Bus). After client A has received the"]
#[doc = "handle from client B, it may use xdg_importer.import to create a reference"]
#[doc = "to the surface client B just exported. See the corresponding requests for"]
#[doc = "details."]
#[doc = ""]
#[doc = "A possible use case for this is out-of-process dialogs. For example when a"]
#[doc = "sandboxed client without file system access needs the user to select a file"]
#[doc = "on the file system, given sandbox environment support, it can export its"]
#[doc = "surface, passing the exported surface handle to an unsandboxed process that"]
#[doc = "can show a file browser dialog and stack it above the sandboxed client's"]
#[doc = "surface."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and backward"]
#[doc = "incompatible changes may be made. Backward compatible changes may be added"]
#[doc = "together with the corresponding interface version bump. Backward"]
#[doc = "incompatible changes are done by bumping the version number in the protocol"]
#[doc = "and interface names and resetting the interface version. Once the protocol"]
#[doc = "is to be declared stable, the 'z' prefix and the version number in the"]
#[doc = "protocol and interface names are removed and the interface version number is"]
#[doc = "reset."]
pub mod xdg_foreign_unstable_v1 {
    #[doc = "A global interface used for exporting surfaces that can later be imported"]
    #[doc = "using xdg_importer."]
    pub mod zxdg_exporter_v1 {
        #[doc = "Trait to implement the zxdg_exporter_v1 interface. See the module level documentation for more info"]
        pub trait ZxdgExporterV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_exporter_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_exporter_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_exporter_v1#{}.export()", object.id);
                        self.export(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Notify the compositor that the xdg_exporter object will no longer be"]
            #[doc = "used."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The export request exports the passed surface so that it can later be"]
            #[doc = "imported via xdg_importer. When called, a new xdg_exported object will"]
            #[doc = "be created and xdg_exported.handle will be sent immediately. See the"]
            #[doc = "corresponding interface and event for details."]
            #[doc = ""]
            #[doc = "A surface may be exported multiple times, and each exported handle may"]
            #[doc = "be used to create an xdg_imported multiple times. Only xdg_surface"]
            #[doc = "surfaces may be exported."]
            async fn export(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "A global interface used for importing surfaces exported by xdg_exporter."]
    #[doc = "With this interface, a client can create a reference to a surface of"]
    #[doc = "another client."]
    pub mod zxdg_importer_v1 {
        #[doc = "Trait to implement the zxdg_importer_v1 interface. See the module level documentation for more info"]
        pub trait ZxdgImporterV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_importer_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_importer_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_importer_v1#{}.import()", object.id);
                        self.import(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Notify the compositor that the xdg_importer object will no longer be"]
            #[doc = "used."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The import request imports a surface from any client given a handle"]
            #[doc = "retrieved by exporting said surface using xdg_exporter.export. When"]
            #[doc = "called, a new xdg_imported object will be created. This new object"]
            #[doc = "represents the imported surface, and the importing client can"]
            #[doc = "manipulate its relationship using it. See xdg_imported for details."]
            async fn import(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                handle: String,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "An xdg_exported object represents an exported reference to a surface. The"]
    #[doc = "exported surface may be referenced as long as the xdg_exported object not"]
    #[doc = "destroyed. Destroying the xdg_exported invalidates any relationship the"]
    #[doc = "importer may have established using xdg_imported."]
    pub mod zxdg_exported_v1 {
        #[doc = "Trait to implement the zxdg_exported_v1 interface. See the module level documentation for more info"]
        pub trait ZxdgExportedV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_exported_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_exported_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Revoke the previously exported surface. This invalidates any"]
            #[doc = "relationship the importer may have set up using the xdg_imported created"]
            #[doc = "given the handle sent via xdg_exported.handle."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The handle event contains the unique handle of this exported surface"]
            #[doc = "reference. It may be shared with any client, which then can use it to"]
            #[doc = "import the surface by calling xdg_importer.import. A handle may be"]
            #[doc = "used to import the surface multiple times."]
            async fn handle(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                handle: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_exported_v1#{}.handle()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(handle))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "An xdg_imported object represents an imported reference to surface exported"]
    #[doc = "by some client. A client can use this interface to manipulate"]
    #[doc = "relationships between its own surfaces and the imported surface."]
    pub mod zxdg_imported_v1 {
        #[doc = "Trait to implement the zxdg_imported_v1 interface. See the module level documentation for more info"]
        pub trait ZxdgImportedV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_imported_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_imported_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_imported_v1#{}.set_parent_of()", object.id);
                        self.set_parent_of(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Notify the compositor that it will no longer use the xdg_imported"]
            #[doc = "object. Any relationship that may have been set up will at this point"]
            #[doc = "be invalidated."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the imported surface as the parent of some surface of the client."]
            #[doc = "The passed surface must be a toplevel xdg_surface. Calling this function"]
            #[doc = "sets up a surface to surface relation with the same stacking and positioning"]
            #[doc = "semantics as xdg_surface.set_parent."]
            async fn set_parent_of(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "The imported surface handle has been destroyed and any relationship set"]
            #[doc = "up has been invalidated. This may happen for various reasons, for"]
            #[doc = "example if the exported surface or the exported surface handle has been"]
            #[doc = "destroyed, if the handle used for importing was invalid."]
            async fn destroyed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_imported_v1#{}.destroyed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "This protocol specifies a way for making it possible to reference a surface"]
#[doc = "of a different client. With such a reference, a client can, by using the"]
#[doc = "interfaces provided by this protocol, manipulate the relationship between"]
#[doc = "its own surfaces and the surface of some other client. For example, stack"]
#[doc = "some of its own surface above the other clients surface."]
#[doc = ""]
#[doc = "In order for a client A to get a reference of a surface of client B, client"]
#[doc = "B must first export its surface using xdg_exporter.export_toplevel. Upon"]
#[doc = "doing this, client B will receive a handle (a unique string) that it may"]
#[doc = "share with client A in some way (for example D-Bus). After client A has"]
#[doc = "received the handle from client B, it may use xdg_importer.import_toplevel"]
#[doc = "to create a reference to the surface client B just exported. See the"]
#[doc = "corresponding requests for details."]
#[doc = ""]
#[doc = "A possible use case for this is out-of-process dialogs. For example when a"]
#[doc = "sandboxed client without file system access needs the user to select a file"]
#[doc = "on the file system, given sandbox environment support, it can export its"]
#[doc = "surface, passing the exported surface handle to an unsandboxed process that"]
#[doc = "can show a file browser dialog and stack it above the sandboxed client's"]
#[doc = "surface."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and backward"]
#[doc = "incompatible changes may be made. Backward compatible changes may be added"]
#[doc = "together with the corresponding interface version bump. Backward"]
#[doc = "incompatible changes are done by bumping the version number in the protocol"]
#[doc = "and interface names and resetting the interface version. Once the protocol"]
#[doc = "is to be declared stable, the 'z' prefix and the version number in the"]
#[doc = "protocol and interface names are removed and the interface version number is"]
#[doc = "reset."]
pub mod xdg_foreign_unstable_v2 {
    #[doc = "A global interface used for exporting surfaces that can later be imported"]
    #[doc = "using xdg_importer."]
    pub mod zxdg_exporter_v2 {
        #[doc = "These errors can be emitted in response to invalid xdg_exporter"]
        #[doc = "requests."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "surface is not an xdg_toplevel"]
            InvalidSurface = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidSurface),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zxdg_exporter_v2 interface. See the module level documentation for more info"]
        pub trait ZxdgExporterV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_exporter_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_exporter_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_exporter_v2#{}.export_toplevel()", object.id);
                        self.export_toplevel(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Notify the compositor that the xdg_exporter object will no longer be"]
            #[doc = "used."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The export_toplevel request exports the passed surface so that it can later be"]
            #[doc = "imported via xdg_importer. When called, a new xdg_exported object will"]
            #[doc = "be created and xdg_exported.handle will be sent immediately. See the"]
            #[doc = "corresponding interface and event for details."]
            #[doc = ""]
            #[doc = "A surface may be exported multiple times, and each exported handle may"]
            #[doc = "be used to create an xdg_imported multiple times. Only xdg_toplevel"]
            #[doc = "equivalent surfaces may be exported, otherwise an invalid_surface"]
            #[doc = "protocol error is sent."]
            async fn export_toplevel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "A global interface used for importing surfaces exported by xdg_exporter."]
    #[doc = "With this interface, a client can create a reference to a surface of"]
    #[doc = "another client."]
    pub mod zxdg_importer_v2 {
        #[doc = "Trait to implement the zxdg_importer_v2 interface. See the module level documentation for more info"]
        pub trait ZxdgImporterV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_importer_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_importer_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_importer_v2#{}.import_toplevel()", object.id);
                        self.import_toplevel(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Notify the compositor that the xdg_importer object will no longer be"]
            #[doc = "used."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The import_toplevel request imports a surface from any client given a handle"]
            #[doc = "retrieved by exporting said surface using xdg_exporter.export_toplevel."]
            #[doc = "When called, a new xdg_imported object will be created. This new object"]
            #[doc = "represents the imported surface, and the importing client can"]
            #[doc = "manipulate its relationship using it. See xdg_imported for details."]
            async fn import_toplevel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                handle: String,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "An xdg_exported object represents an exported reference to a surface. The"]
    #[doc = "exported surface may be referenced as long as the xdg_exported object not"]
    #[doc = "destroyed. Destroying the xdg_exported invalidates any relationship the"]
    #[doc = "importer may have established using xdg_imported."]
    pub mod zxdg_exported_v2 {
        #[doc = "Trait to implement the zxdg_exported_v2 interface. See the module level documentation for more info"]
        pub trait ZxdgExportedV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_exported_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_exported_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Revoke the previously exported surface. This invalidates any"]
            #[doc = "relationship the importer may have set up using the xdg_imported created"]
            #[doc = "given the handle sent via xdg_exported.handle."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The handle event contains the unique handle of this exported surface"]
            #[doc = "reference. It may be shared with any client, which then can use it to"]
            #[doc = "import the surface by calling xdg_importer.import_toplevel. A handle"]
            #[doc = "may be used to import the surface multiple times."]
            async fn handle(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                handle: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_exported_v2#{}.handle()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(handle))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "An xdg_imported object represents an imported reference to surface exported"]
    #[doc = "by some client. A client can use this interface to manipulate"]
    #[doc = "relationships between its own surfaces and the imported surface."]
    pub mod zxdg_imported_v2 {
        #[doc = "These errors can be emitted in response to invalid xdg_imported"]
        #[doc = "requests."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "surface is not an xdg_toplevel"]
            InvalidSurface = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidSurface),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zxdg_imported_v2 interface. See the module level documentation for more info"]
        pub trait ZxdgImportedV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_imported_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_imported_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_imported_v2#{}.set_parent_of()", object.id);
                        self.set_parent_of(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Notify the compositor that it will no longer use the xdg_imported"]
            #[doc = "object. Any relationship that may have been set up will at this point"]
            #[doc = "be invalidated."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the imported surface as the parent of some surface of the client."]
            #[doc = "The passed surface must be an xdg_toplevel equivalent, otherwise an"]
            #[doc = "invalid_surface protocol error is sent. Calling this function sets up"]
            #[doc = "a surface to surface relation with the same stacking and positioning"]
            #[doc = "semantics as xdg_toplevel.set_parent."]
            async fn set_parent_of(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "The imported surface handle has been destroyed and any relationship set"]
            #[doc = "up has been invalidated. This may happen for various reasons, for"]
            #[doc = "example if the exported surface or the exported surface handle has been"]
            #[doc = "destroyed, if the handle used for importing was invalid."]
            async fn destroyed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_imported_v2#{}.destroyed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "This protocol aims at describing outputs in a way which is more in line"]
#[doc = "with the concept of an output on desktop oriented systems."]
#[doc = ""]
#[doc = "Some information are more specific to the concept of an output for"]
#[doc = "a desktop oriented system and may not make sense in other applications,"]
#[doc = "such as IVI systems for example."]
#[doc = ""]
#[doc = "Typically, the global compositor space on a desktop system is made of"]
#[doc = "a contiguous or overlapping set of rectangular regions."]
#[doc = ""]
#[doc = "The logical_position and logical_size events defined in this protocol"]
#[doc = "might provide information identical to their counterparts already"]
#[doc = "available from wl_output, in which case the information provided by this"]
#[doc = "protocol should be preferred to their equivalent in wl_output. The goal is"]
#[doc = "to move the desktop specific concepts (such as output location within the"]
#[doc = "global compositor space, etc.) out of the core wl_output protocol."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and"]
#[doc = "backward incompatible changes may be made. Backward compatible"]
#[doc = "changes may be added together with the corresponding interface"]
#[doc = "version bump."]
#[doc = "Backward incompatible changes are done by bumping the version"]
#[doc = "number in the protocol and interface names and resetting the"]
#[doc = "interface version. Once the protocol is to be declared stable,"]
#[doc = "the 'z' prefix and the version number in the protocol and"]
#[doc = "interface names are removed and the interface version number is"]
#[doc = "reset."]
pub mod xdg_output_unstable_v1 {
    #[doc = "A global factory interface for xdg_output objects."]
    pub mod zxdg_output_manager_v1 {
        #[doc = "Trait to implement the zxdg_output_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZxdgOutputManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_output_manager_v1";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_output_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_output_manager_v1#{}.get_xdg_output()", object.id);
                        self.get_xdg_output(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Using this request a client can tell the server that it is not"]
            #[doc = "going to use the xdg_output_manager object anymore."]
            #[doc = ""]
            #[doc = "Any objects already created through this instance are not affected."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This creates a new xdg_output object for the given wl_output."]
            async fn get_xdg_output(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "An xdg_output describes part of the compositor geometry."]
    #[doc = ""]
    #[doc = "This typically corresponds to a monitor that displays part of the"]
    #[doc = "compositor space."]
    #[doc = ""]
    #[doc = "For objects version 3 onwards, after all xdg_output properties have been"]
    #[doc = "sent (when the object is created and when properties are updated), a"]
    #[doc = "wl_output.done event is sent. This allows changes to the output"]
    #[doc = "properties to be seen as atomic, even if they happen via multiple events."]
    pub mod zxdg_output_v1 {
        #[doc = "Trait to implement the zxdg_output_v1 interface. See the module level documentation for more info"]
        pub trait ZxdgOutputV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_output_v1";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_output_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Using this request a client can tell the server that it is not"]
            #[doc = "going to use the xdg_output object anymore."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The position event describes the location of the wl_output within"]
            #[doc = "the global compositor space."]
            #[doc = ""]
            #[doc = "The logical_position event is sent after creating an xdg_output"]
            #[doc = "(see xdg_output_manager.get_xdg_output) and whenever the location"]
            #[doc = "of the output changes within the global compositor space."]
            async fn logical_position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_output_v1#{}.logical_position()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(x)
                    .put_int(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The logical_size event describes the size of the output in the"]
            #[doc = "global compositor space."]
            #[doc = ""]
            #[doc = "Most regular Wayland clients should not pay attention to the"]
            #[doc = "logical size and would rather rely on xdg_shell interfaces."]
            #[doc = ""]
            #[doc = "Some clients such as Xwayland, however, need this to configure"]
            #[doc = "their surfaces in the global compositor space as the compositor"]
            #[doc = "may apply a different scale from what is advertised by the output"]
            #[doc = "scaling property (to achieve fractional scaling, for example)."]
            #[doc = ""]
            #[doc = "For example, for a wl_output mode 3840×2160 and a scale factor 2:"]
            #[doc = ""]
            #[doc = "- A compositor not scaling the monitor viewport in its compositing space"]
            #[doc = "will advertise a logical size of 3840×2160,"]
            #[doc = ""]
            #[doc = "- A compositor scaling the monitor viewport with scale factor 2 will"]
            #[doc = "advertise a logical size of 1920×1080,"]
            #[doc = ""]
            #[doc = "- A compositor scaling the monitor viewport using a fractional scale of"]
            #[doc = "1.5 will advertise a logical size of 2560×1440."]
            #[doc = ""]
            #[doc = "For example, for a wl_output mode 1920×1080 and a 90 degree rotation,"]
            #[doc = "the compositor will advertise a logical size of 1080x1920."]
            #[doc = ""]
            #[doc = "The logical_size event is sent after creating an xdg_output"]
            #[doc = "(see xdg_output_manager.get_xdg_output) and whenever the logical"]
            #[doc = "size of the output changes, either as a result of a change in the"]
            #[doc = "applied scale or because of a change in the corresponding output"]
            #[doc = "mode(see wl_output.mode) or transform (see wl_output.transform)."]
            async fn logical_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_output_v1#{}.logical_size()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent after all other properties of an xdg_output"]
            #[doc = "have been sent."]
            #[doc = ""]
            #[doc = "This allows changes to the xdg_output properties to be seen as"]
            #[doc = "atomic, even if they happen via multiple events."]
            #[doc = ""]
            #[doc = "For objects version 3 onwards, this event is deprecated. Compositors"]
            #[doc = "are not required to send it anymore and must send wl_output.done"]
            #[doc = "instead."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_output_v1#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Many compositors will assign names to their outputs, show them to the"]
            #[doc = "user, allow them to be configured by name, etc. The client may wish to"]
            #[doc = "know this name as well to offer the user similar behaviors."]
            #[doc = ""]
            #[doc = "The naming convention is compositor defined, but limited to"]
            #[doc = "alphanumeric characters and dashes (-). Each name is unique among all"]
            #[doc = "wl_output globals, but if a wl_output global is destroyed the same name"]
            #[doc = "may be reused later. The names will also remain consistent across"]
            #[doc = "sessions with the same hardware and software configuration."]
            #[doc = ""]
            #[doc = "Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do"]
            #[doc = "not assume that the name is a reflection of an underlying DRM"]
            #[doc = "connector, X11 connection, etc."]
            #[doc = ""]
            #[doc = "The name event is sent after creating an xdg_output (see"]
            #[doc = "xdg_output_manager.get_xdg_output). This event is only sent once per"]
            #[doc = "xdg_output, and the name does not change over the lifetime of the"]
            #[doc = "wl_output global."]
            #[doc = ""]
            #[doc = "This event is deprecated, instead clients should use wl_output.name."]
            #[doc = "Compositors must still support this event."]
            async fn name(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_output_v1#{}.name()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(name))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Many compositors can produce human-readable descriptions of their"]
            #[doc = "outputs.  The client may wish to know this description as well, to"]
            #[doc = "communicate the user for various purposes."]
            #[doc = ""]
            #[doc = "The description is a UTF-8 string with no convention defined for its"]
            #[doc = "contents. Examples might include 'Foocorp 11\" Display' or 'Virtual X11"]
            #[doc = "output via :1'."]
            #[doc = ""]
            #[doc = "The description event is sent after creating an xdg_output (see"]
            #[doc = "xdg_output_manager.get_xdg_output) and whenever the description"]
            #[doc = "changes. The description is optional, and may not be sent at all."]
            #[doc = ""]
            #[doc = "For objects of version 2 and lower, this event is only sent once per"]
            #[doc = "xdg_output, and the description does not change over the lifetime of"]
            #[doc = "the wl_output global."]
            #[doc = ""]
            #[doc = "This event is deprecated, instead clients should use"]
            #[doc = "wl_output.description. Compositors must still support this event."]
            async fn description(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                description: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_output_v1#{}.description()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(description))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod xdg_shell_unstable_v5 {
    #[doc = "xdg_shell allows clients to turn a wl_surface into a \"real window\""]
    #[doc = "which can be dragged, resized, stacked, and moved around by the"]
    #[doc = "user. Everything about this interface is suited towards traditional"]
    #[doc = "desktop environments."]
    pub mod xdg_shell {
        #[doc = "The 'current' member of this enum gives the version of the"]
        #[doc = "protocol.  Implementations can compare this to the version"]
        #[doc = "they implement using static_assert to ensure the protocol and"]
        #[doc = "implementation versions match."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Version {
            #[doc = "Always the latest version"]
            Current = 5u32,
        }
        impl TryFrom<u32> for Version {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    5u32 => Ok(Self::Current),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "given wl_surface has another role"]
            Role = 0u32,
            #[doc = "xdg_shell was destroyed before children"]
            DefunctSurfaces = 1u32,
            #[doc = "the client tried to map or destroy a non-topmost popup"]
            NotTheTopmostPopup = 2u32,
            #[doc = "the client specified an invalid popup parent surface"]
            InvalidPopupParent = 3u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Role),
                    1u32 => Ok(Self::DefunctSurfaces),
                    2u32 => Ok(Self::NotTheTopmostPopup),
                    3u32 => Ok(Self::InvalidPopupParent),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the xdg_shell interface. See the module level documentation for more info"]
        pub trait XdgShell: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_shell";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_shell#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_shell#{}.use_unstable_version()", object.id);
                        self.use_unstable_version(object, client, message.int()?)
                            .await
                    }
                    2u16 => {
                        tracing::debug!("xdg_shell#{}.get_xdg_surface()", object.id);
                        self.get_xdg_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("xdg_shell#{}.get_xdg_popup()", object.id);
                        self.get_xdg_popup(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("xdg_shell#{}.pong()", object.id);
                        self.pong(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy this xdg_shell object."]
            #[doc = ""]
            #[doc = "Destroying a bound xdg_shell object while there are surfaces"]
            #[doc = "still alive created by this xdg_shell object instance is illegal"]
            #[doc = "and will result in a protocol error."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Negotiate the unstable version of the interface.  This"]
            #[doc = "mechanism is in place to ensure client and server agree on the"]
            #[doc = "unstable versions of the protocol that they speak or exit"]
            #[doc = "cleanly if they don't agree.  This request will go away once"]
            #[doc = "the xdg-shell protocol is stable."]
            async fn use_unstable_version(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                version: i32,
            ) -> crate::server::Result<()>;
            #[doc = "This creates an xdg_surface for the given surface and gives it the"]
            #[doc = "xdg_surface role. A wl_surface can only be given an xdg_surface role"]
            #[doc = "once. If get_xdg_surface is called with a wl_surface that already has"]
            #[doc = "an active xdg_surface associated with it, or if it had any other role,"]
            #[doc = "an error is raised."]
            #[doc = ""]
            #[doc = "See the documentation of xdg_surface for more details about what an"]
            #[doc = "xdg_surface is and how it is used."]
            async fn get_xdg_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This creates an xdg_popup for the given surface and gives it the"]
            #[doc = "xdg_popup role. A wl_surface can only be given an xdg_popup role"]
            #[doc = "once. If get_xdg_popup is called with a wl_surface that already has"]
            #[doc = "an active xdg_popup associated with it, or if it had any other role,"]
            #[doc = "an error is raised."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action"]
            #[doc = "like a button press, key press, or touch down event."]
            #[doc = ""]
            #[doc = "See the documentation of xdg_popup for more details about what an"]
            #[doc = "xdg_popup is and how it is used."]
            async fn get_xdg_popup(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
                parent: crate::wire::ObjectId,
                seat: crate::wire::ObjectId,
                serial: u32,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "A client must respond to a ping event with a pong request or"]
            #[doc = "the client may be deemed unresponsive."]
            async fn pong(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "The ping event asks the client if it's still alive. Pass the"]
            #[doc = "serial specified in the event back to the compositor by sending"]
            #[doc = "a \"pong\" request back with the specified serial."]
            #[doc = ""]
            #[doc = "Compositors can use this to determine if the client is still"]
            #[doc = "alive. It's unspecified what will happen if the client doesn't"]
            #[doc = "respond to the ping request, or in what timeframe. Clients should"]
            #[doc = "try to respond in a reasonable amount of time."]
            #[doc = ""]
            #[doc = "A compositor is free to ping in any way it wants, but a client must"]
            #[doc = "always respond to any xdg_shell object it created."]
            async fn ping(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_shell#{}.ping()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "An interface that may be implemented by a wl_surface, for"]
    #[doc = "implementations that provide a desktop-style user interface."]
    #[doc = ""]
    #[doc = "It provides requests to treat surfaces like windows, allowing to set"]
    #[doc = "properties like maximized, fullscreen, minimized, and to move and resize"]
    #[doc = "them, and associate metadata like title and app id."]
    #[doc = ""]
    #[doc = "The client must call wl_surface.commit on the corresponding wl_surface"]
    #[doc = "for the xdg_surface state to take effect. Prior to committing the new"]
    #[doc = "state, it can set up initial configuration, such as maximizing or setting"]
    #[doc = "a window geometry."]
    #[doc = ""]
    #[doc = "Even without attaching a buffer the compositor must respond to initial"]
    #[doc = "committed configuration, for instance sending a configure event with"]
    #[doc = "expected window geometry if the client maximized its surface during"]
    #[doc = "initialization."]
    #[doc = ""]
    #[doc = "For a surface to be mapped by the compositor the client must have"]
    #[doc = "committed both an xdg_surface state and a buffer."]
    pub mod xdg_surface {
        #[doc = "These values are used to indicate which edge of a surface"]
        #[doc = "is being dragged in a resize operation."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ResizeEdge {
            None = 0u32,
            Top = 1u32,
            Bottom = 2u32,
            Left = 4u32,
            TopLeft = 5u32,
            BottomLeft = 6u32,
            Right = 8u32,
            TopRight = 9u32,
            BottomRight = 10u32,
        }
        impl TryFrom<u32> for ResizeEdge {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::None),
                    1u32 => Ok(Self::Top),
                    2u32 => Ok(Self::Bottom),
                    4u32 => Ok(Self::Left),
                    5u32 => Ok(Self::TopLeft),
                    6u32 => Ok(Self::BottomLeft),
                    8u32 => Ok(Self::Right),
                    9u32 => Ok(Self::TopRight),
                    10u32 => Ok(Self::BottomRight),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "The different state values used on the surface. This is designed for"]
        #[doc = "state values like maximized, fullscreen. It is paired with the"]
        #[doc = "configure event to ensure that both the client and the compositor"]
        #[doc = "setting the state can be synchronized."]
        #[doc = ""]
        #[doc = "States set in this way are double-buffered, see wl_surface.commit."]
        #[doc = ""]
        #[doc = "Desktop environments may extend this enum by taking up a range of"]
        #[doc = "values and documenting the range they chose in this description."]
        #[doc = "They are not required to document the values for the range that they"]
        #[doc = "chose. Ideally, any good extensions from a desktop environment should"]
        #[doc = "make its way into standardization into this enum."]
        #[doc = ""]
        #[doc = "The current reserved ranges are:"]
        #[doc = ""]
        #[doc = "0x0000 - 0x0FFF: xdg-shell core values, documented below."]
        #[doc = "0x1000 - 0x1FFF: GNOME"]
        #[doc = "0x2000 - 0x2FFF: EFL"]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum State {
            #[doc = "the surface is maximized"]
            Maximized = 1u32,
            #[doc = "the surface is fullscreen"]
            Fullscreen = 2u32,
            #[doc = "the surface is being resized"]
            Resizing = 3u32,
            #[doc = "the surface is now activated"]
            Activated = 4u32,
        }
        impl TryFrom<u32> for State {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::Maximized),
                    2u32 => Ok(Self::Fullscreen),
                    3u32 => Ok(Self::Resizing),
                    4u32 => Ok(Self::Activated),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the xdg_surface interface. See the module level documentation for more info"]
        pub trait XdgSurface: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_surface";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_surface#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xdg_surface#{}.set_parent()", object.id);
                        self.set_parent(object, client, message.object()?).await
                    }
                    2u16 => {
                        tracing::debug!("xdg_surface#{}.set_title()", object.id);
                        self.set_title(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("xdg_surface#{}.set_app_id()", object.id);
                        self.set_app_id(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("xdg_surface#{}.show_window_menu()", object.id);
                        self.show_window_menu(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    5u16 => {
                        tracing::debug!("xdg_surface#{}.move()", object.id);
                        self.r#move(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    6u16 => {
                        tracing::debug!("xdg_surface#{}.resize()", object.id);
                        self.resize(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    7u16 => {
                        tracing::debug!("xdg_surface#{}.ack_configure()", object.id);
                        self.ack_configure(object, client, message.uint()?).await
                    }
                    8u16 => {
                        tracing::debug!("xdg_surface#{}.set_window_geometry()", object.id);
                        self.set_window_geometry(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    9u16 => {
                        tracing::debug!("xdg_surface#{}.set_maximized()", object.id);
                        self.set_maximized(object, client).await
                    }
                    10u16 => {
                        tracing::debug!("xdg_surface#{}.unset_maximized()", object.id);
                        self.unset_maximized(object, client).await
                    }
                    11u16 => {
                        tracing::debug!("xdg_surface#{}.set_fullscreen()", object.id);
                        self.set_fullscreen(object, client, message.object()?).await
                    }
                    12u16 => {
                        tracing::debug!("xdg_surface#{}.unset_fullscreen()", object.id);
                        self.unset_fullscreen(object, client).await
                    }
                    13u16 => {
                        tracing::debug!("xdg_surface#{}.set_minimized()", object.id);
                        self.set_minimized(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Unmap and destroy the window. The window will be effectively"]
            #[doc = "hidden from the user's point of view, and all state like"]
            #[doc = "maximization, fullscreen, and so on, will be lost."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the \"parent\" of this surface. This window should be stacked"]
            #[doc = "above a parent. The parent surface must be mapped as long as this"]
            #[doc = "surface is mapped."]
            #[doc = ""]
            #[doc = "Parent windows should be set on dialogs, toolboxes, or other"]
            #[doc = "\"auxiliary\" surfaces, so that the parent is raised when the dialog"]
            #[doc = "is raised."]
            async fn set_parent(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                parent: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Set a short title for the surface."]
            #[doc = ""]
            #[doc = "This string may be used to identify the surface in a task bar,"]
            #[doc = "window list, or other user interface elements provided by the"]
            #[doc = "compositor."]
            #[doc = ""]
            #[doc = "The string must be encoded in UTF-8."]
            async fn set_title(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                title: String,
            ) -> crate::server::Result<()>;
            #[doc = "Set an application identifier for the surface."]
            #[doc = ""]
            #[doc = "The app ID identifies the general class of applications to which"]
            #[doc = "the surface belongs. The compositor can use this to group multiple"]
            #[doc = "surfaces together, or to determine how to launch a new application."]
            #[doc = ""]
            #[doc = "For D-Bus activatable applications, the app ID is used as the D-Bus"]
            #[doc = "service name."]
            #[doc = ""]
            #[doc = "The compositor shell will try to group application surfaces together"]
            #[doc = "by their app ID.  As a best practice, it is suggested to select app"]
            #[doc = "ID's that match the basename of the application's .desktop file."]
            #[doc = "For example, \"org.freedesktop.FooViewer\" where the .desktop file is"]
            #[doc = "\"org.freedesktop.FooViewer.desktop\"."]
            #[doc = ""]
            #[doc = "See the desktop-entry specification [0] for more details on"]
            #[doc = "application identifiers and how they relate to well-known D-Bus"]
            #[doc = "names and .desktop files."]
            #[doc = ""]
            #[doc = "[0] http://standards.freedesktop.org/desktop-entry-spec/"]
            async fn set_app_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                app_id: String,
            ) -> crate::server::Result<()>;
            #[doc = "Clients implementing client-side decorations might want to show"]
            #[doc = "a context menu when right-clicking on the decorations, giving the"]
            #[doc = "user a menu that they can use to maximize or minimize the window."]
            #[doc = ""]
            #[doc = "This request asks the compositor to pop up such a window menu at"]
            #[doc = "the given position, relative to the local surface coordinates of"]
            #[doc = "the parent surface. There are no guarantees as to what menu items"]
            #[doc = "the window menu contains."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action"]
            #[doc = "like a button press, key press, or touch down event."]
            async fn show_window_menu(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Start an interactive, user-driven move of the surface."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action"]
            #[doc = "like a button press, key press, or touch down event. The passed"]
            #[doc = "serial is used to determine the type of interactive move (touch,"]
            #[doc = "pointer, etc)."]
            #[doc = ""]
            #[doc = "The server may ignore move requests depending on the state of"]
            #[doc = "the surface (e.g. fullscreen or maximized), or if the passed serial"]
            #[doc = "is no longer valid."]
            #[doc = ""]
            #[doc = "If triggered, the surface will lose the focus of the device"]
            #[doc = "(wl_pointer, wl_touch, etc) used for the move. It is up to the"]
            #[doc = "compositor to visually indicate that the move is taking place, such as"]
            #[doc = "updating a pointer cursor, during the move. There is no guarantee"]
            #[doc = "that the device focus will return when the move is completed."]
            async fn r#move(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Start a user-driven, interactive resize of the surface."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action"]
            #[doc = "like a button press, key press, or touch down event. The passed"]
            #[doc = "serial is used to determine the type of interactive resize (touch,"]
            #[doc = "pointer, etc)."]
            #[doc = ""]
            #[doc = "The server may ignore resize requests depending on the state of"]
            #[doc = "the surface (e.g. fullscreen or maximized)."]
            #[doc = ""]
            #[doc = "If triggered, the client will receive configure events with the"]
            #[doc = "\"resize\" state enum value and the expected sizes. See the \"resize\""]
            #[doc = "enum value for more details about what is required. The client"]
            #[doc = "must also acknowledge configure events using \"ack_configure\". After"]
            #[doc = "the resize is completed, the client will receive another \"configure\""]
            #[doc = "event without the resize state."]
            #[doc = ""]
            #[doc = "If triggered, the surface also will lose the focus of the device"]
            #[doc = "(wl_pointer, wl_touch, etc) used for the resize. It is up to the"]
            #[doc = "compositor to visually indicate that the resize is taking place,"]
            #[doc = "such as updating a pointer cursor, during the resize. There is no"]
            #[doc = "guarantee that the device focus will return when the resize is"]
            #[doc = "completed."]
            #[doc = ""]
            #[doc = "The edges parameter specifies how the surface should be resized,"]
            #[doc = "and is one of the values of the resize_edge enum. The compositor"]
            #[doc = "may use this information to update the surface position for"]
            #[doc = "example when dragging the top left corner. The compositor may also"]
            #[doc = "use this information to adapt its behavior, e.g. choose an"]
            #[doc = "appropriate cursor image."]
            async fn resize(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
                edges: u32,
            ) -> crate::server::Result<()>;
            #[doc = "When a configure event is received, if a client commits the"]
            #[doc = "surface in response to the configure event, then the client"]
            #[doc = "must make an ack_configure request sometime before the commit"]
            #[doc = "request, passing along the serial of the configure event."]
            #[doc = ""]
            #[doc = "For instance, the compositor might use this information to move"]
            #[doc = "a surface to the top left only when the client has drawn itself"]
            #[doc = "for the maximized or fullscreen state."]
            #[doc = ""]
            #[doc = "If the client receives multiple configure events before it"]
            #[doc = "can respond to one, it only has to ack the last configure event."]
            #[doc = ""]
            #[doc = "A client is not required to commit immediately after sending"]
            #[doc = "an ack_configure request - it may even ack_configure several times"]
            #[doc = "before its next surface commit."]
            #[doc = ""]
            #[doc = "The compositor expects that the most recently received"]
            #[doc = "ack_configure request at the time of a commit indicates which"]
            #[doc = "configure event the client is responding to."]
            async fn ack_configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "The window geometry of a window is its \"visible bounds\" from the"]
            #[doc = "user's perspective. Client-side decorations often have invisible"]
            #[doc = "portions like drop-shadows which should be ignored for the"]
            #[doc = "purposes of aligning, placing and constraining windows."]
            #[doc = ""]
            #[doc = "The window geometry is double-buffered state, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "Once the window geometry of the surface is set once, it is not"]
            #[doc = "possible to unset it, and it will remain the same until"]
            #[doc = "set_window_geometry is called again, even if a new subsurface or"]
            #[doc = "buffer is attached."]
            #[doc = ""]
            #[doc = "If never set, the value is the full bounds of the surface,"]
            #[doc = "including any subsurfaces. This updates dynamically on every"]
            #[doc = "commit. This unset mode is meant for extremely simple clients."]
            #[doc = ""]
            #[doc = "If responding to a configure event, the window geometry in here"]
            #[doc = "must respect the sizing negotiations specified by the states in"]
            #[doc = "the configure event."]
            #[doc = ""]
            #[doc = "The arguments are given in the surface local coordinate space of"]
            #[doc = "the wl_surface associated with this xdg_surface."]
            #[doc = ""]
            #[doc = "The width and height must be greater than zero."]
            async fn set_window_geometry(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Maximize the surface."]
            #[doc = ""]
            #[doc = "After requesting that the surface should be maximized, the compositor"]
            #[doc = "will respond by emitting a configure event with the \"maximized\" state"]
            #[doc = "and the required window geometry. The client should then update its"]
            #[doc = "content, drawing it in a maximized state, i.e. without shadow or other"]
            #[doc = "decoration outside of the window geometry. The client must also"]
            #[doc = "acknowledge the configure when committing the new content (see"]
            #[doc = "ack_configure)."]
            #[doc = ""]
            #[doc = "It is up to the compositor to decide how and where to maximize the"]
            #[doc = "surface, for example which output and what region of the screen should"]
            #[doc = "be used."]
            #[doc = ""]
            #[doc = "If the surface was already maximized, the compositor will still emit"]
            #[doc = "a configure event with the \"maximized\" state."]
            #[doc = ""]
            #[doc = "Note that unrelated compositor side state changes may cause"]
            #[doc = "configure events to be emitted at any time, meaning trying to"]
            #[doc = "match this request to a specific future configure event is"]
            #[doc = "futile."]
            async fn set_maximized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Unmaximize the surface."]
            #[doc = ""]
            #[doc = "After requesting that the surface should be unmaximized, the compositor"]
            #[doc = "will respond by emitting a configure event without the \"maximized\""]
            #[doc = "state. If available, the compositor will include the window geometry"]
            #[doc = "dimensions the window had prior to being maximized in the configure"]
            #[doc = "request. The client must then update its content, drawing it in a"]
            #[doc = "regular state, i.e. potentially with shadow, etc. The client must also"]
            #[doc = "acknowledge the configure when committing the new content (see"]
            #[doc = "ack_configure)."]
            #[doc = ""]
            #[doc = "It is up to the compositor to position the surface after it was"]
            #[doc = "unmaximized; usually the position the surface had before maximizing, if"]
            #[doc = "applicable."]
            #[doc = ""]
            #[doc = "If the surface was already not maximized, the compositor will still"]
            #[doc = "emit a configure event without the \"maximized\" state."]
            #[doc = ""]
            #[doc = "Note that unrelated compositor side state changes may cause"]
            #[doc = "configure events to be emitted at any time, meaning trying to"]
            #[doc = "match this request to a specific future configure event is"]
            #[doc = "futile."]
            async fn unset_maximized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Make the surface fullscreen."]
            #[doc = ""]
            #[doc = "You can specify an output that you would prefer to be fullscreen."]
            #[doc = "If this value is NULL, it's up to the compositor to choose which"]
            #[doc = "display will be used to map this surface."]
            #[doc = ""]
            #[doc = "If the surface doesn't cover the whole output, the compositor will"]
            #[doc = "position the surface in the center of the output and compensate with"]
            #[doc = "black borders filling the rest of the output."]
            async fn set_fullscreen(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            async fn unset_fullscreen(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Request that the compositor minimize your surface. There is no"]
            #[doc = "way to know if the surface is currently minimized, nor is there"]
            #[doc = "any way to unset minimization on this surface."]
            #[doc = ""]
            #[doc = "If you are looking to throttle redrawing when minimized, please"]
            #[doc = "instead use the wl_surface.frame event for this, as this will"]
            #[doc = "also work with live previews on windows in Alt-Tab, Expose or"]
            #[doc = "similar compositor features."]
            async fn set_minimized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The configure event asks the client to resize its surface or to"]
            #[doc = "change its state."]
            #[doc = ""]
            #[doc = "The width and height arguments specify a hint to the window"]
            #[doc = "about how its surface should be resized in window geometry"]
            #[doc = "coordinates. See set_window_geometry."]
            #[doc = ""]
            #[doc = "If the width or height arguments are zero, it means the client"]
            #[doc = "should decide its own window dimension. This may happen when the"]
            #[doc = "compositor need to configure the state of the surface but doesn't"]
            #[doc = "have any information about any previous or expected dimension."]
            #[doc = ""]
            #[doc = "The states listed in the event specify how the width/height"]
            #[doc = "arguments should be interpreted, and possibly how it should be"]
            #[doc = "drawn."]
            #[doc = ""]
            #[doc = "Clients should arrange their surface for the new size and"]
            #[doc = "states, and then send a ack_configure request with the serial"]
            #[doc = "sent in this configure event at some point before committing"]
            #[doc = "the new surface."]
            #[doc = ""]
            #[doc = "If the client receives multiple configure events before it"]
            #[doc = "can respond to one, it is free to discard all but the last"]
            #[doc = "event it received."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
                states: Vec<u8>,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_surface#{}.configure()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(width)
                    .put_int(height)
                    .put_array(states)
                    .put_uint(serial)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The close event is sent by the compositor when the user"]
            #[doc = "wants the surface to be closed. This should be equivalent to"]
            #[doc = "the user clicking the close button in client-side decorations,"]
            #[doc = "if your application has any..."]
            #[doc = ""]
            #[doc = "This is only a request that the user intends to close your"]
            #[doc = "window. The client may choose to ignore this request, or show"]
            #[doc = "a dialog to ask the user to save their data..."]
            async fn close(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_surface#{}.close()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A popup surface is a short-lived, temporary surface that can be"]
    #[doc = "used to implement menus. It takes an explicit grab on the surface"]
    #[doc = "that will be dismissed when the user dismisses the popup. This can"]
    #[doc = "be done by the user clicking outside the surface, using the keyboard,"]
    #[doc = "or even locking the screen through closing the lid or a timeout."]
    #[doc = ""]
    #[doc = "When the popup is dismissed, a popup_done event will be sent out,"]
    #[doc = "and at the same time the surface will be unmapped. The xdg_popup"]
    #[doc = "object is now inert and cannot be reactivated, so clients should"]
    #[doc = "destroy it. Explicitly destroying the xdg_popup object will also"]
    #[doc = "dismiss the popup and unmap the surface."]
    #[doc = ""]
    #[doc = "Clients will receive events for all their surfaces during this"]
    #[doc = "grab (which is an \"owner-events\" grab in X11 parlance). This is"]
    #[doc = "done so that users can navigate through submenus and other"]
    #[doc = "\"nested\" popup windows without having to dismiss the topmost"]
    #[doc = "popup."]
    #[doc = ""]
    #[doc = "Clients that want to dismiss the popup when another surface of"]
    #[doc = "their own is clicked should dismiss the popup using the destroy"]
    #[doc = "request."]
    #[doc = ""]
    #[doc = "The parent surface must have either an xdg_surface or xdg_popup"]
    #[doc = "role."]
    #[doc = ""]
    #[doc = "Specifying an xdg_popup for the parent means that the popups are"]
    #[doc = "nested, with this popup now being the topmost popup. Nested"]
    #[doc = "popups must be destroyed in the reverse order they were created"]
    #[doc = "in, e.g. the only popup you are allowed to destroy at all times"]
    #[doc = "is the topmost one."]
    #[doc = ""]
    #[doc = "If there is an existing popup when creating a new popup, the"]
    #[doc = "parent must be the current topmost popup."]
    #[doc = ""]
    #[doc = "A parent surface must be mapped before the new popup is mapped."]
    #[doc = ""]
    #[doc = "When compositors choose to dismiss a popup, they will likely"]
    #[doc = "dismiss every nested popup as well. When a compositor dismisses"]
    #[doc = "popups, it will follow the same dismissing order as required"]
    #[doc = "from the client."]
    #[doc = ""]
    #[doc = "The x and y arguments passed when creating the popup object specify"]
    #[doc = "where the top left of the popup should be placed, relative to the"]
    #[doc = "local surface coordinates of the parent surface. See"]
    #[doc = "xdg_shell.get_xdg_popup."]
    #[doc = ""]
    #[doc = "The client must call wl_surface.commit on the corresponding wl_surface"]
    #[doc = "for the xdg_popup state to take effect."]
    #[doc = ""]
    #[doc = "For a surface to be mapped by the compositor the client must have"]
    #[doc = "committed both the xdg_popup state and a buffer."]
    pub mod xdg_popup {
        #[doc = "Trait to implement the xdg_popup interface. See the module level documentation for more info"]
        pub trait XdgPopup: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_popup";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xdg_popup#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This destroys the popup. Explicitly destroying the xdg_popup"]
            #[doc = "object will also dismiss the popup, and unmap the surface."]
            #[doc = ""]
            #[doc = "If this xdg_popup is not the \"topmost\" popup, a protocol error"]
            #[doc = "will be sent."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The popup_done event is sent out when a popup is dismissed by the"]
            #[doc = "compositor. The client should destroy the xdg_popup object at this"]
            #[doc = "point."]
            async fn popup_done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_popup#{}.popup_done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod xdg_shell_unstable_v6 {
    #[doc = "xdg_shell allows clients to turn a wl_surface into a \"real window\""]
    #[doc = "which can be dragged, resized, stacked, and moved around by the"]
    #[doc = "user. Everything about this interface is suited towards traditional"]
    #[doc = "desktop environments."]
    pub mod zxdg_shell_v6 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "given wl_surface has another role"]
            Role = 0u32,
            #[doc = "xdg_shell was destroyed before children"]
            DefunctSurfaces = 1u32,
            #[doc = "the client tried to map or destroy a non-topmost popup"]
            NotTheTopmostPopup = 2u32,
            #[doc = "the client specified an invalid popup parent surface"]
            InvalidPopupParent = 3u32,
            #[doc = "the client provided an invalid surface state"]
            InvalidSurfaceState = 4u32,
            #[doc = "the client provided an invalid positioner"]
            InvalidPositioner = 5u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Role),
                    1u32 => Ok(Self::DefunctSurfaces),
                    2u32 => Ok(Self::NotTheTopmostPopup),
                    3u32 => Ok(Self::InvalidPopupParent),
                    4u32 => Ok(Self::InvalidSurfaceState),
                    5u32 => Ok(Self::InvalidPositioner),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zxdg_shell_v6 interface. See the module level documentation for more info"]
        pub trait ZxdgShellV6: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_shell_v6";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_shell_v6#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_shell_v6#{}.create_positioner()", object.id);
                        self.create_positioner(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zxdg_shell_v6#{}.get_xdg_surface()", object.id);
                        self.get_xdg_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("zxdg_shell_v6#{}.pong()", object.id);
                        self.pong(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy this xdg_shell object."]
            #[doc = ""]
            #[doc = "Destroying a bound xdg_shell object while there are surfaces"]
            #[doc = "still alive created by this xdg_shell object instance is illegal"]
            #[doc = "and will result in a protocol error."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a positioner object. A positioner object is used to position"]
            #[doc = "surfaces relative to some parent surface. See the interface description"]
            #[doc = "and xdg_surface.get_popup for details."]
            async fn create_positioner(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This creates an xdg_surface for the given surface. While xdg_surface"]
            #[doc = "itself is not a role, the corresponding surface may only be assigned"]
            #[doc = "a role extending xdg_surface, such as xdg_toplevel or xdg_popup."]
            #[doc = ""]
            #[doc = "This creates an xdg_surface for the given surface. An xdg_surface is"]
            #[doc = "used as basis to define a role to a given surface, such as xdg_toplevel"]
            #[doc = "or xdg_popup. It also manages functionality shared between xdg_surface"]
            #[doc = "based surface roles."]
            #[doc = ""]
            #[doc = "See the documentation of xdg_surface for more details about what an"]
            #[doc = "xdg_surface is and how it is used."]
            async fn get_xdg_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "A client must respond to a ping event with a pong request or"]
            #[doc = "the client may be deemed unresponsive. See xdg_shell.ping."]
            async fn pong(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "The ping event asks the client if it's still alive. Pass the"]
            #[doc = "serial specified in the event back to the compositor by sending"]
            #[doc = "a \"pong\" request back with the specified serial. See xdg_shell.ping."]
            #[doc = ""]
            #[doc = "Compositors can use this to determine if the client is still"]
            #[doc = "alive. It's unspecified what will happen if the client doesn't"]
            #[doc = "respond to the ping request, or in what timeframe. Clients should"]
            #[doc = "try to respond in a reasonable amount of time."]
            #[doc = ""]
            #[doc = "A compositor is free to ping in any way it wants, but a client must"]
            #[doc = "always respond to any xdg_shell object it created."]
            async fn ping(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_shell_v6#{}.ping()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "The xdg_positioner provides a collection of rules for the placement of a"]
    #[doc = "child surface relative to a parent surface. Rules can be defined to ensure"]
    #[doc = "the child surface remains within the visible area's borders, and to"]
    #[doc = "specify how the child surface changes its position, such as sliding along"]
    #[doc = "an axis, or flipping around a rectangle. These positioner-created rules are"]
    #[doc = "constrained by the requirement that a child surface must intersect with or"]
    #[doc = "be at least partially adjacent to its parent surface."]
    #[doc = ""]
    #[doc = "See the various requests for details about possible rules."]
    #[doc = ""]
    #[doc = "At the time of the request, the compositor makes a copy of the rules"]
    #[doc = "specified by the xdg_positioner. Thus, after the request is complete the"]
    #[doc = "xdg_positioner object can be destroyed or reused; further changes to the"]
    #[doc = "object will have no effect on previous usages."]
    #[doc = ""]
    #[doc = "For an xdg_positioner object to be considered complete, it must have a"]
    #[doc = "non-zero size set by set_size, and a non-zero anchor rectangle set by"]
    #[doc = "set_anchor_rect. Passing an incomplete xdg_positioner object when"]
    #[doc = "positioning a surface raises an error."]
    pub mod zxdg_positioner_v6 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "invalid input provided"]
            InvalidInput = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidInput),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! { # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Anchor : u32 { # [doc = "the center of the anchor rectangle"] const None = 0u32 ; # [doc = "the top edge of the anchor rectangle"] const Top = 1u32 ; # [doc = "the bottom edge of the anchor rectangle"] const Bottom = 2u32 ; # [doc = "the left edge of the anchor rectangle"] const Left = 4u32 ; # [doc = "the right edge of the anchor rectangle"] const Right = 8u32 ; } }
        impl TryFrom<u32> for Anchor {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        bitflags::bitflags! { # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Gravity : u32 { # [doc = "center over the anchor edge"] const None = 0u32 ; # [doc = "position above the anchor edge"] const Top = 1u32 ; # [doc = "position below the anchor edge"] const Bottom = 2u32 ; # [doc = "position to the left of the anchor edge"] const Left = 4u32 ; # [doc = "position to the right of the anchor edge"] const Right = 8u32 ; } }
        impl TryFrom<u32> for Gravity {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        bitflags::bitflags! { # [doc = "The constraint adjustment value define ways the compositor will adjust"] # [doc = "the position of the surface, if the unadjusted position would result"] # [doc = "in the surface being partly constrained."] # [doc = ""] # [doc = "Whether a surface is considered 'constrained' is left to the compositor"] # [doc = "to determine. For example, the surface may be partly outside the"] # [doc = "compositor's defined 'work area', thus necessitating the child surface's"] # [doc = "position be adjusted until it is entirely inside the work area."] # [doc = ""] # [doc = "The adjustments can be combined, according to a defined precedence: 1)"] # [doc = "Flip, 2) Slide, 3) Resize."] # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct ConstraintAdjustment : u32 { const None = 0u32 ; const SlideX = 1u32 ; const SlideY = 2u32 ; const FlipX = 4u32 ; const FlipY = 8u32 ; const ResizeX = 16u32 ; const ResizeY = 32u32 ; } }
        impl TryFrom<u32> for ConstraintAdjustment {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "Trait to implement the zxdg_positioner_v6 interface. See the module level documentation for more info"]
        pub trait ZxdgPositionerV6: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_positioner_v6";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_positioner_v6#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_positioner_v6#{}.set_size()", object.id);
                        self.set_size(object, client, message.int()?, message.int()?)
                            .await
                    }
                    2u16 => {
                        tracing::debug!("zxdg_positioner_v6#{}.set_anchor_rect()", object.id);
                        self.set_anchor_rect(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("zxdg_positioner_v6#{}.set_anchor()", object.id);
                        self.set_anchor(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    4u16 => {
                        tracing::debug!("zxdg_positioner_v6#{}.set_gravity()", object.id);
                        self.set_gravity(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    5u16 => {
                        tracing::debug!(
                            "zxdg_positioner_v6#{}.set_constraint_adjustment()",
                            object.id
                        );
                        self.set_constraint_adjustment(object, client, message.uint()?)
                            .await
                    }
                    6u16 => {
                        tracing::debug!("zxdg_positioner_v6#{}.set_offset()", object.id);
                        self.set_offset(object, client, message.int()?, message.int()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Notify the compositor that the xdg_positioner will no longer be used."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the size of the surface that is to be positioned with the positioner"]
            #[doc = "object. The size is in surface-local coordinates and corresponds to the"]
            #[doc = "window geometry. See xdg_surface.set_window_geometry."]
            #[doc = ""]
            #[doc = "If a zero or negative size is set the invalid_input error is raised."]
            async fn set_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Specify the anchor rectangle within the parent surface that the child"]
            #[doc = "surface will be placed relative to. The rectangle is relative to the"]
            #[doc = "window geometry as defined by xdg_surface.set_window_geometry of the"]
            #[doc = "parent surface. The rectangle must be at least 1x1 large."]
            #[doc = ""]
            #[doc = "When the xdg_positioner object is used to position a child surface, the"]
            #[doc = "anchor rectangle may not extend outside the window geometry of the"]
            #[doc = "positioned child's parent surface."]
            #[doc = ""]
            #[doc = "If a zero or negative size is set the invalid_input error is raised."]
            async fn set_anchor_rect(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Defines a set of edges for the anchor rectangle. These are used to"]
            #[doc = "derive an anchor point that the child surface will be positioned"]
            #[doc = "relative to. If two orthogonal edges are specified (e.g. 'top' and"]
            #[doc = "'left'), then the anchor point will be the intersection of the edges"]
            #[doc = "(e.g. the top left position of the rectangle); otherwise, the derived"]
            #[doc = "anchor point will be centered on the specified edge, or in the center of"]
            #[doc = "the anchor rectangle if no edge is specified."]
            #[doc = ""]
            #[doc = "If two parallel anchor edges are specified (e.g. 'left' and 'right'),"]
            #[doc = "the invalid_input error is raised."]
            async fn set_anchor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                anchor: Anchor,
            ) -> crate::server::Result<()>;
            #[doc = "Defines in what direction a surface should be positioned, relative to"]
            #[doc = "the anchor point of the parent surface. If two orthogonal gravities are"]
            #[doc = "specified (e.g. 'bottom' and 'right'), then the child surface will be"]
            #[doc = "placed in the specified direction; otherwise, the child surface will be"]
            #[doc = "centered over the anchor point on any axis that had no gravity"]
            #[doc = "specified."]
            #[doc = ""]
            #[doc = "If two parallel gravities are specified (e.g. 'left' and 'right'), the"]
            #[doc = "invalid_input error is raised."]
            async fn set_gravity(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                gravity: Gravity,
            ) -> crate::server::Result<()>;
            #[doc = "Specify how the window should be positioned if the originally intended"]
            #[doc = "position caused the surface to be constrained, meaning at least"]
            #[doc = "partially outside positioning boundaries set by the compositor. The"]
            #[doc = "adjustment is set by constructing a bitmask describing the adjustment to"]
            #[doc = "be made when the surface is constrained on that axis."]
            #[doc = ""]
            #[doc = "If no bit for one axis is set, the compositor will assume that the child"]
            #[doc = "surface should not change its position on that axis when constrained."]
            #[doc = ""]
            #[doc = "If more than one bit for one axis is set, the order of how adjustments"]
            #[doc = "are applied is specified in the corresponding adjustment descriptions."]
            #[doc = ""]
            #[doc = "The default adjustment is none."]
            async fn set_constraint_adjustment(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                constraint_adjustment: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Specify the surface position offset relative to the position of the"]
            #[doc = "anchor on the anchor rectangle and the anchor on the surface. For"]
            #[doc = "example if the anchor of the anchor rectangle is at (x, y), the surface"]
            #[doc = "has the gravity bottom|right, and the offset is (ox, oy), the calculated"]
            #[doc = "surface position will be (x + ox, y + oy). The offset position of the"]
            #[doc = "surface is the one used for constraint testing. See"]
            #[doc = "set_constraint_adjustment."]
            #[doc = ""]
            #[doc = "An example use case is placing a popup menu on top of a user interface"]
            #[doc = "element, while aligning the user interface element of the parent surface"]
            #[doc = "with some user interface element placed somewhere in the popup surface."]
            async fn set_offset(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "An interface that may be implemented by a wl_surface, for"]
    #[doc = "implementations that provide a desktop-style user interface."]
    #[doc = ""]
    #[doc = "It provides a base set of functionality required to construct user"]
    #[doc = "interface elements requiring management by the compositor, such as"]
    #[doc = "toplevel windows, menus, etc. The types of functionality are split into"]
    #[doc = "xdg_surface roles."]
    #[doc = ""]
    #[doc = "Creating an xdg_surface does not set the role for a wl_surface. In order"]
    #[doc = "to map an xdg_surface, the client must create a role-specific object"]
    #[doc = "using, e.g., get_toplevel, get_popup. The wl_surface for any given"]
    #[doc = "xdg_surface can have at most one role, and may not be assigned any role"]
    #[doc = "not based on xdg_surface."]
    #[doc = ""]
    #[doc = "A role must be assigned before any other requests are made to the"]
    #[doc = "xdg_surface object."]
    #[doc = ""]
    #[doc = "The client must call wl_surface.commit on the corresponding wl_surface"]
    #[doc = "for the xdg_surface state to take effect."]
    #[doc = ""]
    #[doc = "Creating an xdg_surface from a wl_surface which has a buffer attached or"]
    #[doc = "committed is a client error, and any attempts by a client to attach or"]
    #[doc = "manipulate a buffer prior to the first xdg_surface.configure call must"]
    #[doc = "also be treated as errors."]
    #[doc = ""]
    #[doc = "For a surface to be mapped by the compositor, the following conditions"]
    #[doc = "must be met: (1) the client has assigned an xdg_surface based role to the"]
    #[doc = "surface, (2) the client has set and committed the xdg_surface state and"]
    #[doc = "the role dependent state to the surface and (3) the client has committed a"]
    #[doc = "buffer to the surface."]
    pub mod zxdg_surface_v6 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            NotConstructed = 1u32,
            AlreadyConstructed = 2u32,
            UnconfiguredBuffer = 3u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::NotConstructed),
                    2u32 => Ok(Self::AlreadyConstructed),
                    3u32 => Ok(Self::UnconfiguredBuffer),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zxdg_surface_v6 interface. See the module level documentation for more info"]
        pub trait ZxdgSurfaceV6: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_surface_v6";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_surface_v6#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_surface_v6#{}.get_toplevel()", object.id);
                        self.get_toplevel(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zxdg_surface_v6#{}.get_popup()", object.id);
                        self.get_popup(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("zxdg_surface_v6#{}.set_window_geometry()", object.id);
                        self.set_window_geometry(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("zxdg_surface_v6#{}.ack_configure()", object.id);
                        self.ack_configure(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the xdg_surface object. An xdg_surface must only be destroyed"]
            #[doc = "after its role object has been destroyed. If the role object still"]
            #[doc = "exists when this request is issued, the zxdg_shell_v6.defunct_surfaces"]
            #[doc = "is raised."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This creates an xdg_toplevel object for the given xdg_surface and gives"]
            #[doc = "the associated wl_surface the xdg_toplevel role. If the surface already"]
            #[doc = "had a role, the zxdg_shell_v6.role error is raised."]
            #[doc = ""]
            #[doc = "See the documentation of xdg_toplevel for more details about what an"]
            #[doc = "xdg_toplevel is and how it is used."]
            async fn get_toplevel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This creates an xdg_popup object for the given xdg_surface and gives the"]
            #[doc = "associated wl_surface the xdg_popup role. If the surface already"]
            #[doc = "had a role, the zxdg_shell_v6.role error is raised."]
            #[doc = ""]
            #[doc = "See the documentation of xdg_popup for more details about what an"]
            #[doc = "xdg_popup is and how it is used."]
            async fn get_popup(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                parent: crate::wire::ObjectId,
                positioner: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "The window geometry of a surface is its \"visible bounds\" from the"]
            #[doc = "user's perspective. Client-side decorations often have invisible"]
            #[doc = "portions like drop-shadows which should be ignored for the"]
            #[doc = "purposes of aligning, placing and constraining windows."]
            #[doc = ""]
            #[doc = "The window geometry is double-buffered state, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "Once the window geometry of the surface is set, it is not possible to"]
            #[doc = "unset it, and it will remain the same until set_window_geometry is"]
            #[doc = "called again, even if a new subsurface or buffer is attached."]
            #[doc = ""]
            #[doc = "If never set, the value is the full bounds of the surface,"]
            #[doc = "including any subsurfaces. This updates dynamically on every"]
            #[doc = "commit. This unset is meant for extremely simple clients."]
            #[doc = ""]
            #[doc = "The arguments are given in the surface-local coordinate space of"]
            #[doc = "the wl_surface associated with this xdg_surface."]
            #[doc = ""]
            #[doc = "The width and height must be greater than zero. Setting an invalid size"]
            #[doc = "will raise an error. When applied, the effective window geometry will be"]
            #[doc = "the set window geometry clamped to the bounding rectangle of the"]
            #[doc = "combined geometry of the surface of the xdg_surface and the associated"]
            #[doc = "subsurfaces."]
            async fn set_window_geometry(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "When a configure event is received, if a client commits the"]
            #[doc = "surface in response to the configure event, then the client"]
            #[doc = "must make an ack_configure request sometime before the commit"]
            #[doc = "request, passing along the serial of the configure event."]
            #[doc = ""]
            #[doc = "For instance, for toplevel surfaces the compositor might use this"]
            #[doc = "information to move a surface to the top left only when the client has"]
            #[doc = "drawn itself for the maximized or fullscreen state."]
            #[doc = ""]
            #[doc = "If the client receives multiple configure events before it"]
            #[doc = "can respond to one, it only has to ack the last configure event."]
            #[doc = ""]
            #[doc = "A client is not required to commit immediately after sending"]
            #[doc = "an ack_configure request - it may even ack_configure several times"]
            #[doc = "before its next surface commit."]
            #[doc = ""]
            #[doc = "A client may send multiple ack_configure requests before committing, but"]
            #[doc = "only the last request sent before a commit indicates which configure"]
            #[doc = "event the client really is responding to."]
            #[doc = ""]
            #[doc = "If an invalid serial is used, the zxdg_shell_v6.invalid_surface_state"]
            #[doc = "error is raised."]
            async fn ack_configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "The configure event marks the end of a configure sequence. A configure"]
            #[doc = "sequence is a set of one or more events configuring the state of the"]
            #[doc = "xdg_surface, including the final xdg_surface.configure event."]
            #[doc = ""]
            #[doc = "Where applicable, xdg_surface surface roles will during a configure"]
            #[doc = "sequence extend this event as a latched state sent as events before the"]
            #[doc = "xdg_surface.configure event. Such events should be considered to make up"]
            #[doc = "a set of atomically applied configuration states, where the"]
            #[doc = "xdg_surface.configure commits the accumulated state."]
            #[doc = ""]
            #[doc = "Clients should arrange their surface for the new states, and then send"]
            #[doc = "an ack_configure request with the serial sent in this configure event at"]
            #[doc = "some point before committing the new surface."]
            #[doc = ""]
            #[doc = "If the client receives multiple configure events before it can respond"]
            #[doc = "to one, it is free to discard all but the last event it received."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_surface_v6#{}.configure()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "This interface defines an xdg_surface role which allows a surface to,"]
    #[doc = "among other things, set window-like properties such as maximize,"]
    #[doc = "fullscreen, and minimize, set application-specific metadata like title and"]
    #[doc = "id, and well as trigger user interactive operations such as interactive"]
    #[doc = "resize and move."]
    pub mod zxdg_toplevel_v6 {
        #[doc = "These values are used to indicate which edge of a surface"]
        #[doc = "is being dragged in a resize operation."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ResizeEdge {
            None = 0u32,
            Top = 1u32,
            Bottom = 2u32,
            Left = 4u32,
            TopLeft = 5u32,
            BottomLeft = 6u32,
            Right = 8u32,
            TopRight = 9u32,
            BottomRight = 10u32,
        }
        impl TryFrom<u32> for ResizeEdge {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::None),
                    1u32 => Ok(Self::Top),
                    2u32 => Ok(Self::Bottom),
                    4u32 => Ok(Self::Left),
                    5u32 => Ok(Self::TopLeft),
                    6u32 => Ok(Self::BottomLeft),
                    8u32 => Ok(Self::Right),
                    9u32 => Ok(Self::TopRight),
                    10u32 => Ok(Self::BottomRight),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "The different state values used on the surface. This is designed for"]
        #[doc = "state values like maximized, fullscreen. It is paired with the"]
        #[doc = "configure event to ensure that both the client and the compositor"]
        #[doc = "setting the state can be synchronized."]
        #[doc = ""]
        #[doc = "States set in this way are double-buffered, see wl_surface.commit."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum State {
            #[doc = "the surface is maximized"]
            Maximized = 1u32,
            #[doc = "the surface is fullscreen"]
            Fullscreen = 2u32,
            #[doc = "the surface is being resized"]
            Resizing = 3u32,
            #[doc = "the surface is now activated"]
            Activated = 4u32,
        }
        impl TryFrom<u32> for State {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::Maximized),
                    2u32 => Ok(Self::Fullscreen),
                    3u32 => Ok(Self::Resizing),
                    4u32 => Ok(Self::Activated),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zxdg_toplevel_v6 interface. See the module level documentation for more info"]
        pub trait ZxdgToplevelV6: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_toplevel_v6";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_parent()", object.id);
                        self.set_parent(object, client, message.object()?).await
                    }
                    2u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_title()", object.id);
                        self.set_title(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_app_id()", object.id);
                        self.set_app_id(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.show_window_menu()", object.id);
                        self.show_window_menu(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    5u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.move()", object.id);
                        self.r#move(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    6u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.resize()", object.id);
                        self.resize(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    7u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_max_size()", object.id);
                        self.set_max_size(object, client, message.int()?, message.int()?)
                            .await
                    }
                    8u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_min_size()", object.id);
                        self.set_min_size(object, client, message.int()?, message.int()?)
                            .await
                    }
                    9u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_maximized()", object.id);
                        self.set_maximized(object, client).await
                    }
                    10u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.unset_maximized()", object.id);
                        self.unset_maximized(object, client).await
                    }
                    11u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_fullscreen()", object.id);
                        self.set_fullscreen(object, client, message.object()?).await
                    }
                    12u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.unset_fullscreen()", object.id);
                        self.unset_fullscreen(object, client).await
                    }
                    13u16 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_minimized()", object.id);
                        self.set_minimized(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Unmap and destroy the window. The window will be effectively"]
            #[doc = "hidden from the user's point of view, and all state like"]
            #[doc = "maximization, fullscreen, and so on, will be lost."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the \"parent\" of this surface. This window should be stacked"]
            #[doc = "above a parent. The parent surface must be mapped as long as this"]
            #[doc = "surface is mapped."]
            #[doc = ""]
            #[doc = "Parent windows should be set on dialogs, toolboxes, or other"]
            #[doc = "\"auxiliary\" surfaces, so that the parent is raised when the dialog"]
            #[doc = "is raised."]
            async fn set_parent(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                parent: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Set a short title for the surface."]
            #[doc = ""]
            #[doc = "This string may be used to identify the surface in a task bar,"]
            #[doc = "window list, or other user interface elements provided by the"]
            #[doc = "compositor."]
            #[doc = ""]
            #[doc = "The string must be encoded in UTF-8."]
            async fn set_title(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                title: String,
            ) -> crate::server::Result<()>;
            #[doc = "Set an application identifier for the surface."]
            #[doc = ""]
            #[doc = "The app ID identifies the general class of applications to which"]
            #[doc = "the surface belongs. The compositor can use this to group multiple"]
            #[doc = "surfaces together, or to determine how to launch a new application."]
            #[doc = ""]
            #[doc = "For D-Bus activatable applications, the app ID is used as the D-Bus"]
            #[doc = "service name."]
            #[doc = ""]
            #[doc = "The compositor shell will try to group application surfaces together"]
            #[doc = "by their app ID. As a best practice, it is suggested to select app"]
            #[doc = "ID's that match the basename of the application's .desktop file."]
            #[doc = "For example, \"org.freedesktop.FooViewer\" where the .desktop file is"]
            #[doc = "\"org.freedesktop.FooViewer.desktop\"."]
            #[doc = ""]
            #[doc = "See the desktop-entry specification [0] for more details on"]
            #[doc = "application identifiers and how they relate to well-known D-Bus"]
            #[doc = "names and .desktop files."]
            #[doc = ""]
            #[doc = "[0] http://standards.freedesktop.org/desktop-entry-spec/"]
            async fn set_app_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                app_id: String,
            ) -> crate::server::Result<()>;
            #[doc = "Clients implementing client-side decorations might want to show"]
            #[doc = "a context menu when right-clicking on the decorations, giving the"]
            #[doc = "user a menu that they can use to maximize or minimize the window."]
            #[doc = ""]
            #[doc = "This request asks the compositor to pop up such a window menu at"]
            #[doc = "the given position, relative to the local surface coordinates of"]
            #[doc = "the parent surface. There are no guarantees as to what menu items"]
            #[doc = "the window menu contains."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action"]
            #[doc = "like a button press, key press, or touch down event."]
            async fn show_window_menu(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Start an interactive, user-driven move of the surface."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action"]
            #[doc = "like a button press, key press, or touch down event. The passed"]
            #[doc = "serial is used to determine the type of interactive move (touch,"]
            #[doc = "pointer, etc)."]
            #[doc = ""]
            #[doc = "The server may ignore move requests depending on the state of"]
            #[doc = "the surface (e.g. fullscreen or maximized), or if the passed serial"]
            #[doc = "is no longer valid."]
            #[doc = ""]
            #[doc = "If triggered, the surface will lose the focus of the device"]
            #[doc = "(wl_pointer, wl_touch, etc) used for the move. It is up to the"]
            #[doc = "compositor to visually indicate that the move is taking place, such as"]
            #[doc = "updating a pointer cursor, during the move. There is no guarantee"]
            #[doc = "that the device focus will return when the move is completed."]
            async fn r#move(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Start a user-driven, interactive resize of the surface."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action"]
            #[doc = "like a button press, key press, or touch down event. The passed"]
            #[doc = "serial is used to determine the type of interactive resize (touch,"]
            #[doc = "pointer, etc)."]
            #[doc = ""]
            #[doc = "The server may ignore resize requests depending on the state of"]
            #[doc = "the surface (e.g. fullscreen or maximized)."]
            #[doc = ""]
            #[doc = "If triggered, the client will receive configure events with the"]
            #[doc = "\"resize\" state enum value and the expected sizes. See the \"resize\""]
            #[doc = "enum value for more details about what is required. The client"]
            #[doc = "must also acknowledge configure events using \"ack_configure\". After"]
            #[doc = "the resize is completed, the client will receive another \"configure\""]
            #[doc = "event without the resize state."]
            #[doc = ""]
            #[doc = "If triggered, the surface also will lose the focus of the device"]
            #[doc = "(wl_pointer, wl_touch, etc) used for the resize. It is up to the"]
            #[doc = "compositor to visually indicate that the resize is taking place,"]
            #[doc = "such as updating a pointer cursor, during the resize. There is no"]
            #[doc = "guarantee that the device focus will return when the resize is"]
            #[doc = "completed."]
            #[doc = ""]
            #[doc = "The edges parameter specifies how the surface should be resized,"]
            #[doc = "and is one of the values of the resize_edge enum. The compositor"]
            #[doc = "may use this information to update the surface position for"]
            #[doc = "example when dragging the top left corner. The compositor may also"]
            #[doc = "use this information to adapt its behavior, e.g. choose an"]
            #[doc = "appropriate cursor image."]
            async fn resize(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
                edges: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Set a maximum size for the window."]
            #[doc = ""]
            #[doc = "The client can specify a maximum size so that the compositor does"]
            #[doc = "not try to configure the window beyond this size."]
            #[doc = ""]
            #[doc = "The width and height arguments are in window geometry coordinates."]
            #[doc = "See xdg_surface.set_window_geometry."]
            #[doc = ""]
            #[doc = "Values set in this way are double-buffered, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "The compositor can use this information to allow or disallow"]
            #[doc = "different states like maximize or fullscreen and draw accurate"]
            #[doc = "animations."]
            #[doc = ""]
            #[doc = "Similarly, a tiling window manager may use this information to"]
            #[doc = "place and resize client windows in a more effective way."]
            #[doc = ""]
            #[doc = "The client should not rely on the compositor to obey the maximum"]
            #[doc = "size. The compositor may decide to ignore the values set by the"]
            #[doc = "client and request a larger size."]
            #[doc = ""]
            #[doc = "If never set, or a value of zero in the request, means that the"]
            #[doc = "client has no expected maximum size in the given dimension."]
            #[doc = "As a result, a client wishing to reset the maximum size"]
            #[doc = "to an unspecified state can use zero for width and height in the"]
            #[doc = "request."]
            #[doc = ""]
            #[doc = "Requesting a maximum size to be smaller than the minimum size of"]
            #[doc = "a surface is illegal and will result in a protocol error."]
            #[doc = ""]
            #[doc = "The width and height must be greater than or equal to zero. Using"]
            #[doc = "strictly negative values for width and height will result in the"]
            #[doc = "zxdg_shell_v6.invalid_surface_state error being raised."]
            async fn set_max_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Set a minimum size for the window."]
            #[doc = ""]
            #[doc = "The client can specify a minimum size so that the compositor does"]
            #[doc = "not try to configure the window below this size."]
            #[doc = ""]
            #[doc = "The width and height arguments are in window geometry coordinates."]
            #[doc = "See xdg_surface.set_window_geometry."]
            #[doc = ""]
            #[doc = "Values set in this way are double-buffered, see wl_surface.commit."]
            #[doc = ""]
            #[doc = "The compositor can use this information to allow or disallow"]
            #[doc = "different states like maximize or fullscreen and draw accurate"]
            #[doc = "animations."]
            #[doc = ""]
            #[doc = "Similarly, a tiling window manager may use this information to"]
            #[doc = "place and resize client windows in a more effective way."]
            #[doc = ""]
            #[doc = "The client should not rely on the compositor to obey the minimum"]
            #[doc = "size. The compositor may decide to ignore the values set by the"]
            #[doc = "client and request a smaller size."]
            #[doc = ""]
            #[doc = "If never set, or a value of zero in the request, means that the"]
            #[doc = "client has no expected minimum size in the given dimension."]
            #[doc = "As a result, a client wishing to reset the minimum size"]
            #[doc = "to an unspecified state can use zero for width and height in the"]
            #[doc = "request."]
            #[doc = ""]
            #[doc = "Requesting a minimum size to be larger than the maximum size of"]
            #[doc = "a surface is illegal and will result in a protocol error."]
            #[doc = ""]
            #[doc = "The width and height must be greater than or equal to zero. Using"]
            #[doc = "strictly negative values for width and height will result in the"]
            #[doc = "zxdg_shell_v6.invalid_surface_state error being raised."]
            async fn set_min_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Maximize the surface."]
            #[doc = ""]
            #[doc = "After requesting that the surface should be maximized, the compositor"]
            #[doc = "will respond by emitting a configure event with the \"maximized\" state"]
            #[doc = "and the required window geometry. The client should then update its"]
            #[doc = "content, drawing it in a maximized state, i.e. without shadow or other"]
            #[doc = "decoration outside of the window geometry. The client must also"]
            #[doc = "acknowledge the configure when committing the new content (see"]
            #[doc = "ack_configure)."]
            #[doc = ""]
            #[doc = "It is up to the compositor to decide how and where to maximize the"]
            #[doc = "surface, for example which output and what region of the screen should"]
            #[doc = "be used."]
            #[doc = ""]
            #[doc = "If the surface was already maximized, the compositor will still emit"]
            #[doc = "a configure event with the \"maximized\" state."]
            #[doc = ""]
            #[doc = "Note that unrelated compositor side state changes may cause"]
            #[doc = "configure events to be emitted at any time, meaning trying to"]
            #[doc = "match this request to a specific future configure event is"]
            #[doc = "futile."]
            async fn set_maximized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Unmaximize the surface."]
            #[doc = ""]
            #[doc = "After requesting that the surface should be unmaximized, the compositor"]
            #[doc = "will respond by emitting a configure event without the \"maximized\""]
            #[doc = "state. If available, the compositor will include the window geometry"]
            #[doc = "dimensions the window had prior to being maximized in the configure"]
            #[doc = "request. The client must then update its content, drawing it in a"]
            #[doc = "regular state, i.e. potentially with shadow, etc. The client must also"]
            #[doc = "acknowledge the configure when committing the new content (see"]
            #[doc = "ack_configure)."]
            #[doc = ""]
            #[doc = "It is up to the compositor to position the surface after it was"]
            #[doc = "unmaximized; usually the position the surface had before maximizing, if"]
            #[doc = "applicable."]
            #[doc = ""]
            #[doc = "If the surface was already not maximized, the compositor will still"]
            #[doc = "emit a configure event without the \"maximized\" state."]
            #[doc = ""]
            #[doc = "Note that unrelated changes in the state of compositor may cause"]
            #[doc = "configure events to be emitted by the compositor between processing"]
            #[doc = "this request and emitting corresponding configure event, so trying"]
            #[doc = "to match the request with the event is futile."]
            async fn unset_maximized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Make the surface fullscreen."]
            #[doc = ""]
            #[doc = "You can specify an output that you would prefer to be fullscreen."]
            #[doc = "If this value is NULL, it's up to the compositor to choose which"]
            #[doc = "display will be used to map this surface."]
            #[doc = ""]
            #[doc = "If the surface doesn't cover the whole output, the compositor will"]
            #[doc = "position the surface in the center of the output and compensate with"]
            #[doc = "black borders filling the rest of the output."]
            async fn set_fullscreen(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            async fn unset_fullscreen(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Request that the compositor minimize your surface. There is no"]
            #[doc = "way to know if the surface is currently minimized, nor is there"]
            #[doc = "any way to unset minimization on this surface."]
            #[doc = ""]
            #[doc = "If you are looking to throttle redrawing when minimized, please"]
            #[doc = "instead use the wl_surface.frame event for this, as this will"]
            #[doc = "also work with live previews on windows in Alt-Tab, Expose or"]
            #[doc = "similar compositor features."]
            async fn set_minimized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This configure event asks the client to resize its toplevel surface or"]
            #[doc = "to change its state. The configured state should not be applied"]
            #[doc = "immediately. See xdg_surface.configure for details."]
            #[doc = ""]
            #[doc = "The width and height arguments specify a hint to the window"]
            #[doc = "about how its surface should be resized in window geometry"]
            #[doc = "coordinates. See set_window_geometry."]
            #[doc = ""]
            #[doc = "If the width or height arguments are zero, it means the client"]
            #[doc = "should decide its own window dimension. This may happen when the"]
            #[doc = "compositor needs to configure the state of the surface but doesn't"]
            #[doc = "have any information about any previous or expected dimension."]
            #[doc = ""]
            #[doc = "The states listed in the event specify how the width/height"]
            #[doc = "arguments should be interpreted, and possibly how it should be"]
            #[doc = "drawn."]
            #[doc = ""]
            #[doc = "Clients must send an ack_configure in response to this event. See"]
            #[doc = "xdg_surface.configure and xdg_surface.ack_configure for details."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
                states: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_toplevel_v6#{}.configure()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(width)
                    .put_int(height)
                    .put_array(states)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The close event is sent by the compositor when the user"]
            #[doc = "wants the surface to be closed. This should be equivalent to"]
            #[doc = "the user clicking the close button in client-side decorations,"]
            #[doc = "if your application has any."]
            #[doc = ""]
            #[doc = "This is only a request that the user intends to close the"]
            #[doc = "window. The client may choose to ignore this request, or show"]
            #[doc = "a dialog to ask the user to save their data, etc."]
            async fn close(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_toplevel_v6#{}.close()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A popup surface is a short-lived, temporary surface. It can be used to"]
    #[doc = "implement for example menus, popovers, tooltips and other similar user"]
    #[doc = "interface concepts."]
    #[doc = ""]
    #[doc = "A popup can be made to take an explicit grab. See xdg_popup.grab for"]
    #[doc = "details."]
    #[doc = ""]
    #[doc = "When the popup is dismissed, a popup_done event will be sent out, and at"]
    #[doc = "the same time the surface will be unmapped. See the xdg_popup.popup_done"]
    #[doc = "event for details."]
    #[doc = ""]
    #[doc = "Explicitly destroying the xdg_popup object will also dismiss the popup and"]
    #[doc = "unmap the surface. Clients that want to dismiss the popup when another"]
    #[doc = "surface of their own is clicked should dismiss the popup using the destroy"]
    #[doc = "request."]
    #[doc = ""]
    #[doc = "The parent surface must have either the xdg_toplevel or xdg_popup surface"]
    #[doc = "role."]
    #[doc = ""]
    #[doc = "A newly created xdg_popup will be stacked on top of all previously created"]
    #[doc = "xdg_popup surfaces associated with the same xdg_toplevel."]
    #[doc = ""]
    #[doc = "The parent of an xdg_popup must be mapped (see the xdg_surface"]
    #[doc = "description) before the xdg_popup itself."]
    #[doc = ""]
    #[doc = "The x and y arguments passed when creating the popup object specify"]
    #[doc = "where the top left of the popup should be placed, relative to the"]
    #[doc = "local surface coordinates of the parent surface. See"]
    #[doc = "xdg_surface.get_popup. An xdg_popup must intersect with or be at least"]
    #[doc = "partially adjacent to its parent surface."]
    #[doc = ""]
    #[doc = "The client must call wl_surface.commit on the corresponding wl_surface"]
    #[doc = "for the xdg_popup state to take effect."]
    pub mod zxdg_popup_v6 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "tried to grab after being mapped"]
            InvalidGrab = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidGrab),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zxdg_popup_v6 interface. See the module level documentation for more info"]
        pub trait ZxdgPopupV6: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_popup_v6";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zxdg_popup_v6#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zxdg_popup_v6#{}.grab()", object.id);
                        self.grab(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This destroys the popup. Explicitly destroying the xdg_popup"]
            #[doc = "object will also dismiss the popup, and unmap the surface."]
            #[doc = ""]
            #[doc = "If this xdg_popup is not the \"topmost\" popup, a protocol error"]
            #[doc = "will be sent."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This request makes the created popup take an explicit grab. An explicit"]
            #[doc = "grab will be dismissed when the user dismisses the popup, or when the"]
            #[doc = "client destroys the xdg_popup. This can be done by the user clicking"]
            #[doc = "outside the surface, using the keyboard, or even locking the screen"]
            #[doc = "through closing the lid or a timeout."]
            #[doc = ""]
            #[doc = "If the compositor denies the grab, the popup will be immediately"]
            #[doc = "dismissed."]
            #[doc = ""]
            #[doc = "This request must be used in response to some sort of user action like a"]
            #[doc = "button press, key press, or touch down event. The serial number of the"]
            #[doc = "event should be passed as 'serial'."]
            #[doc = ""]
            #[doc = "The parent of a grabbing popup must either be an xdg_toplevel surface or"]
            #[doc = "another xdg_popup with an explicit grab. If the parent is another"]
            #[doc = "xdg_popup it means that the popups are nested, with this popup now being"]
            #[doc = "the topmost popup."]
            #[doc = ""]
            #[doc = "Nested popups must be destroyed in the reverse order they were created"]
            #[doc = "in, e.g. the only popup you are allowed to destroy at all times is the"]
            #[doc = "topmost one."]
            #[doc = ""]
            #[doc = "When compositors choose to dismiss a popup, they may dismiss every"]
            #[doc = "nested grabbing popup as well. When a compositor dismisses popups, it"]
            #[doc = "will follow the same dismissing order as required from the client."]
            #[doc = ""]
            #[doc = "The parent of a grabbing popup must either be another xdg_popup with an"]
            #[doc = "active explicit grab, or an xdg_popup or xdg_toplevel, if there are no"]
            #[doc = "explicit grabs already taken."]
            #[doc = ""]
            #[doc = "If the topmost grabbing popup is destroyed, the grab will be returned to"]
            #[doc = "the parent of the popup, if that parent previously had an explicit grab."]
            #[doc = ""]
            #[doc = "If the parent is a grabbing popup which has already been dismissed, this"]
            #[doc = "popup will be immediately dismissed. If the parent is a popup that did"]
            #[doc = "not take an explicit grab, an error will be raised."]
            #[doc = ""]
            #[doc = "During a popup grab, the client owning the grab will receive pointer"]
            #[doc = "and touch events for all their surfaces as normal (similar to an"]
            #[doc = "\"owner-events\" grab in X11 parlance), while the top most grabbing popup"]
            #[doc = "will always have keyboard focus."]
            async fn grab(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This event asks the popup surface to configure itself given the"]
            #[doc = "configuration. The configured state should not be applied immediately."]
            #[doc = "See xdg_surface.configure for details."]
            #[doc = ""]
            #[doc = "The x and y arguments represent the position the popup was placed at"]
            #[doc = "given the xdg_positioner rule, relative to the upper left corner of the"]
            #[doc = "window geometry of the parent surface."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_popup_v6#{}.configure()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(x)
                    .put_int(y)
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The popup_done event is sent out when a popup is dismissed by the"]
            #[doc = "compositor. The client should destroy the xdg_popup object at this"]
            #[doc = "point."]
            async fn popup_done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_popup_v6#{}.popup_done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "This protocol is application-specific to meet the needs of the X11"]
#[doc = "protocol through Xwayland. It provides a way for Xwayland to request"]
#[doc = "all keyboard events to be forwarded to a surface even when the"]
#[doc = "surface does not have keyboard focus."]
#[doc = ""]
#[doc = "In the X11 protocol, a client may request an \"active grab\" on the"]
#[doc = "keyboard. On success, all key events are reported only to the"]
#[doc = "grabbing X11 client. For details, see XGrabKeyboard(3)."]
#[doc = ""]
#[doc = "The core Wayland protocol does not have a notion of an active"]
#[doc = "keyboard grab. When running in Xwayland, X11 applications may"]
#[doc = "acquire an active grab inside Xwayland but that cannot be translated"]
#[doc = "to the Wayland compositor who may set the input focus to some other"]
#[doc = "surface. In doing so, it breaks the X11 client assumption that all"]
#[doc = "key events are reported to the grabbing client."]
#[doc = ""]
#[doc = "This protocol specifies a way for Xwayland to request all keyboard"]
#[doc = "be directed to the given surface. The protocol does not guarantee"]
#[doc = "that the compositor will honor this request and it does not"]
#[doc = "prescribe user interfaces on how to handle the respond. For example,"]
#[doc = "a compositor may inform the user that all key events are now"]
#[doc = "forwarded to the given client surface, or it may ask the user for"]
#[doc = "permission to do so."]
#[doc = ""]
#[doc = "Compositors are required to restrict access to this application"]
#[doc = "specific protocol to Xwayland alone."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and"]
#[doc = "backward incompatible changes may be made. Backward compatible"]
#[doc = "changes may be added together with the corresponding interface"]
#[doc = "version bump."]
#[doc = "Backward incompatible changes are done by bumping the version"]
#[doc = "number in the protocol and interface names and resetting the"]
#[doc = "interface version. Once the protocol is to be declared stable,"]
#[doc = "the 'z' prefix and the version number in the protocol and"]
#[doc = "interface names are removed and the interface version number is"]
#[doc = "reset."]
pub mod xwayland_keyboard_grab_unstable_v1 {
    #[doc = "A global interface used for grabbing the keyboard."]
    pub mod zwp_xwayland_keyboard_grab_manager_v1 {
        #[doc = "Trait to implement the zwp_xwayland_keyboard_grab_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZwpXwaylandKeyboardGrabManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_xwayland_keyboard_grab_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwp_xwayland_keyboard_grab_manager_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwp_xwayland_keyboard_grab_manager_v1#{}.grab_keyboard()",
                            object.id
                        );
                        self.grab_keyboard(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the keyboard grab manager."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The grab_keyboard request asks for a grab of the keyboard, forcing"]
            #[doc = "the keyboard focus for the given seat upon the given surface."]
            #[doc = ""]
            #[doc = "The protocol provides no guarantee that the grab is ever satisfied,"]
            #[doc = "and does not require the compositor to send an error if the grab"]
            #[doc = "cannot ever be satisfied. It is thus possible to request a keyboard"]
            #[doc = "grab that will never be effective."]
            #[doc = ""]
            #[doc = "The protocol:"]
            #[doc = ""]
            #[doc = "* does not guarantee that the grab itself is applied for a surface,"]
            #[doc = "the grab request may be silently ignored by the compositor,"]
            #[doc = "* does not guarantee that any events are sent to this client even"]
            #[doc = "if the grab is applied to a surface,"]
            #[doc = "* does not guarantee that events sent to this client are exhaustive,"]
            #[doc = "a compositor may filter some events for its own consumption,"]
            #[doc = "* does not guarantee that events sent to this client are continuous,"]
            #[doc = "a compositor may change and reroute keyboard events while the grab"]
            #[doc = "is nominally active."]
            async fn grab_keyboard(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "A global interface used for grabbing the keyboard."]
    pub mod zwp_xwayland_keyboard_grab_v1 {
        #[doc = "Trait to implement the zwp_xwayland_keyboard_grab_v1 interface. See the module level documentation for more info"]
        pub trait ZwpXwaylandKeyboardGrabV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_xwayland_keyboard_grab_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_xwayland_keyboard_grab_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the grabbed keyboard object. If applicable, the compositor"]
            #[doc = "will ungrab the keyboard."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
#[doc = "This protocol allows a privileged client to control data devices. In"]
#[doc = "particular, the client will be able to manage the current selection and take"]
#[doc = "the role of a clipboard manager."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and"]
#[doc = "backward incompatible changes may be made. Backward compatible changes"]
#[doc = "may be added together with the corresponding interface version bump."]
#[doc = "Backward incompatible changes are done by bumping the version number in"]
#[doc = "the protocol and interface names and resetting the interface version."]
#[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
#[doc = "version number in the protocol and interface names are removed and the"]
#[doc = "interface version number is reset."]
pub mod wlr_data_control_unstable_v1 {
    #[doc = "This interface is a manager that allows creating per-seat data device"]
    #[doc = "controls."]
    pub mod zwlr_data_control_manager_v1 {
        #[doc = "Trait to implement the zwlr_data_control_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrDataControlManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_data_control_manager_v1";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwlr_data_control_manager_v1#{}.create_data_source()",
                            object.id
                        );
                        self.create_data_source(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwlr_data_control_manager_v1#{}.get_data_device()",
                            object.id
                        );
                        self.get_data_device(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zwlr_data_control_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a new data source."]
            async fn create_data_source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Create a data device that can be used to manage a seat's selection."]
            async fn get_data_device(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "All objects created by the manager will still remain valid, until their"]
            #[doc = "appropriate destroy request has been called."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "This interface allows a client to manage a seat's selection."]
    #[doc = ""]
    #[doc = "When the seat is destroyed, this object becomes inert."]
    pub mod zwlr_data_control_device_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "source given to set_selection or set_primary_selection was already used before"]
            UsedSource = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::UsedSource),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwlr_data_control_device_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrDataControlDeviceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_data_control_device_v1";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwlr_data_control_device_v1#{}.set_selection()",
                            object.id
                        );
                        self.set_selection(object, client, message.object()?).await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_data_control_device_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    2u16 => {
                        tracing::debug!(
                            "zwlr_data_control_device_v1#{}.set_primary_selection()",
                            object.id
                        );
                        self.set_primary_selection(object, client, message.object()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request asks the compositor to set the selection to the data from"]
            #[doc = "the source on behalf of the client."]
            #[doc = ""]
            #[doc = "The given source may not be used in any further set_selection or"]
            #[doc = "set_primary_selection requests. Attempting to use a previously used"]
            #[doc = "source is a protocol error."]
            #[doc = ""]
            #[doc = "To unset the selection, set the source to NULL."]
            async fn set_selection(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys the data device object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This request asks the compositor to set the primary selection to the"]
            #[doc = "data from the source on behalf of the client."]
            #[doc = ""]
            #[doc = "The given source may not be used in any further set_selection or"]
            #[doc = "set_primary_selection requests. Attempting to use a previously used"]
            #[doc = "source is a protocol error."]
            #[doc = ""]
            #[doc = "To unset the primary selection, set the source to NULL."]
            #[doc = ""]
            #[doc = "The compositor will ignore this request if it does not support primary"]
            #[doc = "selection."]
            async fn set_primary_selection(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "The data_offer event introduces a new wlr_data_control_offer object,"]
            #[doc = "which will subsequently be used in either the"]
            #[doc = "wlr_data_control_device.selection event (for the regular clipboard"]
            #[doc = "selections) or the wlr_data_control_device.primary_selection event (for"]
            #[doc = "the primary clipboard selections). Immediately following the"]
            #[doc = "wlr_data_control_device.data_offer event, the new data_offer object"]
            #[doc = "will send out wlr_data_control_offer.offer events to describe the MIME"]
            #[doc = "types it offers."]
            async fn data_offer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_data_control_device_v1#{}.data_offer()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The selection event is sent out to notify the client of a new"]
            #[doc = "wlr_data_control_offer for the selection for this device. The"]
            #[doc = "wlr_data_control_device.data_offer and the wlr_data_control_offer.offer"]
            #[doc = "events are sent out immediately before this event to introduce the data"]
            #[doc = "offer object. The selection event is sent to a client when a new"]
            #[doc = "selection is set. The wlr_data_control_offer is valid until a new"]
            #[doc = "wlr_data_control_offer or NULL is received. The client must destroy the"]
            #[doc = "previous selection wlr_data_control_offer, if any, upon receiving this"]
            #[doc = "event."]
            #[doc = ""]
            #[doc = "The first selection event is sent upon binding the"]
            #[doc = "wlr_data_control_device object."]
            async fn selection(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_data_control_device_v1#{}.selection()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_object(id).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This data control object is no longer valid and should be destroyed by"]
            #[doc = "the client."]
            async fn finished(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_data_control_device_v1#{}.finished()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The primary_selection event is sent out to notify the client of a new"]
            #[doc = "wlr_data_control_offer for the primary selection for this device. The"]
            #[doc = "wlr_data_control_device.data_offer and the wlr_data_control_offer.offer"]
            #[doc = "events are sent out immediately before this event to introduce the data"]
            #[doc = "offer object. The primary_selection event is sent to a client when a"]
            #[doc = "new primary selection is set. The wlr_data_control_offer is valid until"]
            #[doc = "a new wlr_data_control_offer or NULL is received. The client must"]
            #[doc = "destroy the previous primary selection wlr_data_control_offer, if any,"]
            #[doc = "upon receiving this event."]
            #[doc = ""]
            #[doc = "If the compositor supports primary selection, the first"]
            #[doc = "primary_selection event is sent upon binding the"]
            #[doc = "wlr_data_control_device object."]
            async fn primary_selection(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwlr_data_control_device_v1#{}.primary_selection()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_object(id).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "The wlr_data_control_source object is the source side of a"]
    #[doc = "wlr_data_control_offer. It is created by the source client in a data"]
    #[doc = "transfer and provides a way to describe the offered data and a way to"]
    #[doc = "respond to requests to transfer the data."]
    pub mod zwlr_data_control_source_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "offer sent after wlr_data_control_device.set_selection"]
            InvalidOffer = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::InvalidOffer),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwlr_data_control_source_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrDataControlSourceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_data_control_source_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_data_control_source_v1#{}.offer()", object.id);
                        self.offer(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_data_control_source_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request adds a MIME type to the set of MIME types advertised to"]
            #[doc = "targets. Can be called several times to offer multiple types."]
            #[doc = ""]
            #[doc = "Calling this after wlr_data_control_device.set_selection is a protocol"]
            #[doc = "error."]
            async fn offer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys the data source object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Request for data from the client. Send the data as the specified MIME"]
            #[doc = "type over the passed file descriptor, then close it."]
            async fn send(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
                fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_data_control_source_v1#{}.send()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(mime_type))
                    .put_fd(fd)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This data source is no longer valid. The data source has been replaced"]
            #[doc = "by another data source."]
            #[doc = ""]
            #[doc = "The client should clean up and destroy this data source."]
            async fn cancelled(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_data_control_source_v1#{}.cancelled()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A wlr_data_control_offer represents a piece of data offered for transfer"]
    #[doc = "by another client (the source client). The offer describes the different"]
    #[doc = "MIME types that the data can be converted to and provides the mechanism"]
    #[doc = "for transferring the data directly from the source client."]
    pub mod zwlr_data_control_offer_v1 {
        #[doc = "Trait to implement the zwlr_data_control_offer_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrDataControlOfferV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_data_control_offer_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_data_control_offer_v1#{}.receive()", object.id);
                        self.receive(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.fd()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_data_control_offer_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "To transfer the offered data, the client issues this request and"]
            #[doc = "indicates the MIME type it wants to receive. The transfer happens"]
            #[doc = "through the passed file descriptor (typically created with the pipe"]
            #[doc = "system call). The source client writes the data in the MIME type"]
            #[doc = "representation requested and then closes the file descriptor."]
            #[doc = ""]
            #[doc = "The receiving client reads from the read end of the pipe until EOF and"]
            #[doc = "then closes its end, at which point the transfer is complete."]
            #[doc = ""]
            #[doc = "This request may happen multiple times for different MIME types."]
            async fn receive(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
                fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys the data offer object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sent immediately after creating the wlr_data_control_offer object."]
            #[doc = "One event per offered MIME type."]
            async fn offer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_data_control_offer_v1#{}.offer()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(mime_type))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "An interface to capture surfaces in an efficient way by exporting DMA-BUFs."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and"]
#[doc = "backward incompatible changes may be made. Backward compatible changes"]
#[doc = "may be added together with the corresponding interface version bump."]
#[doc = "Backward incompatible changes are done by bumping the version number in"]
#[doc = "the protocol and interface names and resetting the interface version."]
#[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
#[doc = "version number in the protocol and interface names are removed and the"]
#[doc = "interface version number is reset."]
pub mod wlr_export_dmabuf_unstable_v1 {
    #[doc = "This object is a manager with which to start capturing from sources."]
    pub mod zwlr_export_dmabuf_manager_v1 {
        #[doc = "Trait to implement the zwlr_export_dmabuf_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrExportDmabufManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_export_dmabuf_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwlr_export_dmabuf_manager_v1#{}.capture_output()",
                            object.id
                        );
                        self.capture_output(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_export_dmabuf_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Capture the next frame of an entire output."]
            async fn capture_output(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                frame: crate::wire::ObjectId,
                overlay_cursor: i32,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "All objects created by the manager will still remain valid, until their"]
            #[doc = "appropriate destroy request has been called."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "This object represents a single DMA-BUF frame."]
    #[doc = ""]
    #[doc = "If the capture is successful, the compositor will first send a \"frame\""]
    #[doc = "event, followed by one or several \"object\". When the frame is available"]
    #[doc = "for readout, the \"ready\" event is sent."]
    #[doc = ""]
    #[doc = "If the capture failed, the \"cancel\" event is sent. This can happen anytime"]
    #[doc = "before the \"ready\" event."]
    #[doc = ""]
    #[doc = "Once either a \"ready\" or a \"cancel\" event is received, the client should"]
    #[doc = "destroy the frame. Once an \"object\" event is received, the client is"]
    #[doc = "responsible for closing the associated file descriptor."]
    #[doc = ""]
    #[doc = "All frames are read-only and may not be written into or altered."]
    pub mod zwlr_export_dmabuf_frame_v1 {
        #[doc = "Special flags that should be respected by the client."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Flags {
            #[doc = "clients should copy frame before processing"]
            Transient = 1u32,
        }
        impl TryFrom<u32> for Flags {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::Transient),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Indicates reason for cancelling the frame."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum CancelReason {
            #[doc = "temporary error, source will produce more frames"]
            Temporary = 0u32,
            #[doc = "fatal error, source will not produce frames"]
            Permanent = 1u32,
            #[doc = "temporary error, source will produce more frames"]
            Resizing = 2u32,
        }
        impl TryFrom<u32> for CancelReason {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Temporary),
                    1u32 => Ok(Self::Permanent),
                    2u32 => Ok(Self::Resizing),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwlr_export_dmabuf_frame_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrExportDmabufFrameV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_export_dmabuf_frame_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_export_dmabuf_frame_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Unreferences the frame. This request must be called as soon as its no"]
            #[doc = "longer used."]
            #[doc = ""]
            #[doc = "It can be called at any time by the client. The client will still have"]
            #[doc = "to close any FDs it has been given."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Main event supplying the client with information about the frame. If the"]
            #[doc = "capture didn't fail, this event is always emitted first before any other"]
            #[doc = "events."]
            #[doc = ""]
            #[doc = "This event is followed by a number of \"object\" as specified by the"]
            #[doc = "\"num_objects\" argument."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: u32,
                height: u32,
                offset_x: u32,
                offset_y: u32,
                buffer_flags: u32,
                flags: Flags,
                format: u32,
                mod_high: u32,
                mod_low: u32,
                num_objects: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_export_dmabuf_frame_v1#{}.frame()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(width)
                    .put_uint(height)
                    .put_uint(offset_x)
                    .put_uint(offset_y)
                    .put_uint(buffer_flags)
                    .put_uint(flags as u32)
                    .put_uint(format)
                    .put_uint(mod_high)
                    .put_uint(mod_low)
                    .put_uint(num_objects)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Event which serves to supply the client with the file descriptors"]
            #[doc = "containing the data for each object."]
            #[doc = ""]
            #[doc = "After receiving this event, the client must always close the file"]
            #[doc = "descriptor as soon as they're done with it and even if the frame fails."]
            async fn object(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: u32,
                fd: rustix::fd::OwnedFd,
                size: u32,
                offset: u32,
                stride: u32,
                plane_index: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_export_dmabuf_frame_v1#{}.object()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(index)
                    .put_fd(fd)
                    .put_uint(size)
                    .put_uint(offset)
                    .put_uint(stride)
                    .put_uint(plane_index)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent as soon as the frame is presented, indicating it is"]
            #[doc = "available for reading. This event includes the time at which"]
            #[doc = "presentation happened at."]
            #[doc = ""]
            #[doc = "The timestamp is expressed as tv_sec_hi, tv_sec_lo, tv_nsec triples,"]
            #[doc = "each component being an unsigned 32-bit value. Whole seconds are in"]
            #[doc = "tv_sec which is a 64-bit value combined from tv_sec_hi and tv_sec_lo,"]
            #[doc = "and the additional fractional part in tv_nsec as nanoseconds. Hence,"]
            #[doc = "for valid timestamps tv_nsec must be in [0, 999999999]. The seconds part"]
            #[doc = "may have an arbitrary offset at start."]
            #[doc = ""]
            #[doc = "After receiving this event, the client should destroy this object."]
            async fn ready(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tv_sec_hi: u32,
                tv_sec_lo: u32,
                tv_nsec: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_export_dmabuf_frame_v1#{}.ready()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(tv_sec_hi)
                    .put_uint(tv_sec_lo)
                    .put_uint(tv_nsec)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "If the capture failed or if the frame is no longer valid after the"]
            #[doc = "\"frame\" event has been emitted, this event will be used to inform the"]
            #[doc = "client to scrap the frame."]
            #[doc = ""]
            #[doc = "If the failure is temporary, the client may capture again the same"]
            #[doc = "source. If the failure is permanent, any further attempts to capture the"]
            #[doc = "same source will fail again."]
            #[doc = ""]
            #[doc = "After receiving this event, the client should destroy this object."]
            async fn cancel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                reason: CancelReason,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_export_dmabuf_frame_v1#{}.cancel()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(reason as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod wlr_foreign_toplevel_management_unstable_v1 {
    #[doc = "The purpose of this protocol is to enable the creation of taskbars"]
    #[doc = "and docks by providing them with a list of opened applications and"]
    #[doc = "letting them request certain actions on them, like maximizing, etc."]
    #[doc = ""]
    #[doc = "After a client binds the zwlr_foreign_toplevel_manager_v1, each opened"]
    #[doc = "toplevel window will be sent via the toplevel event"]
    pub mod zwlr_foreign_toplevel_manager_v1 {
        #[doc = "Trait to implement the zwlr_foreign_toplevel_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrForeignToplevelManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_foreign_toplevel_manager_v1";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_foreign_toplevel_manager_v1#{}.stop()", object.id);
                        self.stop(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Indicates the client no longer wishes to receive events for new toplevels."]
            #[doc = "However the compositor may emit further toplevel_created events, until"]
            #[doc = "the finished event is emitted."]
            #[doc = ""]
            #[doc = "The client must not send any more requests after this one."]
            async fn stop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is emitted whenever a new toplevel window is created. It"]
            #[doc = "is emitted for all toplevels, regardless of the app that has created"]
            #[doc = "them."]
            #[doc = ""]
            #[doc = "All initial details of the toplevel(title, app_id, states, etc.) will"]
            #[doc = "be sent immediately after this event via the corresponding events in"]
            #[doc = "zwlr_foreign_toplevel_handle_v1."]
            async fn toplevel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                toplevel: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwlr_foreign_toplevel_manager_v1#{}.toplevel()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(toplevel))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates that the compositor is done sending events to the"]
            #[doc = "zwlr_foreign_toplevel_manager_v1. The server will destroy the object"]
            #[doc = "immediately after sending this request, so it will become invalid and"]
            #[doc = "the client should free any resources associated with it."]
            async fn finished(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwlr_foreign_toplevel_manager_v1#{}.finished()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A zwlr_foreign_toplevel_handle_v1 object represents an opened toplevel"]
    #[doc = "window. Each app may have multiple opened toplevels."]
    #[doc = ""]
    #[doc = "Each toplevel has a list of outputs it is visible on, conveyed to the"]
    #[doc = "client with the output_enter and output_leave events."]
    pub mod zwlr_foreign_toplevel_handle_v1 {
        #[doc = "The different states that a toplevel can have. These have the same meaning"]
        #[doc = "as the states with the same names defined in xdg-toplevel"]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum State {
            #[doc = "the toplevel is maximized"]
            Maximized = 0u32,
            #[doc = "the toplevel is minimized"]
            Minimized = 1u32,
            #[doc = "the toplevel is active"]
            Activated = 2u32,
            #[doc = "the toplevel is fullscreen"]
            Fullscreen = 3u32,
        }
        impl TryFrom<u32> for State {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Maximized),
                    1u32 => Ok(Self::Minimized),
                    2u32 => Ok(Self::Activated),
                    3u32 => Ok(Self::Fullscreen),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "the provided rectangle is invalid"]
            InvalidRectangle = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidRectangle),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwlr_foreign_toplevel_handle_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrForeignToplevelHandleV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_foreign_toplevel_handle_v1";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwlr_foreign_toplevel_handle_v1#{}.set_maximized()",
                            object.id
                        );
                        self.set_maximized(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwlr_foreign_toplevel_handle_v1#{}.unset_maximized()",
                            object.id
                        );
                        self.unset_maximized(object, client).await
                    }
                    2u16 => {
                        tracing::debug!(
                            "zwlr_foreign_toplevel_handle_v1#{}.set_minimized()",
                            object.id
                        );
                        self.set_minimized(object, client).await
                    }
                    3u16 => {
                        tracing::debug!(
                            "zwlr_foreign_toplevel_handle_v1#{}.unset_minimized()",
                            object.id
                        );
                        self.unset_minimized(object, client).await
                    }
                    4u16 => {
                        tracing::debug!("zwlr_foreign_toplevel_handle_v1#{}.activate()", object.id);
                        self.activate(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    5u16 => {
                        tracing::debug!("zwlr_foreign_toplevel_handle_v1#{}.close()", object.id);
                        self.close(object, client).await
                    }
                    6u16 => {
                        tracing::debug!(
                            "zwlr_foreign_toplevel_handle_v1#{}.set_rectangle()",
                            object.id
                        );
                        self.set_rectangle(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    7u16 => {
                        tracing::debug!("zwlr_foreign_toplevel_handle_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    8u16 => {
                        tracing::debug!(
                            "zwlr_foreign_toplevel_handle_v1#{}.set_fullscreen()",
                            object.id
                        );
                        self.set_fullscreen(object, client, message.object()?).await
                    }
                    9u16 => {
                        tracing::debug!(
                            "zwlr_foreign_toplevel_handle_v1#{}.unset_fullscreen()",
                            object.id
                        );
                        self.unset_fullscreen(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Requests that the toplevel be maximized. If the maximized state actually"]
            #[doc = "changes, this will be indicated by the state event."]
            async fn set_maximized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Requests that the toplevel be unmaximized. If the maximized state actually"]
            #[doc = "changes, this will be indicated by the state event."]
            async fn unset_maximized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Requests that the toplevel be minimized. If the minimized state actually"]
            #[doc = "changes, this will be indicated by the state event."]
            async fn set_minimized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Requests that the toplevel be unminimized. If the minimized state actually"]
            #[doc = "changes, this will be indicated by the state event."]
            async fn unset_minimized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Request that this toplevel be activated on the given seat."]
            #[doc = "There is no guarantee the toplevel will be actually activated."]
            async fn activate(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Send a request to the toplevel to close itself. The compositor would"]
            #[doc = "typically use a shell-specific method to carry out this request, for"]
            #[doc = "example by sending the xdg_toplevel.close event. However, this gives"]
            #[doc = "no guarantees the toplevel will actually be destroyed. If and when"]
            #[doc = "this happens, the zwlr_foreign_toplevel_handle_v1.closed event will"]
            #[doc = "be emitted."]
            async fn close(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The rectangle of the surface specified in this request corresponds to"]
            #[doc = "the place where the app using this protocol represents the given toplevel."]
            #[doc = "It can be used by the compositor as a hint for some operations, e.g"]
            #[doc = "minimizing. The client is however not required to set this, in which"]
            #[doc = "case the compositor is free to decide some default value."]
            #[doc = ""]
            #[doc = "If the client specifies more than one rectangle, only the last one is"]
            #[doc = "considered."]
            #[doc = ""]
            #[doc = "The dimensions are given in surface-local coordinates."]
            #[doc = "Setting width=height=0 removes the already-set rectangle."]
            async fn set_rectangle(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys the zwlr_foreign_toplevel_handle_v1 object."]
            #[doc = ""]
            #[doc = "This request should be called either when the client does not want to"]
            #[doc = "use the toplevel anymore or after the closed event to finalize the"]
            #[doc = "destruction of the object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Requests that the toplevel be fullscreened on the given output. If the"]
            #[doc = "fullscreen state and/or the outputs the toplevel is visible on actually"]
            #[doc = "change, this will be indicated by the state and output_enter/leave"]
            #[doc = "events."]
            #[doc = ""]
            #[doc = "The output parameter is only a hint to the compositor. Also, if output"]
            #[doc = "is NULL, the compositor should decide which output the toplevel will be"]
            #[doc = "fullscreened on, if at all."]
            async fn set_fullscreen(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Requests that the toplevel be unfullscreened. If the fullscreen state"]
            #[doc = "actually changes, this will be indicated by the state event."]
            async fn unset_fullscreen(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is emitted whenever the title of the toplevel changes."]
            async fn title(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                title: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_foreign_toplevel_handle_v1#{}.title()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(title))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is emitted whenever the app-id of the toplevel changes."]
            async fn app_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                app_id: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_foreign_toplevel_handle_v1#{}.app_id()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(app_id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is emitted whenever the toplevel becomes visible on"]
            #[doc = "the given output. A toplevel may be visible on multiple outputs."]
            async fn output_enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwlr_foreign_toplevel_handle_v1#{}.output_enter()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(output))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is emitted whenever the toplevel stops being visible on"]
            #[doc = "the given output. It is guaranteed that an entered-output event"]
            #[doc = "with the same output has been emitted before this event."]
            async fn output_leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwlr_foreign_toplevel_handle_v1#{}.output_leave()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(output))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is emitted immediately after the zlw_foreign_toplevel_handle_v1"]
            #[doc = "is created and each time the toplevel state changes, either because of a"]
            #[doc = "compositor action or because of a request in this protocol."]
            async fn state(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                state: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_foreign_toplevel_handle_v1#{}.state()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_array(state).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent after all changes in the toplevel state have been"]
            #[doc = "sent."]
            #[doc = ""]
            #[doc = "This allows changes to the zwlr_foreign_toplevel_handle_v1 properties"]
            #[doc = "to be seen as atomic, even if they happen via multiple events."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_foreign_toplevel_handle_v1#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event means the toplevel has been destroyed. It is guaranteed there"]
            #[doc = "won't be any more events for this zwlr_foreign_toplevel_handle_v1. The"]
            #[doc = "toplevel itself becomes inert so any requests will be ignored except the"]
            #[doc = "destroy request."]
            async fn closed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_foreign_toplevel_handle_v1#{}.closed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 6u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is emitted whenever the parent of the toplevel changes."]
            #[doc = ""]
            #[doc = "No event is emitted when the parent handle is destroyed by the client."]
            async fn parent(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                parent: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_foreign_toplevel_handle_v1#{}.parent()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(parent)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 7u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "This protocol allows a privileged client to set the gamma tables for"]
#[doc = "outputs."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and"]
#[doc = "backward incompatible changes may be made. Backward compatible changes"]
#[doc = "may be added together with the corresponding interface version bump."]
#[doc = "Backward incompatible changes are done by bumping the version number in"]
#[doc = "the protocol and interface names and resetting the interface version."]
#[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
#[doc = "version number in the protocol and interface names are removed and the"]
#[doc = "interface version number is reset."]
pub mod wlr_gamma_control_unstable_v1 {
    #[doc = "This interface is a manager that allows creating per-output gamma"]
    #[doc = "controls."]
    pub mod zwlr_gamma_control_manager_v1 {
        #[doc = "Trait to implement the zwlr_gamma_control_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrGammaControlManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_gamma_control_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwlr_gamma_control_manager_v1#{}.get_gamma_control()",
                            object.id
                        );
                        self.get_gamma_control(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_gamma_control_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a gamma control that can be used to adjust gamma tables for the"]
            #[doc = "provided output."]
            async fn get_gamma_control(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "All objects created by the manager will still remain valid, until their"]
            #[doc = "appropriate destroy request has been called."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "This interface allows a client to adjust gamma tables for a particular"]
    #[doc = "output."]
    #[doc = ""]
    #[doc = "The client will receive the gamma size, and will then be able to set gamma"]
    #[doc = "tables. At any time the compositor can send a failed event indicating that"]
    #[doc = "this object is no longer valid."]
    #[doc = ""]
    #[doc = "There can only be at most one gamma control object per output, which"]
    #[doc = "has exclusive access to this particular output. When the gamma control"]
    #[doc = "object is destroyed, the gamma table is restored to its original value."]
    pub mod zwlr_gamma_control_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "invalid gamma tables"]
            InvalidGamma = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::InvalidGamma),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwlr_gamma_control_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrGammaControlV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_gamma_control_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_gamma_control_v1#{}.set_gamma()", object.id);
                        self.set_gamma(object, client, message.fd()?).await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_gamma_control_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Set the gamma table. The file descriptor can be memory-mapped to provide"]
            #[doc = "the raw gamma table, which contains successive gamma ramps for the red,"]
            #[doc = "green and blue channels. Each gamma ramp is an array of 16-byte unsigned"]
            #[doc = "integers which has the same length as the gamma size."]
            #[doc = ""]
            #[doc = "The file descriptor data must have the same length as three times the"]
            #[doc = "gamma size."]
            async fn set_gamma(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys the gamma control object. If the object is still valid, this"]
            #[doc = "restores the original gamma tables."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Advertise the size of each gamma ramp."]
            #[doc = ""]
            #[doc = "This event is sent immediately when the gamma control object is created."]
            async fn gamma_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                size: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_gamma_control_v1#{}.gamma_size()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(size).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates that the gamma control is no longer valid. This"]
            #[doc = "can happen for a number of reasons, including:"]
            #[doc = "- The output doesn't support gamma tables"]
            #[doc = "- Setting the gamma tables failed"]
            #[doc = "- Another client already has exclusive gamma control for this output"]
            #[doc = "- The compositor has transferred gamma control to another client"]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy this object."]
            async fn failed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_gamma_control_v1#{}.failed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod wlr_input_inhibit_unstable_v1 {
    #[doc = "Clients can use this interface to prevent input events from being sent to"]
    #[doc = "any surfaces but its own, which is useful for example in lock screen"]
    #[doc = "software. It is assumed that access to this interface will be locked down"]
    #[doc = "to whitelisted clients by the compositor."]
    #[doc = ""]
    #[doc = "Note! This protocol is deprecated and not intended for production use."]
    #[doc = "For screen lockers, use the ext-session-lock-v1 protocol."]
    pub mod zwlr_input_inhibit_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "an input inhibitor is already in use on the compositor"]
            AlreadyInhibited = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::AlreadyInhibited),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwlr_input_inhibit_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrInputInhibitManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_input_inhibit_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwlr_input_inhibit_manager_v1#{}.get_inhibitor()",
                            object.id
                        );
                        self.get_inhibitor(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Activates the input inhibitor. As long as the inhibitor is active, the"]
            #[doc = "compositor will not send input events to other clients."]
            async fn get_inhibitor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "While this resource exists, input to clients other than the owner of the"]
    #[doc = "inhibitor resource will not receive input events. Any client which"]
    #[doc = "previously had focus will receive a leave event and will not be given"]
    #[doc = "focus again. The client that owns this resource will receive all input"]
    #[doc = "events normally. The compositor will also disable all of its own input"]
    #[doc = "processing (such as keyboard shortcuts) while the inhibitor is active."]
    #[doc = ""]
    #[doc = "The compositor may continue to send input events to selected clients,"]
    #[doc = "such as an on-screen keyboard (via the input-method protocol)."]
    pub mod zwlr_input_inhibitor_v1 {
        #[doc = "Trait to implement the zwlr_input_inhibitor_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrInputInhibitorV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_input_inhibitor_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_input_inhibitor_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the inhibitor and allow other clients to receive input."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod wlr_layer_shell_unstable_v1 {
    #[doc = "Clients can use this interface to assign the surface_layer role to"]
    #[doc = "wl_surfaces. Such surfaces are assigned to a \"layer\" of the output and"]
    #[doc = "rendered with a defined z-depth respective to each other. They may also be"]
    #[doc = "anchored to the edges and corners of a screen and specify input handling"]
    #[doc = "semantics. This interface should be suitable for the implementation of"]
    #[doc = "many desktop shell components, and a broad number of other applications"]
    #[doc = "that interact with the desktop."]
    pub mod zwlr_layer_shell_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "wl_surface has another role"]
            Role = 0u32,
            #[doc = "layer value is invalid"]
            InvalidLayer = 1u32,
            #[doc = "wl_surface has a buffer attached or committed"]
            AlreadyConstructed = 2u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Role),
                    1u32 => Ok(Self::InvalidLayer),
                    2u32 => Ok(Self::AlreadyConstructed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "These values indicate which layers a surface can be rendered in. They"]
        #[doc = "are ordered by z depth, bottom-most first. Traditional shell surfaces"]
        #[doc = "will typically be rendered between the bottom and top layers."]
        #[doc = "Fullscreen shell surfaces are typically rendered at the top layer."]
        #[doc = "Multiple surfaces can share a single layer, and ordering within a"]
        #[doc = "single layer is undefined."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Layer {
            Background = 0u32,
            Bottom = 1u32,
            Top = 2u32,
            Overlay = 3u32,
        }
        impl TryFrom<u32> for Layer {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Background),
                    1u32 => Ok(Self::Bottom),
                    2u32 => Ok(Self::Top),
                    3u32 => Ok(Self::Overlay),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwlr_layer_shell_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrLayerShellV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_layer_shell_v1";
            const VERSION: u32 = 5u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_layer_shell_v1#{}.get_layer_surface()", object.id);
                        self.get_layer_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.object()?,
                            message.uint()?.try_into()?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_layer_shell_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a layer surface for an existing surface. This assigns the role of"]
            #[doc = "layer_surface, or raises a protocol error if another role is already"]
            #[doc = "assigned."]
            #[doc = ""]
            #[doc = "Creating a layer surface from a wl_surface which has a buffer attached"]
            #[doc = "or committed is a client error, and any attempts by a client to attach"]
            #[doc = "or manipulate a buffer prior to the first layer_surface.configure call"]
            #[doc = "must also be treated as errors."]
            #[doc = ""]
            #[doc = "After creating a layer_surface object and setting it up, the client"]
            #[doc = "must perform an initial commit without any buffer attached."]
            #[doc = "The compositor will reply with a layer_surface.configure event."]
            #[doc = "The client must acknowledge it and is then allowed to attach a buffer"]
            #[doc = "to map the surface."]
            #[doc = ""]
            #[doc = "You may pass NULL for output to allow the compositor to decide which"]
            #[doc = "output to use. Generally this will be the one that the user most"]
            #[doc = "recently interacted with."]
            #[doc = ""]
            #[doc = "Clients can specify a namespace that defines the purpose of the layer"]
            #[doc = "surface."]
            async fn get_layer_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
                output: Option<crate::wire::ObjectId>,
                layer: Layer,
                namespace: String,
            ) -> crate::server::Result<()>;
            #[doc = "This request indicates that the client will not use the layer_shell"]
            #[doc = "object any more. Objects that have been created through this instance"]
            #[doc = "are not affected."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "An interface that may be implemented by a wl_surface, for surfaces that"]
    #[doc = "are designed to be rendered as a layer of a stacked desktop-like"]
    #[doc = "environment."]
    #[doc = ""]
    #[doc = "Layer surface state (layer, size, anchor, exclusive zone,"]
    #[doc = "margin, interactivity) is double-buffered, and will be applied at the"]
    #[doc = "time wl_surface.commit of the corresponding wl_surface is called."]
    #[doc = ""]
    #[doc = "Attaching a null buffer to a layer surface unmaps it."]
    #[doc = ""]
    #[doc = "Unmapping a layer_surface means that the surface cannot be shown by the"]
    #[doc = "compositor until it is explicitly mapped again. The layer_surface"]
    #[doc = "returns to the state it had right after layer_shell.get_layer_surface."]
    #[doc = "The client can re-map the surface by performing a commit without any"]
    #[doc = "buffer attached, waiting for a configure event and handling it as usual."]
    pub mod zwlr_layer_surface_v1 {
        #[doc = "Types of keyboard interaction possible for layer shell surfaces. The"]
        #[doc = "rationale for this is twofold: (1) some applications are not interested"]
        #[doc = "in keyboard events and not allowing them to be focused can improve the"]
        #[doc = "desktop experience; (2) some applications will want to take exclusive"]
        #[doc = "keyboard focus."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum KeyboardInteractivity {
            None = 0u32,
            Exclusive = 1u32,
            OnDemand = 2u32,
        }
        impl TryFrom<u32> for KeyboardInteractivity {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::None),
                    1u32 => Ok(Self::Exclusive),
                    2u32 => Ok(Self::OnDemand),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "provided surface state is invalid"]
            InvalidSurfaceState = 0u32,
            #[doc = "size is invalid"]
            InvalidSize = 1u32,
            #[doc = "anchor bitfield is invalid"]
            InvalidAnchor = 2u32,
            #[doc = "keyboard interactivity is invalid"]
            InvalidKeyboardInteractivity = 3u32,
            #[doc = "exclusive edge is invalid given the surface anchors"]
            InvalidExclusiveEdge = 4u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidSurfaceState),
                    1u32 => Ok(Self::InvalidSize),
                    2u32 => Ok(Self::InvalidAnchor),
                    3u32 => Ok(Self::InvalidKeyboardInteractivity),
                    4u32 => Ok(Self::InvalidExclusiveEdge),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! { # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Anchor : u32 { # [doc = "the top edge of the anchor rectangle"] const Top = 1u32 ; # [doc = "the bottom edge of the anchor rectangle"] const Bottom = 2u32 ; # [doc = "the left edge of the anchor rectangle"] const Left = 4u32 ; # [doc = "the right edge of the anchor rectangle"] const Right = 8u32 ; } }
        impl TryFrom<u32> for Anchor {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "Trait to implement the zwlr_layer_surface_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrLayerSurfaceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_layer_surface_v1";
            const VERSION: u32 = 5u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.set_size()", object.id);
                        self.set_size(object, client, message.uint()?, message.uint()?)
                            .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.set_anchor()", object.id);
                        self.set_anchor(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    2u16 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.set_exclusive_zone()", object.id);
                        self.set_exclusive_zone(object, client, message.int()?)
                            .await
                    }
                    3u16 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.set_margin()", object.id);
                        self.set_margin(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!(
                            "zwlr_layer_surface_v1#{}.set_keyboard_interactivity()",
                            object.id
                        );
                        self.set_keyboard_interactivity(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    5u16 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.get_popup()", object.id);
                        self.get_popup(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    6u16 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.ack_configure()", object.id);
                        self.ack_configure(object, client, message.uint()?).await
                    }
                    7u16 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    8u16 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.set_layer()", object.id);
                        self.set_layer(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    9u16 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.set_exclusive_edge()", object.id);
                        self.set_exclusive_edge(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Sets the size of the surface in surface-local coordinates. The"]
            #[doc = "compositor will display the surface centered with respect to its"]
            #[doc = "anchors."]
            #[doc = ""]
            #[doc = "If you pass 0 for either value, the compositor will assign it and"]
            #[doc = "inform you of the assignment in the configure event. You must set your"]
            #[doc = "anchor to opposite edges in the dimensions you omit; not doing so is a"]
            #[doc = "protocol error. Both values are 0 by default."]
            #[doc = ""]
            #[doc = "Size is double-buffered, see wl_surface.commit."]
            async fn set_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: u32,
                height: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Requests that the compositor anchor the surface to the specified edges"]
            #[doc = "and corners. If two orthogonal edges are specified (e.g. 'top' and"]
            #[doc = "'left'), then the anchor point will be the intersection of the edges"]
            #[doc = "(e.g. the top left corner of the output); otherwise the anchor point"]
            #[doc = "will be centered on that edge, or in the center if none is specified."]
            #[doc = ""]
            #[doc = "Anchor is double-buffered, see wl_surface.commit."]
            async fn set_anchor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                anchor: Anchor,
            ) -> crate::server::Result<()>;
            #[doc = "Requests that the compositor avoids occluding an area with other"]
            #[doc = "surfaces. The compositor's use of this information is"]
            #[doc = "implementation-dependent - do not assume that this region will not"]
            #[doc = "actually be occluded."]
            #[doc = ""]
            #[doc = "A positive value is only meaningful if the surface is anchored to one"]
            #[doc = "edge or an edge and both perpendicular edges. If the surface is not"]
            #[doc = "anchored, anchored to only two perpendicular edges (a corner), anchored"]
            #[doc = "to only two parallel edges or anchored to all edges, a positive value"]
            #[doc = "will be treated the same as zero."]
            #[doc = ""]
            #[doc = "A positive zone is the distance from the edge in surface-local"]
            #[doc = "coordinates to consider exclusive."]
            #[doc = ""]
            #[doc = "Surfaces that do not wish to have an exclusive zone may instead specify"]
            #[doc = "how they should interact with surfaces that do. If set to zero, the"]
            #[doc = "surface indicates that it would like to be moved to avoid occluding"]
            #[doc = "surfaces with a positive exclusive zone. If set to -1, the surface"]
            #[doc = "indicates that it would not like to be moved to accommodate for other"]
            #[doc = "surfaces, and the compositor should extend it all the way to the edges"]
            #[doc = "it is anchored to."]
            #[doc = ""]
            #[doc = "For example, a panel might set its exclusive zone to 10, so that"]
            #[doc = "maximized shell surfaces are not shown on top of it. A notification"]
            #[doc = "might set its exclusive zone to 0, so that it is moved to avoid"]
            #[doc = "occluding the panel, but shell surfaces are shown underneath it. A"]
            #[doc = "wallpaper or lock screen might set their exclusive zone to -1, so that"]
            #[doc = "they stretch below or over the panel."]
            #[doc = ""]
            #[doc = "The default value is 0."]
            #[doc = ""]
            #[doc = "Exclusive zone is double-buffered, see wl_surface.commit."]
            async fn set_exclusive_zone(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                zone: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Requests that the surface be placed some distance away from the anchor"]
            #[doc = "point on the output, in surface-local coordinates. Setting this value"]
            #[doc = "for edges you are not anchored to has no effect."]
            #[doc = ""]
            #[doc = "The exclusive zone includes the margin."]
            #[doc = ""]
            #[doc = "Margin is double-buffered, see wl_surface.commit."]
            async fn set_margin(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                top: i32,
                right: i32,
                bottom: i32,
                left: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Set how keyboard events are delivered to this surface. By default,"]
            #[doc = "layer shell surfaces do not receive keyboard events; this request can"]
            #[doc = "be used to change this."]
            #[doc = ""]
            #[doc = "This setting is inherited by child surfaces set by the get_popup"]
            #[doc = "request."]
            #[doc = ""]
            #[doc = "Layer surfaces receive pointer, touch, and tablet events normally. If"]
            #[doc = "you do not want to receive them, set the input region on your surface"]
            #[doc = "to an empty region."]
            #[doc = ""]
            #[doc = "Keyboard interactivity is double-buffered, see wl_surface.commit."]
            async fn set_keyboard_interactivity(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                keyboard_interactivity: KeyboardInteractivity,
            ) -> crate::server::Result<()>;
            #[doc = "This assigns an xdg_popup's parent to this layer_surface.  This popup"]
            #[doc = "should have been created via xdg_surface::get_popup with the parent set"]
            #[doc = "to NULL, and this request must be invoked before committing the popup's"]
            #[doc = "initial state."]
            #[doc = ""]
            #[doc = "See the documentation of xdg_popup for more details about what an"]
            #[doc = "xdg_popup is and how it is used."]
            async fn get_popup(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                popup: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "When a configure event is received, if a client commits the"]
            #[doc = "surface in response to the configure event, then the client"]
            #[doc = "must make an ack_configure request sometime before the commit"]
            #[doc = "request, passing along the serial of the configure event."]
            #[doc = ""]
            #[doc = "If the client receives multiple configure events before it"]
            #[doc = "can respond to one, it only has to ack the last configure event."]
            #[doc = ""]
            #[doc = "A client is not required to commit immediately after sending"]
            #[doc = "an ack_configure request - it may even ack_configure several times"]
            #[doc = "before its next surface commit."]
            #[doc = ""]
            #[doc = "A client may send multiple ack_configure requests before committing, but"]
            #[doc = "only the last request sent before a commit indicates which configure"]
            #[doc = "event the client really is responding to."]
            async fn ack_configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This request destroys the layer surface."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Change the layer that the surface is rendered on."]
            #[doc = ""]
            #[doc = "Layer is double-buffered, see wl_surface.commit."]
            async fn set_layer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                layer: super::super::wlr_layer_shell_unstable_v1::zwlr_layer_shell_v1::Layer,
            ) -> crate::server::Result<()>;
            #[doc = "Requests an edge for the exclusive zone to apply. The exclusive"]
            #[doc = "edge will be automatically deduced from anchor points when possible,"]
            #[doc = "but when the surface is anchored to a corner, it will be necessary"]
            #[doc = "to set it explicitly to disambiguate, as it is not possible to deduce"]
            #[doc = "which one of the two corner edges should be used."]
            #[doc = ""]
            #[doc = "The edge must be one the surface is anchored to, otherwise the"]
            #[doc = "invalid_exclusive_edge protocol error will be raised."]
            async fn set_exclusive_edge(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                edge: Anchor,
            ) -> crate::server::Result<()>;
            #[doc = "The configure event asks the client to resize its surface."]
            #[doc = ""]
            #[doc = "Clients should arrange their surface for the new states, and then send"]
            #[doc = "an ack_configure request with the serial sent in this configure event at"]
            #[doc = "some point before committing the new surface."]
            #[doc = ""]
            #[doc = "The client is free to dismiss all but the last configure event it"]
            #[doc = "received."]
            #[doc = ""]
            #[doc = "The width and height arguments specify the size of the window in"]
            #[doc = "surface-local coordinates."]
            #[doc = ""]
            #[doc = "The size is a hint, in the sense that the client is free to ignore it if"]
            #[doc = "it doesn't resize, pick a smaller size (to satisfy aspect ratio or"]
            #[doc = "resize in steps of NxM pixels). If the client picks a smaller size and"]
            #[doc = "is anchored to two opposite anchors (e.g. 'top' and 'bottom'), the"]
            #[doc = "surface will be centered on this axis."]
            #[doc = ""]
            #[doc = "If the width or height arguments are zero, it means the client should"]
            #[doc = "decide its own window dimension."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                width: u32,
                height: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_layer_surface_v1#{}.configure()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(width)
                    .put_uint(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The closed event is sent by the compositor when the surface will no"]
            #[doc = "longer be shown. The output may have been destroyed or the user may"]
            #[doc = "have asked for it to be removed. Further changes to the surface will be"]
            #[doc = "ignored. The client should destroy the resource after receiving this"]
            #[doc = "event, and create a new surface if they so choose."]
            async fn closed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_layer_surface_v1#{}.closed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "This protocol exposes interfaces to obtain and modify output device"]
#[doc = "configuration."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and"]
#[doc = "backward incompatible changes may be made. Backward compatible changes"]
#[doc = "may be added together with the corresponding interface version bump."]
#[doc = "Backward incompatible changes are done by bumping the version number in"]
#[doc = "the protocol and interface names and resetting the interface version."]
#[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
#[doc = "version number in the protocol and interface names are removed and the"]
#[doc = "interface version number is reset."]
pub mod wlr_output_management_unstable_v1 {
    #[doc = "This interface is a manager that allows reading and writing the current"]
    #[doc = "output device configuration."]
    #[doc = ""]
    #[doc = "Output devices that display pixels (e.g. a physical monitor or a virtual"]
    #[doc = "output in a window) are represented as heads. Heads cannot be created nor"]
    #[doc = "destroyed by the client, but they can be enabled or disabled and their"]
    #[doc = "properties can be changed. Each head may have one or more available modes."]
    #[doc = ""]
    #[doc = "Whenever a head appears (e.g. a monitor is plugged in), it will be"]
    #[doc = "advertised via the head event. Immediately after the output manager is"]
    #[doc = "bound, all current heads are advertised."]
    #[doc = ""]
    #[doc = "Whenever a head's properties change, the relevant wlr_output_head events"]
    #[doc = "will be sent. Not all head properties will be sent: only properties that"]
    #[doc = "have changed need to."]
    #[doc = ""]
    #[doc = "Whenever a head disappears (e.g. a monitor is unplugged), a"]
    #[doc = "wlr_output_head.finished event will be sent."]
    #[doc = ""]
    #[doc = "After one or more heads appear, change or disappear, the done event will"]
    #[doc = "be sent. It carries a serial which can be used in a create_configuration"]
    #[doc = "request to update heads properties."]
    #[doc = ""]
    #[doc = "The information obtained from this protocol should only be used for output"]
    #[doc = "configuration purposes. This protocol is not designed to be a generic"]
    #[doc = "output property advertisement protocol for regular clients. Instead,"]
    #[doc = "protocols such as xdg-output should be used."]
    pub mod zwlr_output_manager_v1 {
        #[doc = "Trait to implement the zwlr_output_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrOutputManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_output_manager_v1";
            const VERSION: u32 = 4u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwlr_output_manager_v1#{}.create_configuration()",
                            object.id
                        );
                        self.create_configuration(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_output_manager_v1#{}.stop()", object.id);
                        self.stop(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a new output configuration object. This allows to update head"]
            #[doc = "properties."]
            async fn create_configuration(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Indicates the client no longer wishes to receive events for output"]
            #[doc = "configuration changes. However the compositor may emit further events,"]
            #[doc = "until the finished event is emitted."]
            #[doc = ""]
            #[doc = "The client must not send any more requests after this one."]
            async fn stop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event introduces a new head. This happens whenever a new head"]
            #[doc = "appears (e.g. a monitor is plugged in) or after the output manager is"]
            #[doc = "bound."]
            async fn head(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                head: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_manager_v1#{}.head()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(head))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent after all information has been sent after binding to"]
            #[doc = "the output manager object and after any subsequent changes. This applies"]
            #[doc = "to child head and mode objects as well. In other words, this event is"]
            #[doc = "sent whenever a head or mode is created or destroyed and whenever one of"]
            #[doc = "their properties has been changed. Not all state is re-sent each time"]
            #[doc = "the current configuration changes: only the actual changes are sent."]
            #[doc = ""]
            #[doc = "This allows changes to the output configuration to be seen as atomic,"]
            #[doc = "even if they happen via multiple events."]
            #[doc = ""]
            #[doc = "A serial is sent to be used in a future create_configuration request."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_manager_v1#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates that the compositor is done sending manager events."]
            #[doc = "The compositor will destroy the object immediately after sending this"]
            #[doc = "event, so it will become invalid and the client should release any"]
            #[doc = "resources associated with it."]
            async fn finished(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_manager_v1#{}.finished()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A head is an output device. The difference between a wl_output object and"]
    #[doc = "a head is that heads are advertised even if they are turned off. A head"]
    #[doc = "object only advertises properties and cannot be used directly to change"]
    #[doc = "them."]
    #[doc = ""]
    #[doc = "A head has some read-only properties: modes, name, description and"]
    #[doc = "physical_size. These cannot be changed by clients."]
    #[doc = ""]
    #[doc = "Other properties can be updated via a wlr_output_configuration object."]
    #[doc = ""]
    #[doc = "Properties sent via this interface are applied atomically via the"]
    #[doc = "wlr_output_manager.done event. No guarantees are made regarding the order"]
    #[doc = "in which properties are sent."]
    pub mod zwlr_output_head_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum AdaptiveSyncState {
            #[doc = "adaptive sync is disabled"]
            Disabled = 0u32,
            #[doc = "adaptive sync is enabled"]
            Enabled = 1u32,
        }
        impl TryFrom<u32> for AdaptiveSyncState {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Disabled),
                    1u32 => Ok(Self::Enabled),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwlr_output_head_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrOutputHeadV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_output_head_v1";
            const VERSION: u32 = 4u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_output_head_v1#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request indicates that the client will no longer use this head"]
            #[doc = "object."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event describes the head name."]
            #[doc = ""]
            #[doc = "The naming convention is compositor defined, but limited to alphanumeric"]
            #[doc = "characters and dashes (-). Each name is unique among all wlr_output_head"]
            #[doc = "objects, but if a wlr_output_head object is destroyed the same name may"]
            #[doc = "be reused later. The names will also remain consistent across sessions"]
            #[doc = "with the same hardware and software configuration."]
            #[doc = ""]
            #[doc = "Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do"]
            #[doc = "not assume that the name is a reflection of an underlying DRM"]
            #[doc = "connector, X11 connection, etc."]
            #[doc = ""]
            #[doc = "If the compositor implements the xdg-output protocol and this head is"]
            #[doc = "enabled, the xdg_output.name event must report the same name."]
            #[doc = ""]
            #[doc = "The name event is sent after a wlr_output_head object is created. This"]
            #[doc = "event is only sent once per object, and the name does not change over"]
            #[doc = "the lifetime of the wlr_output_head object."]
            async fn name(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.name()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(name))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event describes a human-readable description of the head."]
            #[doc = ""]
            #[doc = "The description is a UTF-8 string with no convention defined for its"]
            #[doc = "contents. Examples might include 'Foocorp 11\" Display' or 'Virtual X11"]
            #[doc = "output via :1'. However, do not assume that the name is a reflection of"]
            #[doc = "the make, model, serial of the underlying DRM connector or the display"]
            #[doc = "name of the underlying X11 connection, etc."]
            #[doc = ""]
            #[doc = "If the compositor implements xdg-output and this head is enabled,"]
            #[doc = "the xdg_output.description must report the same description."]
            #[doc = ""]
            #[doc = "The description event is sent after a wlr_output_head object is created."]
            #[doc = "This event is only sent once per object, and the description does not"]
            #[doc = "change over the lifetime of the wlr_output_head object."]
            async fn description(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                description: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.description()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(description))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event describes the physical size of the head. This event is only"]
            #[doc = "sent if the head has a physical size (e.g. is not a projector or a"]
            #[doc = "virtual device)."]
            async fn physical_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.physical_size()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event introduces a mode for this head. It is sent once per"]
            #[doc = "supported mode."]
            async fn mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mode: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.mode()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(mode))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event describes whether the head is enabled. A disabled head is not"]
            #[doc = "mapped to a region of the global compositor space."]
            #[doc = ""]
            #[doc = "When a head is disabled, some properties (current_mode, position,"]
            #[doc = "transform and scale) are irrelevant."]
            async fn enabled(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                enabled: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.enabled()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(enabled).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event describes the mode currently in use for this head. It is only"]
            #[doc = "sent if the output is enabled."]
            async fn current_mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mode: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.current_mode()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(mode))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This events describes the position of the head in the global compositor"]
            #[doc = "space. It is only sent if the output is enabled."]
            async fn position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.position()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(x)
                    .put_int(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 6u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event describes the transformation currently applied to the head."]
            #[doc = "It is only sent if the output is enabled."]
            async fn transform(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                transform: super::super::wayland::wl_output::Transform,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.transform()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(transform as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 7u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This events describes the scale of the head in the global compositor"]
            #[doc = "space. It is only sent if the output is enabled."]
            async fn scale(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                scale: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.scale()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_fixed(scale).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 8u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates that the head is no longer available. The head"]
            #[doc = "object becomes inert. Clients should send a destroy request and release"]
            #[doc = "any resources associated with it."]
            async fn finished(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.finished()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 9u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event describes the manufacturer of the head."]
            #[doc = ""]
            #[doc = "This must report the same make as the wl_output interface does in its"]
            #[doc = "geometry event."]
            #[doc = ""]
            #[doc = "Together with the model and serial_number events the purpose is to"]
            #[doc = "allow clients to recognize heads from previous sessions and for example"]
            #[doc = "load head-specific configurations back."]
            #[doc = ""]
            #[doc = "It is not guaranteed this event will be ever sent. A reason for that"]
            #[doc = "can be that the compositor does not have information about the make of"]
            #[doc = "the head or the definition of a make is not sensible in the current"]
            #[doc = "setup, for example in a virtual session. Clients can still try to"]
            #[doc = "identify the head by available information from other events but should"]
            #[doc = "be aware that there is an increased risk of false positives."]
            #[doc = ""]
            #[doc = "It is not recommended to display the make string in UI to users. For"]
            #[doc = "that the string provided by the description event should be preferred."]
            async fn make(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                make: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.make()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(make))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 10u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event describes the model of the head."]
            #[doc = ""]
            #[doc = "This must report the same model as the wl_output interface does in its"]
            #[doc = "geometry event."]
            #[doc = ""]
            #[doc = "Together with the make and serial_number events the purpose is to"]
            #[doc = "allow clients to recognize heads from previous sessions and for example"]
            #[doc = "load head-specific configurations back."]
            #[doc = ""]
            #[doc = "It is not guaranteed this event will be ever sent. A reason for that"]
            #[doc = "can be that the compositor does not have information about the model of"]
            #[doc = "the head or the definition of a model is not sensible in the current"]
            #[doc = "setup, for example in a virtual session. Clients can still try to"]
            #[doc = "identify the head by available information from other events but should"]
            #[doc = "be aware that there is an increased risk of false positives."]
            #[doc = ""]
            #[doc = "It is not recommended to display the model string in UI to users. For"]
            #[doc = "that the string provided by the description event should be preferred."]
            async fn model(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                model: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.model()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(model))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 11u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event describes the serial number of the head."]
            #[doc = ""]
            #[doc = "Together with the make and model events the purpose is to allow clients"]
            #[doc = "to recognize heads from previous sessions and for example load head-"]
            #[doc = "specific configurations back."]
            #[doc = ""]
            #[doc = "It is not guaranteed this event will be ever sent. A reason for that"]
            #[doc = "can be that the compositor does not have information about the serial"]
            #[doc = "number of the head or the definition of a serial number is not sensible"]
            #[doc = "in the current setup. Clients can still try to identify the head by"]
            #[doc = "available information from other events but should be aware that there"]
            #[doc = "is an increased risk of false positives."]
            #[doc = ""]
            #[doc = "It is not recommended to display the serial_number string in UI to"]
            #[doc = "users. For that the string provided by the description event should be"]
            #[doc = "preferred."]
            async fn serial_number(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial_number: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.serial_number()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(serial_number))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 12u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event describes whether adaptive sync is currently enabled for"]
            #[doc = "the head or not. Adaptive sync is also known as Variable Refresh"]
            #[doc = "Rate or VRR."]
            async fn adaptive_sync(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                state: AdaptiveSyncState,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.adaptive_sync()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(state as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 13u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "This object describes an output mode."]
    #[doc = ""]
    #[doc = "Some heads don't support output modes, in which case modes won't be"]
    #[doc = "advertised."]
    #[doc = ""]
    #[doc = "Properties sent via this interface are applied atomically via the"]
    #[doc = "wlr_output_manager.done event. No guarantees are made regarding the order"]
    #[doc = "in which properties are sent."]
    pub mod zwlr_output_mode_v1 {
        #[doc = "Trait to implement the zwlr_output_mode_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrOutputModeV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_output_mode_v1";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_output_mode_v1#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request indicates that the client will no longer use this mode"]
            #[doc = "object."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event describes the mode size. The size is given in physical"]
            #[doc = "hardware units of the output device. This is not necessarily the same as"]
            #[doc = "the output size in the global compositor space. For instance, the output"]
            #[doc = "may be scaled or transformed."]
            async fn size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_mode_v1#{}.size()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event describes the mode's fixed vertical refresh rate. It is only"]
            #[doc = "sent if the mode has a fixed refresh rate."]
            async fn refresh(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                refresh: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_mode_v1#{}.refresh()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(refresh).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event advertises this mode as preferred."]
            async fn preferred(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_mode_v1#{}.preferred()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates that the mode is no longer available. The mode"]
            #[doc = "object becomes inert. Clients should send a destroy request and release"]
            #[doc = "any resources associated with it."]
            async fn finished(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_mode_v1#{}.finished()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "This object is used by the client to describe a full output configuration."]
    #[doc = ""]
    #[doc = "First, the client needs to setup the output configuration. Each head can"]
    #[doc = "be either enabled (and configured) or disabled. It is a protocol error to"]
    #[doc = "send two enable_head or disable_head requests with the same head. It is a"]
    #[doc = "protocol error to omit a head in a configuration."]
    #[doc = ""]
    #[doc = "Then, the client can apply or test the configuration. The compositor will"]
    #[doc = "then reply with a succeeded, failed or cancelled event. Finally the client"]
    #[doc = "should destroy the configuration object."]
    pub mod zwlr_output_configuration_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "head has been configured twice"]
            AlreadyConfiguredHead = 1u32,
            #[doc = "head has not been configured"]
            UnconfiguredHead = 2u32,
            #[doc = "request sent after configuration has been applied or tested"]
            AlreadyUsed = 3u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::AlreadyConfiguredHead),
                    2u32 => Ok(Self::UnconfiguredHead),
                    3u32 => Ok(Self::AlreadyUsed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwlr_output_configuration_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrOutputConfigurationV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_output_configuration_v1";
            const VERSION: u32 = 4u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_output_configuration_v1#{}.enable_head()", object.id);
                        self.enable_head(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwlr_output_configuration_v1#{}.disable_head()",
                            object.id
                        );
                        self.disable_head(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zwlr_output_configuration_v1#{}.apply()", object.id);
                        self.apply(object, client).await
                    }
                    3u16 => {
                        tracing::debug!("zwlr_output_configuration_v1#{}.test()", object.id);
                        self.test(object, client).await
                    }
                    4u16 => {
                        tracing::debug!("zwlr_output_configuration_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Enable a head. This request creates a head configuration object that can"]
            #[doc = "be used to change the head's properties."]
            async fn enable_head(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                head: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Disable a head."]
            async fn disable_head(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                head: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Apply the new output configuration."]
            #[doc = ""]
            #[doc = "In case the configuration is successfully applied, there is no guarantee"]
            #[doc = "that the new output state matches completely the requested"]
            #[doc = "configuration. For instance, a compositor might round the scale if it"]
            #[doc = "doesn't support fractional scaling."]
            #[doc = ""]
            #[doc = "After this request has been sent, the compositor must respond with an"]
            #[doc = "succeeded, failed or cancelled event. Sending a request that isn't the"]
            #[doc = "destructor is a protocol error."]
            async fn apply(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Test the new output configuration. The configuration won't be applied,"]
            #[doc = "but will only be validated."]
            #[doc = ""]
            #[doc = "Even if the compositor succeeds to test a configuration, applying it may"]
            #[doc = "fail."]
            #[doc = ""]
            #[doc = "After this request has been sent, the compositor must respond with an"]
            #[doc = "succeeded, failed or cancelled event. Sending a request that isn't the"]
            #[doc = "destructor is a protocol error."]
            async fn test(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Using this request a client can tell the compositor that it is not going"]
            #[doc = "to use the configuration object anymore. Any changes to the outputs"]
            #[doc = "that have not been applied will be discarded."]
            #[doc = ""]
            #[doc = "This request also destroys wlr_output_configuration_head objects created"]
            #[doc = "via this object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sent after the compositor has successfully applied the changes or"]
            #[doc = "tested them."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy this object."]
            #[doc = ""]
            #[doc = "If the current configuration has changed, events to describe the changes"]
            #[doc = "will be sent followed by a wlr_output_manager.done event."]
            async fn succeeded(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_configuration_v1#{}.succeeded()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent if the compositor rejects the changes or failed to apply them. The"]
            #[doc = "compositor should revert any changes made by the apply request that"]
            #[doc = "triggered this event."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy this object."]
            async fn failed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_configuration_v1#{}.failed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent if the compositor cancels the configuration because the state of an"]
            #[doc = "output changed and the client has outdated information (e.g. after an"]
            #[doc = "output has been hotplugged)."]
            #[doc = ""]
            #[doc = "The client can create a new configuration with a newer serial and try"]
            #[doc = "again."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy this object."]
            async fn cancelled(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_configuration_v1#{}.cancelled()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "This object is used by the client to update a single head's configuration."]
    #[doc = ""]
    #[doc = "It is a protocol error to set the same property twice."]
    pub mod zwlr_output_configuration_head_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "property has already been set"]
            AlreadySet = 1u32,
            #[doc = "mode doesn't belong to head"]
            InvalidMode = 2u32,
            #[doc = "mode is invalid"]
            InvalidCustomMode = 3u32,
            #[doc = "transform value outside enum"]
            InvalidTransform = 4u32,
            #[doc = "scale negative or zero"]
            InvalidScale = 5u32,
            #[doc = "invalid enum value used in the set_adaptive_sync request"]
            InvalidAdaptiveSyncState = 6u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::AlreadySet),
                    2u32 => Ok(Self::InvalidMode),
                    3u32 => Ok(Self::InvalidCustomMode),
                    4u32 => Ok(Self::InvalidTransform),
                    5u32 => Ok(Self::InvalidScale),
                    6u32 => Ok(Self::InvalidAdaptiveSyncState),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwlr_output_configuration_head_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrOutputConfigurationHeadV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_output_configuration_head_v1";
            const VERSION: u32 = 4u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwlr_output_configuration_head_v1#{}.set_mode()",
                            object.id
                        );
                        self.set_mode(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwlr_output_configuration_head_v1#{}.set_custom_mode()",
                            object.id
                        );
                        self.set_custom_mode(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "zwlr_output_configuration_head_v1#{}.set_position()",
                            object.id
                        );
                        self.set_position(object, client, message.int()?, message.int()?)
                            .await
                    }
                    3u16 => {
                        tracing::debug!(
                            "zwlr_output_configuration_head_v1#{}.set_transform()",
                            object.id
                        );
                        self.set_transform(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    4u16 => {
                        tracing::debug!(
                            "zwlr_output_configuration_head_v1#{}.set_scale()",
                            object.id
                        );
                        self.set_scale(object, client, message.fixed()?).await
                    }
                    5u16 => {
                        tracing::debug!(
                            "zwlr_output_configuration_head_v1#{}.set_adaptive_sync()",
                            object.id
                        );
                        self.set_adaptive_sync(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request sets the head's mode."]
            async fn set_mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mode: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This request assigns a custom mode to the head. The size is given in"]
            #[doc = "physical hardware units of the output device. If set to zero, the"]
            #[doc = "refresh rate is unspecified."]
            #[doc = ""]
            #[doc = "It is a protocol error to set both a mode and a custom mode."]
            async fn set_custom_mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
                refresh: i32,
            ) -> crate::server::Result<()>;
            #[doc = "This request sets the head's position in the global compositor space."]
            async fn set_position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "This request sets the head's transform."]
            async fn set_transform(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                transform: super::super::wayland::wl_output::Transform,
            ) -> crate::server::Result<()>;
            #[doc = "This request sets the head's scale."]
            async fn set_scale(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                scale: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            #[doc = "This request enables/disables adaptive sync. Adaptive sync is also"]
            #[doc = "known as Variable Refresh Rate or VRR."]
            async fn set_adaptive_sync(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                state : super :: super :: wlr_output_management_unstable_v1 :: zwlr_output_head_v1 :: AdaptiveSyncState,
            ) -> crate::server::Result<()>;
        }
    }
}
#[doc = "This protocol allows clients to control power management modes"]
#[doc = "of outputs that are currently part of the compositor space. The"]
#[doc = "intent is to allow special clients like desktop shells to power"]
#[doc = "down outputs when the system is idle."]
#[doc = ""]
#[doc = "To modify outputs not currently part of the compositor space see"]
#[doc = "wlr-output-management."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and"]
#[doc = "backward incompatible changes may be made. Backward compatible changes"]
#[doc = "may be added together with the corresponding interface version bump."]
#[doc = "Backward incompatible changes are done by bumping the version number in"]
#[doc = "the protocol and interface names and resetting the interface version."]
#[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
#[doc = "version number in the protocol and interface names are removed and the"]
#[doc = "interface version number is reset."]
pub mod wlr_output_power_management_unstable_v1 {
    #[doc = "This interface is a manager that allows creating per-output power"]
    #[doc = "management mode controls."]
    pub mod zwlr_output_power_manager_v1 {
        #[doc = "Trait to implement the zwlr_output_power_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrOutputPowerManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_output_power_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwlr_output_power_manager_v1#{}.get_output_power()",
                            object.id
                        );
                        self.get_output_power(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_output_power_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create an output power management mode control that can be used to"]
            #[doc = "adjust the power management mode for a given output."]
            async fn get_output_power(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "All objects created by the manager will still remain valid, until their"]
            #[doc = "appropriate destroy request has been called."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "This object offers requests to set the power management mode of"]
    #[doc = "an output."]
    pub mod zwlr_output_power_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Mode {
            #[doc = "Output is turned off."]
            Off = 0u32,
            #[doc = "Output is turned on, no power saving"]
            On = 1u32,
        }
        impl TryFrom<u32> for Mode {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Off),
                    1u32 => Ok(Self::On),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "nonexistent power save mode"]
            InvalidMode = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::InvalidMode),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwlr_output_power_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrOutputPowerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_output_power_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_output_power_v1#{}.set_mode()", object.id);
                        self.set_mode(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_output_power_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Set an output's power save mode to the given mode. The mode change"]
            #[doc = "is effective immediately. If the output does not support the given"]
            #[doc = "mode a failed event is sent."]
            async fn set_mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mode: Mode,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys the output power management mode control object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Report the power management mode change of an output."]
            #[doc = ""]
            #[doc = "The mode event is sent after an output changed its power"]
            #[doc = "management mode. The reason can be a client using set_mode or the"]
            #[doc = "compositor deciding to change an output's mode."]
            #[doc = "This event is also sent immediately when the object is created"]
            #[doc = "so the client is informed about the current power management mode."]
            async fn mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mode: Mode,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_power_v1#{}.mode()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(mode as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates that the output power management mode control"]
            #[doc = "is no longer valid. This can happen for a number of reasons,"]
            #[doc = "including:"]
            #[doc = "- The output doesn't support power management"]
            #[doc = "- Another client already has exclusive power management mode control"]
            #[doc = "for this output"]
            #[doc = "- The output disappeared"]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy this object."]
            async fn failed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_power_v1#{}.failed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "This protocol allows clients to ask the compositor to copy part of the"]
#[doc = "screen content to a client buffer."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is experimental and"]
#[doc = "backward incompatible changes may be made. Backward compatible changes"]
#[doc = "may be added together with the corresponding interface version bump."]
#[doc = "Backward incompatible changes are done by bumping the version number in"]
#[doc = "the protocol and interface names and resetting the interface version."]
#[doc = "Once the protocol is to be declared stable, the 'z' prefix and the"]
#[doc = "version number in the protocol and interface names are removed and the"]
#[doc = "interface version number is reset."]
pub mod wlr_screencopy_unstable_v1 {
    #[doc = "This object is a manager which offers requests to start capturing from a"]
    #[doc = "source."]
    pub mod zwlr_screencopy_manager_v1 {
        #[doc = "Trait to implement the zwlr_screencopy_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrScreencopyManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_screencopy_manager_v1";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwlr_screencopy_manager_v1#{}.capture_output()",
                            object.id
                        );
                        self.capture_output(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zwlr_screencopy_manager_v1#{}.capture_output_region()",
                            object.id
                        );
                        self.capture_output_region(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zwlr_screencopy_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Capture the next frame of an entire output."]
            async fn capture_output(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                frame: crate::wire::ObjectId,
                overlay_cursor: i32,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Capture the next frame of an output's region."]
            #[doc = ""]
            #[doc = "The region is given in output logical coordinates, see"]
            #[doc = "xdg_output.logical_size. The region will be clipped to the output's"]
            #[doc = "extents."]
            async fn capture_output_region(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                frame: crate::wire::ObjectId,
                overlay_cursor: i32,
                output: crate::wire::ObjectId,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "All objects created by the manager will still remain valid, until their"]
            #[doc = "appropriate destroy request has been called."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "This object represents a single frame."]
    #[doc = ""]
    #[doc = "When created, a series of buffer events will be sent, each representing a"]
    #[doc = "supported buffer type. The \"buffer_done\" event is sent afterwards to"]
    #[doc = "indicate that all supported buffer types have been enumerated. The client"]
    #[doc = "will then be able to send a \"copy\" request. If the capture is successful,"]
    #[doc = "the compositor will send a \"flags\" followed by a \"ready\" event."]
    #[doc = ""]
    #[doc = "For objects version 2 or lower, wl_shm buffers are always supported, ie."]
    #[doc = "the \"buffer\" event is guaranteed to be sent."]
    #[doc = ""]
    #[doc = "If the capture failed, the \"failed\" event is sent. This can happen anytime"]
    #[doc = "before the \"ready\" event."]
    #[doc = ""]
    #[doc = "Once either a \"ready\" or a \"failed\" event is received, the client should"]
    #[doc = "destroy the frame."]
    pub mod zwlr_screencopy_frame_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "the object has already been used to copy a wl_buffer"]
            AlreadyUsed = 0u32,
            #[doc = "buffer attributes are invalid"]
            InvalidBuffer = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::AlreadyUsed),
                    1u32 => Ok(Self::InvalidBuffer),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! { # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Flags : u32 { # [doc = "contents are y-inverted"] const YInvert = 1u32 ; } }
        impl TryFrom<u32> for Flags {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "Trait to implement the zwlr_screencopy_frame_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrScreencopyFrameV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_screencopy_frame_v1";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_screencopy_frame_v1#{}.copy()", object.id);
                        self.copy(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_screencopy_frame_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    2u16 => {
                        tracing::debug!(
                            "zwlr_screencopy_frame_v1#{}.copy_with_damage()",
                            object.id
                        );
                        self.copy_with_damage(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Copy the frame to the supplied buffer. The buffer must have a the"]
            #[doc = "correct size, see zwlr_screencopy_frame_v1.buffer and"]
            #[doc = "zwlr_screencopy_frame_v1.linux_dmabuf. The buffer needs to have a"]
            #[doc = "supported format."]
            #[doc = ""]
            #[doc = "If the frame is successfully copied, a \"flags\" and a \"ready\" events are"]
            #[doc = "sent. Otherwise, a \"failed\" event is sent."]
            async fn copy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys the frame. This request can be sent at any time by the client."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Same as copy, except it waits until there is damage to copy."]
            async fn copy_with_damage(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Provides information about wl_shm buffer parameters that need to be"]
            #[doc = "used for this frame. This event is sent once after the frame is created"]
            #[doc = "if wl_shm buffers are supported."]
            async fn buffer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                format: super::super::wayland::wl_shm::Format,
                width: u32,
                height: u32,
                stride: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_screencopy_frame_v1#{}.buffer()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(format as u32)
                    .put_uint(width)
                    .put_uint(height)
                    .put_uint(stride)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Provides flags about the frame. This event is sent once before the"]
            #[doc = "\"ready\" event."]
            async fn flags(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                flags: Flags,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_screencopy_frame_v1#{}.flags()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(flags.bits())
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Called as soon as the frame is copied, indicating it is available"]
            #[doc = "for reading. This event includes the time at which presentation happened"]
            #[doc = "at."]
            #[doc = ""]
            #[doc = "The timestamp is expressed as tv_sec_hi, tv_sec_lo, tv_nsec triples,"]
            #[doc = "each component being an unsigned 32-bit value. Whole seconds are in"]
            #[doc = "tv_sec which is a 64-bit value combined from tv_sec_hi and tv_sec_lo,"]
            #[doc = "and the additional fractional part in tv_nsec as nanoseconds. Hence,"]
            #[doc = "for valid timestamps tv_nsec must be in [0, 999999999]. The seconds part"]
            #[doc = "may have an arbitrary offset at start."]
            #[doc = ""]
            #[doc = "After receiving this event, the client should destroy the object."]
            async fn ready(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tv_sec_hi: u32,
                tv_sec_lo: u32,
                tv_nsec: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_screencopy_frame_v1#{}.ready()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(tv_sec_hi)
                    .put_uint(tv_sec_lo)
                    .put_uint(tv_nsec)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates that the attempted frame copy has failed."]
            #[doc = ""]
            #[doc = "After receiving this event, the client should destroy the object."]
            async fn failed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_screencopy_frame_v1#{}.failed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent right before the ready event when copy_with_damage is"]
            #[doc = "requested. It may be generated multiple times for each copy_with_damage"]
            #[doc = "request."]
            #[doc = ""]
            #[doc = "The arguments describe a box around an area that has changed since the"]
            #[doc = "last copy request that was derived from the current screencopy manager"]
            #[doc = "instance."]
            #[doc = ""]
            #[doc = "The union of all regions received between the call to copy_with_damage"]
            #[doc = "and a ready event is the total damage since the prior ready event."]
            async fn damage(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: u32,
                y: u32,
                width: u32,
                height: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_screencopy_frame_v1#{}.damage()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(x)
                    .put_uint(y)
                    .put_uint(width)
                    .put_uint(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Provides information about linux-dmabuf buffer parameters that need to"]
            #[doc = "be used for this frame. This event is sent once after the frame is"]
            #[doc = "created if linux-dmabuf buffers are supported."]
            async fn linux_dmabuf(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                format: u32,
                width: u32,
                height: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_screencopy_frame_v1#{}.linux_dmabuf()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(format)
                    .put_uint(width)
                    .put_uint(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent once after all buffer events have been sent."]
            #[doc = ""]
            #[doc = "The client should proceed to create a buffer of one of the supported"]
            #[doc = "types, and send a \"copy\" request."]
            async fn buffer_done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_screencopy_frame_v1#{}.buffer_done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 6u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod wlr_virtual_pointer_unstable_v1 {
    #[doc = "This protocol allows clients to emulate a physical pointer device. The"]
    #[doc = "requests are mostly mirror opposites of those specified in wl_pointer."]
    pub mod zwlr_virtual_pointer_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "client sent invalid axis enumeration value"]
            InvalidAxis = 0u32,
            #[doc = "client sent invalid axis source enumeration value"]
            InvalidAxisSource = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidAxis),
                    1u32 => Ok(Self::InvalidAxisSource),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwlr_virtual_pointer_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrVirtualPointerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_virtual_pointer_v1";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.motion()", object.id);
                        self.motion(
                            object,
                            client,
                            message.uint()?,
                            message.fixed()?,
                            message.fixed()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.motion_absolute()", object.id);
                        self.motion_absolute(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.button()", object.id);
                        self.button(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.axis()", object.id);
                        self.axis(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?.try_into()?,
                            message.fixed()?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.frame()", object.id);
                        self.frame(object, client).await
                    }
                    5u16 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.axis_source()", object.id);
                        self.axis_source(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    6u16 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.axis_stop()", object.id);
                        self.axis_stop(object, client, message.uint()?, message.uint()?.try_into()?)
                            .await
                    }
                    7u16 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.axis_discrete()", object.id);
                        self.axis_discrete(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?.try_into()?,
                            message.fixed()?,
                            message.int()?,
                        )
                        .await
                    }
                    8u16 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "The pointer has moved by a relative amount to the previous request."]
            #[doc = ""]
            #[doc = "Values are in the global compositor space."]
            async fn motion(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                dx: crate::wire::Fixed,
                dy: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            #[doc = "The pointer has moved in an absolute coordinate frame."]
            #[doc = ""]
            #[doc = "Value of x can range from 0 to x_extent, value of y can range from 0"]
            #[doc = "to y_extent."]
            async fn motion_absolute(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                x: u32,
                y: u32,
                x_extent: u32,
                y_extent: u32,
            ) -> crate::server::Result<()>;
            #[doc = "A button was pressed or released."]
            async fn button(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                button: u32,
                state: super::super::wayland::wl_pointer::ButtonState,
            ) -> crate::server::Result<()>;
            #[doc = "Scroll and other axis requests."]
            async fn axis(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                axis: super::super::wayland::wl_pointer::Axis,
                value: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            #[doc = "Indicates the set of events that logically belong together."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Source information for scroll and other axis."]
            async fn axis_source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                axis_source: super::super::wayland::wl_pointer::AxisSource,
            ) -> crate::server::Result<()>;
            #[doc = "Stop notification for scroll and other axes."]
            async fn axis_stop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                axis: super::super::wayland::wl_pointer::Axis,
            ) -> crate::server::Result<()>;
            #[doc = "Discrete step information for scroll and other axes."]
            #[doc = ""]
            #[doc = "This event allows the client to extend data normally sent using the axis"]
            #[doc = "event with discrete value."]
            async fn axis_discrete(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                axis: super::super::wayland::wl_pointer::Axis,
                value: crate::wire::Fixed,
                discrete: i32,
            ) -> crate::server::Result<()>;
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "This object allows clients to create individual virtual pointer objects."]
    pub mod zwlr_virtual_pointer_manager_v1 {
        #[doc = "Trait to implement the zwlr_virtual_pointer_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZwlrVirtualPointerManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_virtual_pointer_manager_v1";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zwlr_virtual_pointer_manager_v1#{}.create_virtual_pointer()",
                            object.id
                        );
                        self.create_virtual_pointer(
                            object,
                            client,
                            message.object()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zwlr_virtual_pointer_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    2u16 => {
                        tracing :: debug ! ("zwlr_virtual_pointer_manager_v1#{}.create_virtual_pointer_with_output()" , object . id);
                        self.create_virtual_pointer_with_output(
                            object,
                            client,
                            message.object()?,
                            message.object()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Creates a new virtual pointer. The optional seat is a suggestion to the"]
            #[doc = "compositor."]
            async fn create_virtual_pointer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: Option<crate::wire::ObjectId>,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Creates a new virtual pointer. The seat and the output arguments are"]
            #[doc = "optional. If the seat argument is set, the compositor should assign the"]
            #[doc = "input device to the requested seat. If the output argument is set, the"]
            #[doc = "compositor should map the input device to the requested output."]
            async fn create_virtual_pointer_with_output(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: Option<crate::wire::ObjectId>,
                output: Option<crate::wire::ObjectId>,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod appmenu {
    #[doc = "This interface allows a client to link a window (or wl_surface) to an com.canonical.dbusmenu"]
    #[doc = "interface registered on DBus."]
    pub mod org_kde_kwin_appmenu_manager {
        #[doc = "Trait to implement the org_kde_kwin_appmenu_manager interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinAppmenuManager: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_appmenu_manager";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("org_kde_kwin_appmenu_manager#{}.create()", object.id);
                        self.create(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn create(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "The DBus service name and object path where the appmenu interface is present"]
    #[doc = "The object should be registered on the session bus before sending this request."]
    #[doc = "If not applicable, clients should remove this object."]
    pub mod org_kde_kwin_appmenu {
        #[doc = "Trait to implement the org_kde_kwin_appmenu interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinAppmenu: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_appmenu";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("org_kde_kwin_appmenu#{}.set_address()", object.id);
                        self.set_address(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("org_kde_kwin_appmenu#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Set or update the service name and object path."]
            #[doc = "Strings should be formatted in Latin-1 matching the relevant DBus specifications."]
            async fn set_address(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                service_name: String,
                object_path: String,
            ) -> crate::server::Result<()>;
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod blur {
    pub mod org_kde_kwin_blur_manager {
        #[doc = "Trait to implement the org_kde_kwin_blur_manager interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinBlurManager: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_blur_manager";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("org_kde_kwin_blur_manager#{}.create()", object.id);
                        self.create(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("org_kde_kwin_blur_manager#{}.unset()", object.id);
                        self.unset(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn create(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            async fn unset(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod org_kde_kwin_blur {
        #[doc = "Trait to implement the org_kde_kwin_blur interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinBlur: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_blur";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("org_kde_kwin_blur#{}.commit()", object.id);
                        self.commit(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("org_kde_kwin_blur#{}.set_region()", object.id);
                        self.set_region(object, client, message.object()?).await
                    }
                    2u16 => {
                        tracing::debug!("org_kde_kwin_blur#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn commit(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            async fn set_region(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                region: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod contrast {
    pub mod org_kde_kwin_contrast_manager {
        #[doc = "Trait to implement the org_kde_kwin_contrast_manager interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinContrastManager: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_contrast_manager";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("org_kde_kwin_contrast_manager#{}.create()", object.id);
                        self.create(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("org_kde_kwin_contrast_manager#{}.unset()", object.id);
                        self.unset(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn create(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            async fn unset(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod org_kde_kwin_contrast {
        #[doc = "Trait to implement the org_kde_kwin_contrast interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinContrast: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_contrast";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("org_kde_kwin_contrast#{}.commit()", object.id);
                        self.commit(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("org_kde_kwin_contrast#{}.set_region()", object.id);
                        self.set_region(object, client, message.object()?).await
                    }
                    2u16 => {
                        tracing::debug!("org_kde_kwin_contrast#{}.set_contrast()", object.id);
                        self.set_contrast(object, client, message.fixed()?).await
                    }
                    3u16 => {
                        tracing::debug!("org_kde_kwin_contrast#{}.set_intensity()", object.id);
                        self.set_intensity(object, client, message.fixed()?).await
                    }
                    4u16 => {
                        tracing::debug!("org_kde_kwin_contrast#{}.set_saturation()", object.id);
                        self.set_saturation(object, client, message.fixed()?).await
                    }
                    5u16 => {
                        tracing::debug!("org_kde_kwin_contrast#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    6u16 => {
                        tracing::debug!("org_kde_kwin_contrast#{}.set_frost()", object.id);
                        self.set_frost(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    7u16 => {
                        tracing::debug!("org_kde_kwin_contrast#{}.unset_frost()", object.id);
                        self.unset_frost(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn commit(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            async fn set_region(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                region: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            async fn set_contrast(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                contrast: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            async fn set_intensity(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                intensity: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            async fn set_saturation(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                saturation: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "enables 'frost' variant of contrast effect."]
            #[doc = ""]
            #[doc = "'frost' is an enhanced version of the contrast effect that"]
            #[doc = "uses different colour arithmetic to get backgrounds simultaneously"]
            #[doc = "higher in contrast and (apparent) transparency."]
            #[doc = ""]
            #[doc = "r, g, b, a are channels from 0-255, indicating a colour to use in contrast calculation."]
            #[doc = "should be based off of the \"main\" background colour of the surface."]
            async fn set_frost(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                red: i32,
                green: i32,
                blue: i32,
                alpha: i32,
            ) -> crate::server::Result<()>;
            async fn unset_frost(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod fullscreen_shell {
    #[doc = "Displays a single surface per output."]
    #[doc = ""]
    #[doc = "This interface provides a mechanism for a single client to display"]
    #[doc = "simple full-screen surfaces.  While there technically may be multiple"]
    #[doc = "clients bound to this interface, only one of those clients should be"]
    #[doc = "shown at a time."]
    #[doc = ""]
    #[doc = "To present a surface, the client uses either the present_surface or"]
    #[doc = "present_surface_for_mode requests.  Presenting a surface takes effect"]
    #[doc = "on the next wl_surface.commit.  See the individual requests for"]
    #[doc = "details about scaling and mode switches."]
    #[doc = ""]
    #[doc = "The client can have at most one surface per output at any time."]
    #[doc = "Requesting a surface be presented on an output that already has a"]
    #[doc = "surface replaces the previously presented surface.  Presenting a null"]
    #[doc = "surface removes its content and effectively disables the output."]
    #[doc = "Exactly what happens when an output is \"disabled\" is"]
    #[doc = "compositor-specific.  The same surface may be presented on multiple"]
    #[doc = "outputs simultaneously."]
    #[doc = ""]
    #[doc = "Once a surface is presented on an output, it stays on that output"]
    #[doc = "until either the client removes it or the compositor destroys the"]
    #[doc = "output.  This way, the client can update the output's contents by"]
    #[doc = "simply attaching a new buffer."]
    pub mod _wl_fullscreen_shell {
        #[doc = "Various capabilities that can be advertised by the compositor.  They"]
        #[doc = "are advertised one-at-a-time when the wl_fullscreen_shell interface is"]
        #[doc = "bound.  See the wl_fullscreen_shell.capability event for more details."]
        #[doc = ""]
        #[doc = "ARBITRARY_MODE:"]
        #[doc = "This is a hint to the client that indicates that the compositor is"]
        #[doc = "capable of setting practically any mode on its outputs.  If this"]
        #[doc = "capability is provided, wl_fullscreen_shell.present_surface_for_mode"]
        #[doc = "will almost never fail and clients should feel free to set whatever"]
        #[doc = "mode they like.  If the compositor does not advertise this, it may"]
        #[doc = "still support some modes that are not advertised through wl_global.mode"]
        #[doc = "but it is less likely."]
        #[doc = ""]
        #[doc = "CURSOR_PLANE:"]
        #[doc = "This is a hint to the client that indicates that the compositor can"]
        #[doc = "handle a cursor surface from the client without actually compositing."]
        #[doc = "This may be because of a hardware cursor plane or some other mechanism."]
        #[doc = "If the compositor does not advertise this capability then setting"]
        #[doc = "wl_pointer.cursor may degrade performance or be ignored entirely.  If"]
        #[doc = "CURSOR_PLANE is not advertised, it is recommended that the client draw"]
        #[doc = "its own cursor and set wl_pointer.cursor(NULL)."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Capability {
            #[doc = "compositor is capable of almost any output mode"]
            ArbitraryModes = 1u32,
            #[doc = "compositor has a separate cursor plane"]
            CursorPlane = 2u32,
        }
        impl TryFrom<u32> for Capability {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::ArbitraryModes),
                    2u32 => Ok(Self::CursorPlane),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Hints to indicate to the compositor how to deal with a conflict"]
        #[doc = "between the dimensions of the surface and the dimensions of the"]
        #[doc = "output. The compositor is free to ignore this parameter."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum PresentMethod {
            #[doc = "no preference, apply default policy"]
            Default = 0u32,
            #[doc = "center the surface on the output"]
            Center = 1u32,
            #[doc = "scale the surface, preserving aspect ratio, to the largest size that will fit on the output"]
            Zoom = 2u32,
            #[doc = "scale the surface, preserving aspect ratio, to fully fill the output cropping if needed"]
            ZoomCrop = 3u32,
            #[doc = "scale the surface to the size of the output ignoring aspect ratio"]
            Stretch = 4u32,
        }
        impl TryFrom<u32> for PresentMethod {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Default),
                    1u32 => Ok(Self::Center),
                    2u32 => Ok(Self::Zoom),
                    3u32 => Ok(Self::ZoomCrop),
                    4u32 => Ok(Self::Stretch),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "These errors can be emitted in response to wl_fullscreen_shell requests"]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "present_method is not known"]
            InvalidMethod = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidMethod),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the _wl_fullscreen_shell interface. See the module level documentation for more info"]
        pub trait WlFullscreenShell: crate::server::Dispatcher {
            const INTERFACE: &'static str = "_wl_fullscreen_shell";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("_wl_fullscreen_shell#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("_wl_fullscreen_shell#{}.present_surface()", object.id);
                        self.present_surface(
                            object,
                            client,
                            message.object()?,
                            message.uint()?,
                            message.object()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "_wl_fullscreen_shell#{}.present_surface_for_mode()",
                            object.id
                        );
                        self.present_surface_for_mode(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Release the binding from the wl_fullscreen_shell interface"]
            #[doc = ""]
            #[doc = "This destroys the server-side object and frees this binding.  If"]
            #[doc = "the client binds to wl_fullscreen_shell multiple times, it may wish"]
            #[doc = "to free some of those bindings."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Present a surface on the given output."]
            #[doc = ""]
            #[doc = "If the output is null, the compositor will present the surface on"]
            #[doc = "whatever display (or displays) it thinks best.  In particular, this"]
            #[doc = "may replace any or all surfaces currently presented so it should"]
            #[doc = "not be used in combination with placing surfaces on specific"]
            #[doc = "outputs."]
            #[doc = ""]
            #[doc = "The method parameter is a hint to the compositor for how the surface"]
            #[doc = "is to be presented.  In particular, it tells the compostior how to"]
            #[doc = "handle a size mismatch between the presented surface and the"]
            #[doc = "output.  The compositor is free to ignore this parameter."]
            #[doc = ""]
            #[doc = "The \"zoom\", \"zoom_crop\", and \"stretch\" methods imply a scaling"]
            #[doc = "operation on the surface.  This will override any kind of output"]
            #[doc = "scaling, so the buffer_scale property of the surface is effectively"]
            #[doc = "ignored."]
            async fn present_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: Option<crate::wire::ObjectId>,
                method: u32,
                output: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "Presents a surface on the given output for a particular mode."]
            #[doc = ""]
            #[doc = "If the current size of the output differs from that of the surface,"]
            #[doc = "the compositor will attempt to change the size of the output to"]
            #[doc = "match the surface.  The result of the mode-switch operation will be"]
            #[doc = "returned via the provided wl_fullscreen_shell_mode_feedback object."]
            #[doc = ""]
            #[doc = "If the current output mode matches the one requested or if the"]
            #[doc = "compositor successfully switches the mode to match the surface,"]
            #[doc = "then the mode_successful event will be sent and the output will"]
            #[doc = "contain the contents of the given surface.  If the compositor"]
            #[doc = "cannot match the output size to the surface size, the mode_failed"]
            #[doc = "will be sent and the output will contain the contents of the"]
            #[doc = "previously presented surface (if any).  If another surface is"]
            #[doc = "presented on the given output before either of these has a chance"]
            #[doc = "to happen, the present_cancelled event will be sent."]
            #[doc = ""]
            #[doc = "Due to race conditions and other issues unknown to the client, no"]
            #[doc = "mode-switch operation is guaranteed to succeed.  However, if the"]
            #[doc = "mode is one advertised by wl_output.mode or if the compositor"]
            #[doc = "advertises the ARBITRARY_MODES capability, then the client should"]
            #[doc = "expect that the mode-switch operation will usually succeed."]
            #[doc = ""]
            #[doc = "If the size of the presented surface changes, the resulting output"]
            #[doc = "is undefined.  The compositor may attempt to change the output mode"]
            #[doc = "to compensate.  However, there is no guarantee that a suitable mode"]
            #[doc = "will be found and the client has no way to be notified of success"]
            #[doc = "or failure."]
            #[doc = ""]
            #[doc = "The framerate parameter specifies the desired framerate for the"]
            #[doc = "output in mHz.  The compositor is free to ignore this parameter.  A"]
            #[doc = "value of 0 indicates that the client has no preference."]
            #[doc = ""]
            #[doc = "If the value of wl_output.scale differs from wl_surface.buffer_scale,"]
            #[doc = "then the compositor may choose a mode that matches either the buffer"]
            #[doc = "size or the surface size.  In either case, the surface will fill the"]
            #[doc = "output."]
            async fn present_surface_for_mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
                output: crate::wire::ObjectId,
                framerate: i32,
                feedback: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Advertises a single capability of the compositor."]
            #[doc = ""]
            #[doc = "When the wl_fullscreen_shell interface is bound, this event is emitted"]
            #[doc = "once for each capability advertised.  Valid capabilities are given by"]
            #[doc = "the wl_fullscreen_shell.capability enum.  If clients want to take"]
            #[doc = "advantage of any of these capabilities, they should use a"]
            #[doc = "wl_display.sync request immediately after binding to ensure that they"]
            #[doc = "receive all the capability events."]
            async fn capability(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                capability: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> _wl_fullscreen_shell#{}.capability()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(capability)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod _wl_fullscreen_shell_mode_feedback {
        #[doc = "Trait to implement the _wl_fullscreen_shell_mode_feedback interface. See the module level documentation for more info"]
        pub trait WlFullscreenShellModeFeedback: crate::server::Dispatcher {
            const INTERFACE: &'static str = "_wl_fullscreen_shell_mode_feedback";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This event indicates that the attempted mode switch operation was"]
            #[doc = "successful.  A surface of the size requested in the mode switch"]
            #[doc = "will fill the output without scaling."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy the"]
            #[doc = "wl_fullscreen_shell_mode_feedback object."]
            async fn mode_successful(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> _wl_fullscreen_shell_mode_feedback#{}.mode_successful()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates that the attempted mode switch operation"]
            #[doc = "failed. This may be because the requested output mode is not"]
            #[doc = "possible or it may mean that the compositor does not want to allow it."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy the"]
            #[doc = "wl_fullscreen_shell_mode_feedback object."]
            async fn mode_failed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> _wl_fullscreen_shell_mode_feedback#{}.mode_failed()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates that the attempted mode switch operation was"]
            #[doc = "cancelled.  Most likely this is because the client requested a"]
            #[doc = "second mode switch before the first one completed."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy the"]
            #[doc = "wl_fullscreen_shell_mode_feedback object."]
            async fn present_cancelled(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> _wl_fullscreen_shell_mode_feedback#{}.present_cancelled()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod idle {
    #[doc = "This interface allows to monitor user idle time on a given seat. The interface"]
    #[doc = "allows to register timers which trigger after no user activity was registered"]
    #[doc = "on the seat for a given interval. It notifies when user activity resumes."]
    #[doc = ""]
    #[doc = "This is useful for applications wanting to perform actions when the user is not"]
    #[doc = "interacting with the system, e.g. chat applications setting the user as away, power"]
    #[doc = "management features to dim screen, etc.."]
    pub mod org_kde_kwin_idle {
        #[doc = "Trait to implement the org_kde_kwin_idle interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinIdle: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_idle";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("org_kde_kwin_idle#{}.get_idle_timeout()", object.id);
                        self.get_idle_timeout(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn get_idle_timeout(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                seat: crate::wire::ObjectId,
                timeout: u32,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod org_kde_kwin_idle_timeout {
        #[doc = "Trait to implement the org_kde_kwin_idle_timeout interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinIdleTimeout: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_idle_timeout";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("org_kde_kwin_idle_timeout#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "org_kde_kwin_idle_timeout#{}.simulate_user_activity()",
                            object.id
                        );
                        self.simulate_user_activity(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            async fn simulate_user_activity(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            async fn idle(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_kwin_idle_timeout#{}.idle()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn resumed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_kwin_idle_timeout#{}.resumed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod keystate {
    #[doc = "Keeps track of the states of the different keys that have a state attached to it."]
    pub mod org_kde_kwin_keystate {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Key {
            Capslock = 0u32,
            Numlock = 1u32,
            Scrolllock = 2u32,
        }
        impl TryFrom<u32> for Key {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Capslock),
                    1u32 => Ok(Self::Numlock),
                    2u32 => Ok(Self::Scrolllock),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum State {
            Unlocked = 0u32,
            Latched = 1u32,
            Locked = 2u32,
        }
        impl TryFrom<u32> for State {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Unlocked),
                    1u32 => Ok(Self::Latched),
                    2u32 => Ok(Self::Locked),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the org_kde_kwin_keystate interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinKeystate: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_keystate";
            const VERSION: u32 = 4u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("org_kde_kwin_keystate#{}.fetch_states()", object.id);
                        self.fetchStates(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("org_kde_kwin_keystate#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn fetch_states(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            async fn state_changed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                key: u32,
                state: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_kwin_keystate#{}.state_changed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(key)
                    .put_uint(state)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod outputmanagement {
    #[doc = "This interface enables clients to set properties of output devices for screen"]
    #[doc = "configuration purposes via the server. To this end output devices are referenced"]
    #[doc = "by global org_kde_kwin_outputdevice objects."]
    #[doc = ""]
    #[doc = "outputmanagement (wl_global)"]
    #[doc = "--------------------------"]
    #[doc = "request:"]
    #[doc = "* create_configuration -> outputconfiguration (wl_resource)"]
    #[doc = ""]
    #[doc = "outputconfiguration (wl_resource)"]
    #[doc = "--------------------------"]
    #[doc = "requests:"]
    #[doc = "* enable(outputdevice, bool)"]
    #[doc = "* mode(outputdevice, mode_id)"]
    #[doc = "* transformation(outputdevice, flag)"]
    #[doc = "* position(outputdevice, x, y)"]
    #[doc = "* apply"]
    #[doc = ""]
    #[doc = "events:"]
    #[doc = "* applied"]
    #[doc = "* failed"]
    #[doc = ""]
    #[doc = "The server registers one outputmanagement object as a global object. In order"]
    #[doc = "to configure outputs a client requests create_configuration, which provides a"]
    #[doc = "resource referencing an outputconfiguration for one-time configuration. That"]
    #[doc = "way the server knows which requests belong together and can group them by that."]
    #[doc = ""]
    #[doc = "On the outputconfiguration object the client calls for each output whether the"]
    #[doc = "output should be enabled, which mode should be set (by referencing the mode from"]
    #[doc = "the list of announced modes) and the output's global position. Once all outputs"]
    #[doc = "are configured that way, the client calls apply."]
    #[doc = "At that point and not earlier the server should try to apply the configuration."]
    #[doc = "If this succeeds the server emits the applied signal, otherwise the failed"]
    #[doc = "signal, such that the configuring client is noticed about the success of its"]
    #[doc = "configuration request."]
    #[doc = ""]
    #[doc = "Through this design the interface enables atomic output configuration changes if"]
    #[doc = "internally supported by the server."]
    pub mod org_kde_kwin_outputmanagement {
        #[doc = "Trait to implement the org_kde_kwin_outputmanagement interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinOutputmanagement: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_outputmanagement";
            const VERSION: u32 = 4u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "org_kde_kwin_outputmanagement#{}.create_configuration()",
                            object.id
                        );
                        self.create_configuration(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Request an outputconfiguration object through which the client can configure"]
            #[doc = "output devices."]
            async fn create_configuration(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "outputconfiguration is a client-specific resource that can be used to ask"]
    #[doc = "the server to apply changes to available output devices."]
    #[doc = ""]
    #[doc = "The client receives a list of output devices from the registry. When it wants"]
    #[doc = "to apply new settings, it creates a configuration object from the"]
    #[doc = "outputmanagement global, writes changes through this object's enable, scale,"]
    #[doc = "transform and mode calls. It then asks the server to apply these settings in"]
    #[doc = "an atomic fashion, for example through Linux' DRM interface."]
    #[doc = ""]
    #[doc = "The server signals back whether the new settings have applied successfully"]
    #[doc = "or failed to apply. outputdevice objects are updated after the changes have been"]
    #[doc = "applied to the hardware and before the server side sends the applied event."]
    pub mod org_kde_kwin_outputconfiguration {
        #[doc = "Describes when the compositor may employ variable refresh rate"]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum VrrPolicy {
            Never = 0u32,
            Always = 1u32,
            Automatic = 2u32,
        }
        impl TryFrom<u32> for VrrPolicy {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Never),
                    1u32 => Ok(Self::Always),
                    2u32 => Ok(Self::Automatic),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the org_kde_kwin_outputconfiguration interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinOutputconfiguration: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_outputconfiguration";
            const VERSION: u32 = 4u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("org_kde_kwin_outputconfiguration#{}.enable()", object.id);
                        self.enable(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("org_kde_kwin_outputconfiguration#{}.mode()", object.id);
                        self.mode(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "org_kde_kwin_outputconfiguration#{}.transform()",
                            object.id
                        );
                        self.transform(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!(
                            "org_kde_kwin_outputconfiguration#{}.position()",
                            object.id
                        );
                        self.position(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("org_kde_kwin_outputconfiguration#{}.scale()", object.id);
                        self.scale(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                        )
                        .await
                    }
                    5u16 => {
                        tracing::debug!("org_kde_kwin_outputconfiguration#{}.apply()", object.id);
                        self.apply(object, client).await
                    }
                    6u16 => {
                        tracing::debug!("org_kde_kwin_outputconfiguration#{}.scalef()", object.id);
                        self.scalef(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.fixed()?,
                        )
                        .await
                    }
                    7u16 => {
                        tracing::debug!(
                            "org_kde_kwin_outputconfiguration#{}.colorcurves()",
                            object.id
                        );
                        self.colorcurves(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.array()?,
                            message.array()?,
                            message.array()?,
                        )
                        .await
                    }
                    8u16 => {
                        tracing::debug!("org_kde_kwin_outputconfiguration#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    9u16 => {
                        tracing::debug!(
                            "org_kde_kwin_outputconfiguration#{}.overscan()",
                            object.id
                        );
                        self.overscan(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    10u16 => {
                        tracing::debug!(
                            "org_kde_kwin_outputconfiguration#{}.set_vrr_policy()",
                            object.id
                        );
                        self.set_vrr_policy(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Mark the output as enabled or disabled."]
            async fn enable(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                enable: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the mode for a given output by its mode size (width and height) and refresh rate."]
            async fn mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                mode_id: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the transformation for a given output."]
            async fn transform(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                transform: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the position for this output device. (x,y) describe the top-left corner"]
            #[doc = "of the output in global space, whereby the origin (0,0) of the global space"]
            #[doc = "has to be aligned with the top-left corner of the most left and in case this"]
            #[doc = "does not define a single one the top output."]
            #[doc = ""]
            #[doc = "There may be no gaps or overlaps between outputs, i.e. the outputs are"]
            #[doc = "stacked horizontally, vertically, or both on each other."]
            async fn position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the scaling factor for this output device."]
            async fn scale(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                scale: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Asks the server to apply property changes requested through this outputconfiguration"]
            #[doc = "object to all outputs on the server side."]
            async fn apply(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the scaling factor for this output device."]
            #[doc = "Sending both scale and scalef is undefined."]
            async fn scalef(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                scale: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            #[doc = "Set color curves of output devices through RGB color ramps. Allows color"]
            #[doc = "correction of output device from user space."]
            #[doc = ""]
            #[doc = "These are the raw values. A compositor might opt to adjust these values"]
            #[doc = "internally, for example to shift color temperature at night."]
            async fn colorcurves(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                red: Vec<u8>,
                green: Vec<u8>,
                blue: Vec<u8>,
            ) -> crate::server::Result<()>;
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the overscan value of this output device with a value in percent."]
            async fn overscan(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                overscan: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Set what policy the compositor should employ regarding its use of"]
            #[doc = "variable refresh rate."]
            async fn set_vrr_policy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                policy: VrrPolicy,
            ) -> crate::server::Result<()>;
            #[doc = "Sent after the server has successfully applied the changes."]
            #[doc = "."]
            async fn applied(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> org_kde_kwin_outputconfiguration#{}.applied()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent if the server rejects the changes or failed to apply them."]
            async fn failed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_kwin_outputconfiguration#{}.failed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod org_kde_kwin_outputdevice {
    #[doc = "An outputdevice describes a display device available to the compositor."]
    #[doc = "outputdevice is similar to wl_output, but focuses on output"]
    #[doc = "configuration management."]
    #[doc = ""]
    #[doc = "A client can query all global outputdevice objects to enlist all"]
    #[doc = "available display devices, even those that may currently not be"]
    #[doc = "represented by the compositor as a wl_output."]
    #[doc = ""]
    #[doc = "The client sends configuration changes to the server through the"]
    #[doc = "outputconfiguration interface, and the server applies the configuration"]
    #[doc = "changes to the hardware and signals changes to the outputdevices"]
    #[doc = "accordingly."]
    #[doc = ""]
    #[doc = "This object is published as global during start up for every available"]
    #[doc = "display devices, or when one later becomes available, for example by"]
    #[doc = "being hotplugged via a physical connector."]
    pub mod org_kde_kwin_outputdevice {
        #[doc = "This enumeration describes how the physical pixels on an output are"]
        #[doc = "laid out."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Subpixel {
            Unknown = 0u32,
            None = 1u32,
            HorizontalRgb = 2u32,
            HorizontalBgr = 3u32,
            VerticalRgb = 4u32,
            VerticalBgr = 5u32,
        }
        impl TryFrom<u32> for Subpixel {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Unknown),
                    1u32 => Ok(Self::None),
                    2u32 => Ok(Self::HorizontalRgb),
                    3u32 => Ok(Self::HorizontalBgr),
                    4u32 => Ok(Self::VerticalRgb),
                    5u32 => Ok(Self::VerticalBgr),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This describes the transform, that a compositor will apply to a"]
        #[doc = "surface to compensate for the rotation or mirroring of an"]
        #[doc = "output device."]
        #[doc = ""]
        #[doc = "The flipped values correspond to an initial flip around a"]
        #[doc = "vertical axis followed by rotation."]
        #[doc = ""]
        #[doc = "The purpose is mainly to allow clients to render accordingly and"]
        #[doc = "tell the compositor, so that for fullscreen surfaces, the"]
        #[doc = "compositor is still able to scan out directly client surfaces."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Transform {
            Normal = 0u32,
            _90 = 1u32,
            _180 = 2u32,
            _270 = 3u32,
            Flipped = 4u32,
            Flipped90 = 5u32,
            Flipped180 = 6u32,
            Flipped270 = 7u32,
        }
        impl TryFrom<u32> for Transform {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Normal),
                    1u32 => Ok(Self::_90),
                    2u32 => Ok(Self::_180),
                    3u32 => Ok(Self::_270),
                    4u32 => Ok(Self::Flipped),
                    5u32 => Ok(Self::Flipped90),
                    6u32 => Ok(Self::Flipped180),
                    7u32 => Ok(Self::Flipped270),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "These flags describe properties of an output mode. They are"]
        #[doc = "used in the flags bitfield of the mode event."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Mode {
            #[doc = "indicates this is the current mode"]
            Current = 1u32,
            #[doc = "indicates this is the preferred mode"]
            Preferred = 2u32,
        }
        impl TryFrom<u32> for Mode {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::Current),
                    2u32 => Ok(Self::Preferred),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Describes whether a device is enabled, i.e. device is used to"]
        #[doc = "display content by the compositor. This wraps a boolean around"]
        #[doc = "an int to avoid a boolean trap."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Enablement {
            Disabled = 0u32,
            Enabled = 1u32,
        }
        impl TryFrom<u32> for Enablement {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Disabled),
                    1u32 => Ok(Self::Enabled),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! { # [doc = "Describes what capabilities this device has."] # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Capability : u32 { # [doc = "if this outputdevice can use overscan"] const Overscan = 1u32 ; # [doc = "if this outputdevice supports variable refresh rate"] const Vrr = 2u32 ; } }
        impl TryFrom<u32> for Capability {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "Describes when the compositor may employ variable refresh rate"]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum VrrPolicy {
            Never = 0u32,
            Always = 1u32,
            Automatic = 2u32,
        }
        impl TryFrom<u32> for VrrPolicy {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Never),
                    1u32 => Ok(Self::Always),
                    2u32 => Ok(Self::Automatic),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the org_kde_kwin_outputdevice interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinOutputdevice: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_outputdevice";
            const VERSION: u32 = 4u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "The geometry event describes geometric properties of the output."]
            #[doc = "The event is sent when binding to the output object and whenever"]
            #[doc = "any of the properties change."]
            async fn geometry(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                physical_width: i32,
                physical_height: i32,
                subpixel: i32,
                make: String,
                model: String,
                transform: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_kwin_outputdevice#{}.geometry()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(x)
                    .put_int(y)
                    .put_int(physical_width)
                    .put_int(physical_height)
                    .put_int(subpixel)
                    .put_string(Some(make))
                    .put_string(Some(model))
                    .put_int(transform)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The mode event describes an available mode for the output."]
            #[doc = ""]
            #[doc = "When the client binds to the outputdevice object, the server sends this"]
            #[doc = "event once for every available mode the outputdevice can be operated by."]
            #[doc = ""]
            #[doc = "There will always be at least one event sent out on initial binding,"]
            #[doc = "which represents the current mode."]
            #[doc = ""]
            #[doc = "Later on if an output changes its mode the event is sent again, whereby"]
            #[doc = "this event represents the mode that has now become current. In other"]
            #[doc = "words, the current mode is always represented by the latest event sent"]
            #[doc = "with the current flag set."]
            #[doc = ""]
            #[doc = "The size of a mode is given in physical hardware units of the output device."]
            #[doc = "This is not necessarily the same as the output size in the global compositor"]
            #[doc = "space. For instance, the output may be scaled, as described in"]
            #[doc = "org_kde_kwin_outputdevice.scale, or transformed, as described in"]
            #[doc = "org_kde_kwin_outputdevice.transform."]
            #[doc = ""]
            #[doc = "The id can be used to refer to a mode when calling set_mode on an"]
            #[doc = "org_kde_kwin_outputconfiguration object."]
            async fn mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                flags: u32,
                width: i32,
                height: i32,
                refresh: i32,
                mode_id: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_kwin_outputdevice#{}.mode()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(flags)
                    .put_int(width)
                    .put_int(height)
                    .put_int(refresh)
                    .put_int(mode_id)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent after all other properties have been"]
            #[doc = "sent on binding to the output object as well as after any"]
            #[doc = "other output property change have been applied later on."]
            #[doc = "This allows to see changes to the output properties as atomic,"]
            #[doc = "even if multiple events successively announce them."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_kwin_outputdevice#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event contains scaling geometry information"]
            #[doc = "that is not in the geometry event. It may be sent after"]
            #[doc = "binding the output object or if the output scale changes"]
            #[doc = "later. If it is not sent, the client should assume a"]
            #[doc = "scale of 1."]
            #[doc = ""]
            #[doc = "A scale larger than 1 means that the compositor will"]
            #[doc = "automatically scale surface buffers by this amount"]
            #[doc = "when rendering. This is used for high resolution"]
            #[doc = "displays where applications rendering at the native"]
            #[doc = "resolution would be too small to be legible."]
            #[doc = ""]
            #[doc = "It is intended that scaling aware clients track the"]
            #[doc = "current output of a surface, and if it is on a scaled"]
            #[doc = "output it should use wl_surface.set_buffer_scale with"]
            #[doc = "the scale of the output. That way the compositor can"]
            #[doc = "avoid scaling the surface, and the client can supply"]
            #[doc = "a higher detail image."]
            async fn scale(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                factor: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_kwin_outputdevice#{}.scale()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(factor).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The edid event encapsulates the EDID data for the outputdevice."]
            #[doc = ""]
            #[doc = "The event is sent when binding to the output object. The EDID"]
            #[doc = "data may be empty, in which case this event is sent anyway."]
            #[doc = "If the EDID information is empty, you can fall back to the name"]
            #[doc = "et al. properties of the outputdevice."]
            async fn edid(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                raw: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_kwin_outputdevice#{}.edid()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(raw))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The enabled event notifies whether this output is currently"]
            #[doc = "enabled and used for displaying content by the server."]
            #[doc = "The event is sent when binding to the output object and"]
            #[doc = "whenever later on an output changes its state by becoming"]
            #[doc = "enabled or disabled."]
            async fn enabled(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                enabled: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_kwin_outputdevice#{}.enabled()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(enabled).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The uuid can be used to identify the output. It's controlled by"]
            #[doc = "the server entirely. The server should make sure the uuid is"]
            #[doc = "persistent across restarts. An empty uuid is considered invalid."]
            async fn uuid(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                uuid: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_kwin_outputdevice#{}.uuid()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(uuid))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 6u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event contains scaling geometry information"]
            #[doc = "that is not in the geometry event. It may be sent after"]
            #[doc = "binding the output object or if the output scale changes"]
            #[doc = "later. If it is not sent, the client should assume a"]
            #[doc = "scale of 1."]
            #[doc = ""]
            #[doc = "A scale larger than 1 means that the compositor will"]
            #[doc = "automatically scale surface buffers by this amount"]
            #[doc = "when rendering. This is used for high resolution"]
            #[doc = "displays where applications rendering at the native"]
            #[doc = "resolution would be too small to be legible."]
            #[doc = ""]
            #[doc = "It is intended that scaling aware clients track the"]
            #[doc = "current output of a surface, and if it is on a scaled"]
            #[doc = "output it should use wl_surface.set_buffer_scale with"]
            #[doc = "the scale of the output. That way the compositor can"]
            #[doc = "avoid scaling the surface, and the client can supply"]
            #[doc = "a higher detail image."]
            #[doc = ""]
            #[doc = "wl_output will keep the output scale as an integer. In every situation except"]
            #[doc = "configuring the window manager you want to use that."]
            async fn scalef(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                factor: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_kwin_outputdevice#{}.scalef()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_fixed(factor).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 7u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Describes the color intensity profile of the output."]
            #[doc = "Commonly used for gamma/color correction."]
            #[doc = ""]
            #[doc = "The array contains all color ramp values of the output."]
            #[doc = "For example on 8bit screens there are 256 of them."]
            #[doc = ""]
            #[doc = "The array elements are unsigned 16bit integers."]
            async fn colorcurves(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                red: Vec<u8>,
                green: Vec<u8>,
                blue: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_kwin_outputdevice#{}.colorcurves()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_array(red)
                    .put_array(green)
                    .put_array(blue)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 8u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Serial ID of the monitor, sent on startup before the first done event."]
            async fn serial_number(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial_number: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_kwin_outputdevice#{}.serial_number()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(serial_number))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 9u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "EISA ID of the monitor, sent on startup before the first done event."]
            async fn eisa_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                eisa_id: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_kwin_outputdevice#{}.eisa_id()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(eisa_id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 10u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "What capabilities this device has, sent on startup before the first"]
            #[doc = "done event."]
            async fn capabilities(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                flags: Capability,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_kwin_outputdevice#{}.capabilities()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(flags.bits())
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 11u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Overscan value of the monitor in percent, sent on startup before the"]
            #[doc = "first done event."]
            async fn overscan(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                overscan: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_kwin_outputdevice#{}.overscan()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(overscan)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 12u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "What policy the compositor will employ regarding its use of variable"]
            #[doc = "refresh rate."]
            async fn vrr_policy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                vrr_policy: VrrPolicy,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_kwin_outputdevice#{}.vrr_policy()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(vrr_policy as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 13u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod remote_access {
    pub mod org_kde_kwin_remote_access_manager {
        #[doc = "Trait to implement the org_kde_kwin_remote_access_manager interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinRemoteAccessManager: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_remote_access_manager";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "org_kde_kwin_remote_access_manager#{}.get_buffer()",
                            object.id
                        );
                        self.get_buffer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "org_kde_kwin_remote_access_manager#{}.release()",
                            object.id
                        );
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn get_buffer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer: crate::wire::ObjectId,
                internal_buffer_id: i32,
            ) -> crate::server::Result<()>;
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            async fn buffer_ready(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: i32,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> org_kde_kwin_remote_access_manager#{}.buffer_ready()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(id)
                    .put_object(Some(output))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod org_kde_kwin_remote_buffer {
        #[doc = "Trait to implement the org_kde_kwin_remote_buffer interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinRemoteBuffer: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_remote_buffer";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("org_kde_kwin_remote_buffer#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            async fn gbm_handle(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                fd: rustix::fd::OwnedFd,
                width: u32,
                height: u32,
                stride: u32,
                format: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_kwin_remote_buffer#{}.gbm_handle()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fd(fd)
                    .put_uint(width)
                    .put_uint(height)
                    .put_uint(stride)
                    .put_uint(format)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod server_decoration_palette {
    #[doc = "This interface allows a client to alter the palette of a server side decoration."]
    pub mod org_kde_kwin_server_decoration_palette_manager {
        #[doc = "Trait to implement the org_kde_kwin_server_decoration_palette_manager interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinServerDecorationPaletteManager: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_server_decoration_palette_manager";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "org_kde_kwin_server_decoration_palette_manager#{}.create()",
                            object.id
                        );
                        self.create(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn create(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "This interface allows a client to alter the palette of a server side decoration."]
    pub mod org_kde_kwin_server_decoration_palette {
        #[doc = "Trait to implement the org_kde_kwin_server_decoration_palette interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinServerDecorationPalette: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_server_decoration_palette";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "org_kde_kwin_server_decoration_palette#{}.set_palette()",
                            object.id
                        );
                        self.set_palette(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "org_kde_kwin_server_decoration_palette#{}.release()",
                            object.id
                        );
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Color scheme that should be applied to the window decoration."]
            #[doc = "Absolute file path, or name of palette in the user's config directory."]
            #[doc = "The server may choose not to follow the requested style."]
            async fn set_palette(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                palette: String,
            ) -> crate::server::Result<()>;
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod server_decoration {
    #[doc = "This interface allows to coordinate whether the server should create"]
    #[doc = "a server-side window decoration around a wl_surface representing a"]
    #[doc = "shell surface (wl_shell_surface or similar). By announcing support"]
    #[doc = "for this interface the server indicates that it supports server"]
    #[doc = "side decorations."]
    #[doc = ""]
    #[doc = "Use in conjunction with zxdg_decoration_manager_v1 is undefined."]
    pub mod org_kde_kwin_server_decoration_manager {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Mode {
            #[doc = "Undecorated: The surface is not decorated at all, neither server nor client-side. An example is a popup surface which should not be decorated."]
            None = 0u32,
            #[doc = "Client-side decoration: The decoration is part of the surface and the client."]
            Client = 1u32,
            #[doc = "Server-side decoration: The server embeds the surface into a decoration frame."]
            Server = 2u32,
        }
        impl TryFrom<u32> for Mode {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::None),
                    1u32 => Ok(Self::Client),
                    2u32 => Ok(Self::Server),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the org_kde_kwin_server_decoration_manager interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinServerDecorationManager: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_server_decoration_manager";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "org_kde_kwin_server_decoration_manager#{}.create()",
                            object.id
                        );
                        self.create(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "When a client creates a server-side decoration object it indicates"]
            #[doc = "that it supports the protocol. The client is supposed to tell the"]
            #[doc = "server whether it wants server-side decorations or will provide"]
            #[doc = "client-side decorations."]
            #[doc = ""]
            #[doc = "If the client does not create a server-side decoration object for"]
            #[doc = "a surface the server interprets this as lack of support for this"]
            #[doc = "protocol and considers it as client-side decorated. Nevertheless a"]
            #[doc = "client-side decorated surface should use this protocol to indicate"]
            #[doc = "to the server that it does not want a server-side deco."]
            async fn create(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This event is emitted directly after binding the interface. It contains"]
            #[doc = "the default mode for the decoration. When a new server decoration object"]
            #[doc = "is created this new object will be in the default mode until the first"]
            #[doc = "request_mode is requested."]
            #[doc = ""]
            #[doc = "The server may change the default mode at any time."]
            async fn default_mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mode: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> org_kde_kwin_server_decoration_manager#{}.default_mode()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(mode).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod org_kde_kwin_server_decoration {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Mode {
            #[doc = "Undecorated: The surface is not decorated at all, neither server nor client-side. An example is a popup surface which should not be decorated."]
            None = 0u32,
            #[doc = "Client-side decoration: The decoration is part of the surface and the client."]
            Client = 1u32,
            #[doc = "Server-side decoration: The server embeds the surface into a decoration frame."]
            Server = 2u32,
        }
        impl TryFrom<u32> for Mode {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::None),
                    1u32 => Ok(Self::Client),
                    2u32 => Ok(Self::Server),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the org_kde_kwin_server_decoration interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinServerDecoration: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_server_decoration";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("org_kde_kwin_server_decoration#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "org_kde_kwin_server_decoration#{}.request_mode()",
                            object.id
                        );
                        self.request_mode(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            async fn request_mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mode: u32,
            ) -> crate::server::Result<()>;
            #[doc = "This event is emitted directly after the decoration is created and"]
            #[doc = "represents the base decoration policy by the server. E.g. a server"]
            #[doc = "which wants all surfaces to be client-side decorated will send Client,"]
            #[doc = "a server which wants server-side decoration will send Server."]
            #[doc = ""]
            #[doc = "The client can request a different mode through the decoration request."]
            #[doc = "The server will acknowledge this by another event with the same mode. So"]
            #[doc = "even if a server prefers server-side decoration it's possible to force a"]
            #[doc = "client-side decoration."]
            #[doc = ""]
            #[doc = "The server may emit this event at any time. In this case the client can"]
            #[doc = "again request a different mode. It's the responsibility of the server to"]
            #[doc = "prevent a feedback loop."]
            async fn mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mode: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_kwin_server_decoration#{}.mode()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(mode).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod shadow {
    pub mod org_kde_kwin_shadow_manager {
        #[doc = "Trait to implement the org_kde_kwin_shadow_manager interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinShadowManager: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_shadow_manager";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("org_kde_kwin_shadow_manager#{}.create()", object.id);
                        self.create(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("org_kde_kwin_shadow_manager#{}.unset()", object.id);
                        self.unset(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("org_kde_kwin_shadow_manager#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn create(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            async fn unset(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the org_kde_kwin_shadow_manager object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod org_kde_kwin_shadow {
        #[doc = "Trait to implement the org_kde_kwin_shadow interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinShadow: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_shadow";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("org_kde_kwin_shadow#{}.commit()", object.id);
                        self.commit(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("org_kde_kwin_shadow#{}.attach_left()", object.id);
                        self.attach_left(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("org_kde_kwin_shadow#{}.attach_top_left()", object.id);
                        self.attach_top_left(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("org_kde_kwin_shadow#{}.attach_top()", object.id);
                        self.attach_top(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("org_kde_kwin_shadow#{}.attach_top_right()", object.id);
                        self.attach_top_right(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    5u16 => {
                        tracing::debug!("org_kde_kwin_shadow#{}.attach_right()", object.id);
                        self.attach_right(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    6u16 => {
                        tracing::debug!("org_kde_kwin_shadow#{}.attach_bottom_right()", object.id);
                        self.attach_bottom_right(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    7u16 => {
                        tracing::debug!("org_kde_kwin_shadow#{}.attach_bottom()", object.id);
                        self.attach_bottom(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    8u16 => {
                        tracing::debug!("org_kde_kwin_shadow#{}.attach_bottom_left()", object.id);
                        self.attach_bottom_left(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    9u16 => {
                        tracing::debug!("org_kde_kwin_shadow#{}.set_left_offset()", object.id);
                        self.set_left_offset(object, client, message.fixed()?).await
                    }
                    10u16 => {
                        tracing::debug!("org_kde_kwin_shadow#{}.set_top_offset()", object.id);
                        self.set_top_offset(object, client, message.fixed()?).await
                    }
                    11u16 => {
                        tracing::debug!("org_kde_kwin_shadow#{}.set_right_offset()", object.id);
                        self.set_right_offset(object, client, message.fixed()?)
                            .await
                    }
                    12u16 => {
                        tracing::debug!("org_kde_kwin_shadow#{}.set_bottom_offset()", object.id);
                        self.set_bottom_offset(object, client, message.fixed()?)
                            .await
                    }
                    13u16 => {
                        tracing::debug!("org_kde_kwin_shadow#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn commit(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            async fn attach_left(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            async fn attach_top_left(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            async fn attach_top(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            async fn attach_top_right(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            async fn attach_right(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            async fn attach_bottom_right(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            async fn attach_bottom(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            async fn attach_bottom_left(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            async fn set_left_offset(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                offset: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            async fn set_top_offset(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                offset: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            async fn set_right_offset(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                offset: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            async fn set_bottom_offset(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                offset: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the org_kde_kwin_shadow object. If the org_kde_kwin_shadow is"]
            #[doc = "still set on a wl_surface the shadow will be immediately removed."]
            #[doc = "Prefer to first call the request unset on the org_kde_kwin_shadow_manager and"]
            #[doc = "commit the wl_surface to apply the change."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod slide {
    pub mod org_kde_kwin_slide_manager {
        #[doc = "Trait to implement the org_kde_kwin_slide_manager interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinSlideManager: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_slide_manager";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("org_kde_kwin_slide_manager#{}.create()", object.id);
                        self.create(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("org_kde_kwin_slide_manager#{}.unset()", object.id);
                        self.unset(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn create(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            async fn unset(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "Ask the compositor to move the surface from a location to another"]
    #[doc = "with a slide animation."]
    #[doc = ""]
    #[doc = "The from argument provides a clue about where the slide animation"]
    #[doc = "begins, offset is the distance from screen edge to begin the animation."]
    pub mod org_kde_kwin_slide {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Location {
            Left = 0u32,
            Top = 1u32,
            Right = 2u32,
            Bottom = 3u32,
        }
        impl TryFrom<u32> for Location {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Left),
                    1u32 => Ok(Self::Top),
                    2u32 => Ok(Self::Right),
                    3u32 => Ok(Self::Bottom),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the org_kde_kwin_slide interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinSlide: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_slide";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("org_kde_kwin_slide#{}.commit()", object.id);
                        self.commit(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("org_kde_kwin_slide#{}.set_location()", object.id);
                        self.set_location(object, client, message.uint()?).await
                    }
                    2u16 => {
                        tracing::debug!("org_kde_kwin_slide#{}.set_offset()", object.id);
                        self.set_offset(object, client, message.int()?).await
                    }
                    3u16 => {
                        tracing::debug!("org_kde_kwin_slide#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn commit(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            async fn set_location(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                location: u32,
            ) -> crate::server::Result<()>;
            async fn set_offset(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                offset: i32,
            ) -> crate::server::Result<()>;
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod surface_extension {
    pub mod qt_surface_extension {
        #[doc = "Trait to implement the qt_surface_extension interface. See the module level documentation for more info"]
        pub trait QtSurfaceExtension: crate::server::Dispatcher {
            const INTERFACE: &'static str = "qt_surface_extension";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "qt_surface_extension#{}.get_extended_surface()",
                            object.id
                        );
                        self.get_extended_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn get_extended_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod qt_extended_surface {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Orientation {
            PrimaryOrientation = 0u32,
            PortraitOrientation = 1u32,
            LandscapeOrientation = 2u32,
            InvertedPortraitOrientation = 4u32,
            InvertedLandscapeOrientation = 8u32,
        }
        impl TryFrom<u32> for Orientation {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::PrimaryOrientation),
                    1u32 => Ok(Self::PortraitOrientation),
                    2u32 => Ok(Self::LandscapeOrientation),
                    4u32 => Ok(Self::InvertedPortraitOrientation),
                    8u32 => Ok(Self::InvertedLandscapeOrientation),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Windowflag {
            OverridesSystemGestures = 1u32,
            StaysOnTop = 2u32,
            BypassWindowManager = 4u32,
        }
        impl TryFrom<u32> for Windowflag {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::OverridesSystemGestures),
                    2u32 => Ok(Self::StaysOnTop),
                    4u32 => Ok(Self::BypassWindowManager),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the qt_extended_surface interface. See the module level documentation for more info"]
        pub trait QtExtendedSurface: crate::server::Dispatcher {
            const INTERFACE: &'static str = "qt_extended_surface";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "qt_extended_surface#{}.update_generic_property()",
                            object.id
                        );
                        self.update_generic_property(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.array()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "qt_extended_surface#{}.set_content_orientation_mask()",
                            object.id
                        );
                        self.set_content_orientation_mask(object, client, message.int()?)
                            .await
                    }
                    2u16 => {
                        tracing::debug!("qt_extended_surface#{}.set_window_flags()", object.id);
                        self.set_window_flags(object, client, message.int()?).await
                    }
                    3u16 => {
                        tracing::debug!("qt_extended_surface#{}.raise()", object.id);
                        self.raise(object, client).await
                    }
                    4u16 => {
                        tracing::debug!("qt_extended_surface#{}.lower()", object.id);
                        self.lower(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn update_generic_property(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
                value: Vec<u8>,
            ) -> crate::server::Result<()>;
            async fn set_content_orientation_mask(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                orientation: i32,
            ) -> crate::server::Result<()>;
            async fn set_window_flags(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                flags: i32,
            ) -> crate::server::Result<()>;
            async fn raise(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            async fn lower(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            async fn onscreen_visibility(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                visible: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> qt_extended_surface#{}.onscreen_visibility()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(visible).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn set_generic_property(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
                value: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> qt_extended_surface#{}.set_generic_property()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(name))
                    .put_array(value)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn close(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> qt_extended_surface#{}.close()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod text_input_unstable_v2 {
    #[doc = "The zwp_text_input_v2 interface represents text input and input methods"]
    #[doc = "associated with a seat. It provides enter/leave events to follow the"]
    #[doc = "text input focus for a seat."]
    #[doc = ""]
    #[doc = "Requests are used to enable/disable the text-input object and set"]
    #[doc = "state information like surrounding and selected text or the content type."]
    #[doc = "The information about the entered text is sent to the text-input object"]
    #[doc = "via the pre-edit and commit events. Using this interface removes the need"]
    #[doc = "for applications to directly process hardware key events and compose text"]
    #[doc = "out of them."]
    #[doc = ""]
    #[doc = "Text is valid UTF-8 encoded, indices and lengths are in bytes. Indices"]
    #[doc = "have to always point to the first byte of an UTF-8 encoded code point."]
    #[doc = "Lengths are not allowed to contain just a part of an UTF-8 encoded code"]
    #[doc = "point."]
    #[doc = ""]
    #[doc = "State is sent by the state requests (set_surrounding_text,"]
    #[doc = "set_content_type, set_cursor_rectangle and set_preferred_language) and"]
    #[doc = "an update_state request. After an enter or an input_method_change event"]
    #[doc = "all state information is invalidated and needs to be resent from the"]
    #[doc = "client. A reset or entering a new widget on client side also"]
    #[doc = "invalidates all current state information."]
    pub mod zwp_text_input_v2 {
        bitflags::bitflags! { # [doc = "Content hint is a bitmask to allow to modify the behavior of the text"] # [doc = "input."] # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct ContentHint : u32 { # [doc = "no special behaviour"] const None = 0u32 ; # [doc = "suggest word completions"] const AutoCompletion = 1u32 ; # [doc = "suggest word corrections"] const AutoCorrection = 2u32 ; # [doc = "switch to uppercase letters at the start of a sentence"] const AutoCapitalization = 4u32 ; # [doc = "prefer lowercase letters"] const Lowercase = 8u32 ; # [doc = "prefer uppercase letters"] const Uppercase = 16u32 ; # [doc = "prefer casing for titles and headings (can be language dependent)"] const Titlecase = 32u32 ; # [doc = "characters should be hidden"] const HiddenText = 64u32 ; # [doc = "typed text should not be stored"] const SensitiveData = 128u32 ; # [doc = "just latin characters should be entered"] const Latin = 256u32 ; # [doc = "the text input is multiline"] const Multiline = 512u32 ; } }
        impl TryFrom<u32> for ContentHint {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "The content purpose allows to specify the primary purpose of a text"]
        #[doc = "input."]
        #[doc = ""]
        #[doc = "This allows an input method to show special purpose input panels with"]
        #[doc = "extra characters or to disallow some characters."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ContentPurpose {
            #[doc = "default input, allowing all characters"]
            Normal = 0u32,
            #[doc = "allow only alphabetic characters"]
            Alpha = 1u32,
            #[doc = "allow only digits"]
            Digits = 2u32,
            #[doc = "input a number (including decimal separator and sign)"]
            Number = 3u32,
            #[doc = "input a phone number"]
            Phone = 4u32,
            #[doc = "input an URL"]
            Url = 5u32,
            #[doc = "input an email address"]
            Email = 6u32,
            #[doc = "input a name of a person"]
            Name = 7u32,
            #[doc = "input a password (combine with password or sensitive_data hint)"]
            Password = 8u32,
            #[doc = "input a date"]
            Date = 9u32,
            #[doc = "input a time"]
            Time = 10u32,
            #[doc = "input a date and time"]
            Datetime = 11u32,
            #[doc = "input for a terminal"]
            Terminal = 12u32,
        }
        impl TryFrom<u32> for ContentPurpose {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Normal),
                    1u32 => Ok(Self::Alpha),
                    2u32 => Ok(Self::Digits),
                    3u32 => Ok(Self::Number),
                    4u32 => Ok(Self::Phone),
                    5u32 => Ok(Self::Url),
                    6u32 => Ok(Self::Email),
                    7u32 => Ok(Self::Name),
                    8u32 => Ok(Self::Password),
                    9u32 => Ok(Self::Date),
                    10u32 => Ok(Self::Time),
                    11u32 => Ok(Self::Datetime),
                    12u32 => Ok(Self::Terminal),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Defines the reason for sending an updated state."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum UpdateState {
            #[doc = "updated state because it changed"]
            Change = 0u32,
            #[doc = "full state after enter or input_method_changed event"]
            Full = 1u32,
            #[doc = "full state after reset"]
            Reset = 2u32,
            #[doc = "full state after switching focus to a different widget on client side"]
            Enter = 3u32,
        }
        impl TryFrom<u32> for UpdateState {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Change),
                    1u32 => Ok(Self::Full),
                    2u32 => Ok(Self::Reset),
                    3u32 => Ok(Self::Enter),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum InputPanelVisibility {
            #[doc = "the input panel (virtual keyboard) is hidden"]
            Hidden = 0u32,
            #[doc = "the input panel (virtual keyboard) is visible"]
            Visible = 1u32,
        }
        impl TryFrom<u32> for InputPanelVisibility {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Hidden),
                    1u32 => Ok(Self::Visible),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum PreeditStyle {
            #[doc = "default style for composing text"]
            Default = 0u32,
            #[doc = "composing text should be shown the same as non-composing text"]
            None = 1u32,
            #[doc = "composing text might be bold"]
            Active = 2u32,
            #[doc = "composing text might be cursive"]
            Inactive = 3u32,
            #[doc = "composing text might have a different background color"]
            Highlight = 4u32,
            #[doc = "composing text might be underlined"]
            Underline = 5u32,
            #[doc = "composing text should be shown the same as selected text"]
            Selection = 6u32,
            #[doc = "composing text might be underlined with a red wavy line"]
            Incorrect = 7u32,
        }
        impl TryFrom<u32> for PreeditStyle {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Default),
                    1u32 => Ok(Self::None),
                    2u32 => Ok(Self::Active),
                    3u32 => Ok(Self::Inactive),
                    4u32 => Ok(Self::Highlight),
                    5u32 => Ok(Self::Underline),
                    6u32 => Ok(Self::Selection),
                    7u32 => Ok(Self::Incorrect),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum TextDirection {
            #[doc = "automatic text direction based on text and language"]
            Auto = 0u32,
            #[doc = "left-to-right"]
            Ltr = 1u32,
            #[doc = "right-to-left"]
            Rtl = 2u32,
        }
        impl TryFrom<u32> for TextDirection {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Auto),
                    1u32 => Ok(Self::Ltr),
                    2u32 => Ok(Self::Rtl),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zwp_text_input_v2 interface. See the module level documentation for more info"]
        pub trait ZwpTextInputV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_text_input_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_text_input_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zwp_text_input_v2#{}.enable()", object.id);
                        self.enable(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zwp_text_input_v2#{}.disable()", object.id);
                        self.disable(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("zwp_text_input_v2#{}.show_input_panel()", object.id);
                        self.show_input_panel(object, client).await
                    }
                    4u16 => {
                        tracing::debug!("zwp_text_input_v2#{}.hide_input_panel()", object.id);
                        self.hide_input_panel(object, client).await
                    }
                    5u16 => {
                        tracing::debug!("zwp_text_input_v2#{}.set_surrounding_text()", object.id);
                        self.set_surrounding_text(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    6u16 => {
                        tracing::debug!("zwp_text_input_v2#{}.set_content_type()", object.id);
                        self.set_content_type(
                            object,
                            client,
                            message.uint()?.try_into()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    7u16 => {
                        tracing::debug!("zwp_text_input_v2#{}.set_cursor_rectangle()", object.id);
                        self.set_cursor_rectangle(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    8u16 => {
                        tracing::debug!("zwp_text_input_v2#{}.set_preferred_language()", object.id);
                        self.set_preferred_language(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    9u16 => {
                        tracing::debug!("zwp_text_input_v2#{}.update_state()", object.id);
                        self.update_state(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the wp_text_input object. Also disables all surfaces enabled"]
            #[doc = "through this wp_text_input object"]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Enable text input in a surface (usually when a text entry inside of it"]
            #[doc = "has focus)."]
            #[doc = ""]
            #[doc = "This can be called before or after a surface gets text (or keyboard)"]
            #[doc = "focus via the enter event. Text input to a surface is only active"]
            #[doc = "when it has the current text (or keyboard) focus and is enabled."]
            async fn enable(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Disable text input in a surface (typically when there is no focus on any"]
            #[doc = "text entry inside the surface)."]
            async fn disable(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Requests input panels (virtual keyboard) to show."]
            #[doc = ""]
            #[doc = "This should be used for example to show a virtual keyboard again"]
            #[doc = "(with a tap) after it was closed by pressing on a close button on the"]
            #[doc = "keyboard."]
            async fn show_input_panel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Requests input panels (virtual keyboard) to hide."]
            async fn hide_input_panel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the plain surrounding text around the input position. Text is"]
            #[doc = "UTF-8 encoded. Cursor is the byte offset within the surrounding text."]
            #[doc = "Anchor is the byte offset of the selection anchor within the"]
            #[doc = "surrounding text. If there is no selected text, anchor is the same as"]
            #[doc = "cursor."]
            #[doc = ""]
            #[doc = "Make sure to always send some text before and after the cursor"]
            #[doc = "except when the cursor is at the beginning or end of text."]
            #[doc = ""]
            #[doc = "When there was a configure_surrounding_text event take the"]
            #[doc = "before_cursor and after_cursor arguments into account for picking how"]
            #[doc = "much surrounding text to send."]
            #[doc = ""]
            #[doc = "There is a maximum length of wayland messages so text can not be"]
            #[doc = "longer than 4000 bytes."]
            async fn set_surrounding_text(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                text: String,
                cursor: i32,
                anchor: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the content purpose and content hint. While the purpose is the"]
            #[doc = "basic purpose of an input field, the hint flags allow to modify some"]
            #[doc = "of the behavior."]
            #[doc = ""]
            #[doc = "When no content type is explicitly set, a normal content purpose with"]
            #[doc = "none hint should be assumed."]
            async fn set_content_type(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                hint: ContentHint,
                purpose: ContentPurpose,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the cursor outline as a x, y, width, height rectangle in surface"]
            #[doc = "local coordinates."]
            #[doc = ""]
            #[doc = "Allows the compositor to put a window with word suggestions near the"]
            #[doc = "cursor."]
            async fn set_cursor_rectangle(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Sets a specific language. This allows for example a virtual keyboard to"]
            #[doc = "show a language specific layout. The \"language\" argument is a RFC-3066"]
            #[doc = "format language tag."]
            #[doc = ""]
            #[doc = "It could be used for example in a word processor to indicate language of"]
            #[doc = "currently edited document or in an instant message application which"]
            #[doc = "tracks languages of contacts."]
            async fn set_preferred_language(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                language: String,
            ) -> crate::server::Result<()>;
            #[doc = "Allows to atomically send state updates from client."]
            #[doc = ""]
            #[doc = "This request should follow after a batch of state updating requests"]
            #[doc = "like set_surrounding_text, set_content_type, set_cursor_rectangle and"]
            #[doc = "set_preferred_language."]
            #[doc = ""]
            #[doc = "The flags field indicates why an updated state is sent to the input"]
            #[doc = "method."]
            #[doc = ""]
            #[doc = "Reset should be used by an editor widget after the text was changed"]
            #[doc = "outside of the normal input method flow."]
            #[doc = ""]
            #[doc = "For \"change\" it is enough to send the changed state, else the full"]
            #[doc = "state should be send."]
            #[doc = ""]
            #[doc = "Serial should be set to the serial from the last enter or"]
            #[doc = "input_method_changed event."]
            #[doc = ""]
            #[doc = "To make sure to not receive outdated input method events after a"]
            #[doc = "reset or switching to a new widget wl_display_sync() should be used"]
            #[doc = "after update_state in these cases."]
            async fn update_state(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                reason: UpdateState,
            ) -> crate::server::Result<()>;
            #[doc = "Notification that this seat's text-input focus is on a certain surface."]
            #[doc = ""]
            #[doc = "When the seat has the keyboard capability the text-input focus follows"]
            #[doc = "the keyboard focus."]
            async fn enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v2#{}.enter()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notification that this seat's text-input focus is no longer on"]
            #[doc = "a certain surface."]
            #[doc = ""]
            #[doc = "The leave notification is sent before the enter notification"]
            #[doc = "for the new focus."]
            #[doc = ""]
            #[doc = "When the seat has the keyboard capability the text-input focus follows"]
            #[doc = "the keyboard focus."]
            async fn leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v2#{}.leave()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notification that the visibility of the input panel (virtual keyboard)"]
            #[doc = "changed."]
            #[doc = ""]
            #[doc = "The rectangle x, y, width, height defines the area overlapped by the"]
            #[doc = "input panel (virtual keyboard) on the surface having the text"]
            #[doc = "focus in surface local coordinates."]
            #[doc = ""]
            #[doc = "That can be used to make sure widgets are visible and not covered by"]
            #[doc = "a virtual keyboard."]
            async fn input_panel_state(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                state: InputPanelVisibility,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v2#{}.input_panel_state()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(state as u32)
                    .put_int(x)
                    .put_int(y)
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notify when a new composing text (pre-edit) should be set around the"]
            #[doc = "current cursor position. Any previously set composing text should"]
            #[doc = "be removed."]
            #[doc = ""]
            #[doc = "The commit text can be used to replace the composing text in some cases"]
            #[doc = "(for example when losing focus)."]
            #[doc = ""]
            #[doc = "The text input should also handle all preedit_style and preedit_cursor"]
            #[doc = "events occurring directly before preedit_string."]
            async fn preedit_string(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                text: String,
                commit: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v2#{}.preedit_string()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(text))
                    .put_string(Some(commit))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sets styling information on composing text. The style is applied for"]
            #[doc = "length bytes from index relative to the beginning of the composing"]
            #[doc = "text (as byte offset). Multiple styles can be applied to a composing"]
            #[doc = "text by sending multiple preedit_styling events."]
            #[doc = ""]
            #[doc = "This event is handled as part of a following preedit_string event."]
            async fn preedit_styling(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: u32,
                length: u32,
                style: PreeditStyle,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v2#{}.preedit_styling()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(index)
                    .put_uint(length)
                    .put_uint(style as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sets the cursor position inside the composing text (as byte"]
            #[doc = "offset) relative to the start of the composing text. When index is a"]
            #[doc = "negative number no cursor is shown."]
            #[doc = ""]
            #[doc = "When no preedit_cursor event is sent the cursor will be at the end of"]
            #[doc = "the composing text by default."]
            #[doc = ""]
            #[doc = "This event is handled as part of a following preedit_string event."]
            async fn preedit_cursor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v2#{}.preedit_cursor()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(index).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notify when text should be inserted into the editor widget. The text to"]
            #[doc = "commit could be either just a single character after a key press or the"]
            #[doc = "result of some composing (pre-edit). It could be also an empty text"]
            #[doc = "when some text should be removed (see delete_surrounding_text) or when"]
            #[doc = "the input cursor should be moved (see cursor_position)."]
            #[doc = ""]
            #[doc = "Any previously set composing text should be removed."]
            async fn commit_string(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                text: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v2#{}.commit_string()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(text))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 6u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notify when the cursor or anchor position should be modified."]
            #[doc = ""]
            #[doc = "This event should be handled as part of a following commit_string"]
            #[doc = "event."]
            #[doc = ""]
            #[doc = "The text between anchor and index should be selected."]
            async fn cursor_position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: i32,
                anchor: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v2#{}.cursor_position()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(index)
                    .put_int(anchor)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 7u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notify when the text around the current cursor position should be"]
            #[doc = "deleted. BeforeLength and afterLength is the length (in bytes) of text"]
            #[doc = "before and after the current cursor position (excluding the selection)"]
            #[doc = "to delete."]
            #[doc = ""]
            #[doc = "This event should be handled as part of a following commit_string"]
            #[doc = "or preedit_string event."]
            async fn delete_surrounding_text(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                before_length: u32,
                after_length: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_text_input_v2#{}.delete_surrounding_text()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(before_length)
                    .put_uint(after_length)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 8u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Transfer an array of 0-terminated modifiers names. The position in"]
            #[doc = "the array is the index of the modifier as used in the modifiers"]
            #[doc = "bitmask in the keysym event."]
            async fn modifiers_map(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                map: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v2#{}.modifiers_map()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_array(map).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 9u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notify when a key event was sent. Key events should not be used"]
            #[doc = "for normal text input operations, which should be done with"]
            #[doc = "commit_string, delete_surrounding_text, etc. The key event follows"]
            #[doc = "the wl_keyboard key event convention. Sym is a XKB keysym, state a"]
            #[doc = "wl_keyboard key_state. Modifiers are a mask for effective modifiers"]
            #[doc = "(where the modifier indices are set by the modifiers_map event)"]
            async fn keysym(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                sym: u32,
                state: u32,
                modifiers: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v2#{}.keysym()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_uint(sym)
                    .put_uint(state)
                    .put_uint(modifiers)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 10u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sets the language of the input text. The \"language\" argument is a RFC-3066"]
            #[doc = "format language tag."]
            async fn language(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                language: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v2#{}.language()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(language))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 11u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sets the text direction of input text."]
            #[doc = ""]
            #[doc = "It is mainly needed for showing input cursor on correct side of the"]
            #[doc = "editor when there is no input yet done and making sure neutral"]
            #[doc = "direction text is laid out properly."]
            async fn text_direction(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                direction: TextDirection,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v2#{}.text_direction()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(direction as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 12u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Configure what amount of surrounding text is expected by the"]
            #[doc = "input method. The surrounding text will be sent in the"]
            #[doc = "set_surrounding_text request on the following state information updates."]
            async fn configure_surrounding_text(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                before_cursor: i32,
                after_cursor: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_text_input_v2#{}.configure_surrounding_text()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(before_cursor)
                    .put_int(after_cursor)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 13u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The input method changed on compositor side, which invalidates all"]
            #[doc = "current state information. New state information should be sent from"]
            #[doc = "the client via state requests (set_surrounding_text,"]
            #[doc = "set_content_hint, ...) and update_state."]
            async fn input_method_changed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                flags: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v2#{}.input_method_changed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(flags)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 14u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A factory for text-input objects. This object is a global singleton."]
    pub mod zwp_text_input_manager_v2 {
        #[doc = "Trait to implement the zwp_text_input_manager_v2 interface. See the module level documentation for more info"]
        pub trait ZwpTextInputManagerV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_text_input_manager_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zwp_text_input_manager_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zwp_text_input_manager_v2#{}.get_text_input()", object.id);
                        self.get_text_input(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the wp_text_input_manager object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Creates a new text-input object for a given seat."]
            async fn get_text_input(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod text {
    #[doc = "An object used for text input. Adds support for text input and input"]
    #[doc = "methods to applications. A text-input object is created from a"]
    #[doc = "wl_text_input_manager and corresponds typically to a text entry in an"]
    #[doc = "application."]
    #[doc = "Requests are used to activate/deactivate the text-input object and set"]
    #[doc = "state information like surrounding and selected text or the content type."]
    #[doc = "The information about entered text is sent to the text-input object via"]
    #[doc = "the pre-edit and commit events. Using this interface removes the need"]
    #[doc = "for applications to directly process hardware key events and compose text"]
    #[doc = "out of them."]
    #[doc = ""]
    #[doc = "Text is generally UTF-8 encoded, indices and lengths are in bytes."]
    #[doc = ""]
    #[doc = "Serials are used to synchronize the state between the text input and"]
    #[doc = "an input method. New serials are sent by the text input in the"]
    #[doc = "commit_state request and are used by the input method to indicate"]
    #[doc = "the known text input state in events like preedit_string, commit_string,"]
    #[doc = "and keysym. The text input can then ignore events from the input method"]
    #[doc = "which are based on an outdated state (for example after a reset)."]
    pub mod wl_text_input {
        #[doc = "Content hint is a bitmask to allow to modify the behavior of the text"]
        #[doc = "input."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ContentHint {
            #[doc = "no special behaviour"]
            None = 0u32,
            #[doc = "auto completion, correction and capitalization"]
            Default = 7u32,
            #[doc = "hidden and sensitive text"]
            Password = 192u32,
            #[doc = "suggest word completions"]
            AutoCompletion = 1u32,
            #[doc = "suggest word corrections"]
            AutoCorrection = 2u32,
            #[doc = "switch to uppercase letters at the start of a sentence"]
            AutoCapitalization = 4u32,
            #[doc = "prefer lowercase letters"]
            Lowercase = 8u32,
            #[doc = "prefer uppercase letters"]
            Uppercase = 16u32,
            #[doc = "prefer casing for titles and headings (can be language dependent)"]
            Titlecase = 32u32,
            #[doc = "characters should be hidden"]
            HiddenText = 64u32,
            #[doc = "typed text should not be stored"]
            SensitiveData = 128u32,
            #[doc = "just latin characters should be entered"]
            Latin = 256u32,
            #[doc = "the text input is multiline"]
            Multiline = 512u32,
        }
        impl TryFrom<u32> for ContentHint {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::None),
                    7u32 => Ok(Self::Default),
                    192u32 => Ok(Self::Password),
                    1u32 => Ok(Self::AutoCompletion),
                    2u32 => Ok(Self::AutoCorrection),
                    4u32 => Ok(Self::AutoCapitalization),
                    8u32 => Ok(Self::Lowercase),
                    16u32 => Ok(Self::Uppercase),
                    32u32 => Ok(Self::Titlecase),
                    64u32 => Ok(Self::HiddenText),
                    128u32 => Ok(Self::SensitiveData),
                    256u32 => Ok(Self::Latin),
                    512u32 => Ok(Self::Multiline),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "The content purpose allows to specify the primary purpose of a text"]
        #[doc = "input."]
        #[doc = ""]
        #[doc = "This allows an input method to show special purpose input panels with"]
        #[doc = "extra characters or to disallow some characters."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ContentPurpose {
            #[doc = "default input, allowing all characters"]
            Normal = 0u32,
            #[doc = "allow only alphabetic characters"]
            Alpha = 1u32,
            #[doc = "allow only digits"]
            Digits = 2u32,
            #[doc = "input a number (including decimal separator and sign)"]
            Number = 3u32,
            #[doc = "input a phone number"]
            Phone = 4u32,
            #[doc = "input an URL"]
            Url = 5u32,
            #[doc = "input an email address"]
            Email = 6u32,
            #[doc = "input a name of a person"]
            Name = 7u32,
            #[doc = "input a password (combine with password or sensitive_data hint)"]
            Password = 8u32,
            #[doc = "input a date"]
            Date = 9u32,
            #[doc = "input a time"]
            Time = 10u32,
            #[doc = "input a date and time"]
            Datetime = 11u32,
            #[doc = "input for a terminal"]
            Terminal = 12u32,
        }
        impl TryFrom<u32> for ContentPurpose {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Normal),
                    1u32 => Ok(Self::Alpha),
                    2u32 => Ok(Self::Digits),
                    3u32 => Ok(Self::Number),
                    4u32 => Ok(Self::Phone),
                    5u32 => Ok(Self::Url),
                    6u32 => Ok(Self::Email),
                    7u32 => Ok(Self::Name),
                    8u32 => Ok(Self::Password),
                    9u32 => Ok(Self::Date),
                    10u32 => Ok(Self::Time),
                    11u32 => Ok(Self::Datetime),
                    12u32 => Ok(Self::Terminal),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum PreeditStyle {
            #[doc = "default style for composing text"]
            Default = 0u32,
            #[doc = "style should be the same as in non-composing text"]
            None = 1u32,
            Active = 2u32,
            Inactive = 3u32,
            Highlight = 4u32,
            Underline = 5u32,
            Selection = 6u32,
            Incorrect = 7u32,
        }
        impl TryFrom<u32> for PreeditStyle {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Default),
                    1u32 => Ok(Self::None),
                    2u32 => Ok(Self::Active),
                    3u32 => Ok(Self::Inactive),
                    4u32 => Ok(Self::Highlight),
                    5u32 => Ok(Self::Underline),
                    6u32 => Ok(Self::Selection),
                    7u32 => Ok(Self::Incorrect),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum TextDirection {
            #[doc = "automatic text direction based on text and language"]
            Auto = 0u32,
            #[doc = "left-to-right"]
            Ltr = 1u32,
            #[doc = "right-to-left"]
            Rtl = 2u32,
        }
        impl TryFrom<u32> for TextDirection {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Auto),
                    1u32 => Ok(Self::Ltr),
                    2u32 => Ok(Self::Rtl),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wl_text_input interface. See the module level documentation for more info"]
        pub trait WlTextInput: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_text_input";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_text_input#{}.activate()", object.id);
                        self.activate(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("wl_text_input#{}.deactivate()", object.id);
                        self.deactivate(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("wl_text_input#{}.show_input_panel()", object.id);
                        self.show_input_panel(object, client).await
                    }
                    3u16 => {
                        tracing::debug!("wl_text_input#{}.hide_input_panel()", object.id);
                        self.hide_input_panel(object, client).await
                    }
                    4u16 => {
                        tracing::debug!("wl_text_input#{}.reset()", object.id);
                        self.reset(object, client).await
                    }
                    5u16 => {
                        tracing::debug!("wl_text_input#{}.set_surrounding_text()", object.id);
                        self.set_surrounding_text(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    6u16 => {
                        tracing::debug!("wl_text_input#{}.set_content_type()", object.id);
                        self.set_content_type(object, client, message.uint()?, message.uint()?)
                            .await
                    }
                    7u16 => {
                        tracing::debug!("wl_text_input#{}.set_cursor_rectangle()", object.id);
                        self.set_cursor_rectangle(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    8u16 => {
                        tracing::debug!("wl_text_input#{}.set_preferred_language()", object.id);
                        self.set_preferred_language(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    9u16 => {
                        tracing::debug!("wl_text_input#{}.commit_state()", object.id);
                        self.commit_state(object, client, message.uint()?).await
                    }
                    10u16 => {
                        tracing::debug!("wl_text_input#{}.invoke_action()", object.id);
                        self.invoke_action(object, client, message.uint()?, message.uint()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Requests the text-input object to be activated (typically when the"]
            #[doc = "text entry gets focus)."]
            #[doc = "The seat argument is a wl_seat which maintains the focus for this"]
            #[doc = "activation. The surface argument is a wl_surface assigned to the"]
            #[doc = "text-input object and tracked for focus lost. The enter event"]
            #[doc = "is emitted on successful activation."]
            async fn activate(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Requests the text-input object to be deactivated (typically when the"]
            #[doc = "text entry lost focus). The seat argument is a wl_seat which was used"]
            #[doc = "for activation."]
            async fn deactivate(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Requests input panels (virtual keyboard) to show."]
            async fn show_input_panel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Requests input panels (virtual keyboard) to hide."]
            async fn hide_input_panel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Should be called by an editor widget when the input state should be"]
            #[doc = "reset, for example after the text was changed outside of the normal"]
            #[doc = "input method flow."]
            async fn reset(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the plain surrounding text around the input position. Text is"]
            #[doc = "UTF-8 encoded. Cursor is the byte offset within the"]
            #[doc = "surrounding text. Anchor is the byte offset of the"]
            #[doc = "selection anchor within the surrounding text. If there is no selected"]
            #[doc = "text anchor is the same as cursor."]
            async fn set_surrounding_text(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                text: String,
                cursor: u32,
                anchor: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the content purpose and content hint. While the purpose is the"]
            #[doc = "basic purpose of an input field, the hint flags allow to modify some"]
            #[doc = "of the behavior."]
            #[doc = ""]
            #[doc = "When no content type is explicitly set, a normal content purpose with"]
            #[doc = "default hints (auto completion, auto correction, auto capitalization)"]
            #[doc = "should be assumed."]
            async fn set_content_type(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                hint: u32,
                purpose: u32,
            ) -> crate::server::Result<()>;
            async fn set_cursor_rectangle(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Sets a specific language. This allows for example a virtual keyboard to"]
            #[doc = "show a language specific layout. The \"language\" argument is a RFC-3066"]
            #[doc = "format language tag."]
            #[doc = ""]
            #[doc = "It could be used for example in a word processor to indicate language of"]
            #[doc = "currently edited document or in an instant message application which tracks"]
            #[doc = "languages of contacts."]
            async fn set_preferred_language(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                language: String,
            ) -> crate::server::Result<()>;
            async fn commit_state(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()>;
            async fn invoke_action(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                button: u32,
                index: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Notify the text-input object when it received focus. Typically in"]
            #[doc = "response to an activate request."]
            async fn enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_text_input#{}.enter()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notify the text-input object when it lost focus. Either in response"]
            #[doc = "to a deactivate request or when the assigned surface lost focus or was"]
            #[doc = "destroyed."]
            async fn leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_text_input#{}.leave()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Transfer an array of 0-terminated modifiers names. The position in"]
            #[doc = "the array is the index of the modifier as used in the modifiers"]
            #[doc = "bitmask in the keysym event."]
            async fn modifiers_map(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                map: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_text_input#{}.modifiers_map()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_array(map).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notify when the visibility state of the input panel changed."]
            async fn input_panel_state(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                state: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_text_input#{}.input_panel_state()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(state).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notify when a new composing text (pre-edit) should be set around the"]
            #[doc = "current cursor position. Any previously set composing text should"]
            #[doc = "be removed."]
            #[doc = ""]
            #[doc = "The commit text can be used to replace the preedit text on reset"]
            #[doc = "(for example on unfocus)."]
            #[doc = ""]
            #[doc = "The text input should also handle all preedit_style and preedit_cursor"]
            #[doc = "events occurring directly before preedit_string."]
            async fn preedit_string(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                text: String,
                commit: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_text_input#{}.preedit_string()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_string(Some(text))
                    .put_string(Some(commit))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sets styling information on composing text. The style is applied for"]
            #[doc = "length bytes from index relative to the beginning of the composing"]
            #[doc = "text (as byte offset). Multiple styles can"]
            #[doc = "be applied to a composing text by sending multiple preedit_styling"]
            #[doc = "events."]
            #[doc = ""]
            #[doc = "This event is handled as part of a following preedit_string event."]
            async fn preedit_styling(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: u32,
                length: u32,
                style: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_text_input#{}.preedit_styling()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(index)
                    .put_uint(length)
                    .put_uint(style)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sets the cursor position inside the composing text (as byte"]
            #[doc = "offset) relative to the start of the composing text. When index is a"]
            #[doc = "negative number no cursor is shown."]
            #[doc = ""]
            #[doc = "This event is handled as part of a following preedit_string event."]
            async fn preedit_cursor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_text_input#{}.preedit_cursor()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(index).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 6u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notify when text should be inserted into the editor widget. The text to"]
            #[doc = "commit could be either just a single character after a key press or the"]
            #[doc = "result of some composing (pre-edit). It could be also an empty text"]
            #[doc = "when some text should be removed (see delete_surrounding_text) or when"]
            #[doc = "the input cursor should be moved (see cursor_position)."]
            #[doc = ""]
            #[doc = "Any previously set composing text should be removed."]
            async fn commit_string(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                text: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_text_input#{}.commit_string()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_string(Some(text))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 7u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notify when the cursor or anchor position should be modified."]
            #[doc = ""]
            #[doc = "This event should be handled as part of a following commit_string"]
            #[doc = "event."]
            async fn cursor_position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: i32,
                anchor: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_text_input#{}.cursor_position()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(index)
                    .put_int(anchor)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 8u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notify when the text around the current cursor position should be"]
            #[doc = "deleted."]
            #[doc = ""]
            #[doc = "Index is relative to the current cursor (in bytes)."]
            #[doc = "Length is the length of deleted text (in bytes)."]
            #[doc = ""]
            #[doc = "This event should be handled as part of a following commit_string"]
            #[doc = "event."]
            async fn delete_surrounding_text(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: i32,
                length: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_text_input#{}.delete_surrounding_text()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(index)
                    .put_uint(length)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 9u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Notify when a key event was sent. Key events should not be used"]
            #[doc = "for normal text input operations, which should be done with"]
            #[doc = "commit_string, delete_surrounding_text, etc. The key event follows"]
            #[doc = "the wl_keyboard key event convention. Sym is a XKB keysym, state a"]
            #[doc = "wl_keyboard key_state. Modifiers are a mask for effective modifiers"]
            #[doc = "(where the modifier indices are set by the modifiers_map event)"]
            async fn keysym(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                sym: u32,
                state: u32,
                modifiers: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_text_input#{}.keysym()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(time)
                    .put_uint(sym)
                    .put_uint(state)
                    .put_uint(modifiers)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 10u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sets the language of the input text. The \"language\" argument is a RFC-3066"]
            #[doc = "format language tag."]
            async fn language(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                language: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_text_input#{}.language()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_string(Some(language))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 11u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sets the text direction of input text."]
            #[doc = ""]
            #[doc = "It is mainly needed for showing input cursor on correct side of the"]
            #[doc = "editor when there is no input yet done and making sure neutral"]
            #[doc = "direction text is laid out properly."]
            async fn text_direction(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                direction: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_text_input#{}.text_direction()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(direction)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 12u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A factory for text-input objects. This object is a global singleton."]
    pub mod wl_text_input_manager {
        #[doc = "Trait to implement the wl_text_input_manager interface. See the module level documentation for more info"]
        pub trait WlTextInputManager: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_text_input_manager";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("wl_text_input_manager#{}.create_text_input()", object.id);
                        self.create_text_input(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Creates a new text-input object."]
            async fn create_text_input(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod wl_eglstream_controller {
    pub mod wl_eglstream_controller {
        #[doc = "- dont_care: Using this enum will tell the server to make its own"]
        #[doc = "decisions regarding present mode."]
        #[doc = ""]
        #[doc = "- fifo:      Tells the server to use a fifo present mode. The decision to"]
        #[doc = "use fifo synchronous is left up to the server."]
        #[doc = ""]
        #[doc = "- mailbox:   Tells the server to use a mailbox present mode."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum PresentMode {
            #[doc = "Let the Server decide present mode"]
            DontCare = 0u32,
            #[doc = "Use a fifo present mode"]
            Fifo = 1u32,
            #[doc = "Use a mailbox mode"]
            Mailbox = 2u32,
        }
        impl TryFrom<u32> for PresentMode {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::DontCare),
                    1u32 => Ok(Self::Fifo),
                    2u32 => Ok(Self::Mailbox),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "- present_mode: Must be one of wl_eglstream_controller_present_mode. Tells the"]
        #[doc = "server the desired present mode that should be used."]
        #[doc = ""]
        #[doc = "- fifo_length:  Only valid when the present_mode attrib is provided and its"]
        #[doc = "value is specified as fifo. Tells the server the desired fifo"]
        #[doc = "length to be used when the desired present_mode is fifo."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Attrib {
            #[doc = "Tells the server the desired present mode"]
            PresentMode = 0u32,
            #[doc = "Tells the server the desired fifo length when the desired presenation_mode is fifo."]
            FifoLength = 1u32,
        }
        impl TryFrom<u32> for Attrib {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::PresentMode),
                    1u32 => Ok(Self::FifoLength),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the wl_eglstream_controller interface. See the module level documentation for more info"]
        pub trait WlEglstreamController: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_eglstream_controller";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "wl_eglstream_controller#{}.attach_eglstream_consumer()",
                            object.id
                        );
                        self.attach_eglstream_consumer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "wl_eglstream_controller#{}.attach_eglstream_consumer_attribs()",
                            object.id
                        );
                        self.attach_eglstream_consumer_attribs(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.array()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Creates the corresponding server side EGLStream from the given wl_buffer"]
            #[doc = "and attaches a consumer to it."]
            async fn attach_eglstream_consumer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                wl_surface: crate::wire::ObjectId,
                wl_resource: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Creates the corresponding server side EGLStream from the given wl_buffer"]
            #[doc = "and attaches a consumer to it using the given attributes."]
            async fn attach_eglstream_consumer_attribs(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                wl_surface: crate::wire::ObjectId,
                wl_resource: crate::wire::ObjectId,
                attribs: Vec<u8>,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod dpms {
    #[doc = "The Dpms manager allows to get a org_kde_kwin_dpms for a given wl_output."]
    #[doc = "The org_kde_kwin_dpms provides the currently used VESA Display Power Management"]
    #[doc = "Signaling state (see https://en.wikipedia.org/wiki/VESA_Display_Power_Management_Signaling )."]
    #[doc = "In addition it allows to request a state change. A compositor is not obliged to honor it"]
    #[doc = "and will normally automatically switch back to on state."]
    pub mod org_kde_kwin_dpms_manager {
        #[doc = "Trait to implement the org_kde_kwin_dpms_manager interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinDpmsManager: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_dpms_manager";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("org_kde_kwin_dpms_manager#{}.get()", object.id);
                        self.get(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Factory request to get the org_kde_kwin_dpms for a given wl_output."]
            async fn get(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "This interface provides information about the VESA DPMS state for a wl_output."]
    #[doc = "It gets created through the request get on the org_kde_kwin_dpms_manager interface."]
    #[doc = ""]
    #[doc = "On creating the resource the server will push whether DPSM is supported for the output,"]
    #[doc = "the currently used DPMS state and notifies the client through the done event once all"]
    #[doc = "states are pushed. Whenever a state changes the set of changes is committed with the"]
    #[doc = "done event."]
    pub mod org_kde_kwin_dpms {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Mode {
            On = 0u32,
            Standby = 1u32,
            Suspend = 2u32,
            Off = 3u32,
        }
        impl TryFrom<u32> for Mode {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::On),
                    1u32 => Ok(Self::Standby),
                    2u32 => Ok(Self::Suspend),
                    3u32 => Ok(Self::Off),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the org_kde_kwin_dpms interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinDpms: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_dpms";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("org_kde_kwin_dpms#{}.set()", object.id);
                        self.set(object, client, message.uint()?).await
                    }
                    1u16 => {
                        tracing::debug!("org_kde_kwin_dpms#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Requests that the compositor puts the wl_output into the passed mode. The compositor"]
            #[doc = "is not obliged to change the state. In addition the compositor might leave the mode"]
            #[doc = "whenever it seems suitable. E.g. the compositor might return to On state on user input."]
            #[doc = ""]
            #[doc = "The client should not assume that the mode changed after requesting a new mode."]
            #[doc = "Instead the client should listen for the mode event."]
            async fn set(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mode: u32,
            ) -> crate::server::Result<()>;
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event gets pushed on binding the resource and indicates whether the wl_output"]
            #[doc = "supports DPMS. There are operation modes of a Wayland server where DPMS might not"]
            #[doc = "make sense (e.g. nested compositors)."]
            async fn supported(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                supported: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_kwin_dpms#{}.supported()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(supported)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This mode gets pushed on binding the resource and provides the currently used"]
            #[doc = "DPMS mode. It also gets pushed if DPMS is not supported for the wl_output, in that"]
            #[doc = "case the value will be On."]
            #[doc = ""]
            #[doc = "The event is also pushed whenever the state changes."]
            async fn mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mode: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_kwin_dpms#{}.mode()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(mode).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event gets pushed on binding the resource once all other states are pushed."]
            #[doc = ""]
            #[doc = "In addition it gets pushed whenever a state changes to tell the client that all"]
            #[doc = "state changes have been pushed."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_kwin_dpms#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod fake_input {
    #[doc = "This interface allows other processes to provide fake input events."]
    #[doc = "Purpose is on the one hand side to provide testing facilities like XTest on X11."]
    #[doc = "But also to support use case like kdeconnect's mouse pad interface."]
    #[doc = ""]
    #[doc = "A compositor should not trust the input received from this interface."]
    #[doc = "Clients should not expect that the compositor honors the requests from this"]
    #[doc = "interface."]
    pub mod org_kde_kwin_fake_input {
        #[doc = "Trait to implement the org_kde_kwin_fake_input interface. See the module level documentation for more info"]
        pub trait OrgKdeKwinFakeInput: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_kwin_fake_input";
            const VERSION: u32 = 5u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("org_kde_kwin_fake_input#{}.authenticate()", object.id);
                        self.authenticate(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("org_kde_kwin_fake_input#{}.pointer_motion()", object.id);
                        self.pointer_motion(object, client, message.fixed()?, message.fixed()?)
                            .await
                    }
                    2u16 => {
                        tracing::debug!("org_kde_kwin_fake_input#{}.button()", object.id);
                        self.button(object, client, message.uint()?, message.uint()?)
                            .await
                    }
                    3u16 => {
                        tracing::debug!("org_kde_kwin_fake_input#{}.axis()", object.id);
                        self.axis(object, client, message.uint()?, message.fixed()?)
                            .await
                    }
                    4u16 => {
                        tracing::debug!("org_kde_kwin_fake_input#{}.touch_down()", object.id);
                        self.touch_down(
                            object,
                            client,
                            message.uint()?,
                            message.fixed()?,
                            message.fixed()?,
                        )
                        .await
                    }
                    5u16 => {
                        tracing::debug!("org_kde_kwin_fake_input#{}.touch_motion()", object.id);
                        self.touch_motion(
                            object,
                            client,
                            message.uint()?,
                            message.fixed()?,
                            message.fixed()?,
                        )
                        .await
                    }
                    6u16 => {
                        tracing::debug!("org_kde_kwin_fake_input#{}.touch_up()", object.id);
                        self.touch_up(object, client, message.uint()?).await
                    }
                    7u16 => {
                        tracing::debug!("org_kde_kwin_fake_input#{}.touch_cancel()", object.id);
                        self.touch_cancel(object, client).await
                    }
                    8u16 => {
                        tracing::debug!("org_kde_kwin_fake_input#{}.touch_frame()", object.id);
                        self.touch_frame(object, client).await
                    }
                    9u16 => {
                        tracing::debug!(
                            "org_kde_kwin_fake_input#{}.pointer_motion_absolute()",
                            object.id
                        );
                        self.pointer_motion_absolute(
                            object,
                            client,
                            message.fixed()?,
                            message.fixed()?,
                        )
                        .await
                    }
                    10u16 => {
                        tracing::debug!("org_kde_kwin_fake_input#{}.keyboard_key()", object.id);
                        self.keyboard_key(object, client, message.uint()?, message.uint()?)
                            .await
                    }
                    11u16 => {
                        tracing::debug!("org_kde_kwin_fake_input#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "A client should use this request to tell the compositor why it wants to"]
            #[doc = "use this interface. The compositor might use the information to decide"]
            #[doc = "whether it wants to grant the request. The data might also be passed to"]
            #[doc = "the user to decide whether the application should get granted access to"]
            #[doc = "this very privileged interface."]
            async fn authenticate(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                application: String,
                reason: String,
            ) -> crate::server::Result<()>;
            async fn pointer_motion(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                delta_x: crate::wire::Fixed,
                delta_y: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            async fn button(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                button: u32,
                state: u32,
            ) -> crate::server::Result<()>;
            async fn axis(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                axis: u32,
                value: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            #[doc = "A client should use this request to send touch down event at specific"]
            #[doc = "coordinates."]
            async fn touch_down(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: u32,
                x: crate::wire::Fixed,
                y: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            #[doc = "A client should use this request to send touch motion to specific position."]
            async fn touch_motion(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: u32,
                x: crate::wire::Fixed,
                y: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            #[doc = "A client should use this request to send touch up event."]
            async fn touch_up(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: u32,
            ) -> crate::server::Result<()>;
            #[doc = "A client should use this request to cancel the current"]
            #[doc = "touch event."]
            async fn touch_cancel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "A client should use this request to send touch frame event."]
            async fn touch_frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            async fn pointer_motion_absolute(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: crate::wire::Fixed,
                y: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            async fn keyboard_key(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                button: u32,
                state: u32,
            ) -> crate::server::Result<()>;
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod kde_lockscreen_overlay_v1 {
    #[doc = "Allows a client to request a surface to be visible when the system is locked."]
    #[doc = ""]
    #[doc = "This is meant to be used for specific high urgency cases like phone calls or alarms."]
    pub mod kde_lockscreen_overlay_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "the client provided an invalid surface state"]
            InvalidSurfaceState = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidSurfaceState),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the kde_lockscreen_overlay_v1 interface. See the module level documentation for more info"]
        pub trait KdeLockscreenOverlayV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "kde_lockscreen_overlay_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("kde_lockscreen_overlay_v1#{}.allow()", object.id);
                        self.allow(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("kde_lockscreen_overlay_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Informs the compositor that the surface could be shown when the screen is locked. This request should be called while the surface is unmapped."]
            async fn allow(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This won't affect the surface previously marked with the allow request."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod kde_output_device_v2 {
    #[doc = "An output device describes a display device available to the compositor."]
    #[doc = "output_device is similar to wl_output, but focuses on output"]
    #[doc = "configuration management."]
    #[doc = ""]
    #[doc = "A client can query all global output_device objects to enlist all"]
    #[doc = "available display devices, even those that may currently not be"]
    #[doc = "represented by the compositor as a wl_output."]
    #[doc = ""]
    #[doc = "The client sends configuration changes to the server through the"]
    #[doc = "outputconfiguration interface, and the server applies the configuration"]
    #[doc = "changes to the hardware and signals changes to the output devices"]
    #[doc = "accordingly."]
    #[doc = ""]
    #[doc = "This object is published as global during start up for every available"]
    #[doc = "display devices, or when one later becomes available, for example by"]
    #[doc = "being hotplugged via a physical connector."]
    pub mod kde_output_device_v2 {
        #[doc = "This enumeration describes how the physical pixels on an output are"]
        #[doc = "laid out."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Subpixel {
            Unknown = 0u32,
            None = 1u32,
            HorizontalRgb = 2u32,
            HorizontalBgr = 3u32,
            VerticalRgb = 4u32,
            VerticalBgr = 5u32,
        }
        impl TryFrom<u32> for Subpixel {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Unknown),
                    1u32 => Ok(Self::None),
                    2u32 => Ok(Self::HorizontalRgb),
                    3u32 => Ok(Self::HorizontalBgr),
                    4u32 => Ok(Self::VerticalRgb),
                    5u32 => Ok(Self::VerticalBgr),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "This describes the transform, that a compositor will apply to a"]
        #[doc = "surface to compensate for the rotation or mirroring of an"]
        #[doc = "output device."]
        #[doc = ""]
        #[doc = "The flipped values correspond to an initial flip around a"]
        #[doc = "vertical axis followed by rotation."]
        #[doc = ""]
        #[doc = "The purpose is mainly to allow clients to render accordingly and"]
        #[doc = "tell the compositor, so that for fullscreen surfaces, the"]
        #[doc = "compositor is still able to scan out directly client surfaces."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Transform {
            Normal = 0u32,
            _90 = 1u32,
            _180 = 2u32,
            _270 = 3u32,
            Flipped = 4u32,
            Flipped90 = 5u32,
            Flipped180 = 6u32,
            Flipped270 = 7u32,
        }
        impl TryFrom<u32> for Transform {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Normal),
                    1u32 => Ok(Self::_90),
                    2u32 => Ok(Self::_180),
                    3u32 => Ok(Self::_270),
                    4u32 => Ok(Self::Flipped),
                    5u32 => Ok(Self::Flipped90),
                    6u32 => Ok(Self::Flipped180),
                    7u32 => Ok(Self::Flipped270),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! { # [doc = "Describes what capabilities this device has."] # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Capability : u32 { # [doc = "if this output_device can use overscan"] const Overscan = 1u32 ; # [doc = "if this outputdevice supports variable refresh rate"] const Vrr = 2u32 ; # [doc = "if setting the rgb range is possible"] const RgbRange = 4u32 ; # [doc = "if this outputdevice supports high dynamic range"] const HighDynamicRange = 8u32 ; # [doc = "if this outputdevice supports a wide color gamut"] const WideColorGamut = 16u32 ; # [doc = "if this outputdevice supports autorotation"] const AutoRotate = 32u32 ; # [doc = "if this outputdevice supports icc profiles"] const IccProfile = 64u32 ; } }
        impl TryFrom<u32> for Capability {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "Describes when the compositor may employ variable refresh rate"]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum VrrPolicy {
            Never = 0u32,
            Always = 1u32,
            Automatic = 2u32,
        }
        impl TryFrom<u32> for VrrPolicy {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Never),
                    1u32 => Ok(Self::Always),
                    2u32 => Ok(Self::Automatic),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Whether full or limited color range should be used"]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum RgbRange {
            Automatic = 0u32,
            Full = 1u32,
            Limited = 2u32,
        }
        impl TryFrom<u32> for RgbRange {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Automatic),
                    1u32 => Ok(Self::Full),
                    2u32 => Ok(Self::Limited),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum AutoRotatePolicy {
            Never = 0u32,
            InTabletMode = 1u32,
            Always = 2u32,
        }
        impl TryFrom<u32> for AutoRotatePolicy {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Never),
                    1u32 => Ok(Self::InTabletMode),
                    2u32 => Ok(Self::Always),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ColorProfileSource {
            SRgb = 0u32,
            Icc = 1u32,
            Edid = 2u32,
        }
        impl TryFrom<u32> for ColorProfileSource {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::SRgb),
                    1u32 => Ok(Self::Icc),
                    2u32 => Ok(Self::Edid),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the kde_output_device_v2 interface. See the module level documentation for more info"]
        pub trait KdeOutputDeviceV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "kde_output_device_v2";
            const VERSION: u32 = 8u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "The geometry event describes geometric properties of the output."]
            #[doc = "The event is sent when binding to the output object and whenever"]
            #[doc = "any of the properties change."]
            async fn geometry(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                physical_width: i32,
                physical_height: i32,
                subpixel: i32,
                make: String,
                model: String,
                transform: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_v2#{}.geometry()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(x)
                    .put_int(y)
                    .put_int(physical_width)
                    .put_int(physical_height)
                    .put_int(subpixel)
                    .put_string(Some(make))
                    .put_string(Some(model))
                    .put_int(transform)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event describes the mode currently in use for this head. It is only"]
            #[doc = "sent if the output is enabled."]
            async fn current_mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mode: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_v2#{}.current_mode()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(mode))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The mode event describes an available mode for the output."]
            #[doc = ""]
            #[doc = "When the client binds to the output_device object, the server sends this"]
            #[doc = "event once for every available mode the output_device can be operated by."]
            #[doc = ""]
            #[doc = "There will always be at least one event sent out on initial binding,"]
            #[doc = "which represents the current mode."]
            #[doc = ""]
            #[doc = "Later if an output changes, its mode event is sent again for the"]
            #[doc = "eventual added modes and lastly the current mode. In other words, the"]
            #[doc = "current mode is always represented by the latest event sent with the current"]
            #[doc = "flag set."]
            #[doc = ""]
            #[doc = "The size of a mode is given in physical hardware units of the output device."]
            #[doc = "This is not necessarily the same as the output size in the global compositor"]
            #[doc = "space. For instance, the output may be scaled, as described in"]
            #[doc = "kde_output_device_v2.scale, or transformed, as described in"]
            #[doc = "kde_output_device_v2.transform."]
            async fn mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                mode: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_v2#{}.mode()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(mode))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent after all other properties have been"]
            #[doc = "sent on binding to the output object as well as after any"]
            #[doc = "other output property change have been applied later on."]
            #[doc = "This allows to see changes to the output properties as atomic,"]
            #[doc = "even if multiple events successively announce them."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_v2#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event contains scaling geometry information"]
            #[doc = "that is not in the geometry event. It may be sent after"]
            #[doc = "binding the output object or if the output scale changes"]
            #[doc = "later. If it is not sent, the client should assume a"]
            #[doc = "scale of 1."]
            #[doc = ""]
            #[doc = "A scale larger than 1 means that the compositor will"]
            #[doc = "automatically scale surface buffers by this amount"]
            #[doc = "when rendering. This is used for high resolution"]
            #[doc = "displays where applications rendering at the native"]
            #[doc = "resolution would be too small to be legible."]
            #[doc = ""]
            #[doc = "It is intended that scaling aware clients track the"]
            #[doc = "current output of a surface, and if it is on a scaled"]
            #[doc = "output it should use wl_surface.set_buffer_scale with"]
            #[doc = "the scale of the output. That way the compositor can"]
            #[doc = "avoid scaling the surface, and the client can supply"]
            #[doc = "a higher detail image."]
            async fn scale(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                factor: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_v2#{}.scale()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_fixed(factor).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The edid event encapsulates the EDID data for the outputdevice."]
            #[doc = ""]
            #[doc = "The event is sent when binding to the output object. The EDID"]
            #[doc = "data may be empty, in which case this event is sent anyway."]
            #[doc = "If the EDID information is empty, you can fall back to the name"]
            #[doc = "et al. properties of the outputdevice."]
            async fn edid(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                raw: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_v2#{}.edid()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(raw))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The enabled event notifies whether this output is currently"]
            #[doc = "enabled and used for displaying content by the server."]
            #[doc = "The event is sent when binding to the output object and"]
            #[doc = "whenever later on an output changes its state by becoming"]
            #[doc = "enabled or disabled."]
            async fn enabled(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                enabled: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_v2#{}.enabled()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(enabled).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 6u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The uuid can be used to identify the output. It's controlled by"]
            #[doc = "the server entirely. The server should make sure the uuid is"]
            #[doc = "persistent across restarts. An empty uuid is considered invalid."]
            async fn uuid(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                uuid: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_v2#{}.uuid()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(uuid))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 7u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Serial ID of the monitor, sent on startup before the first done event."]
            async fn serial_number(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial_number: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_v2#{}.serial_number()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(serial_number))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 8u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "EISA ID of the monitor, sent on startup before the first done event."]
            async fn eisa_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                eisa_id: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_v2#{}.eisa_id()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(eisa_id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 9u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "What capabilities this device has, sent on startup before the first"]
            #[doc = "done event."]
            async fn capabilities(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                flags: Capability,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_v2#{}.capabilities()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(flags.bits())
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 10u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Overscan value of the monitor in percent, sent on startup before the"]
            #[doc = "first done event."]
            async fn overscan(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                overscan: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_v2#{}.overscan()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(overscan)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 11u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "What policy the compositor will employ regarding its use of variable"]
            #[doc = "refresh rate."]
            async fn vrr_policy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                vrr_policy: VrrPolicy,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_v2#{}.vrr_policy()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(vrr_policy as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 12u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "What rgb range the compositor is using for this output"]
            async fn rgb_range(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                rgb_range: RgbRange,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_v2#{}.rgb_range()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(rgb_range as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 13u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Name of the output, it's useful to cross-reference to an zxdg_output_v1 and ultimately QScreen"]
            async fn name(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_v2#{}.name()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(name))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 14u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Whether or not high dynamic range is enabled for this output"]
            async fn high_dynamic_range(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                hdr_enabled: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_v2#{}.high_dynamic_range()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(hdr_enabled)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 15u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "If high dynamic range is used, this value defines the brightness in nits for content"]
            #[doc = "that's in standard dynamic range format. Note that while the value is in nits, that"]
            #[doc = "doesn't necessarily translate to the same brightness on the screen."]
            async fn sdr_brightness(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                sdr_brightness: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_v2#{}.sdr_brightness()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(sdr_brightness)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 16u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Whether or not the use of a wide color gamut is enabled for this output"]
            async fn wide_color_gamut(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                wcg_enabled: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_v2#{}.wide_color_gamut()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(wcg_enabled)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 17u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn auto_rotate_policy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                policy: AutoRotatePolicy,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_v2#{}.auto_rotate_policy()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(policy as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 18u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn icc_profile_path(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                profile_path: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_v2#{}.icc_profile_path()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(profile_path))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 19u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn brightness_metadata(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                max_peak_brightness: u32,
                max_frame_average_brightness: u32,
                min_brightness: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> kde_output_device_v2#{}.brightness_metadata()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(max_peak_brightness)
                    .put_uint(max_frame_average_brightness)
                    .put_uint(min_brightness)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 20u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn brightness_overrides(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                max_peak_brightness: i32,
                max_average_brightness: i32,
                min_brightness: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> kde_output_device_v2#{}.brightness_overrides()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(max_peak_brightness)
                    .put_int(max_average_brightness)
                    .put_int(min_brightness)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 21u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This can be used to provide the colors users assume sRGB applications should have based on the"]
            #[doc = "default experience on many modern sRGB screens."]
            async fn sdr_gamut_wideness(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                gamut_wideness: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_v2#{}.sdr_gamut_wideness()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(gamut_wideness)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 22u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn color_profile_source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: ColorProfileSource,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> kde_output_device_v2#{}.color_profile_source()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(source as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 23u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This is the brightness modifier of the output. It doesn't specify"]
            #[doc = "any absolute values, but is merely a multiplier on top of other"]
            #[doc = "brightness values, like sdr_brightness and brightness_metadata."]
            #[doc = "0 is the minimum brightness (not completely dark) and 10000 is"]
            #[doc = "the maximum brightness."]
            #[doc = "This is currently only supported / meaningful while HDR is active."]
            async fn brightness(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                brightness: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_v2#{}.brightness()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(brightness)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 24u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "This object describes an output mode."]
    #[doc = ""]
    #[doc = "Some heads don't support output modes, in which case modes won't be"]
    #[doc = "advertised."]
    #[doc = ""]
    #[doc = "Properties sent via this interface are applied atomically via the"]
    #[doc = "kde_output_device.done event. No guarantees are made regarding the order"]
    #[doc = "in which properties are sent."]
    pub mod kde_output_device_mode_v2 {
        #[doc = "Trait to implement the kde_output_device_mode_v2 interface. See the module level documentation for more info"]
        pub trait KdeOutputDeviceModeV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "kde_output_device_mode_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This event describes the mode size. The size is given in physical"]
            #[doc = "hardware units of the output device. This is not necessarily the same as"]
            #[doc = "the output size in the global compositor space. For instance, the output"]
            #[doc = "may be scaled or transformed."]
            async fn size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_mode_v2#{}.size()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event describes the mode's fixed vertical refresh rate. It is only"]
            #[doc = "sent if the mode has a fixed refresh rate."]
            async fn refresh(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                refresh: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_mode_v2#{}.refresh()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(refresh).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event advertises this mode as preferred."]
            async fn preferred(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_mode_v2#{}.preferred()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The compositor will destroy the object immediately after sending this"]
            #[doc = "event, so it will become invalid and the client should release any"]
            #[doc = "resources associated with it."]
            async fn removed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_device_mode_v2#{}.removed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod kde_output_management_v2 {
    #[doc = "This interface enables clients to set properties of output devices for screen"]
    #[doc = "configuration purposes via the server. To this end output devices are referenced"]
    #[doc = "by global kde_output_device_v2 objects."]
    #[doc = ""]
    #[doc = "outputmanagement (wl_global)"]
    #[doc = "--------------------------"]
    #[doc = "request:"]
    #[doc = "* create_configuration -> outputconfiguration (wl_resource)"]
    #[doc = ""]
    #[doc = "outputconfiguration (wl_resource)"]
    #[doc = "--------------------------"]
    #[doc = "requests:"]
    #[doc = "* enable(outputdevice, bool)"]
    #[doc = "* mode(outputdevice, mode)"]
    #[doc = "* transformation(outputdevice, flag)"]
    #[doc = "* position(outputdevice, x, y)"]
    #[doc = "* apply"]
    #[doc = ""]
    #[doc = "events:"]
    #[doc = "* applied"]
    #[doc = "* failed"]
    #[doc = ""]
    #[doc = "The server registers one outputmanagement object as a global object. In order"]
    #[doc = "to configure outputs a client requests create_configuration, which provides a"]
    #[doc = "resource referencing an outputconfiguration for one-time configuration. That"]
    #[doc = "way the server knows which requests belong together and can group them by that."]
    #[doc = ""]
    #[doc = "On the outputconfiguration object the client calls for each output whether the"]
    #[doc = "output should be enabled, which mode should be set (by referencing the mode from"]
    #[doc = "the list of announced modes) and the output's global position. Once all outputs"]
    #[doc = "are configured that way, the client calls apply."]
    #[doc = "At that point and not earlier the server should try to apply the configuration."]
    #[doc = "If this succeeds the server emits the applied signal, otherwise the failed"]
    #[doc = "signal, such that the configuring client is noticed about the success of its"]
    #[doc = "configuration request."]
    #[doc = ""]
    #[doc = "Through this design the interface enables atomic output configuration changes if"]
    #[doc = "internally supported by the server."]
    pub mod kde_output_management_v2 {
        #[doc = "Trait to implement the kde_output_management_v2 interface. See the module level documentation for more info"]
        pub trait KdeOutputManagementV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "kde_output_management_v2";
            const VERSION: u32 = 9u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "kde_output_management_v2#{}.create_configuration()",
                            object.id
                        );
                        self.create_configuration(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Request an outputconfiguration object through which the client can configure"]
            #[doc = "output devices."]
            async fn create_configuration(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "outputconfiguration is a client-specific resource that can be used to ask"]
    #[doc = "the server to apply changes to available output devices."]
    #[doc = ""]
    #[doc = "The client receives a list of output devices from the registry. When it wants"]
    #[doc = "to apply new settings, it creates a configuration object from the"]
    #[doc = "outputmanagement global, writes changes through this object's enable, scale,"]
    #[doc = "transform and mode calls. It then asks the server to apply these settings in"]
    #[doc = "an atomic fashion, for example through Linux' DRM interface."]
    #[doc = ""]
    #[doc = "The server signals back whether the new settings have applied successfully"]
    #[doc = "or failed to apply. outputdevice objects are updated after the changes have been"]
    #[doc = "applied to the hardware and before the server side sends the applied event."]
    pub mod kde_output_configuration_v2 {
        #[doc = "These error can be emitted in response to kde_output_configuration_v2 requests."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "the config is already applied"]
            AlreadyApplied = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::AlreadyApplied),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Describes when the compositor may employ variable refresh rate"]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum VrrPolicy {
            Never = 0u32,
            Always = 1u32,
            Automatic = 2u32,
        }
        impl TryFrom<u32> for VrrPolicy {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Never),
                    1u32 => Ok(Self::Always),
                    2u32 => Ok(Self::Automatic),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Whether this output should use full or limited rgb."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum RgbRange {
            Automatic = 0u32,
            Full = 1u32,
            Limited = 2u32,
        }
        impl TryFrom<u32> for RgbRange {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Automatic),
                    1u32 => Ok(Self::Full),
                    2u32 => Ok(Self::Limited),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum AutoRotatePolicy {
            Never = 0u32,
            InTabletMode = 1u32,
            Always = 2u32,
        }
        impl TryFrom<u32> for AutoRotatePolicy {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Never),
                    1u32 => Ok(Self::InTabletMode),
                    2u32 => Ok(Self::Always),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ColorProfileSource {
            SRgb = 0u32,
            Icc = 1u32,
            Edid = 2u32,
        }
        impl TryFrom<u32> for ColorProfileSource {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::SRgb),
                    1u32 => Ok(Self::Icc),
                    2u32 => Ok(Self::Edid),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the kde_output_configuration_v2 interface. See the module level documentation for more info"]
        pub trait KdeOutputConfigurationV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "kde_output_configuration_v2";
            const VERSION: u32 = 9u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("kde_output_configuration_v2#{}.enable()", object.id);
                        self.enable(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("kde_output_configuration_v2#{}.mode()", object.id);
                        self.mode(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("kde_output_configuration_v2#{}.transform()", object.id);
                        self.transform(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("kde_output_configuration_v2#{}.position()", object.id);
                        self.position(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("kde_output_configuration_v2#{}.scale()", object.id);
                        self.scale(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.fixed()?,
                        )
                        .await
                    }
                    5u16 => {
                        tracing::debug!("kde_output_configuration_v2#{}.apply()", object.id);
                        self.apply(object, client).await
                    }
                    6u16 => {
                        tracing::debug!("kde_output_configuration_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    7u16 => {
                        tracing::debug!("kde_output_configuration_v2#{}.overscan()", object.id);
                        self.overscan(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    8u16 => {
                        tracing::debug!(
                            "kde_output_configuration_v2#{}.set_vrr_policy()",
                            object.id
                        );
                        self.set_vrr_policy(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    9u16 => {
                        tracing::debug!(
                            "kde_output_configuration_v2#{}.set_rgb_range()",
                            object.id
                        );
                        self.set_rgb_range(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    10u16 => {
                        tracing::debug!(
                            "kde_output_configuration_v2#{}.set_primary_output()",
                            object.id
                        );
                        self.set_primary_output(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    11u16 => {
                        tracing::debug!("kde_output_configuration_v2#{}.set_priority()", object.id);
                        self.set_priority(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    12u16 => {
                        tracing::debug!(
                            "kde_output_configuration_v2#{}.set_high_dynamic_range()",
                            object.id
                        );
                        self.set_high_dynamic_range(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    13u16 => {
                        tracing::debug!(
                            "kde_output_configuration_v2#{}.set_sdr_brightness()",
                            object.id
                        );
                        self.set_sdr_brightness(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    14u16 => {
                        tracing::debug!(
                            "kde_output_configuration_v2#{}.set_wide_color_gamut()",
                            object.id
                        );
                        self.set_wide_color_gamut(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    15u16 => {
                        tracing::debug!(
                            "kde_output_configuration_v2#{}.set_auto_rotate_policy()",
                            object.id
                        );
                        self.set_auto_rotate_policy(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    16u16 => {
                        tracing::debug!(
                            "kde_output_configuration_v2#{}.set_icc_profile_path()",
                            object.id
                        );
                        self.set_icc_profile_path(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    17u16 => {
                        tracing::debug!(
                            "kde_output_configuration_v2#{}.set_brightness_overrides()",
                            object.id
                        );
                        self.set_brightness_overrides(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    18u16 => {
                        tracing::debug!(
                            "kde_output_configuration_v2#{}.set_sdr_gamut_wideness()",
                            object.id
                        );
                        self.set_sdr_gamut_wideness(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    19u16 => {
                        tracing::debug!(
                            "kde_output_configuration_v2#{}.set_color_profile_source()",
                            object.id
                        );
                        self.set_color_profile_source(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    20u16 => {
                        tracing::debug!(
                            "kde_output_configuration_v2#{}.set_brightness()",
                            object.id
                        );
                        self.set_brightness(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Mark the output as enabled or disabled."]
            async fn enable(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                enable: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the mode for a given output."]
            async fn mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                mode: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the transformation for a given output."]
            async fn transform(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                transform: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the position for this output device. (x,y) describe the top-left corner"]
            #[doc = "of the output in global space, whereby the origin (0,0) of the global space"]
            #[doc = "has to be aligned with the top-left corner of the most left and in case this"]
            #[doc = "does not define a single one the top output."]
            #[doc = ""]
            #[doc = "There may be no gaps or overlaps between outputs, i.e. the outputs are"]
            #[doc = "stacked horizontally, vertically, or both on each other."]
            async fn position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the scaling factor for this output device."]
            async fn scale(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                scale: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            #[doc = "Asks the server to apply property changes requested through this outputconfiguration"]
            #[doc = "object to all outputs on the server side."]
            #[doc = ""]
            #[doc = "The output configuration can be applied only once. The already_applied protocol error"]
            #[doc = "will be posted if the apply request is called the second time."]
            async fn apply(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the overscan value of this output device with a value in percent."]
            async fn overscan(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                overscan: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Set what policy the compositor should employ regarding its use of"]
            #[doc = "variable refresh rate."]
            async fn set_vrr_policy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                policy: VrrPolicy,
            ) -> crate::server::Result<()>;
            #[doc = "Whether full or limited color range should be used"]
            async fn set_rgb_range(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                rgb_range: RgbRange,
            ) -> crate::server::Result<()>;
            async fn set_primary_output(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "The order of outputs can be used to assign desktop environment components to a specific screen,"]
            #[doc = "see kde_output_order_v1 for details. The priority is 1-based for outputs that will be enabled after"]
            #[doc = "this changeset is applied, all outputs that are disabled need to have the index set to zero."]
            async fn set_priority(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                priority: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Sets whether or not the output should be set to HDR mode."]
            async fn set_high_dynamic_range(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                enable_hdr: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the brightness of standard dynamic range content in nits. Only has an effect while the output is in HDR mode."]
            #[doc = "Note that while the value is in nits, that doesn't necessarily translate to the same brightness on the screen."]
            async fn set_sdr_brightness(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                sdr_brightness: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Whether or not the output should use a wide color gamut"]
            async fn set_wide_color_gamut(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                enable_wcg: u32,
            ) -> crate::server::Result<()>;
            async fn set_auto_rotate_policy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                policy: AutoRotatePolicy,
            ) -> crate::server::Result<()>;
            async fn set_icc_profile_path(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                profile_path: String,
            ) -> crate::server::Result<()>;
            async fn set_brightness_overrides(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                max_peak_brightness: i32,
                max_frame_average_brightness: i32,
                min_brightness: i32,
            ) -> crate::server::Result<()>;
            #[doc = "This can be used to provide the colors users assume sRGB applications should have based on the"]
            #[doc = "default experience on many modern sRGB screens."]
            async fn set_sdr_gamut_wideness(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                gamut_wideness: u32,
            ) -> crate::server::Result<()>;
            async fn set_color_profile_source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                color_profile_source: ColorProfileSource,
            ) -> crate::server::Result<()>;
            #[doc = "Set the brightness modifier of the output. It doesn't specify"]
            #[doc = "any absolute values, but is merely a multiplier on top of other"]
            #[doc = "brightness values, like sdr_brightness and brightness_metadata."]
            #[doc = "0 is the minimum brightness (not completely dark) and 10000 is"]
            #[doc = "the maximum brightness."]
            #[doc = "This is currently only supported / meaningful while HDR is active."]
            async fn set_brightness(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                outputdevice: crate::wire::ObjectId,
                brightness: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Sent after the server has successfully applied the changes."]
            #[doc = "."]
            async fn applied(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_configuration_v2#{}.applied()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent if the server rejects the changes or failed to apply them."]
            async fn failed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_configuration_v2#{}.failed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod kde_output_order_v1 {
    #[doc = "Announce the order in which desktop environment components should be placed on outputs."]
    #[doc = "The compositor will send the list of outputs when the global is bound and whenever there is a change."]
    pub mod kde_output_order_v1 {
        #[doc = "Trait to implement the kde_output_order_v1 interface. See the module level documentation for more info"]
        pub trait KdeOutputOrderV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "kde_output_order_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("kde_output_order_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Specifies the output identified by their wl_output.name."]
            async fn output(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output_name: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_order_v1#{}.output()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(output_name))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Specifies that the output list is complete. On the next output event, a new list begins."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_output_order_v1#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod kde_primary_output_v1 {
    #[doc = "Protocol for telling which is the primary display among the selection of enabled outputs."]
    pub mod kde_primary_output_v1 {
        #[doc = "Trait to implement the kde_primary_output_v1 interface. See the module level documentation for more info"]
        pub trait KdePrimaryOutputV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "kde_primary_output_v1";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("kde_primary_output_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Specifies which output is the primary one identified by their uuid. See kde_output_device_v2 uuid event for more information about it."]
            async fn primary_output(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output_name: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> kde_primary_output_v1#{}.primary_output()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(output_name))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod kde_screen_edge_v1 {
    #[doc = "This interface allows clients to associate actions with screen edges. For"]
    #[doc = "example, showing a surface by moving the pointer to a screen edge."]
    #[doc = ""]
    #[doc = "Potential ways to trigger the screen edge are subject to compositor"]
    #[doc = "policies. As an example, the compositor may consider the screen edge to be"]
    #[doc = "triggered if the pointer hits its associated screen border. Other ways may"]
    #[doc = "include using touchscreen or touchpad gestures."]
    pub mod kde_screen_edge_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "the specified border value is invalid"]
            InvalidBorder = 0u32,
            #[doc = "the surface has invalid role"]
            InvalidRole = 1u32,
            #[doc = "the surface already has a screen edge"]
            AlreadyConstructed = 2u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidBorder),
                    1u32 => Ok(Self::InvalidRole),
                    2u32 => Ok(Self::AlreadyConstructed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "These values describe possible screen borders."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Border {
            #[doc = "top screen edge"]
            Top = 1u32,
            #[doc = "bottom screen edge"]
            Bottom = 2u32,
            #[doc = "left screen edge"]
            Left = 3u32,
            #[doc = "right screen edge"]
            Right = 4u32,
        }
        impl TryFrom<u32> for Border {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::Top),
                    2u32 => Ok(Self::Bottom),
                    3u32 => Ok(Self::Left),
                    4u32 => Ok(Self::Right),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the kde_screen_edge_manager_v1 interface. See the module level documentation for more info"]
        pub trait KdeScreenEdgeManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "kde_screen_edge_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("kde_screen_edge_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "kde_screen_edge_manager_v1#{}.get_auto_hide_screen_edge()",
                            object.id
                        );
                        self.get_auto_hide_screen_edge(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?.try_into()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the screen edge manager. This doesn't destroy objects created"]
            #[doc = "with this manager."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Create a new auto hide screen edge object associated with the specified"]
            #[doc = "surface and the border."]
            #[doc = ""]
            #[doc = "Creating a kde_auto_hide_screen_edge_v1 object does not change the"]
            #[doc = "visibility of the surface. The kde_auto_hide_screen_edge_v1.activate"]
            #[doc = "request must be issued in order to hide the surface."]
            #[doc = ""]
            #[doc = "The \"border\" argument must be a valid enum entry, otherwise the"]
            #[doc = "invalid_border protocol error is raised."]
            #[doc = ""]
            #[doc = "The invalid_role protocol error will be raised if the specified surface"]
            #[doc = "does not have layer_surface role."]
            async fn get_auto_hide_screen_edge(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                border: Border,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "The auto hide screen edge object allows to hide the surface and make it"]
    #[doc = "visible by triggering the screen edge. The screen edge is inactive and"]
    #[doc = "the surface is visible by default."]
    #[doc = ""]
    #[doc = "This interface can be used to implement user interface elements such as"]
    #[doc = "auto-hide panels or docks."]
    #[doc = ""]
    #[doc = "kde_auto_hide_screen_edge_v1.activate activates the screen edge and makes"]
    #[doc = "the surface hidden. The surface can be made visible by triggering the"]
    #[doc = "screen edge or calling kde_auto_hide_screen_edge_v1.deactivate."]
    #[doc = ""]
    #[doc = "If the screen edge has been triggered, it won't be re-activated again."]
    #[doc = "Another kde_auto_hide_screen_edge_v1.activate request must be made by the"]
    #[doc = "client to activate the screen edge."]
    pub mod kde_auto_hide_screen_edge_v1 {
        #[doc = "Trait to implement the kde_auto_hide_screen_edge_v1 interface. See the module level documentation for more info"]
        pub trait KdeAutoHideScreenEdgeV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "kde_auto_hide_screen_edge_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("kde_auto_hide_screen_edge_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("kde_auto_hide_screen_edge_v1#{}.deactivate()", object.id);
                        self.deactivate(object, client).await
                    }
                    2u16 => {
                        tracing::debug!("kde_auto_hide_screen_edge_v1#{}.activate()", object.id);
                        self.activate(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the auto hide screen edge object. If the screen edge is active,"]
            #[doc = "it will be deactivated and the surface will be made visible."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Deactivate the screen edge. The surface will be made visible."]
            async fn deactivate(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Activate the screen edge. The surface will be hidden until the screen"]
            #[doc = "edge is triggered."]
            async fn activate(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod org_kde_plasma_virtual_desktop {
    pub mod org_kde_plasma_virtual_desktop_management {
        #[doc = "Trait to implement the org_kde_plasma_virtual_desktop_management interface. See the module level documentation for more info"]
        pub trait OrgKdePlasmaVirtualDesktopManagement: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_plasma_virtual_desktop_management";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "org_kde_plasma_virtual_desktop_management#{}.get_virtual_desktop()",
                            object.id
                        );
                        self.get_virtual_desktop(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing :: debug ! ("org_kde_plasma_virtual_desktop_management#{}.request_create_virtual_desktop()" , object . id);
                        self.request_create_virtual_desktop(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing :: debug ! ("org_kde_plasma_virtual_desktop_management#{}.request_remove_virtual_desktop()" , object . id);
                        self.request_remove_virtual_desktop(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Given the id of a particular virtual desktop, get the corresponding org_kde_plasma_virtual_desktop which represents only the desktop with that id."]
            async fn get_virtual_desktop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                desktop_id: String,
            ) -> crate::server::Result<()>;
            #[doc = "Ask the server to create a new virtual desktop, and position it at a specified position. If the position is zero or less, it will be positioned at the beginning, if the position is the count or more, it will be positioned at the end."]
            async fn request_create_virtual_desktop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
                position: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Ask the server to get rid of a virtual desktop, the server may or may not acconsent to the request."]
            async fn request_remove_virtual_desktop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                desktop_id: String,
            ) -> crate::server::Result<()>;
            async fn desktop_created(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                desktop_id: String,
                position: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> org_kde_plasma_virtual_desktop_management#{}.desktop_created()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(desktop_id))
                    .put_uint(position)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn desktop_removed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                desktop_id: String,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> org_kde_plasma_virtual_desktop_management#{}.desktop_removed()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(desktop_id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent after all other properties has been"]
            #[doc = "sent after binding to the desktop manager object and after any"]
            #[doc = "other property changes done after that. This allows"]
            #[doc = "changes to the org_kde_plasma_virtual_desktop_management properties to be seen as"]
            #[doc = "atomic, even if they happen via multiple events."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> org_kde_plasma_virtual_desktop_management#{}.done()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn rows(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                rows: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> org_kde_plasma_virtual_desktop_management#{}.rows()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(rows).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod org_kde_plasma_virtual_desktop {
        #[doc = "Trait to implement the org_kde_plasma_virtual_desktop interface. See the module level documentation for more info"]
        pub trait OrgKdePlasmaVirtualDesktop: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_plasma_virtual_desktop";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "org_kde_plasma_virtual_desktop#{}.request_activate()",
                            object.id
                        );
                        self.request_activate(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Request the server to set the status of this desktop to active: The server is free to consent or deny the request. This will be the new \"current\" virtual desktop of the system."]
            async fn request_activate(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The format of the id is decided by the compositor implementation. A desktop id univocally identifies a virtual desktop and must be guaranteed to never exist two desktops with the same id. The format of the string id is up to the server implementation."]
            async fn desktop_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                desktop_id: String,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> org_kde_plasma_virtual_desktop#{}.desktop_id()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(desktop_id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn name(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_plasma_virtual_desktop#{}.name()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(name))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The desktop will be the new \"current\" desktop of the system. The server may support either one virtual desktop active at a time, or other combinations such as one virtual desktop active per screen."]
            #[doc = "Windows associated to this virtual desktop will be shown."]
            async fn activated(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> org_kde_plasma_virtual_desktop#{}.activated()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Windows that were associated only to this desktop will be hidden."]
            async fn deactivated(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> org_kde_plasma_virtual_desktop#{}.deactivated()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent after all other properties has been"]
            #[doc = "sent after binding to the desktop object and after any"]
            #[doc = "other property changes done after that. This allows"]
            #[doc = "changes to the org_kde_plasma_virtual_desktop properties to be seen as"]
            #[doc = "atomic, even if they happen via multiple events."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_plasma_virtual_desktop#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This virtual desktop has just been removed by the server:"]
            #[doc = "All windows will lose the association to this desktop."]
            async fn removed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_plasma_virtual_desktop#{}.removed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod plasma_shell {
    #[doc = "This interface is used by KF5 powered Wayland shells to communicate with"]
    #[doc = "the compositor and can only be bound one time."]
    pub mod org_kde_plasma_shell {
        #[doc = "Trait to implement the org_kde_plasma_shell interface. See the module level documentation for more info"]
        pub trait OrgKdePlasmaShell: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_plasma_shell";
            const VERSION: u32 = 8u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("org_kde_plasma_shell#{}.get_surface()", object.id);
                        self.get_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a shell surface for an existing surface."]
            #[doc = ""]
            #[doc = "Only one shell surface can be associated with a given"]
            #[doc = "surface."]
            async fn get_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "An interface that may be implemented by a wl_surface, for"]
    #[doc = "implementations that provide the shell user interface."]
    #[doc = ""]
    #[doc = "It provides requests to set surface roles, assign an output"]
    #[doc = "or set the position in output coordinates."]
    #[doc = ""]
    #[doc = "On the server side the object is automatically destroyed when"]
    #[doc = "the related wl_surface is destroyed.  On client side,"]
    #[doc = "org_kde_plasma_surface.destroy() must be called before"]
    #[doc = "destroying the wl_surface object."]
    pub mod org_kde_plasma_surface {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Role {
            Normal = 0u32,
            Desktop = 1u32,
            Panel = 2u32,
            Onscreendisplay = 3u32,
            Notification = 4u32,
            Tooltip = 5u32,
            Criticalnotification = 6u32,
            Appletpopup = 7u32,
        }
        impl TryFrom<u32> for Role {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Normal),
                    1u32 => Ok(Self::Desktop),
                    2u32 => Ok(Self::Panel),
                    3u32 => Ok(Self::Onscreendisplay),
                    4u32 => Ok(Self::Notification),
                    5u32 => Ok(Self::Tooltip),
                    6u32 => Ok(Self::Criticalnotification),
                    7u32 => Ok(Self::Appletpopup),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum PanelBehavior {
            AlwaysVisible = 1u32,
            AutoHide = 2u32,
            WindowsCanCover = 3u32,
            WindowsGoBelow = 4u32,
        }
        impl TryFrom<u32> for PanelBehavior {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::AlwaysVisible),
                    2u32 => Ok(Self::AutoHide),
                    3u32 => Ok(Self::WindowsCanCover),
                    4u32 => Ok(Self::WindowsGoBelow),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "Request panel_auto_hide performed on a surface which does not correspond to an auto-hide panel."]
            PanelNotAutoHide = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::PanelNotAutoHide),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the org_kde_plasma_surface interface. See the module level documentation for more info"]
        pub trait OrgKdePlasmaSurface: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_plasma_surface";
            const VERSION: u32 = 8u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("org_kde_plasma_surface#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("org_kde_plasma_surface#{}.set_output()", object.id);
                        self.set_output(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("org_kde_plasma_surface#{}.set_position()", object.id);
                        self.set_position(object, client, message.int()?, message.int()?)
                            .await
                    }
                    3u16 => {
                        tracing::debug!("org_kde_plasma_surface#{}.set_role()", object.id);
                        self.set_role(object, client, message.uint()?).await
                    }
                    4u16 => {
                        tracing::debug!(
                            "org_kde_plasma_surface#{}.set_panel_behavior()",
                            object.id
                        );
                        self.set_panel_behavior(object, client, message.uint()?)
                            .await
                    }
                    5u16 => {
                        tracing::debug!("org_kde_plasma_surface#{}.set_skip_taskbar()", object.id);
                        self.set_skip_taskbar(object, client, message.uint()?).await
                    }
                    6u16 => {
                        tracing::debug!(
                            "org_kde_plasma_surface#{}.panel_auto_hide_hide()",
                            object.id
                        );
                        self.panel_auto_hide_hide(object, client).await
                    }
                    7u16 => {
                        tracing::debug!(
                            "org_kde_plasma_surface#{}.panel_auto_hide_show()",
                            object.id
                        );
                        self.panel_auto_hide_show(object, client).await
                    }
                    8u16 => {
                        tracing::debug!(
                            "org_kde_plasma_surface#{}.set_panel_takes_focus()",
                            object.id
                        );
                        self.set_panel_takes_focus(object, client, message.uint()?)
                            .await
                    }
                    9u16 => {
                        tracing::debug!("org_kde_plasma_surface#{}.set_skip_switcher()", object.id);
                        self.set_skip_switcher(object, client, message.uint()?)
                            .await
                    }
                    10u16 => {
                        tracing::debug!("org_kde_plasma_surface#{}.open_under_cursor()", object.id);
                        self.open_under_cursor(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "The org_kde_plasma_surface interface is removed from the"]
            #[doc = "wl_surface object that was turned into a shell surface with the"]
            #[doc = "org_kde_plasma_shell.get_surface request."]
            #[doc = "The shell surface role is lost and wl_surface is unmapped."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Assign an output to this shell surface."]
            #[doc = "The compositor will use this information to set the position"]
            #[doc = "when org_kde_plasma_surface.set_position request is"]
            #[doc = "called."]
            async fn set_output(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Move the surface to new coordinates."]
            #[doc = ""]
            #[doc = "Coordinates are global, for example 50,50 for a 1920,0+1920x1080 output"]
            #[doc = "is 1970,50 in global coordinates space."]
            #[doc = ""]
            #[doc = "Use org_kde_plasma_surface.set_output to assign an output"]
            #[doc = "to this surface."]
            async fn set_position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Assign a role to a shell surface."]
            #[doc = ""]
            #[doc = "The compositor handles surfaces depending on their role."]
            #[doc = "See the explanation below."]
            #[doc = ""]
            #[doc = "This request fails if the surface already has a role, this means"]
            #[doc = "the surface role may be assigned only once."]
            #[doc = ""]
            #[doc = "== Surfaces with splash role =="]
            #[doc = ""]
            #[doc = "Splash surfaces are placed above every other surface during the"]
            #[doc = "shell startup phase."]
            #[doc = ""]
            #[doc = "The surfaces are placed according to the output coordinates."]
            #[doc = "No size is imposed to those surfaces, the shell has to resize"]
            #[doc = "them according to output size."]
            #[doc = ""]
            #[doc = "These surfaces are meant to hide the desktop during the startup"]
            #[doc = "phase so that the user will always see a ready to work desktop."]
            #[doc = ""]
            #[doc = "A shell might not create splash surfaces if the compositor reveals"]
            #[doc = "the desktop in an alternative fashion, for example with a fade"]
            #[doc = "in effect."]
            #[doc = ""]
            #[doc = "That depends on how much time the desktop usually need to prepare"]
            #[doc = "the workspace or specific design decisions."]
            #[doc = "This specification doesn't impose any particular design."]
            #[doc = ""]
            #[doc = "When the startup phase is finished, the shell will send the"]
            #[doc = "org_kde_plasma.desktop_ready request to the compositor."]
            #[doc = ""]
            #[doc = "== Surfaces with desktop role =="]
            #[doc = ""]
            #[doc = "Desktop surfaces are placed below all other surfaces and are used"]
            #[doc = "to show the actual desktop view with icons, search results or"]
            #[doc = "controls the user will interact with. What to show depends on the"]
            #[doc = "shell implementation."]
            #[doc = ""]
            #[doc = "The surfaces are placed according to the output coordinates."]
            #[doc = "No size is imposed to those surfaces, the shell has to resize"]
            #[doc = "them according to output size."]
            #[doc = ""]
            #[doc = "Only one surface per output can have the desktop role."]
            #[doc = ""]
            #[doc = "== Surfaces with dashboard role =="]
            #[doc = ""]
            #[doc = "Dashboard surfaces are placed above desktop surfaces and are used to"]
            #[doc = "show additional widgets and controls."]
            #[doc = ""]
            #[doc = "The surfaces are placed according to the output coordinates."]
            #[doc = "No size is imposed to those surfaces, the shell has to resize"]
            #[doc = "them according to output size."]
            #[doc = ""]
            #[doc = "Only one surface per output can have the dashboard role."]
            #[doc = ""]
            #[doc = "== Surfaces with config role =="]
            #[doc = ""]
            #[doc = "A configuration surface is shown when the user wants to configure"]
            #[doc = "panel or desktop views."]
            #[doc = ""]
            #[doc = "Only one surface per output can have the config role."]
            #[doc = ""]
            #[doc = "TODO: This should grab the input like popup menus, right?"]
            #[doc = ""]
            #[doc = "== Surfaces with overlay role =="]
            #[doc = ""]
            #[doc = "Overlays are special surfaces that shows for a limited amount"]
            #[doc = "of time.  Such surfaces are useful to display things like volume,"]
            #[doc = "brightness and status changes."]
            #[doc = ""]
            #[doc = "Compositors may decide to show those surfaces in a layer above"]
            #[doc = "all surfaces, even full screen ones if so is desired."]
            #[doc = ""]
            #[doc = "== Surfaces with notification role =="]
            #[doc = ""]
            #[doc = "Notification surfaces display informative content for a limited"]
            #[doc = "amount of time.  The compositor may decide to show them in a corner"]
            #[doc = "depending on the configuration."]
            #[doc = ""]
            #[doc = "These surfaces are shown in a layer above all other surfaces except"]
            #[doc = "for full screen ones."]
            #[doc = ""]
            #[doc = "== Surfaces with lock role =="]
            #[doc = ""]
            #[doc = "The lock surface is shown by the compositor when the session is"]
            #[doc = "locked, users interact with it to unlock the session."]
            #[doc = ""]
            #[doc = "Compositors should move lock surfaces to 0,0 in output"]
            #[doc = "coordinates space and hide all other surfaces for security sake."]
            #[doc = "For the same reason it is recommended that clients make the"]
            #[doc = "lock surface as big as the screen."]
            #[doc = ""]
            #[doc = "Only one surface per output can have the lock role."]
            async fn set_role(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                role: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Set flags bitmask as described by the flag enum."]
            #[doc = "Pass 0 to unset any flag, the surface will adjust its behavior to"]
            #[doc = "the default."]
            #[doc = ""]
            #[doc = "Deprecated in Plasma 6. Setting this flag will have no effect. Applications should use layer shell where appropriate."]
            async fn set_panel_behavior(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                flag: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Setting this bit to the window, will make it say it prefers to not be listed in the taskbar. Taskbar implementations may or may not follow this hint."]
            async fn set_skip_taskbar(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                skip: u32,
            ) -> crate::server::Result<()>;
            #[doc = "A panel surface with panel_behavior auto_hide can perform this request to hide the panel"]
            #[doc = "on a screen edge without unmapping it. The compositor informs the client about the panel"]
            #[doc = "being hidden with the event auto_hidden_panel_hidden."]
            #[doc = ""]
            #[doc = "The compositor will restore the visibility state of the"]
            #[doc = "surface when the pointer touches the screen edge the panel borders. Once the compositor restores"]
            #[doc = "the visibility the event auto_hidden_panel_shown will be sent. This event will also be sent"]
            #[doc = "if the compositor is unable to hide the panel."]
            #[doc = ""]
            #[doc = "The client can also request to show the panel again with the request panel_auto_hide_show."]
            async fn panel_auto_hide_hide(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "A panel surface with panel_behavior auto_hide can perform this request to show the panel"]
            #[doc = "again which got hidden with panel_auto_hide_hide."]
            async fn panel_auto_hide_show(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "By default various org_kde_plasma_surface roles do not take focus and cannot be"]
            #[doc = "activated. With this request the compositor can be instructed to pass focus also to this"]
            #[doc = "org_kde_plasma_surface."]
            async fn set_panel_takes_focus(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                takes_focus: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Setting this bit will indicate that the window prefers not to be listed in a switcher."]
            async fn set_skip_switcher(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                skip: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Request the initial position of this surface to be under the current"]
            #[doc = "cursor position. Has to be called before attaching any buffer to this surface."]
            async fn open_under_cursor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "An auto-hiding panel got hidden by the compositor."]
            async fn auto_hidden_panel_hidden(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> org_kde_plasma_surface#{}.auto_hidden_panel_hidden()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "An auto-hiding panel got shown by the compositor."]
            async fn auto_hidden_panel_shown(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> org_kde_plasma_surface#{}.auto_hidden_panel_shown()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod plasma_window_management {
    #[doc = "This interface manages application windows."]
    #[doc = "It provides requests to show and hide the desktop and emits"]
    #[doc = "an event every time a window is created so that the client can"]
    #[doc = "use it to manage the window."]
    #[doc = ""]
    #[doc = "Only one client can bind this interface at a time."]
    pub mod org_kde_plasma_window_management {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum State {
            Active = 1u32,
            Minimized = 2u32,
            Maximized = 4u32,
            Fullscreen = 8u32,
            KeepAbove = 16u32,
            KeepBelow = 32u32,
            OnAllDesktops = 64u32,
            DemandsAttention = 128u32,
            Closeable = 256u32,
            Minimizable = 512u32,
            Maximizable = 1024u32,
            Fullscreenable = 2048u32,
            Skiptaskbar = 4096u32,
            Shadeable = 8192u32,
            Shaded = 16384u32,
            Movable = 32768u32,
            Resizable = 65536u32,
            VirtualDesktopChangeable = 131072u32,
            Skipswitcher = 262144u32,
        }
        impl TryFrom<u32> for State {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::Active),
                    2u32 => Ok(Self::Minimized),
                    4u32 => Ok(Self::Maximized),
                    8u32 => Ok(Self::Fullscreen),
                    16u32 => Ok(Self::KeepAbove),
                    32u32 => Ok(Self::KeepBelow),
                    64u32 => Ok(Self::OnAllDesktops),
                    128u32 => Ok(Self::DemandsAttention),
                    256u32 => Ok(Self::Closeable),
                    512u32 => Ok(Self::Minimizable),
                    1024u32 => Ok(Self::Maximizable),
                    2048u32 => Ok(Self::Fullscreenable),
                    4096u32 => Ok(Self::Skiptaskbar),
                    8192u32 => Ok(Self::Shadeable),
                    16384u32 => Ok(Self::Shaded),
                    32768u32 => Ok(Self::Movable),
                    65536u32 => Ok(Self::Resizable),
                    131072u32 => Ok(Self::VirtualDesktopChangeable),
                    262144u32 => Ok(Self::Skipswitcher),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ShowDesktop {
            Disabled = 0u32,
            Enabled = 1u32,
        }
        impl TryFrom<u32> for ShowDesktop {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Disabled),
                    1u32 => Ok(Self::Enabled),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the org_kde_plasma_window_management interface. See the module level documentation for more info"]
        pub trait OrgKdePlasmaWindowManagement: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_plasma_window_management";
            const VERSION: u32 = 17u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "org_kde_plasma_window_management#{}.show_desktop()",
                            object.id
                        );
                        self.show_desktop(object, client, message.uint()?).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "org_kde_plasma_window_management#{}.get_window()",
                            object.id
                        );
                        self.get_window(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "org_kde_plasma_window_management#{}.get_window_by_uuid()",
                            object.id
                        );
                        self.get_window_by_uuid(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!(
                            "org_kde_plasma_window_management#{}.get_stacking_order()",
                            object.id
                        );
                        self.get_stacking_order(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Tell the compositor to show/hide the desktop."]
            async fn show_desktop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                state: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Deprecated: use get_window_by_uuid"]
            async fn get_window(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                internal_window_id: u32,
            ) -> crate::server::Result<()>;
            async fn get_window_by_uuid(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                internal_window_uuid: String,
            ) -> crate::server::Result<()>;
            async fn get_stacking_order(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                stacking_order: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This event will be sent whenever the show desktop mode changes. E.g. when it is entered"]
            #[doc = "or left."]
            #[doc = ""]
            #[doc = "On binding the interface the current state is sent."]
            async fn show_desktop_changed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                state: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> org_kde_plasma_window_management#{}.show_desktop_changed()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(state).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event will be sent immediately after a window is mapped."]
            async fn window(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_plasma_window_management#{}.window()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(id).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event will be sent when stacking order changed and on bind."]
            #[doc = ""]
            #[doc = "With version 17 this event is deprecated and will no longer be sent."]
            async fn stacking_order_changed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                ids: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> org_kde_plasma_window_management#{}.stacking_order_changed()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_array(ids).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event will be sent when stacking order changed and on bind."]
            #[doc = ""]
            #[doc = "With version 17 this event is deprecated and will no longer be sent."]
            async fn stacking_order_uuid_changed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                uuids: String,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> org_kde_plasma_window_management#{}.stacking_order_uuid_changed()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(uuids))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event will be sent immediately after a window is mapped."]
            async fn window_with_uuid(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: u32,
                uuid: String,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> org_kde_plasma_window_management#{}.window_with_uuid()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(id)
                    .put_string(Some(uuid))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event will be sent when stacking order changed."]
            async fn stacking_order_changed_2(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> org_kde_plasma_window_management#{}.stacking_order_changed_2()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "Manages and control an application window."]
    #[doc = ""]
    #[doc = "Only one client can bind this interface at a time."]
    pub mod org_kde_plasma_window {
        #[doc = "Trait to implement the org_kde_plasma_window interface. See the module level documentation for more info"]
        pub trait OrgKdePlasmaWindow: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_plasma_window";
            const VERSION: u32 = 17u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("org_kde_plasma_window#{}.set_state()", object.id);
                        self.set_state(object, client, message.uint()?, message.uint()?)
                            .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "org_kde_plasma_window#{}.set_virtual_desktop()",
                            object.id
                        );
                        self.set_virtual_desktop(object, client, message.uint()?)
                            .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "org_kde_plasma_window#{}.set_minimized_geometry()",
                            object.id
                        );
                        self.set_minimized_geometry(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!(
                            "org_kde_plasma_window#{}.unset_minimized_geometry()",
                            object.id
                        );
                        self.unset_minimized_geometry(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("org_kde_plasma_window#{}.close()", object.id);
                        self.close(object, client).await
                    }
                    5u16 => {
                        tracing::debug!("org_kde_plasma_window#{}.request_move()", object.id);
                        self.request_move(object, client).await
                    }
                    6u16 => {
                        tracing::debug!("org_kde_plasma_window#{}.request_resize()", object.id);
                        self.request_resize(object, client).await
                    }
                    7u16 => {
                        tracing::debug!("org_kde_plasma_window#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    8u16 => {
                        tracing::debug!("org_kde_plasma_window#{}.get_icon()", object.id);
                        self.get_icon(object, client, message.fd()?).await
                    }
                    9u16 => {
                        tracing::debug!(
                            "org_kde_plasma_window#{}.request_enter_virtual_desktop()",
                            object.id
                        );
                        self.request_enter_virtual_desktop(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    10u16 => {
                        tracing::debug!(
                            "org_kde_plasma_window#{}.request_enter_new_virtual_desktop()",
                            object.id
                        );
                        self.request_enter_new_virtual_desktop(object, client).await
                    }
                    11u16 => {
                        tracing::debug!(
                            "org_kde_plasma_window#{}.request_leave_virtual_desktop()",
                            object.id
                        );
                        self.request_leave_virtual_desktop(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    12u16 => {
                        tracing::debug!(
                            "org_kde_plasma_window#{}.request_enter_activity()",
                            object.id
                        );
                        self.request_enter_activity(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    13u16 => {
                        tracing::debug!(
                            "org_kde_plasma_window#{}.request_leave_activity()",
                            object.id
                        );
                        self.request_leave_activity(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    14u16 => {
                        tracing::debug!("org_kde_plasma_window#{}.send_to_output()", object.id);
                        self.send_to_output(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Set window state."]
            #[doc = ""]
            #[doc = "Values for state argument are described by org_kde_plasma_window_management.state"]
            #[doc = "and can be used together in a bitfield. The flags bitfield describes which flags are"]
            #[doc = "supposed to be set, the state bitfield the value for the set flags"]
            async fn set_state(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                flags: u32,
                state: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Deprecated: use enter_virtual_desktop"]
            #[doc = "Maps the window to a different virtual desktop."]
            #[doc = ""]
            #[doc = "To show the window on all virtual desktops, call the"]
            #[doc = "org_kde_plasma_window.set_state request and specify a on_all_desktops"]
            #[doc = "state in the bitfield."]
            async fn set_virtual_desktop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                number: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the geometry of the taskbar entry for this window."]
            #[doc = "The geometry is relative to a panel in particular."]
            async fn set_minimized_geometry(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                panel: crate::wire::ObjectId,
                x: u32,
                y: u32,
                width: u32,
                height: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Remove the task geometry information for a particular panel."]
            async fn unset_minimized_geometry(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                panel: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Close this window."]
            async fn close(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Request an interactive move for this window."]
            async fn request_move(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Request an interactive resize for this window."]
            async fn request_resize(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Removes the resource bound for this org_kde_plasma_window."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The compositor will write the window icon into the provided file descriptor."]
            #[doc = "The data is a serialized QIcon with QDataStream."]
            async fn get_icon(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()>;
            #[doc = "Make the window enter a virtual desktop. A window can enter more"]
            #[doc = "than one virtual desktop. if the id is empty or invalid, no action will be performed."]
            async fn request_enter_virtual_desktop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: String,
            ) -> crate::server::Result<()>;
            #[doc = "RFC: do this with an empty id to request_enter_virtual_desktop?"]
            #[doc = "Make the window enter a new virtual desktop. If the server consents the request,"]
            #[doc = "it will create a new virtual desktop and assign the window to it."]
            async fn request_enter_new_virtual_desktop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Make the window exit a virtual desktop. If it exits all desktops it will be considered on all of them."]
            async fn request_leave_virtual_desktop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: String,
            ) -> crate::server::Result<()>;
            #[doc = "Make the window enter an activity. A window can enter more activity. If the id is empty or invalid, no action will be performed."]
            async fn request_enter_activity(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: String,
            ) -> crate::server::Result<()>;
            #[doc = "Make the window exit a an activity. If it exits all activities it will be considered on all of them."]
            async fn request_leave_activity(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: String,
            ) -> crate::server::Result<()>;
            #[doc = "Requests this window to be displayed in a specific output."]
            async fn send_to_output(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This event will be sent as soon as the window title is changed."]
            async fn title_changed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                title: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_plasma_window#{}.title_changed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(title))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event will be sent as soon as the application"]
            #[doc = "identifier is changed."]
            async fn app_id_changed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                app_id: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_plasma_window#{}.app_id_changed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(app_id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event will be sent as soon as the window state changes."]
            #[doc = ""]
            #[doc = "Values for state argument are described by org_kde_plasma_window_management.state."]
            async fn state_changed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                flags: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_plasma_window#{}.state_changed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(flags).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "DEPRECATED: use virtual_desktop_entered and virtual_desktop_left instead"]
            #[doc = "This event will be sent when a window is moved to another"]
            #[doc = "virtual desktop."]
            #[doc = ""]
            #[doc = "It is not sent if it becomes visible on all virtual desktops though."]
            async fn virtual_desktop_changed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                number: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> org_kde_plasma_window#{}.virtual_desktop_changed()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(number).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event will be sent whenever the themed icon name changes. May be null."]
            async fn themed_icon_name_changed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> org_kde_plasma_window#{}.themed_icon_name_changed()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(name))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event will be sent immediately after the window is closed"]
            #[doc = "and its surface is unmapped."]
            async fn unmapped(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_plasma_window#{}.unmapped()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event will be sent immediately after all initial state been sent to the client."]
            #[doc = "If the Plasma window is already unmapped, the unmapped event will be sent before the"]
            #[doc = "initial_state event."]
            async fn initial_state(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_plasma_window#{}.initial_state()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 6u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event will be sent whenever the parent window of this org_kde_plasma_window changes."]
            #[doc = "The passed parent is another org_kde_plasma_window and this org_kde_plasma_window is a"]
            #[doc = "transient window to the parent window. If the parent argument is null, this"]
            #[doc = "org_kde_plasma_window does not have a parent window."]
            async fn parent_window(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                parent: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_plasma_window#{}.parent_window()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(parent)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 7u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event will be sent whenever the window geometry of this org_kde_plasma_window changes."]
            #[doc = "The coordinates are in absolute coordinates of the windowing system."]
            async fn geometry(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: u32,
                height: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_plasma_window#{}.geometry()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(x)
                    .put_int(y)
                    .put_uint(width)
                    .put_uint(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 8u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event will be sent whenever the icon of the window changes, but there is no themed"]
            #[doc = "icon name. Common examples are Xwayland windows which have a pixmap based icon."]
            #[doc = ""]
            #[doc = "The client can request the icon using get_icon."]
            async fn icon_changed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_plasma_window#{}.icon_changed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 9u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event will be sent when the compositor has set the process id this window belongs to."]
            #[doc = "This should be set once before the initial_state is sent."]
            async fn pid_changed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                pid: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_plasma_window#{}.pid_changed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(pid).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 10u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event will be sent when the window has entered a new virtual desktop. The window can be on more than one desktop, or none: then is considered on all of them."]
            async fn virtual_desktop_entered(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: String,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> org_kde_plasma_window#{}.virtual_desktop_entered()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 11u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event will be sent when the window left a virtual desktop. If the window leaves all desktops, it can be considered on all."]
            #[doc = "If the window gets manually added on all desktops, the server has to send virtual_desktop_left for every previous desktop it was in for the window to be really considered on all desktops."]
            async fn virtual_desktop_left(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                is: String,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> org_kde_plasma_window#{}.virtual_desktop_left()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(is))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 12u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event will be sent after the application menu"]
            #[doc = "for the window has changed."]
            async fn application_menu(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                service_name: String,
                object_path: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_plasma_window#{}.application_menu()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(service_name))
                    .put_string(Some(object_path))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 13u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event will be sent when the window has entered an activity. The window can be on more than one activity, or none: then is considered on all of them."]
            async fn activity_entered(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_plasma_window#{}.activity_entered()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 14u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event will be sent when the window left an activity. If the window leaves all activities, it will be considered on all."]
            #[doc = "If the window gets manually added on all activities, the server has to send activity_left for every previous activity it was in for the window to be really considered on all activities."]
            async fn activity_left(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_plasma_window#{}.activity_left()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 15u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event will be sent when the X11 resource name of the window has changed."]
            #[doc = "This is only set for XWayland windows."]
            async fn resource_name_changed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                resource_name: String,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> org_kde_plasma_window#{}.resource_name_changed()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(resource_name))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 16u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "The activation manager interface provides a way to get notified"]
    #[doc = "when an application is about to be activated."]
    pub mod org_kde_plasma_activation_feedback {
        #[doc = "Trait to implement the org_kde_plasma_activation_feedback interface. See the module level documentation for more info"]
        pub trait OrgKdePlasmaActivationFeedback: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_plasma_activation_feedback";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "org_kde_plasma_activation_feedback#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the activation manager object. The activation objects introduced"]
            #[doc = "by this manager object will be unaffected."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Will be issued when an app is set to be activated. It offers"]
            #[doc = "an instance of org_kde_plasma_activation that will tell us the app_id"]
            #[doc = "and the extent of the activation."]
            async fn activation(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> org_kde_plasma_activation_feedback#{}.activation()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod org_kde_plasma_activation {
        #[doc = "Trait to implement the org_kde_plasma_activation interface. See the module level documentation for more info"]
        pub trait OrgKdePlasmaActivation: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_plasma_activation";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("org_kde_plasma_activation#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Notify the compositor that the org_kde_plasma_activation object will no"]
            #[doc = "longer be used."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            async fn app_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                app_id: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_plasma_activation#{}.app_id()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(app_id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn finished(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_plasma_activation#{}.finished()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "When this object is created, the compositor sends a window event for"]
    #[doc = "each window in the stacking order, and afterwards sends the done event"]
    #[doc = "and destroys this object."]
    pub mod org_kde_plasma_stacking_order {
        #[doc = "Trait to implement the org_kde_plasma_stacking_order interface. See the module level documentation for more info"]
        pub trait OrgKdePlasmaStackingOrder: crate::server::Dispatcher {
            const INTERFACE: &'static str = "org_kde_plasma_stacking_order";
            const VERSION: u32 = 17u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn window(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                uuid: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_plasma_stacking_order#{}.window()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(uuid))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> org_kde_plasma_stacking_order#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod zkde_screencast_unstable_v1 {
    pub mod zkde_screencast_unstable_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Pointer {
            #[doc = "No cursor"]
            Hidden = 1u32,
            #[doc = "Render the cursor on the stream"]
            Embedded = 2u32,
            #[doc = "Send metadata about where the cursor is through PipeWire"]
            Metadata = 4u32,
        }
        impl TryFrom<u32> for Pointer {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::Hidden),
                    2u32 => Ok(Self::Embedded),
                    4u32 => Ok(Self::Metadata),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zkde_screencast_unstable_v1 interface. See the module level documentation for more info"]
        pub trait ZkdeScreencastUnstableV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zkde_screencast_unstable_v1";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zkde_screencast_unstable_v1#{}.stream_output()",
                            object.id
                        );
                        self.stream_output(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zkde_screencast_unstable_v1#{}.stream_window()",
                            object.id
                        );
                        self.stream_window(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zkde_screencast_unstable_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    3u16 => {
                        tracing::debug!(
                            "zkde_screencast_unstable_v1#{}.stream_virtual_output()",
                            object.id
                        );
                        self.stream_virtual_output(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.fixed()?,
                            message.uint()?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!(
                            "zkde_screencast_unstable_v1#{}.stream_region()",
                            object.id
                        );
                        self.stream_region(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.uint()?,
                            message.uint()?,
                            message.fixed()?,
                            message.uint()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn stream_output(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                stream: crate::wire::ObjectId,
                output: crate::wire::ObjectId,
                pointer: u32,
            ) -> crate::server::Result<()>;
            async fn stream_window(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                stream: crate::wire::ObjectId,
                window_uuid: String,
                pointer: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the zkde_screencast_unstable_v1 object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            async fn stream_virtual_output(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                stream: crate::wire::ObjectId,
                name: String,
                width: i32,
                height: i32,
                scale: crate::wire::Fixed,
                pointer: u32,
            ) -> crate::server::Result<()>;
            async fn stream_region(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                stream: crate::wire::ObjectId,
                x: i32,
                y: i32,
                width: u32,
                height: u32,
                scale: crate::wire::Fixed,
                pointer: u32,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zkde_screencast_stream_unstable_v1 {
        #[doc = "Trait to implement the zkde_screencast_stream_unstable_v1 interface. See the module level documentation for more info"]
        pub trait ZkdeScreencastStreamUnstableV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zkde_screencast_stream_unstable_v1";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zkde_screencast_stream_unstable_v1#{}.close()", object.id);
                        self.close(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn close(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            async fn closed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zkde_screencast_stream_unstable_v1#{}.closed()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn created(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                node: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zkde_screencast_stream_unstable_v1#{}.created()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(node).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn failed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                error: String,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zkde_screencast_stream_unstable_v1#{}.failed()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(error))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "The aim of the color management extension is to allow clients to know"]
#[doc = "the color properties of outputs, and to tell the compositor about the color"]
#[doc = "properties of their content on surfaces. Doing this enables a compositor"]
#[doc = "to perform automatic color management of content for different outputs"]
#[doc = "according to how content is intended to look like."]
#[doc = ""]
#[doc = "The color properties are represented as an image description object which"]
#[doc = "is immutable after it has been created. A wl_output always has an"]
#[doc = "associated image description that clients can observe. A wl_surface"]
#[doc = "always has an associated preferred image description as a hint chosen by"]
#[doc = "the compositor that clients can also observe. Clients can set an image"]
#[doc = "description on a wl_surface to denote the color characteristics of the"]
#[doc = "surface contents."]
#[doc = ""]
#[doc = "An image description includes SDR and HDR colorimetry and encoding, HDR"]
#[doc = "metadata, and viewing environment parameters. An image description does"]
#[doc = "not include the properties set through color-representation extension."]
#[doc = "It is expected that the color-representation extension is used in"]
#[doc = "conjunction with the color management extension when necessary,"]
#[doc = "particularly with the YUV family of pixel formats."]
#[doc = ""]
#[doc = "Recommendation ITU-T H.273"]
#[doc = "\"Coding-independent code points for video signal type identification\""]
#[doc = "shall be referred to as simply H.273 here."]
#[doc = ""]
#[doc = "The color-and-hdr repository"]
#[doc = "(https://gitlab.freedesktop.org/pq/color-and-hdr) contains"]
#[doc = "background information on the protocol design and legacy color management."]
#[doc = "It also contains a glossary, learning resources for digital color, tools,"]
#[doc = "samples and more."]
#[doc = ""]
#[doc = "The terminology used in this protocol is based on common color science and"]
#[doc = "color encoding terminology where possible. The glossary in the color-and-hdr"]
#[doc = "repository shall be the authority on the definition of terms in this"]
#[doc = "protocol."]
pub mod color_management_v1 {
    #[doc = "A global interface used for getting color management extensions for"]
    #[doc = "wl_surface and wl_output objects, and for creating client defined image"]
    #[doc = "description objects. The extension interfaces allow"]
    #[doc = "getting the image description of outputs and setting the image"]
    #[doc = "description of surfaces."]
    pub mod xx_color_manager_v4 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "request not supported"]
            UnsupportedFeature = 0u32,
            #[doc = "color management surface exists already"]
            SurfaceExists = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::UnsupportedFeature),
                    1u32 => Ok(Self::SurfaceExists),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "See the ICC.1:2022 specification from the International Color Consortium"]
        #[doc = "for more details about rendering intents."]
        #[doc = ""]
        #[doc = "The principles of ICC defined rendering intents apply with all types of"]
        #[doc = "image descriptions, not only those with ICC file profiles."]
        #[doc = ""]
        #[doc = "Compositors must support the perceptual rendering intent. Other"]
        #[doc = "rendering intents are optional."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum RenderIntent {
            #[doc = "perceptual"]
            Perceptual = 0u32,
            #[doc = "media-relative colorimetric"]
            Relative = 1u32,
            #[doc = "saturation"]
            Saturation = 2u32,
            #[doc = "ICC-absolute colorimetric"]
            Absolute = 3u32,
            #[doc = "media-relative colorimetric + black point compensation"]
            RelativeBpc = 4u32,
        }
        impl TryFrom<u32> for RenderIntent {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Perceptual),
                    1u32 => Ok(Self::Relative),
                    2u32 => Ok(Self::Saturation),
                    3u32 => Ok(Self::Absolute),
                    4u32 => Ok(Self::RelativeBpc),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Feature {
            #[doc = "new_icc_creator request"]
            IccV2V4 = 0u32,
            #[doc = "new_parametric_creator request"]
            Parametric = 1u32,
            #[doc = "parametric set_primaries request"]
            SetPrimaries = 2u32,
            #[doc = "parametric set_tf_power request"]
            SetTfPower = 3u32,
            #[doc = "parametric set_luminances request"]
            SetLuminances = 4u32,
            SetMasteringDisplayPrimaries = 5u32,
            ExtendedTargetVolume = 6u32,
        }
        impl TryFrom<u32> for Feature {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::IccV2V4),
                    1u32 => Ok(Self::Parametric),
                    2u32 => Ok(Self::SetPrimaries),
                    3u32 => Ok(Self::SetTfPower),
                    4u32 => Ok(Self::SetLuminances),
                    5u32 => Ok(Self::SetMasteringDisplayPrimaries),
                    6u32 => Ok(Self::ExtendedTargetVolume),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Named color primaries used to encode well-known sets of primaries. H.273"]
        #[doc = "is the authority, when it comes to the exact values of primaries and"]
        #[doc = "authoritative specifications, where an equivalent code point exists."]
        #[doc = ""]
        #[doc = "Descriptions do list the specifications for convenience."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Primaries {
            Srgb = 0u32,
            PalM = 1u32,
            Pal = 2u32,
            Ntsc = 3u32,
            GenericFilm = 4u32,
            Bt2020 = 5u32,
            Cie1931Xyz = 6u32,
            DciP3 = 7u32,
            DisplayP3 = 8u32,
            AdobeRgb = 9u32,
        }
        impl TryFrom<u32> for Primaries {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Srgb),
                    1u32 => Ok(Self::PalM),
                    2u32 => Ok(Self::Pal),
                    3u32 => Ok(Self::Ntsc),
                    4u32 => Ok(Self::GenericFilm),
                    5u32 => Ok(Self::Bt2020),
                    6u32 => Ok(Self::Cie1931Xyz),
                    7u32 => Ok(Self::DciP3),
                    8u32 => Ok(Self::DisplayP3),
                    9u32 => Ok(Self::AdobeRgb),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Named transfer functions used to encode well-known transfer"]
        #[doc = "characteristics. H.273 is the authority, when it comes to the exact"]
        #[doc = "formulas and authoritative specifications, where an equivalent code"]
        #[doc = "point exists."]
        #[doc = ""]
        #[doc = "Descriptions do list the specifications for convenience."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum TransferFunction {
            Bt709 = 0u32,
            Gamma22 = 1u32,
            Gamma28 = 2u32,
            St240 = 3u32,
            Linear = 4u32,
            Log100 = 5u32,
            Log316 = 6u32,
            Xvycc = 7u32,
            Bt1361 = 8u32,
            Srgb = 9u32,
            ExtSrgb = 10u32,
            St2084Pq = 11u32,
            St428 = 12u32,
            Hlg = 13u32,
        }
        impl TryFrom<u32> for TransferFunction {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Bt709),
                    1u32 => Ok(Self::Gamma22),
                    2u32 => Ok(Self::Gamma28),
                    3u32 => Ok(Self::St240),
                    4u32 => Ok(Self::Linear),
                    5u32 => Ok(Self::Log100),
                    6u32 => Ok(Self::Log316),
                    7u32 => Ok(Self::Xvycc),
                    8u32 => Ok(Self::Bt1361),
                    9u32 => Ok(Self::Srgb),
                    10u32 => Ok(Self::ExtSrgb),
                    11u32 => Ok(Self::St2084Pq),
                    12u32 => Ok(Self::St428),
                    13u32 => Ok(Self::Hlg),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the xx_color_manager_v4 interface. See the module level documentation for more info"]
        pub trait XxColorManagerV4: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xx_color_manager_v4";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xx_color_manager_v4#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xx_color_manager_v4#{}.get_output()", object.id);
                        self.get_output(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("xx_color_manager_v4#{}.get_surface()", object.id);
                        self.get_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("xx_color_manager_v4#{}.get_feedback_surface()", object.id);
                        self.get_feedback_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("xx_color_manager_v4#{}.new_icc_creator()", object.id);
                        self.new_icc_creator(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    5u16 => {
                        tracing::debug!(
                            "xx_color_manager_v4#{}.new_parametric_creator()",
                            object.id
                        );
                        self.new_parametric_creator(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the xx_color_manager_v4 object. This does not affect any other"]
            #[doc = "objects in any way."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This creates a new xx_color_management_output_v4 object for the"]
            #[doc = "given wl_output."]
            #[doc = ""]
            #[doc = "See the xx_color_management_output_v4 interface for more details."]
            async fn get_output(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "If a xx_color_management_surface_v4 object already exists for the given"]
            #[doc = "wl_surface, the protocol error surface_exists is raised."]
            #[doc = ""]
            #[doc = "This creates a new color xx_color_management_surface_v4 object for the"]
            #[doc = "given wl_surface."]
            #[doc = ""]
            #[doc = "See the xx_color_management_surface_v4 interface for more details."]
            async fn get_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This creates a new color xx_color_management_feedback_surface_v4 object"]
            #[doc = "for the given wl_surface."]
            #[doc = ""]
            #[doc = "See the xx_color_management_feedback_surface_v4 interface for more"]
            #[doc = "details."]
            async fn get_feedback_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Makes a new ICC-based image description creator object with all"]
            #[doc = "properties initially unset. The client can then use the object's"]
            #[doc = "interface to define all the required properties for an image description"]
            #[doc = "and finally create a xx_image_description_v4 object."]
            #[doc = ""]
            #[doc = "This request can be used when the compositor advertises"]
            #[doc = "xx_color_manager_v4.feature.icc_v2_v4."]
            #[doc = "Otherwise this request raises the protocol error unsupported_feature."]
            async fn new_icc_creator(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                obj: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Makes a new parametric image description creator object with all"]
            #[doc = "properties initially unset. The client can then use the object's"]
            #[doc = "interface to define all the required properties for an image description"]
            #[doc = "and finally create a xx_image_description_v4 object."]
            #[doc = ""]
            #[doc = "This request can be used when the compositor advertises"]
            #[doc = "xx_color_manager_v4.feature.parametric."]
            #[doc = "Otherwise this request raises the protocol error unsupported_feature."]
            async fn new_parametric_creator(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                obj: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "When this object is created, it shall immediately send this event once"]
            #[doc = "for each rendering intent the compositor supports."]
            async fn supported_intent(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                render_intent: RenderIntent,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xx_color_manager_v4#{}.supported_intent()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(render_intent as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "When this object is created, it shall immediately send this event once"]
            #[doc = "for each compositor supported feature listed in the enumeration."]
            async fn supported_feature(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                feature: Feature,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xx_color_manager_v4#{}.supported_feature()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(feature as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "When this object is created, it shall immediately send this event once"]
            #[doc = "for each named transfer function the compositor supports with the"]
            #[doc = "parametric image description creator."]
            async fn supported_tf_named(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tf: TransferFunction,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xx_color_manager_v4#{}.supported_tf_named()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(tf as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "When this object is created, it shall immediately send this event once"]
            #[doc = "for each named set of primaries the compositor supports with the"]
            #[doc = "parametric image description creator."]
            async fn supported_primaries_named(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                primaries: Primaries,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> xx_color_manager_v4#{}.supported_primaries_named()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(primaries as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A xx_color_management_output_v4 describes the color properties of an"]
    #[doc = "output."]
    #[doc = ""]
    #[doc = "The xx_color_management_output_v4 is associated with the wl_output global"]
    #[doc = "underlying the wl_output object. Therefore the client destroying the"]
    #[doc = "wl_output object has no impact, but the compositor removing the output"]
    #[doc = "global makes the xx_color_management_output_v4 object inert."]
    pub mod xx_color_management_output_v4 {
        #[doc = "Trait to implement the xx_color_management_output_v4 interface. See the module level documentation for more info"]
        pub trait XxColorManagementOutputV4: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xx_color_management_output_v4";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xx_color_management_output_v4#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "xx_color_management_output_v4#{}.get_image_description()",
                            object.id
                        );
                        self.get_image_description(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the color xx_color_management_output_v4 object. This does not"]
            #[doc = "affect any remaining protocol objects."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This creates a new xx_image_description_v4 object for the current image"]
            #[doc = "description of the output. There always is exactly one image description"]
            #[doc = "active for an output so the client should destroy the image description"]
            #[doc = "created by earlier invocations of this request. This request is usually"]
            #[doc = "sent as a reaction to the image_description_changed event or when"]
            #[doc = "creating a xx_color_management_output_v4 object."]
            #[doc = ""]
            #[doc = "The image description of an output represents the color encoding the"]
            #[doc = "output expects. There might be performance and power advantages, as well"]
            #[doc = "as improved color reproduction, if a content update matches the image"]
            #[doc = "description of the output it is being shown on. If a content update is"]
            #[doc = "shown on any other output than the one it matches the image description"]
            #[doc = "of, then the color reproduction on those outputs might be considerably"]
            #[doc = "worse."]
            #[doc = ""]
            #[doc = "The created xx_image_description_v4 object preserves the image"]
            #[doc = "description of the output from the time the object was created."]
            #[doc = ""]
            #[doc = "The resulting image description object allows get_information request."]
            #[doc = ""]
            #[doc = "If this protocol object is inert, the resulting image description object"]
            #[doc = "shall immediately deliver the xx_image_description_v4.failed event with"]
            #[doc = "the no_output cause."]
            #[doc = ""]
            #[doc = "If the interface version is inadequate for the output's image"]
            #[doc = "description, meaning that the client does not support all the events"]
            #[doc = "needed to deliver the crucial information, the resulting image"]
            #[doc = "description object shall immediately deliver the"]
            #[doc = "xx_image_description_v4.failed event with the low_version cause."]
            #[doc = ""]
            #[doc = "Otherwise the object shall immediately deliver the ready event."]
            async fn get_image_description(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                image_description: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent whenever the image description of the output changed,"]
            #[doc = "followed by one wl_output.done event common to output events across all"]
            #[doc = "extensions."]
            #[doc = ""]
            #[doc = "If the client wants to use the updated image description, it needs to do"]
            #[doc = "get_image_description again, because image description objects are"]
            #[doc = "immutable."]
            async fn image_description_changed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> xx_color_management_output_v4#{}.image_description_changed()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A xx_color_management_surface_v4 allows the client to set the color"]
    #[doc = "space and HDR properties of a surface."]
    #[doc = ""]
    #[doc = "If the wl_surface associated with the xx_color_management_surface_v4 is"]
    #[doc = "destroyed, the xx_color_management_surface_v4 object becomes inert."]
    pub mod xx_color_management_surface_v4 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "unsupported rendering intent"]
            RenderIntent = 0u32,
            #[doc = "invalid image description"]
            ImageDescription = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::RenderIntent),
                    1u32 => Ok(Self::ImageDescription),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the xx_color_management_surface_v4 interface. See the module level documentation for more info"]
        pub trait XxColorManagementSurfaceV4: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xx_color_management_surface_v4";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xx_color_management_surface_v4#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "xx_color_management_surface_v4#{}.set_image_description()",
                            object.id
                        );
                        self.set_image_description(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "xx_color_management_surface_v4#{}.unset_image_description()",
                            object.id
                        );
                        self.unset_image_description(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the xx_color_management_surface_v4 object and do the same as"]
            #[doc = "unset_image_description."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Set the image description of the underlying surface. The image"]
            #[doc = "description and rendering intent are double-buffered state, see"]
            #[doc = "wl_surface.commit."]
            #[doc = ""]
            #[doc = "It is the client's responsibility to understand the image description"]
            #[doc = "it sets on a surface, and to provide content that matches that image"]
            #[doc = "description. Compositors might convert images to match their own or any"]
            #[doc = "other image descriptions."]
            #[doc = ""]
            #[doc = "Image description whose creation gracefully failed (received"]
            #[doc = "xx_image_description_v4.failed) are forbidden in this request, and in"]
            #[doc = "such case the protocol error image_description is raised."]
            #[doc = ""]
            #[doc = "All image descriptions whose creation succeeded (received"]
            #[doc = "xx_image_description_v4.ready) are allowed and must always be accepted"]
            #[doc = "by the compositor."]
            #[doc = ""]
            #[doc = "A rendering intent provides the client's preference on how content"]
            #[doc = "colors should be mapped to each output. The render_intent value must"]
            #[doc = "be one advertised by the compositor with"]
            #[doc = "xx_color_manager_v4.render_intent event, otherwise the protocol error"]
            #[doc = "render_intent is raised."]
            #[doc = ""]
            #[doc = "By default, a surface does not have an associated image description"]
            #[doc = "nor a rendering intent. The handling of color on such surfaces is"]
            #[doc = "compositor implementation defined. Compositors should handle such"]
            #[doc = "surfaces as sRGB but may handle them differently if they have specific"]
            #[doc = "requirements."]
            async fn set_image_description(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                image_description: crate::wire::ObjectId,
                render_intent: super::super::color_management_v1::xx_color_manager_v4::RenderIntent,
            ) -> crate::server::Result<()>;
            #[doc = "This request removes any image description from the surface. See"]
            #[doc = "set_image_description for how a compositor handles a surface without"]
            #[doc = "an image description. This is double-buffered state, see"]
            #[doc = "wl_surface.commit."]
            async fn unset_image_description(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "A xx_color_management_feedback_surface_v4 allows the client to get the"]
    #[doc = "preferred color description of a surface."]
    #[doc = ""]
    #[doc = "If the wl_surface associated with this object is destroyed, the"]
    #[doc = "xx_color_management_feedback_surface_v4 object becomes inert."]
    pub mod xx_color_management_feedback_surface_v4 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "forbidden request on inert object"]
            Inert = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Inert),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the xx_color_management_feedback_surface_v4 interface. See the module level documentation for more info"]
        pub trait XxColorManagementFeedbackSurfaceV4: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xx_color_management_feedback_surface_v4";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "xx_color_management_feedback_surface_v4#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "xx_color_management_feedback_surface_v4#{}.get_preferred()",
                            object.id
                        );
                        self.get_preferred(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the xx_color_management_feedback_surface_v4 object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "If this protocol object is inert, the protocol error inert is raised."]
            #[doc = ""]
            #[doc = "The preferred image description represents the compositor's preferred"]
            #[doc = "color encoding for this wl_surface at the current time. There might be"]
            #[doc = "performance and power advantages, as well as improved color"]
            #[doc = "reproduction, if the image description of a content update matches the"]
            #[doc = "preferred image description."]
            #[doc = ""]
            #[doc = "This creates a new xx_image_description_v4 object for the currently"]
            #[doc = "preferred image description for the wl_surface. The client should"]
            #[doc = "stop using and destroy the image descriptions created by earlier"]
            #[doc = "invocations of this request for the associated wl_surface."]
            #[doc = "This request is usually sent as a reaction to the preferred_changed"]
            #[doc = "event or when creating a xx_color_management_feedback_surface_v4 object"]
            #[doc = "if the client is capable of adapting to image descriptions."]
            #[doc = ""]
            #[doc = "The created xx_image_description_v4 object preserves the preferred image"]
            #[doc = "description of the wl_surface from the time the object was created."]
            #[doc = ""]
            #[doc = "The resulting image description object allows get_information request."]
            #[doc = ""]
            #[doc = "If the interface version is inadequate for the preferred image"]
            #[doc = "description, meaning that the client does not support all the"]
            #[doc = "events needed to deliver the crucial information, the resulting image"]
            #[doc = "description object shall immediately deliver the"]
            #[doc = "xx_image_description_v4.failed event with the low_version cause,"]
            #[doc = "otherwise the object shall immediately deliver the ready event."]
            async fn get_preferred(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                image_description: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "The preferred image description is the one which likely has the most"]
            #[doc = "performance and/or quality benefits for the compositor if used by the"]
            #[doc = "client for its wl_surface contents. This event is sent whenever the"]
            #[doc = "compositor changes the wl_surface's preferred image description."]
            #[doc = ""]
            #[doc = "This event is merely a notification. When the client wants to know"]
            #[doc = "what the preferred image description is, it shall use the get_preferred"]
            #[doc = "request."]
            #[doc = ""]
            #[doc = "The preferred image description is not automatically used for anything."]
            #[doc = "It is only a hint, and clients may set any valid image description with"]
            #[doc = "set_image_description but there might be performance and color accuracy"]
            #[doc = "improvements by providing the wl_surface contents in the preferred"]
            #[doc = "image description. Therefore clients that can, should render according"]
            #[doc = "to the preferred image description"]
            async fn preferred_changed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> xx_color_management_feedback_surface_v4#{}.preferred_changed()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "This type of object is used for collecting all the information required"]
    #[doc = "to create a xx_image_description_v4 object from an ICC file. A complete"]
    #[doc = "set of required parameters consists of these properties:"]
    #[doc = "- ICC file"]
    #[doc = ""]
    #[doc = "Each required property must be set exactly once if the client is to create"]
    #[doc = "an image description. The set requests verify that a property was not"]
    #[doc = "already set. The create request verifies that all required properties are"]
    #[doc = "set. There may be several alternative requests for setting each property,"]
    #[doc = "and in that case the client must choose one of them."]
    #[doc = ""]
    #[doc = "Once all properties have been set, the create request must be used to"]
    #[doc = "create the image description object, destroying the creator in the"]
    #[doc = "process."]
    pub mod xx_image_description_creator_icc_v4 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "incomplete parameter set"]
            IncompleteSet = 0u32,
            #[doc = "property already set"]
            AlreadySet = 1u32,
            #[doc = "fd not seekable and readable"]
            BadFd = 2u32,
            #[doc = "no or too much data"]
            BadSize = 3u32,
            #[doc = "offset + length exceeds file size"]
            OutOfFile = 4u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::IncompleteSet),
                    1u32 => Ok(Self::AlreadySet),
                    2u32 => Ok(Self::BadFd),
                    3u32 => Ok(Self::BadSize),
                    4u32 => Ok(Self::OutOfFile),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the xx_image_description_creator_icc_v4 interface. See the module level documentation for more info"]
        pub trait XxImageDescriptionCreatorIccV4: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xx_image_description_creator_icc_v4";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "xx_image_description_creator_icc_v4#{}.create()",
                            object.id
                        );
                        self.create(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "xx_image_description_creator_icc_v4#{}.set_icc_file()",
                            object.id
                        );
                        self.set_icc_file(
                            object,
                            client,
                            message.fd()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create an image description object based on the ICC information"]
            #[doc = "previously set on this object. A compositor must parse the ICC data in"]
            #[doc = "some undefined but finite amount of time."]
            #[doc = ""]
            #[doc = "The completeness of the parameter set is verified. If the set is not"]
            #[doc = "complete, the protocol error incomplete_set is raised. For the"]
            #[doc = "definition of a complete set, see the description of this interface."]
            #[doc = ""]
            #[doc = "If the particular combination of the information is not supported"]
            #[doc = "by the compositor, the resulting image description object shall"]
            #[doc = "immediately deliver the xx_image_description_v4.failed event with the"]
            #[doc = "'unsupported' cause. If a valid image description was created from the"]
            #[doc = "information, the xx_image_description_v4.ready event will eventually"]
            #[doc = "be sent instead."]
            #[doc = ""]
            #[doc = "This request destroys the xx_image_description_creator_icc_v4 object."]
            #[doc = ""]
            #[doc = "The resulting image description object does not allow get_information"]
            #[doc = "request."]
            async fn create(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                image_description: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the ICC profile file to be used as the basis of the image"]
            #[doc = "description."]
            #[doc = ""]
            #[doc = "The data shall be found through the given fd at the given offset, having"]
            #[doc = "the given length. The fd must seekable and readable. Violating these"]
            #[doc = "requirements raises the bad_fd protocol error."]
            #[doc = ""]
            #[doc = "If reading the data fails due to an error independent of the client, the"]
            #[doc = "compositor shall send the xx_image_description_v4.failed event on the"]
            #[doc = "created xx_image_description_v4 with the 'operating_system' cause."]
            #[doc = ""]
            #[doc = "The maximum size of the ICC profile is 4 MB. If length is greater than"]
            #[doc = "that or zero, the protocol error bad_size is raised. If offset + length"]
            #[doc = "exceeds the file size, the protocol error out_of_file is raised."]
            #[doc = ""]
            #[doc = "A compositor may read the file at any time starting from this request"]
            #[doc = "and only until whichever happens first:"]
            #[doc = "- If create request was issued, the xx_image_description_v4 object"]
            #[doc = "delivers either failed or ready event; or"]
            #[doc = "- if create request was not issued, this"]
            #[doc = "xx_image_description_creator_icc_v4 object is destroyed."]
            #[doc = ""]
            #[doc = "A compositor shall not modify the contents of the file, and the fd may"]
            #[doc = "be sealed for writes and size changes. The client must ensure to its"]
            #[doc = "best ability that the data does not change while the compositor is"]
            #[doc = "reading it."]
            #[doc = ""]
            #[doc = "The data must represent a valid ICC profile. The ICC profile version"]
            #[doc = "must be 2 or 4, it must be a 3 channel profile and the class must be"]
            #[doc = "Display or ColorSpace. Violating these requirements will not result in a"]
            #[doc = "protocol error but will eventually send the"]
            #[doc = "xx_image_description_v4.failed event on the created"]
            #[doc = "xx_image_description_v4 with the 'unsupported' cause."]
            #[doc = ""]
            #[doc = "See the International Color Consortium specification ICC.1:2022 for more"]
            #[doc = "details about ICC profiles."]
            #[doc = ""]
            #[doc = "If ICC file has already been set on this object, the protocol error"]
            #[doc = "already_set is raised."]
            async fn set_icc_file(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                icc_profile: rustix::fd::OwnedFd,
                offset: u32,
                length: u32,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "This type of object is used for collecting all the parameters required"]
    #[doc = "to create a xx_image_description_v4 object. A complete set of required"]
    #[doc = "parameters consists of these properties:"]
    #[doc = "- transfer characteristic function (tf)"]
    #[doc = "- chromaticities of primaries and white point (primary color volume)"]
    #[doc = ""]
    #[doc = "The following properties are optional and have a well-defined default"]
    #[doc = "if not explicitly set:"]
    #[doc = "- primary color volume luminance range"]
    #[doc = "- reference white luminance level"]
    #[doc = "- mastering display primaries and white point (target color volume)"]
    #[doc = "- mastering luminance range"]
    #[doc = "- maximum content light level"]
    #[doc = "- maximum frame-average light level"]
    #[doc = ""]
    #[doc = "Each required property must be set exactly once if the client is to create"]
    #[doc = "an image description. The set requests verify that a property was not"]
    #[doc = "already set. The create request verifies that all required properties are"]
    #[doc = "set. There may be several alternative requests for setting each property,"]
    #[doc = "and in that case the client must choose one of them."]
    #[doc = ""]
    #[doc = "Once all properties have been set, the create request must be used to"]
    #[doc = "create the image description object, destroying the creator in the"]
    #[doc = "process."]
    pub mod xx_image_description_creator_params_v4 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "incomplete parameter set"]
            IncompleteSet = 0u32,
            #[doc = "invalid combination of parameters"]
            InconsistentSet = 1u32,
            #[doc = "property already set"]
            AlreadySet = 2u32,
            #[doc = "request not supported"]
            UnsupportedFeature = 3u32,
            #[doc = "invalid transfer characteristic"]
            InvalidTf = 4u32,
            #[doc = "invalid primaries or white point"]
            InvalidPrimaries = 5u32,
            #[doc = "invalid luminance value or range"]
            InvalidLuminance = 6u32,
            #[doc = "invalid mastering information"]
            InvalidMastering = 7u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::IncompleteSet),
                    1u32 => Ok(Self::InconsistentSet),
                    2u32 => Ok(Self::AlreadySet),
                    3u32 => Ok(Self::UnsupportedFeature),
                    4u32 => Ok(Self::InvalidTf),
                    5u32 => Ok(Self::InvalidPrimaries),
                    6u32 => Ok(Self::InvalidLuminance),
                    7u32 => Ok(Self::InvalidMastering),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the xx_image_description_creator_params_v4 interface. See the module level documentation for more info"]
        pub trait XxImageDescriptionCreatorParamsV4: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xx_image_description_creator_params_v4";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "xx_image_description_creator_params_v4#{}.create()",
                            object.id
                        );
                        self.create(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "xx_image_description_creator_params_v4#{}.set_tf_named()",
                            object.id
                        );
                        self.set_tf_named(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "xx_image_description_creator_params_v4#{}.set_tf_power()",
                            object.id
                        );
                        self.set_tf_power(object, client, message.uint()?).await
                    }
                    3u16 => {
                        tracing::debug!(
                            "xx_image_description_creator_params_v4#{}.set_primaries_named()",
                            object.id
                        );
                        self.set_primaries_named(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    4u16 => {
                        tracing::debug!(
                            "xx_image_description_creator_params_v4#{}.set_primaries()",
                            object.id
                        );
                        self.set_primaries(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    5u16 => {
                        tracing::debug!(
                            "xx_image_description_creator_params_v4#{}.set_luminances()",
                            object.id
                        );
                        self.set_luminances(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    6u16 => {
                        tracing :: debug ! ("xx_image_description_creator_params_v4#{}.set_mastering_display_primaries()" , object . id);
                        self.set_mastering_display_primaries(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    7u16 => {
                        tracing::debug!(
                            "xx_image_description_creator_params_v4#{}.set_mastering_luminance()",
                            object.id
                        );
                        self.set_mastering_luminance(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    8u16 => {
                        tracing::debug!(
                            "xx_image_description_creator_params_v4#{}.set_max_cll()",
                            object.id
                        );
                        self.set_max_cll(object, client, message.uint()?).await
                    }
                    9u16 => {
                        tracing::debug!(
                            "xx_image_description_creator_params_v4#{}.set_max_fall()",
                            object.id
                        );
                        self.set_max_fall(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create an image description object based on the parameters previously"]
            #[doc = "set on this object."]
            #[doc = ""]
            #[doc = "The completeness of the parameter set is verified. If the set is not"]
            #[doc = "complete, the protocol error incomplete_set is raised. For the"]
            #[doc = "definition of a complete set, see the description of this interface."]
            #[doc = ""]
            #[doc = "Also, the combination of the parameter set is verified. If the set is"]
            #[doc = "not consistent, the protocol error inconsistent_set is raised."]
            #[doc = ""]
            #[doc = "If the particular combination of the parameter set is not supported"]
            #[doc = "by the compositor, the resulting image description object shall"]
            #[doc = "immediately deliver the xx_image_description_v4.failed event with the"]
            #[doc = "'unsupported' cause. If a valid image description was created from the"]
            #[doc = "parameter set, the xx_image_description_v4.ready event will eventually"]
            #[doc = "be sent instead."]
            #[doc = ""]
            #[doc = "This request destroys the xx_image_description_creator_params_v4"]
            #[doc = "object."]
            #[doc = ""]
            #[doc = "The resulting image description object does not allow get_information"]
            #[doc = "request."]
            async fn create(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                image_description: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the transfer characteristic using explicitly enumerated named"]
            #[doc = "functions."]
            #[doc = ""]
            #[doc = "When the resulting image description is attached to an image, the"]
            #[doc = "content should be encoded and decoded according to the industry standard"]
            #[doc = "practices for the transfer characteristic."]
            #[doc = ""]
            #[doc = "Only names advertised with xx_color_manager_v4 event supported_tf_named"]
            #[doc = "are allowed. Other values shall raise the protocol error invalid_tf."]
            #[doc = ""]
            #[doc = "If transfer characteristic has already been set on this object, the"]
            #[doc = "protocol error already_set is raised."]
            async fn set_tf_named(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tf: super::super::color_management_v1::xx_color_manager_v4::TransferFunction,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the color component transfer characteristic to a power curve with"]
            #[doc = "the given exponent. This curve represents the conversion from electrical"]
            #[doc = "to optical pixel or color values."]
            #[doc = ""]
            #[doc = "When the resulting image description is attached to an image, the"]
            #[doc = "content should be encoded with the inverse of the power curve."]
            #[doc = ""]
            #[doc = "The curve exponent shall be multiplied by 10000 to get the argument eexp"]
            #[doc = "value to carry the precision of 4 decimals."]
            #[doc = ""]
            #[doc = "The curve exponent must be at least 1.0 and at most 10.0. Otherwise the"]
            #[doc = "protocol error invalid_tf is raised."]
            #[doc = ""]
            #[doc = "If transfer characteristic has already been set on this object, the"]
            #[doc = "protocol error already_set is raised."]
            #[doc = ""]
            #[doc = "This request can be used when the compositor advertises"]
            #[doc = "xx_color_manager_v4.feature.set_tf_power. Otherwise this request raises"]
            #[doc = "the protocol error unsupported_feature."]
            async fn set_tf_power(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                eexp: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the color primaries and white point using explicitly named sets."]
            #[doc = "This describes the primary color volume which is the basis for color"]
            #[doc = "value encoding."]
            #[doc = ""]
            #[doc = "Only names advertised with xx_color_manager_v4 event"]
            #[doc = "supported_primaries_named are allowed. Other values shall raise the"]
            #[doc = "protocol error invalid_primaries."]
            #[doc = ""]
            #[doc = "If primaries have already been set on this object, the protocol error"]
            #[doc = "already_set is raised."]
            async fn set_primaries_named(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                primaries: super::super::color_management_v1::xx_color_manager_v4::Primaries,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the color primaries and white point using CIE 1931 xy chromaticity"]
            #[doc = "coordinates. This describes the primary color volume which is the basis"]
            #[doc = "for color value encoding."]
            #[doc = ""]
            #[doc = "Each coordinate value is multiplied by 10000 to get the argument value"]
            #[doc = "to carry precision of 4 decimals."]
            #[doc = ""]
            #[doc = "If primaries have already been set on this object, the protocol error"]
            #[doc = "already_set is raised."]
            #[doc = ""]
            #[doc = "This request can be used if the compositor advertises"]
            #[doc = "xx_color_manager_v4.feature.set_primaries. Otherwise this request raises"]
            #[doc = "the protocol error unsupported_feature."]
            async fn set_primaries(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                r_x: i32,
                r_y: i32,
                g_x: i32,
                g_y: i32,
                b_x: i32,
                b_y: i32,
                w_x: i32,
                w_y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the primary color volume luminance range and the reference white"]
            #[doc = "luminance level."]
            #[doc = ""]
            #[doc = "The default luminances are"]
            #[doc = "- primary color volume minimum: 0.2 cd/m²"]
            #[doc = "- primary color volume maximum: 80 cd/m²"]
            #[doc = "- reference white: 80 cd/m²"]
            #[doc = ""]
            #[doc = "Setting a named transfer characteristic can imply other default"]
            #[doc = "luminances."]
            #[doc = ""]
            #[doc = "The default luminances get overwritten when this request is used."]
            #[doc = ""]
            #[doc = "'min_lum' and 'max_lum' specify the minimum and maximum luminances of"]
            #[doc = "the primary color volume as reproduced by the targeted display."]
            #[doc = ""]
            #[doc = "'reference_lum' specifies the luminance of the reference white as"]
            #[doc = "reproduced by the targeted display, and reflects the targeted viewing"]
            #[doc = "environment."]
            #[doc = ""]
            #[doc = "Compositors should make sure that all content is anchored, meaning that"]
            #[doc = "an input signal level of 'reference_lum' on one image description and"]
            #[doc = "another input signal level of 'reference_lum' on another image"]
            #[doc = "description should produce the same output level, even though the"]
            #[doc = "'reference_lum' on both image representations can be different."]
            #[doc = ""]
            #[doc = "If 'max_lum' is less than the 'reference_lum', or 'reference_lum' is"]
            #[doc = "less than or equal to 'min_lum', the protocol error invalid_luminance is"]
            #[doc = "raised."]
            #[doc = ""]
            #[doc = "The minimum luminance is multiplied by 10000 to get the argument"]
            #[doc = "'min_lum' value and carries precision of 4 decimals. The maximum"]
            #[doc = "luminance and reference white luminance values are unscaled."]
            #[doc = ""]
            #[doc = "If the primary color volume luminance range and the reference white"]
            #[doc = "luminance level have already been set on this object, the protocol error"]
            #[doc = "already_set is raised."]
            #[doc = ""]
            #[doc = "This request can be used if the compositor advertises"]
            #[doc = "xx_color_manager_v4.feature.set_luminances. Otherwise this request"]
            #[doc = "raises the protocol error unsupported_feature."]
            async fn set_luminances(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                min_lum: u32,
                max_lum: u32,
                reference_lum: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Provides the color primaries and white point of the mastering display"]
            #[doc = "using CIE 1931 xy chromaticity coordinates. This is compatible with the"]
            #[doc = "SMPTE ST 2086 definition of HDR static metadata."]
            #[doc = ""]
            #[doc = "The mastering display primaries define the target color volume."]
            #[doc = ""]
            #[doc = "If mastering display primaries are not explicitly set, the target color"]
            #[doc = "volume is assumed to be equal to the primary color volume."]
            #[doc = ""]
            #[doc = "The target color volume is defined by all tristimulus values between 0.0"]
            #[doc = "and 1.0 (inclusive) of the color space defined by the given mastering"]
            #[doc = "display primaries and white point. The colorimetry is identical between"]
            #[doc = "the container color space and the mastering display color space,"]
            #[doc = "including that no chromatic adaptation is applied even if the white"]
            #[doc = "points differ."]
            #[doc = ""]
            #[doc = "The target color volume can exceed the primary color volume to allow for"]
            #[doc = "a greater color volume with an existing color space definition (for"]
            #[doc = "example scRGB). It can be smaller than the primary color volume to"]
            #[doc = "minimize gamut and tone mapping distances for big color spaces (HDR"]
            #[doc = "metadata)."]
            #[doc = ""]
            #[doc = "To make use of the entire target color volume a suitable pixel format"]
            #[doc = "has to be chosen (e.g. floating point to exceed the primary color"]
            #[doc = "volume, or abusing limited quantization range as with xvYCC)."]
            #[doc = ""]
            #[doc = "Each coordinate value is multiplied by 10000 to get the argument value"]
            #[doc = "to carry precision of 4 decimals."]
            #[doc = ""]
            #[doc = "If mastering display primaries have already been set on this object, the"]
            #[doc = "protocol error already_set is raised."]
            #[doc = ""]
            #[doc = "This request can be used if the compositor advertises"]
            #[doc = "xx_color_manager_v4.feature.set_mastering_display_primaries. Otherwise"]
            #[doc = "this request raises the protocol error unsupported_feature. The"]
            #[doc = "advertisement implies support only for target color volumes fully"]
            #[doc = "contained within the primary color volume."]
            #[doc = ""]
            #[doc = "If a compositor additionally supports target color volume exceeding the"]
            #[doc = "primary color volume, it must advertise"]
            #[doc = "xx_color_manager_v4.feature.extended_target_volume. If a client uses"]
            #[doc = "target color volume exceeding the primary color volume and the"]
            #[doc = "compositor does not support it, the result is implementation defined."]
            #[doc = "Compositors are recommended to detect this case and fail the image"]
            #[doc = "description gracefully, but it may as well result in color artifacts."]
            async fn set_mastering_display_primaries(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                r_x: i32,
                r_y: i32,
                g_x: i32,
                g_y: i32,
                b_x: i32,
                b_y: i32,
                w_x: i32,
                w_y: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the luminance range that was used during the content mastering"]
            #[doc = "process as the minimum and maximum absolute luminance L. This is"]
            #[doc = "compatible with the SMPTE ST 2086 definition of HDR static metadata."]
            #[doc = ""]
            #[doc = "The mastering luminance range is undefined by default."]
            #[doc = ""]
            #[doc = "If max L is less than or equal to min L, the protocol error"]
            #[doc = "invalid_luminance is raised."]
            #[doc = ""]
            #[doc = "Min L value is multiplied by 10000 to get the argument min_lum value"]
            #[doc = "and carry precision of 4 decimals. Max L value is unscaled for max_lum."]
            async fn set_mastering_luminance(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                min_lum: u32,
                max_lum: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the maximum content light level (max_cll) as defined by CTA-861-H."]
            #[doc = ""]
            #[doc = "This can only be set when set_tf_cicp is used to set the transfer"]
            #[doc = "characteristic to Rec. ITU-R BT.2100-2 perceptual quantization system."]
            #[doc = "Otherwise, 'create' request shall raise inconsistent_set protocol"]
            #[doc = "error."]
            #[doc = ""]
            #[doc = "max_cll is undefined by default."]
            async fn set_max_cll(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                max_cll: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Sets the maximum frame-average light level (max_fall) as defined by"]
            #[doc = "CTA-861-H."]
            #[doc = ""]
            #[doc = "This can only be set when set_tf_cicp is used to set the transfer"]
            #[doc = "characteristic to Rec. ITU-R BT.2100-2 perceptual quantization system."]
            #[doc = "Otherwise, 'create' request shall raise inconsistent_set protocol error."]
            #[doc = ""]
            #[doc = "max_fall is undefined by default."]
            async fn set_max_fall(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                max_fall: u32,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "An image description carries information about the color encoding used on"]
    #[doc = "a surface when attached to a wl_surface via"]
    #[doc = "xx_color_management_surface_v4.set_image_description. A compositor can use"]
    #[doc = "this information to decode pixel values into colorimetrically meaningful"]
    #[doc = "quantities."]
    #[doc = ""]
    #[doc = "Note, that the xx_image_description_v4 object is not ready to be used"]
    #[doc = "immediately after creation. The object eventually delivers either the"]
    #[doc = "'ready' or the 'failed' event, specified in all requests creating it. The"]
    #[doc = "object is deemed \"ready\" after receiving the 'ready' event."]
    #[doc = ""]
    #[doc = "An object which is not ready is illegal to use, it can only be destroyed."]
    #[doc = "Any other request in this interface shall result in the 'not_ready'"]
    #[doc = "protocol error. Attempts to use an object which is not ready through other"]
    #[doc = "interfaces shall raise protocol errors defined there."]
    #[doc = ""]
    #[doc = "Once created and regardless of how it was created, a"]
    #[doc = "xx_image_description_v4 object always refers to one fixed image"]
    #[doc = "description. It cannot change after creation."]
    pub mod xx_image_description_v4 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "attempted to use an object which is not ready"]
            NotReady = 0u32,
            #[doc = "get_information not allowed"]
            NoInformation = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::NotReady),
                    1u32 => Ok(Self::NoInformation),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Cause {
            #[doc = "interface version too low"]
            LowVersion = 0u32,
            #[doc = "unsupported image description data"]
            Unsupported = 1u32,
            #[doc = "error independent of the client"]
            OperatingSystem = 2u32,
            #[doc = "the relevant output no longer exists"]
            NoOutput = 3u32,
        }
        impl TryFrom<u32> for Cause {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::LowVersion),
                    1u32 => Ok(Self::Unsupported),
                    2u32 => Ok(Self::OperatingSystem),
                    3u32 => Ok(Self::NoOutput),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the xx_image_description_v4 interface. See the module level documentation for more info"]
        pub trait XxImageDescriptionV4: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xx_image_description_v4";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("xx_image_description_v4#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("xx_image_description_v4#{}.get_information()", object.id);
                        self.get_information(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy this object. It is safe to destroy an object which is not ready."]
            #[doc = ""]
            #[doc = "Destroying a xx_image_description_v4 object has no side-effects, not"]
            #[doc = "even if a xx_color_management_surface_v4.set_image_description has not"]
            #[doc = "yet been followed by a wl_surface.commit."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Creates a xx_image_description_info_v4 object which delivers the"]
            #[doc = "information that makes up the image description."]
            #[doc = ""]
            #[doc = "Not all image description protocol objects allow get_information"]
            #[doc = "request. Whether it is allowed or not is defined by the request that"]
            #[doc = "created the object. If get_information is not allowed, the protocol"]
            #[doc = "error no_information is raised."]
            async fn get_information(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                information: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "If creating a xx_image_description_v4 object fails for a reason that is"]
            #[doc = "not defined as a protocol error, this event is sent."]
            #[doc = ""]
            #[doc = "The requests that create image description objects define whether and"]
            #[doc = "when this can occur. Only such creation requests can trigger this event."]
            #[doc = "This event cannot be triggered after the image description was"]
            #[doc = "successfully formed."]
            #[doc = ""]
            #[doc = "Once this event has been sent, the xx_image_description_v4 object will"]
            #[doc = "never become ready and it can only be destroyed."]
            async fn failed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                cause: Cause,
                msg: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xx_image_description_v4#{}.failed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(cause as u32)
                    .put_string(Some(msg))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Once this event has been sent, the xx_image_description_v4 object is"]
            #[doc = "deemed \"ready\". Ready objects can be used to send requests and can be"]
            #[doc = "used through other interfaces."]
            #[doc = ""]
            #[doc = "Every ready xx_image_description_v4 protocol object refers to an"]
            #[doc = "underlying image description record in the compositor. Multiple protocol"]
            #[doc = "objects may end up referring to the same record. Clients may identify"]
            #[doc = "these \"copies\" by comparing their id numbers: if the numbers from two"]
            #[doc = "protocol objects are identical, the protocol objects refer to the same"]
            #[doc = "image description record. Two different image description records"]
            #[doc = "cannot have the same id number simultaneously. The id number does not"]
            #[doc = "change during the lifetime of the image description record."]
            #[doc = ""]
            #[doc = "The id number is valid only as long as the protocol object is alive. If"]
            #[doc = "all protocol objects referring to the same image description record are"]
            #[doc = "destroyed, the id number may be recycled for a different image"]
            #[doc = "description record."]
            #[doc = ""]
            #[doc = "Image description id number is not a protocol object id. Zero is"]
            #[doc = "reserved as an invalid id number. It shall not be possible for a client"]
            #[doc = "to refer to an image description by its id number in protocol. The id"]
            #[doc = "numbers might not be portable between Wayland connections."]
            #[doc = ""]
            #[doc = "This identity allows clients to de-duplicate image description records"]
            #[doc = "and avoid get_information request if they already have the image"]
            #[doc = "description information."]
            async fn ready(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                identity: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xx_image_description_v4#{}.ready()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(identity)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "Sends all matching events describing an image description object exactly"]
    #[doc = "once and finally sends the 'done' event."]
    #[doc = ""]
    #[doc = "Once a xx_image_description_info_v4 object has delivered a 'done' event it"]
    #[doc = "is automatically destroyed."]
    #[doc = ""]
    #[doc = "Every xx_image_description_info_v4 created from the same"]
    #[doc = "xx_image_description_v4 shall always return the exact same data."]
    pub mod xx_image_description_info_v4 {
        #[doc = "Trait to implement the xx_image_description_info_v4 interface. See the module level documentation for more info"]
        pub trait XxImageDescriptionInfoV4: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xx_image_description_info_v4";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Signals the end of information events and destroys the object."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xx_image_description_info_v4#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The icc argument provides a file descriptor to the client which may be"]
            #[doc = "memory-mapped to provide the ICC profile matching the image description."]
            #[doc = "The fd is read-only, and if mapped then it must be mapped with"]
            #[doc = "MAP_PRIVATE by the client."]
            #[doc = ""]
            #[doc = "The ICC profile version and other details are determined by the"]
            #[doc = "compositor. There is no provision for a client to ask for a specific"]
            #[doc = "kind of a profile."]
            async fn icc_file(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                icc: rustix::fd::OwnedFd,
                icc_size: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xx_image_description_info_v4#{}.icc_file()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fd(icc)
                    .put_uint(icc_size)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Delivers the primary color volume primaries and white point using CIE"]
            #[doc = "1931 xy chromaticity coordinates."]
            #[doc = ""]
            #[doc = "Each coordinate value is multiplied by 10000 to get the argument value"]
            #[doc = "to carry precision of 4 decimals."]
            async fn primaries(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                r_x: i32,
                r_y: i32,
                g_x: i32,
                g_y: i32,
                b_x: i32,
                b_y: i32,
                w_x: i32,
                w_y: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xx_image_description_info_v4#{}.primaries()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(r_x)
                    .put_int(r_y)
                    .put_int(g_x)
                    .put_int(g_y)
                    .put_int(b_x)
                    .put_int(b_y)
                    .put_int(w_x)
                    .put_int(w_y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Delivers the primary color volume primaries and white point using an"]
            #[doc = "explicitly enumerated named set."]
            async fn primaries_named(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                primaries: super::super::color_management_v1::xx_color_manager_v4::Primaries,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> xx_image_description_info_v4#{}.primaries_named()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(primaries as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The color component transfer characteristic of this image description is"]
            #[doc = "a pure power curve. This event provides the exponent of the power"]
            #[doc = "function. This curve represents the conversion from electrical to"]
            #[doc = "optical pixel or color values."]
            #[doc = ""]
            #[doc = "The curve exponent has been multiplied by 10000 to get the argument eexp"]
            #[doc = "value to carry the precision of 4 decimals."]
            async fn tf_power(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                eexp: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xx_image_description_info_v4#{}.tf_power()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(eexp).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Delivers the transfer characteristic using an explicitly enumerated"]
            #[doc = "named function."]
            async fn tf_named(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tf: super::super::color_management_v1::xx_color_manager_v4::TransferFunction,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xx_image_description_info_v4#{}.tf_named()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(tf as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Delivers the primary color volume luminance range and the reference"]
            #[doc = "white luminance level."]
            #[doc = ""]
            #[doc = "The minimum luminance is multiplied by 10000 to get the argument"]
            #[doc = "'min_lum' value and carries precision of 4 decimals. The maximum"]
            #[doc = "luminance and reference white luminance values are unscaled."]
            async fn luminances(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                min_lum: u32,
                max_lum: u32,
                reference_lum: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xx_image_description_info_v4#{}.luminances()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(min_lum)
                    .put_uint(max_lum)
                    .put_uint(reference_lum)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 6u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Provides the color primaries and white point of the target color volume"]
            #[doc = "using CIE 1931 xy chromaticity coordinates. This is compatible with the"]
            #[doc = "SMPTE ST 2086 definition of HDR static metadata for mastering displays."]
            #[doc = ""]
            #[doc = "While primary color volume is about how color is encoded, the target"]
            #[doc = "color volume is the actually displayable color volume. If target color"]
            #[doc = "volume is equal to the primary color volume, then this event is not"]
            #[doc = "sent."]
            #[doc = ""]
            #[doc = "Each coordinate value is multiplied by 10000 to get the argument value"]
            #[doc = "to carry precision of 4 decimals."]
            async fn target_primaries(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                r_x: i32,
                r_y: i32,
                g_x: i32,
                g_y: i32,
                b_x: i32,
                b_y: i32,
                w_x: i32,
                w_y: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> xx_image_description_info_v4#{}.target_primaries()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(r_x)
                    .put_int(r_y)
                    .put_int(g_x)
                    .put_int(g_y)
                    .put_int(b_x)
                    .put_int(b_y)
                    .put_int(w_x)
                    .put_int(w_y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 7u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Provides the luminance range that the image description is targeting as"]
            #[doc = "the minimum and maximum absolute luminance L. This is compatible with"]
            #[doc = "the SMPTE ST 2086 definition of HDR static metadata."]
            #[doc = ""]
            #[doc = "This luminance range is only theoretical and may not correspond to the"]
            #[doc = "luminance of light emitted on an actual display."]
            #[doc = ""]
            #[doc = "Min L value is multiplied by 10000 to get the argument min_lum value and"]
            #[doc = "carry precision of 4 decimals. Max L value is unscaled for max_lum."]
            async fn target_luminance(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                min_lum: u32,
                max_lum: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> xx_image_description_info_v4#{}.target_luminance()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(min_lum)
                    .put_uint(max_lum)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 8u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Provides the targeted max_cll of the image description. max_cll is"]
            #[doc = "defined by CTA-861-H."]
            #[doc = ""]
            #[doc = "This luminance is only theoretical and may not correspond to the"]
            #[doc = "luminance of light emitted on an actual display."]
            async fn target_max_cll(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                max_cll: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> xx_image_description_info_v4#{}.target_max_cll()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(max_cll).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 9u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Provides the targeted max_fall of the image description. max_fall is"]
            #[doc = "defined by CTA-861-H."]
            #[doc = ""]
            #[doc = "This luminance is only theoretical and may not correspond to the"]
            #[doc = "luminance of light emitted on an actual display."]
            async fn target_max_fall(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                max_fall: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> xx_image_description_info_v4#{}.target_max_fall()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(max_fall)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 10u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod ivi_application {
    pub mod ivi_surface {
        #[doc = "Trait to implement the ivi_surface interface. See the module level documentation for more info"]
        pub trait IviSurface: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ivi_surface";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("ivi_surface#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This removes the link from ivi_id to wl_surface and destroys ivi_surface."]
            #[doc = "The ID, ivi_id, is free and can be used for surface_create again."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The configure event asks the client to resize its surface."]
            #[doc = ""]
            #[doc = "The size is a hint, in the sense that the client is free to"]
            #[doc = "ignore it if it doesn't resize, pick a smaller size (to"]
            #[doc = "satisfy aspect ratio or resize in steps of NxM pixels)."]
            #[doc = ""]
            #[doc = "The client is free to dismiss all but the last configure"]
            #[doc = "event it received."]
            #[doc = ""]
            #[doc = "The width and height arguments specify the size of the window"]
            #[doc = "in surface-local coordinates."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ivi_surface#{}.configure()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "This interface is exposed as a global singleton."]
    #[doc = "This interface is implemented by servers that provide IVI-style user interfaces."]
    #[doc = "It allows clients to associate an ivi_surface with wl_surface."]
    pub mod ivi_application {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "given wl_surface has another role"]
            Role = 0u32,
            #[doc = "given ivi_id is assigned to another wl_surface"]
            IviId = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Role),
                    1u32 => Ok(Self::IviId),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the ivi_application interface. See the module level documentation for more info"]
        pub trait IviApplication: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ivi_application";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("ivi_application#{}.surface_create()", object.id);
                        self.surface_create(
                            object,
                            client,
                            message.uint()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request gives the wl_surface the role of an IVI Surface. Creating more than"]
            #[doc = "one ivi_surface for a wl_surface is not allowed. Note, that this still allows the"]
            #[doc = "following example:"]
            #[doc = ""]
            #[doc = "1. create a wl_surface"]
            #[doc = "2. create ivi_surface for the wl_surface"]
            #[doc = "3. destroy the ivi_surface"]
            #[doc = "4. create ivi_surface for the wl_surface (with the same or another ivi_id as before)"]
            #[doc = ""]
            #[doc = "surface_create will create an interface:ivi_surface with numeric ID; ivi_id in"]
            #[doc = "ivi compositor. These ivi_ids are defined as unique in the system to identify"]
            #[doc = "it inside of ivi compositor. The ivi compositor implements business logic how to"]
            #[doc = "set properties of the surface with ivi_id according to the status of the system."]
            #[doc = "E.g. a unique ID for Car Navigation application is used for implementing special"]
            #[doc = "logic of the application about where it shall be located."]
            #[doc = "The server regards the following cases as protocol errors and disconnects the client."]
            #[doc = "- wl_surface already has another role."]
            #[doc = "- ivi_id is already assigned to another wl_surface."]
            #[doc = ""]
            #[doc = "If client destroys ivi_surface or wl_surface which is assigned to the ivi_surface,"]
            #[doc = "ivi_id which is assigned to the ivi_surface is free for reuse."]
            async fn surface_create(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                ivi_id: u32,
                surface: crate::wire::ObjectId,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod ivi_hmi_controller {
    pub mod ivi_hmi_controller {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum LayoutMode {
            Tiling = 0u32,
            SideBySide = 1u32,
            FullScreen = 2u32,
            Random = 3u32,
        }
        impl TryFrom<u32> for LayoutMode {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Tiling),
                    1u32 => Ok(Self::SideBySide),
                    2u32 => Ok(Self::FullScreen),
                    3u32 => Ok(Self::Random),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Home {
            Off = 0u32,
            On = 1u32,
        }
        impl TryFrom<u32> for Home {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Off),
                    1u32 => Ok(Self::On),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the ivi_hmi_controller interface. See the module level documentation for more info"]
        pub trait IviHmiController: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ivi_hmi_controller";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("ivi_hmi_controller#{}.ui_ready()", object.id);
                        self.UI_ready(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("ivi_hmi_controller#{}.workspace_control()", object.id);
                        self.workspace_control(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("ivi_hmi_controller#{}.switch_mode()", object.id);
                        self.switch_mode(object, client, message.uint()?).await
                    }
                    3u16 => {
                        tracing::debug!("ivi_hmi_controller#{}.home()", object.id);
                        self.home(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn ui_ready(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Reference protocol to control a surface by server."]
            #[doc = "To control a surface by server, it gives seat to the server"]
            #[doc = "to e.g. control Home screen. Home screen has several workspaces"]
            #[doc = "to group launchers of wayland application. These workspaces"]
            #[doc = "are drawn on a horizontally long surface to be controlled"]
            #[doc = "by motion of input device. E.g. A motion from right to left"]
            #[doc = "happens, the viewport of surface is controlled in the ivi-shell"]
            #[doc = "by using ivi-layout. client can recognizes the end of controlling"]
            #[doc = "by event \"workspace_end_control\"."]
            async fn workspace_control(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                seat: crate::wire::ObjectId,
                serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = "hmi-controller loaded to ivi-shall implements 4 types of layout"]
            #[doc = "as a reference; tiling, side by side, full_screen, and random."]
            async fn switch_mode(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                layout_mode: u32,
            ) -> crate::server::Result<()>;
            #[doc = "home screen is a reference implementation of launcher to launch"]
            #[doc = "wayland applications. The home screen has several workspaces to"]
            #[doc = "group wayland applications. By defining the following keys in"]
            #[doc = "weston.ini, user can add launcher icon to launch a wayland application"]
            #[doc = "to a workspace."]
            #[doc = "[ivi-launcher]"]
            #[doc = "workspace-id=0"]
            #[doc = ": id of workspace to add a launcher"]
            #[doc = "icon-id=4001"]
            #[doc = ": ivi id of ivi_surface to draw an icon"]
            #[doc = "icon=/home/user/review/build-ivi-shell/data/icon_ivi_flower.png"]
            #[doc = ": path to icon image"]
            #[doc = "path=/home/user/review/build-ivi-shell/weston-dnd"]
            #[doc = ": path to wayland application"]
            async fn home(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                home: u32,
            ) -> crate::server::Result<()>;
            async fn workspace_end_control(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                is_controlled: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> ivi_hmi_controller#{}.workspace_end_control()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(is_controlled)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod text_cursor_position {
    pub mod text_cursor_position {
        #[doc = "Trait to implement the text_cursor_position interface. See the module level documentation for more info"]
        pub trait TextCursorPosition: crate::server::Dispatcher {
            const INTERFACE: &'static str = "text_cursor_position";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("text_cursor_position#{}.notify()", object.id);
                        self.notify(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.fixed()?,
                            message.fixed()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn notify(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
                x: crate::wire::Fixed,
                y: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
        }
    }
}
#[doc = "This protocol specifies a set of interfaces used to provide"]
#[doc = "content-protection for e.g. HDCP, and protect surface contents on the"]
#[doc = "secured outputs and prevent from appearing in screenshots or from being"]
#[doc = "visible on non-secure outputs."]
#[doc = ""]
#[doc = "A secure-output is defined as an output that is secured by some"]
#[doc = "content-protection mechanism e.g. HDCP, and meets at least the minimum"]
#[doc = "required content-protection level requested by a client."]
#[doc = ""]
#[doc = "The term content-protection is defined in terms of HDCP type 0 and"]
#[doc = "HDCP type 1, but this may be extended in future."]
#[doc = ""]
#[doc = "This protocol is not intended for implementing Digital Rights Management on"]
#[doc = "general (e.g. Desktop) systems, and would only be useful for closed systems."]
#[doc = "As the server is the one responsible for implementing"]
#[doc = "the content-protection, the client can only trust the content-protection as"]
#[doc = "much they can trust the server."]
#[doc = ""]
#[doc = "In order to protect the content and prevent surface contents from appearing"]
#[doc = "in screenshots or from being visible on non-secure outputs, a client must"]
#[doc = "first bind the global interface \"weston_content_protection\" which, if a"]
#[doc = "compositor supports secure output, is exposed by the registry."]
#[doc = "Using the bound global object, the client uses the \"get_protection\" request"]
#[doc = "to instantiate an interface extension for a wl_surface object."]
#[doc = "This extended interface will then allow surfaces to request for"]
#[doc = "content-protection, and also to censor the visibility of the surface on"]
#[doc = "non-secure outputs. Client applications should not wait for the protection"]
#[doc = "to change, as it might never change in case the content-protection cannot be"]
#[doc = "achieved. Alternatively, clients can use a timeout and start showing the"]
#[doc = "content in lower quality."]
#[doc = ""]
#[doc = "Censored visibility is defined as the compositor censoring the protected"]
#[doc = "content on non-secure outputs. Censoring may include artificially reducing"]
#[doc = "image quality or replacing the protected content completely with"]
#[doc = "placeholder graphics."]
#[doc = ""]
#[doc = "Censored visibility is controlled by protection mode, set by the client."]
#[doc = "In \"relax\" mode, the compositor may show protected content on non-secure"]
#[doc = "outputs. It will be up to the client to adapt to secure and non-secure"]
#[doc = "presentation. In \"enforce\" mode, the compositor will censor the parts of"]
#[doc = "protected content that would otherwise show on non-secure outputs."]
pub mod weston_content_protection {
    #[doc = "The global interface weston_content_protection is used for exposing the"]
    #[doc = "content protection capabilities to a client. It provides a way for clients"]
    #[doc = "to request their wl_surface contents to not be displayed on an output"]
    #[doc = "below their required level of content-protection."]
    #[doc = "Using this interface clients can request for a weston_protected_surface"]
    #[doc = "which is an extension to the wl_surface to provide content-protection, and"]
    #[doc = "set the censored-visibility on the non-secured-outputs."]
    pub mod weston_content_protection {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "the surface already has a protected surface associated"]
            SurfaceExists = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::SurfaceExists),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the weston_content_protection interface. See the module level documentation for more info"]
        pub trait WestonContentProtection: crate::server::Dispatcher {
            const INTERFACE: &'static str = "weston_content_protection";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("weston_content_protection#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("weston_content_protection#{}.get_protection()", object.id);
                        self.get_protection(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Informs the server that the client will not be using this"]
            #[doc = "protocol object anymore. This does not affect any other objects,"]
            #[doc = "protected_surface objects included."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Instantiate an interface extension for the given wl_surface to"]
            #[doc = "provide surface protection. If the given wl_surface already has"]
            #[doc = "a weston_protected_surface associated, the surface_exists protocol"]
            #[doc = "error is raised."]
            async fn get_protection(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "An additional interface to a wl_surface object, which allows a client to"]
    #[doc = "request the minimum level of content-protection, request to change the"]
    #[doc = "visibility of their contents, and receive notifications about changes in"]
    #[doc = "content-protection."]
    #[doc = ""]
    #[doc = "A protected surface has a 'status' associated with it, that indicates"]
    #[doc = "what type of protection it is currently providing, specified by"]
    #[doc = "content-type. Updates to this status are sent to the client"]
    #[doc = "via the 'status' event. Before the first status event is sent, the client"]
    #[doc = "should assume that the status is 'unprotected'."]
    #[doc = ""]
    #[doc = "A client can request a content protection level to be the minimum for an"]
    #[doc = "output to be considered secure, using the 'set_type' request."]
    #[doc = "It is responsibility of the client to monitor the actual"]
    #[doc = "content-protection level achieved via the 'status' event, and make"]
    #[doc = "decisions as to what content to show based on this."]
    #[doc = ""]
    #[doc = "The server should make its best effort to achieve the desired"]
    #[doc = "content-protection level on all of the outputs the client's contents are"]
    #[doc = "being displayed on. Any changes to the content protection status should be"]
    #[doc = "reported to the client, even if they are below the requested"]
    #[doc = "content-protection level. If the client's contents are being displayed on"]
    #[doc = "multiple outputs, the lowest content protection level achieved should be"]
    #[doc = "reported."]
    #[doc = ""]
    #[doc = "A client can also request that its content only be displayed on outputs"]
    #[doc = "that are considered secure. The 'enforce/relax' requests can achieve this."]
    #[doc = "In enforce mode, the content is censored for non-secure outputs."]
    #[doc = "The implementation of censored-visibility is compositor-defined."]
    #[doc = "In relax mode there are no such limitation. On an attempt to show the"]
    #[doc = "client on unsecured output, compositor would keep on showing the content"]
    #[doc = "and send the 'status' event to the client. Client can take a call to"]
    #[doc = "downgrade the content."]
    #[doc = ""]
    #[doc = "If the wl_surface associated with the protected_surface is destroyed,"]
    #[doc = "the protected_surface becomes inert."]
    pub mod weston_protected_surface {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "provided type was not valid"]
            InvalidType = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidType),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Description of a particular type of content protection."]
        #[doc = ""]
        #[doc = "A server may not necessarily support all of these types."]
        #[doc = ""]
        #[doc = "Note that there is no ordering between enum members unless specified."]
        #[doc = "Over time, different types of content protection may be added, which"]
        #[doc = "may be considered less secure than what is already here."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Type {
            #[doc = "no protection required"]
            Unprotected = 0u32,
            #[doc = "HDCP type 0"]
            Hdcp0 = 1u32,
            #[doc = "HDCP type 1. This is a more secure than HDCP type 0."]
            Hdcp1 = 2u32,
        }
        impl TryFrom<u32> for Type {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Unprotected),
                    1u32 => Ok(Self::Hdcp0),
                    2u32 => Ok(Self::Hdcp1),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the weston_protected_surface interface. See the module level documentation for more info"]
        pub trait WestonProtectedSurface: crate::server::Dispatcher {
            const INTERFACE: &'static str = "weston_protected_surface";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("weston_protected_surface#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("weston_protected_surface#{}.set_type()", object.id);
                        self.set_type(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    2u16 => {
                        tracing::debug!("weston_protected_surface#{}.enforce()", object.id);
                        self.enforce(object, client).await
                    }
                    3u16 => {
                        tracing::debug!("weston_protected_surface#{}.relax()", object.id);
                        self.relax(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "If the protected_surface is destroyed, the wl_surface desired protection"]
            #[doc = "level returns to unprotected, as if set_type request was sent with type"]
            #[doc = "as 'unprotected'."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Informs the server about the type of content. The level of"]
            #[doc = "content-protection depends upon the content-type set by the client"]
            #[doc = "through this request. Initially, this is set to 'unprotected'."]
            #[doc = ""]
            #[doc = "If the requested value is not a valid content_type enum value, the"]
            #[doc = "'invalid_type' protocol error is raised. It is not an error to request"]
            #[doc = "a valid protection type the compositor does not implement or cannot"]
            #[doc = "achieve."]
            #[doc = ""]
            #[doc = "The requested content protection is double-buffered, see"]
            #[doc = "wl_surface.commit."]
            async fn set_type(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                r#type: Type,
            ) -> crate::server::Result<()>;
            #[doc = "Censor the visibility of the wl_surface contents on non-secure outputs."]
            #[doc = "See weston_protected_surface for the description."]
            #[doc = ""]
            #[doc = "The force constrain mode is double-buffered, see wl_surface.commit"]
            async fn enforce(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Do not enforce censored-visibility of the wl_surface contents on"]
            #[doc = "non-secure-outputs. See weston_protected_surface for the description."]
            #[doc = ""]
            #[doc = "The relax mode is selected by default, if no explicit request is made"]
            #[doc = "for enforcing the censored-visibility."]
            #[doc = ""]
            #[doc = "The relax mode is double-buffered, see wl_surface.commit"]
            async fn relax(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent to the client to inform about the actual protection"]
            #[doc = "level for its surface in the relax mode."]
            #[doc = ""]
            #[doc = "The 'type' argument indicates what that current level of content"]
            #[doc = "protection that the server has currently established."]
            #[doc = ""]
            #[doc = "The 'status' event is first sent, when a weston_protected_surface is"]
            #[doc = "created."]
            #[doc = ""]
            #[doc = "Until this event is sent for the first time, the client should assume"]
            #[doc = "that its contents are not secure, and the type is 'unprotected'."]
            #[doc = ""]
            #[doc = "Possible reasons the content protection status can change is due to"]
            #[doc = "change in censored-visibility mode from enforced to relaxed, a new"]
            #[doc = "connector being added, movement of window to another output, or,"]
            #[doc = "the client attaching a buffer too large for what the server may secure."]
            #[doc = "However, it is not limited to these reasons."]
            #[doc = ""]
            #[doc = "A client may want to listen to this event and lower the resolution of"]
            #[doc = "their content until it can successfully be shown securely."]
            #[doc = ""]
            #[doc = "In case of \"enforce\" mode, the client will not get any status event."]
            #[doc = "If the mode is then changed to \"relax\", the client will receive the"]
            #[doc = "status event."]
            async fn status(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                r#type: Type,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> weston_protected_surface#{}.status()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(r#type as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod weston_debug {
    #[doc = "This is a generic debugging interface for Weston internals, the global"]
    #[doc = "object advertized through wl_registry."]
    #[doc = ""]
    #[doc = "WARNING: This interface by design allows a denial-of-service attack. It"]
    #[doc = "should not be offered in production, or proper authorization mechanisms"]
    #[doc = "must be enforced."]
    #[doc = ""]
    #[doc = "The idea is for a client to provide a file descriptor that the server"]
    #[doc = "uses for printing debug information. The server uses the file"]
    #[doc = "descriptor in blocking writes mode, which exposes the denial-of-service"]
    #[doc = "risk. The blocking mode is necessary to ensure all debug messages can"]
    #[doc = "be easily printed in place. It also ensures message ordering if a"]
    #[doc = "client subscribes to more than one debug stream."]
    #[doc = ""]
    #[doc = "The available debugging features depend on the server."]
    #[doc = ""]
    #[doc = "A debug stream can be one-shot where the server prints the requested"]
    #[doc = "information and then closes it, or continuous where server keeps on"]
    #[doc = "printing until the client stops it. Or anything in between."]
    pub mod weston_debug_v1 {
        #[doc = "Trait to implement the weston_debug_v1 interface. See the module level documentation for more info"]
        pub trait WestonDebugV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "weston_debug_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("weston_debug_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("weston_debug_v1#{}.subscribe()", object.id);
                        self.subscribe(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.fd()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroys the factory object, but does not affect any other objects."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Subscribe to a named debug stream. The server will start printing"]
            #[doc = "to the given file descriptor."]
            #[doc = ""]
            #[doc = "If the named debug stream is a one-shot dump, the server will send"]
            #[doc = "weston_debug_stream_v1.complete event once all requested data has"]
            #[doc = "been printed. Otherwise, the server will continue streaming debug"]
            #[doc = "prints until the subscription object is destroyed."]
            #[doc = ""]
            #[doc = "If the debug stream name is unknown to the server, the server will"]
            #[doc = "immediately respond with weston_debug_stream_v1.failure event."]
            async fn subscribe(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
                streamfd: rustix::fd::OwnedFd,
                stream: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Advertises an available debug scope which the client may be able to"]
            #[doc = "bind to. No information is provided by the server about the content"]
            #[doc = "contained within the debug streams provided by the scope, once a"]
            #[doc = "client has subscribed."]
            async fn available(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
                description: Option<String>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> weston_debug_v1#{}.available()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(name))
                    .put_string(description)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "Represents one subscribed debug stream, created with"]
    #[doc = "weston_debug_v1.subscribe. When the object is created, it is associated"]
    #[doc = "with a given file descriptor. The server will continue writing to the"]
    #[doc = "file descriptor until the object is destroyed or the server sends an"]
    #[doc = "event through the object."]
    pub mod weston_debug_stream_v1 {
        #[doc = "Trait to implement the weston_debug_stream_v1 interface. See the module level documentation for more info"]
        pub trait WestonDebugStreamV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "weston_debug_stream_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("weston_debug_stream_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroys the object, which causes the server to stop writing into"]
            #[doc = "and closes the associated file descriptor if it was not closed"]
            #[doc = "already."]
            #[doc = ""]
            #[doc = "Use a wl_display.sync if the clients needs to guarantee the file"]
            #[doc = "descriptor is closed before continuing."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The server has successfully finished writing to and has closed the"]
            #[doc = "associated file descriptor."]
            #[doc = ""]
            #[doc = "This event is delivered only for one-shot debug streams where the"]
            #[doc = "server dumps some data and stop. This is never delivered for"]
            #[doc = "continuous debbug streams because they by definition never complete."]
            async fn complete(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> weston_debug_stream_v1#{}.complete()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The server has stopped writing to and has closed the"]
            #[doc = "associated file descriptor. The data already written to the file"]
            #[doc = "descriptor is correct, but it may be truncated."]
            #[doc = ""]
            #[doc = "This event may be delivered at any time and for any kind of debug"]
            #[doc = "stream. It may be due to a failure in or shutdown of the server."]
            #[doc = "The message argument may provide a hint of the reason."]
            async fn failure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: Option<String>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> weston_debug_stream_v1#{}.failure()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(message)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod weston_desktop {
    #[doc = "Traditional user interfaces can rely on this interface to define the"]
    #[doc = "foundations of typical desktops. Currently it's possible to set up"]
    #[doc = "background, panels and locking surfaces."]
    pub mod weston_desktop_shell {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Cursor {
            None = 0u32,
            ResizeTop = 1u32,
            ResizeBottom = 2u32,
            Arrow = 3u32,
            ResizeLeft = 4u32,
            ResizeTopLeft = 5u32,
            ResizeBottomLeft = 6u32,
            Move = 7u32,
            ResizeRight = 8u32,
            ResizeTopRight = 9u32,
            ResizeBottomRight = 10u32,
            Busy = 11u32,
        }
        impl TryFrom<u32> for Cursor {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::None),
                    1u32 => Ok(Self::ResizeTop),
                    2u32 => Ok(Self::ResizeBottom),
                    3u32 => Ok(Self::Arrow),
                    4u32 => Ok(Self::ResizeLeft),
                    5u32 => Ok(Self::ResizeTopLeft),
                    6u32 => Ok(Self::ResizeBottomLeft),
                    7u32 => Ok(Self::Move),
                    8u32 => Ok(Self::ResizeRight),
                    9u32 => Ok(Self::ResizeTopRight),
                    10u32 => Ok(Self::ResizeBottomRight),
                    11u32 => Ok(Self::Busy),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum PanelPosition {
            Top = 0u32,
            Bottom = 1u32,
            Left = 2u32,
            Right = 3u32,
        }
        impl TryFrom<u32> for PanelPosition {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Top),
                    1u32 => Ok(Self::Bottom),
                    2u32 => Ok(Self::Left),
                    3u32 => Ok(Self::Right),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "an invalid argument was provided in a request"]
            InvalidArgument = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidArgument),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the weston_desktop_shell interface. See the module level documentation for more info"]
        pub trait WestonDesktopShell: crate::server::Dispatcher {
            const INTERFACE: &'static str = "weston_desktop_shell";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("weston_desktop_shell#{}.set_background()", object.id);
                        self.set_background(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("weston_desktop_shell#{}.set_panel()", object.id);
                        self.set_panel(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("weston_desktop_shell#{}.set_lock_surface()", object.id);
                        self.set_lock_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("weston_desktop_shell#{}.unlock()", object.id);
                        self.unlock(object, client).await
                    }
                    4u16 => {
                        tracing::debug!("weston_desktop_shell#{}.set_grab_surface()", object.id);
                        self.set_grab_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    5u16 => {
                        tracing::debug!("weston_desktop_shell#{}.desktop_ready()", object.id);
                        self.desktop_ready(object, client).await
                    }
                    6u16 => {
                        tracing::debug!("weston_desktop_shell#{}.set_panel_position()", object.id);
                        self.set_panel_position(object, client, message.uint()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn set_background(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            async fn set_panel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            async fn set_lock_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            async fn unlock(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The surface set by this request will receive a fake"]
            #[doc = "pointer.enter event during grabs at position 0, 0 and is"]
            #[doc = "expected to set an appropriate cursor image as described by"]
            #[doc = "the grab_cursor event sent just before the enter event."]
            async fn set_grab_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Tell the server, that enough desktop elements have been drawn"]
            #[doc = "to make the desktop look ready for use. During start-up, the"]
            #[doc = "server can wait for this request with a black screen before"]
            #[doc = "starting to fade in the desktop, for instance. If the client"]
            #[doc = "parts of a desktop take a long time to initialize, we avoid"]
            #[doc = "showing temporary garbage."]
            async fn desktop_ready(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Tell the shell which side of the screen the panel is"]
            #[doc = "located. This is so that new windows do not overlap the panel"]
            #[doc = "and maximized windows maximize properly."]
            async fn set_panel_position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                position: u32,
            ) -> crate::server::Result<()>;
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                edges: u32,
                surface: crate::wire::ObjectId,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> weston_desktop_shell#{}.configure()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(edges)
                    .put_object(Some(surface))
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Tell the client we want it to create and set the lock surface, which is"]
            #[doc = "a GUI asking the user to unlock the screen. The lock surface is"]
            #[doc = "announced with 'set_lock_surface'. Whether or not the client actually"]
            #[doc = "implements locking, it MUST send 'unlock' request to let the normal"]
            #[doc = "desktop resume."]
            async fn prepare_lock_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> weston_desktop_shell#{}.prepare_lock_surface()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event will be sent immediately before a fake enter event on the"]
            #[doc = "grab surface."]
            async fn grab_cursor(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                cursor: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> weston_desktop_shell#{}.grab_cursor()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(cursor).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "Only one client can bind this interface at a time."]
    pub mod weston_screensaver {
        #[doc = "Trait to implement the weston_screensaver interface. See the module level documentation for more info"]
        pub trait WestonScreensaver: crate::server::Dispatcher {
            const INTERFACE: &'static str = "weston_screensaver";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("weston_screensaver#{}.set_surface()", object.id);
                        self.set_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "A screensaver surface is normally hidden, and only visible after an"]
            #[doc = "idle timeout."]
            async fn set_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod weston_direct_display {
    #[doc = "Weston extension to instruct the compositor to avoid any import"]
    #[doc = "of the dmabuf created by 'linux-dmabuf' protocol other than the display"]
    #[doc = "controller."]
    #[doc = ""]
    #[doc = "Compositors are already going to use direct scan-out as much as possible but"]
    #[doc = "there's no assurance that while doing so, they won't first import the dmabuf"]
    #[doc = "in to the GPU. This extension assures the client that the compositor will"]
    #[doc = "never attempt to import in to the GPU and pass it directly to the display"]
    #[doc = "controller."]
    #[doc = ""]
    #[doc = "Clients can make use of this extension to pass the dmabuf buffer to the"]
    #[doc = "display controller, potentially increasing the performance and lowering the"]
    #[doc = "bandwidth usage."]
    #[doc = ""]
    #[doc = "Lastly, clients can make use of this extension in tandem with content-protection"]
    #[doc = "one thus avoiding any GPU interaction and providing a secure-content path."]
    #[doc = "Also, in some cases, the memory where dmabuf are allocated are in specially"]
    #[doc = "crafted memory zone which would be seen as an illegal memory access when the"]
    #[doc = "GPU will attempt to read it."]
    #[doc = ""]
    #[doc = "WARNING: This interface by design might break screenshoting functionality"]
    #[doc = "as compositing might be involved while doing that. Also, do note, that in"]
    #[doc = "case the dmabufer provided can't be imported by KMS, the client connection"]
    #[doc = "will be terminated."]
    #[doc = ""]
    #[doc = "WARNING: This extension requires 'linux-dmabuf' protocol and"]
    #[doc = "'zwp_linux_buffer_params_v1' be already created by 'zwp_linux_buffer_v1'."]
    pub mod weston_direct_display_v1 {
        #[doc = "Trait to implement the weston_direct_display_v1 interface. See the module level documentation for more info"]
        pub trait WestonDirectDisplayV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "weston_direct_display_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("weston_direct_display_v1#{}.enable()", object.id);
                        self.enable(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("weston_direct_display_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request tells the compositor not to import the dmabuf to the GPU"]
            #[doc = "in order to bypass it entirely, such that the buffer will be directly"]
            #[doc = "scanned-out by the display controller. If HW is not capable/or there"]
            #[doc = "aren't any available resources to directly scan-out the buffer, a"]
            #[doc = "placeholder should be installed in-place by the compositor. The"]
            #[doc = "compositor may perform checks on the dmabuf and refuse to create a"]
            #[doc = "wl_buffer if the dmabuf seems unusable for being used directly."]
            #[doc = ""]
            #[doc = "Assumes that 'zwp_linux_buffer_params_v1' was already created"]
            #[doc = "by 'zwp_linux_dmabuf_v1_create_params'."]
            async fn enable(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                dmabuf: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys the factory object, but does not affect any other objects."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod weston_output_capture {
    #[doc = "The global interface exposing Weston screenshooting functionality"]
    #[doc = "intended for single shots."]
    #[doc = ""]
    #[doc = "This is a privileged inteface."]
    pub mod weston_capture_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "invalid source enum value"]
            InvalidSource = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidSource),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Source {
            #[doc = "use hardware writeback"]
            Writeback = 0u32,
            #[doc = "copy from framebuffer, desktop area"]
            Framebuffer = 1u32,
            #[doc = "copy whole framebuffer, including borders"]
            FullFramebuffer = 2u32,
            #[doc = "copy from blending space"]
            Blending = 3u32,
        }
        impl TryFrom<u32> for Source {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Writeback),
                    1u32 => Ok(Self::Framebuffer),
                    2u32 => Ok(Self::FullFramebuffer),
                    3u32 => Ok(Self::Blending),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the weston_capture_v1 interface. See the module level documentation for more info"]
        pub trait WestonCaptureV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "weston_capture_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("weston_capture_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("weston_capture_v1#{}.create()", object.id);
                        self.create(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?.try_into()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Affects no other protocol objects in any way."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This creates a weston_capture_source_v1 object corresponding to the"]
            #[doc = "given wl_output. The object delivers information for allocating"]
            #[doc = "suitable buffers, and exposes the capture function."]
            #[doc = ""]
            #[doc = "The object will be using the given pixel source for capturing images."]
            #[doc = "If the source is not available, all attempts to capture will fail"]
            #[doc = "gracefully."]
            #[doc = ""]
            #[doc = "'writeback' source will use hardware writeback feature of DRM KMS for"]
            #[doc = "capturing. This may allow hardware planes to remain used"]
            #[doc = "during the capture. This source is often not available."]
            #[doc = ""]
            #[doc = "'framebuffer' source copies the contents of the final framebuffer."]
            #[doc = "Using this source temporarily disables all use of hardware planes and"]
            #[doc = "DRM KMS color pipeline features. This source is always available."]
            #[doc = ""]
            #[doc = "'full_framebuffer' is otherwise the same as 'framebuffer' except it"]
            #[doc = "will include also any borders (decorations) that the framebuffer may"]
            #[doc = "contain."]
            #[doc = ""]
            #[doc = "'blending' source copies the contents of the intermediate blending"]
            #[doc = "buffer, which should be in linear-light format.  Using this source"]
            #[doc = "temporarily disables all use of hardware planes. This source is only"]
            #[doc = "available when a blending buffer exists, e.g. when color management"]
            #[doc = "is active on the output."]
            #[doc = ""]
            #[doc = "If the pixel source is not one of the defined enumeration values,"]
            #[doc = "'invalid_source' protocol error is raised."]
            async fn create(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: crate::wire::ObjectId,
                source: Source,
                capture_source_new_id: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "An object representing image capturing functionality for a single"]
    #[doc = "source. When created, it sends the initial events if and only if the"]
    #[doc = "output still exists and the specified pixel source is available on"]
    #[doc = "the output."]
    pub mod weston_capture_source_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "the wl_buffer is not writable"]
            BadBuffer = 0u32,
            #[doc = "capture requested again before previous retired"]
            Sequence = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::BadBuffer),
                    1u32 => Ok(Self::Sequence),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the weston_capture_source_v1 interface. See the module level documentation for more info"]
        pub trait WestonCaptureSourceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "weston_capture_source_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("weston_capture_source_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("weston_capture_source_v1#{}.capture()", object.id);
                        self.capture(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "If a capture is on-going on this object, this will cancel it and"]
            #[doc = "make the image buffer contents undefined."]
            #[doc = ""]
            #[doc = "This object is destroyed."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "If the given wl_buffer is compatible, the associated output will go"]
            #[doc = "through a repaint some time after this request has been processed,"]
            #[doc = "and that repaint will execute the capture."]
            #[doc = "Once the capture is complete, 'complete' event is emitted."]
            #[doc = ""]
            #[doc = "If the given wl_buffer is incompatible, the event 'retry' is"]
            #[doc = "emitted."]
            #[doc = ""]
            #[doc = "If the capture fails or the buffer type is unsupported, the event"]
            #[doc = "'failed' is emitted."]
            #[doc = ""]
            #[doc = "The client must wait for one of these events before attempting"]
            #[doc = "'capture' on this object again. If 'capture' is requested again before"]
            #[doc = "any of those events, 'sequence' protocol error is raised."]
            #[doc = ""]
            #[doc = "The wl_buffer object will not emit wl_buffer.release event due to"]
            #[doc = "this request."]
            #[doc = ""]
            #[doc = "The wl_buffer must refer to compositor-writable storage. If buffer"]
            #[doc = "storage is not writable, either the protocol error bad_buffer or"]
            #[doc = "wl_shm.error.invalid_fd is raised."]
            #[doc = ""]
            #[doc = "If the wl_buffer is destroyed before any event is emitted, the buffer"]
            #[doc = "contents become undefined."]
            #[doc = ""]
            #[doc = "A compositor is required to implement capture into wl_shm buffers."]
            #[doc = "Other buffer types may or may not be supported."]
            async fn capture(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This event delivers the pixel format that should be used for the"]
            #[doc = "image buffer. Any buffer is incompatible if it does not have"]
            #[doc = "this pixel format."]
            #[doc = ""]
            #[doc = "The format modifier is linear (DRM_FORMAT_MOD_LINEAR)."]
            #[doc = ""]
            #[doc = "This is an initial event, and sent whenever the required format"]
            #[doc = "changes."]
            async fn format(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                drm_format: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> weston_capture_source_v1#{}.format()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(drm_format)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event delivers the size that should be used for the"]
            #[doc = "image buffer. Any buffer is incompatible if it does not have"]
            #[doc = "this size."]
            #[doc = ""]
            #[doc = "Row alignment of the buffer must be 4 bytes, and it must not contain"]
            #[doc = "further row padding. Otherwise the buffer is unsupported."]
            #[doc = ""]
            #[doc = "This is an initial event, and sent whenever the required size"]
            #[doc = "changes."]
            async fn size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> weston_capture_source_v1#{}.size()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is emitted as a response to 'capture' request when it"]
            #[doc = "has successfully completed."]
            #[doc = ""]
            #[doc = "If the buffer used in the shot is a dmabuf, the client also needs to"]
            #[doc = "wait for any implicit fences on it before accessing the contents."]
            async fn complete(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> weston_capture_source_v1#{}.complete()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is emitted as a response to 'capture' request when it"]
            #[doc = "cannot succeed due to an incompatible buffer. The client has already"]
            #[doc = "received the events delivering the new buffer parameters. The client"]
            #[doc = "should retry the capture with the new buffer parameters."]
            async fn retry(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> weston_capture_source_v1#{}.retry()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is emitted as a response to 'capture' request when it"]
            #[doc = "has failed for reasons other than an incompatible buffer. The reasons"]
            #[doc = "may include: unsupported buffer type, unsupported buffer stride,"]
            #[doc = "unsupported image source, the image source (output) was removed, or"]
            #[doc = "compositor policy denied the capture."]
            #[doc = ""]
            #[doc = "The string 'msg' may contain a human-readable explanation of the"]
            #[doc = "failure to aid debugging."]
            async fn failed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                msg: Option<String>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> weston_capture_source_v1#{}.failed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_string(msg).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod weston_test {
    #[doc = "Internal testing facilities for the weston compositor."]
    #[doc = ""]
    #[doc = "It can't be stressed enough that these should never ever be used"]
    #[doc = "outside of running weston's tests.  The weston-test.so module should"]
    #[doc = "never be installed."]
    #[doc = ""]
    #[doc = "These requests may allow clients to do very bad things."]
    pub mod weston_test {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "invalid coordinate"]
            TouchUpWithCoordinate = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::TouchUpWithCoordinate),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Breakpoint {
            #[doc = "after output repaint (filter type: wl_output)"]
            PostRepaint = 0u32,
        }
        impl TryFrom<u32> for Breakpoint {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::PostRepaint),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the weston_test interface. See the module level documentation for more info"]
        pub trait WestonTest: crate::server::Dispatcher {
            const INTERFACE: &'static str = "weston_test";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("weston_test#{}.move_surface()", object.id);
                        self.move_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("weston_test#{}.move_pointer()", object.id);
                        self.move_pointer(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("weston_test#{}.send_button()", object.id);
                        self.send_button(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.int()?,
                            message.uint()?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("weston_test#{}.send_axis()", object.id);
                        self.send_axis(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.fixed()?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!("weston_test#{}.activate_surface()", object.id);
                        self.activate_surface(object, client, message.object()?)
                            .await
                    }
                    5u16 => {
                        tracing::debug!("weston_test#{}.send_key()", object.id);
                        self.send_key(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    6u16 => {
                        tracing::debug!("weston_test#{}.device_release()", object.id);
                        self.device_release(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    7u16 => {
                        tracing::debug!("weston_test#{}.device_add()", object.id);
                        self.device_add(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    8u16 => {
                        tracing::debug!("weston_test#{}.send_touch()", object.id);
                        self.send_touch(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.int()?,
                            message.fixed()?,
                            message.fixed()?,
                            message.uint()?,
                        )
                        .await
                    }
                    9u16 => {
                        tracing::debug!("weston_test#{}.client_break()", object.id);
                        self.client_break(
                            object,
                            client,
                            message.uint()?.try_into()?,
                            message.uint()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn move_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
            async fn move_pointer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tv_sec_hi: u32,
                tv_sec_lo: u32,
                tv_nsec: u32,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()>;
            async fn send_button(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tv_sec_hi: u32,
                tv_sec_lo: u32,
                tv_nsec: u32,
                button: i32,
                state: u32,
            ) -> crate::server::Result<()>;
            async fn send_axis(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tv_sec_hi: u32,
                tv_sec_lo: u32,
                tv_nsec: u32,
                axis: u32,
                value: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            async fn activate_surface(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            async fn send_key(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tv_sec_hi: u32,
                tv_sec_lo: u32,
                tv_nsec: u32,
                key: u32,
                state: u32,
            ) -> crate::server::Result<()>;
            async fn device_release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                device: String,
            ) -> crate::server::Result<()>;
            async fn device_add(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                device: String,
            ) -> crate::server::Result<()>;
            async fn send_touch(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tv_sec_hi: u32,
                tv_sec_lo: u32,
                tv_nsec: u32,
                touch_id: i32,
                x: crate::wire::Fixed,
                y: crate::wire::Fixed,
                touch_type: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Request that the compositor pauses execution at a certain point. When"]
            #[doc = "execution is paused, the compositor will signal the shared semaphore"]
            #[doc = "to the client."]
            async fn client_break(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                breakpoint: Breakpoint,
                resource_id: u32,
            ) -> crate::server::Result<()>;
            async fn pointer_position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: crate::wire::Fixed,
                y: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> weston_test#{}.pointer_position()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fixed(x)
                    .put_fixed(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "This is a global singleton interface for Weston internal tests."]
    #[doc = ""]
    #[doc = "This interface allows a test client to trigger compositor-side"]
    #[doc = "test procedures. This is useful for cases, where the actual tests"]
    #[doc = "are in compositor plugins, but they also require the presence of"]
    #[doc = "a particular client."]
    #[doc = ""]
    #[doc = "This interface is implemented by the compositor plugins containing"]
    #[doc = "the testing code."]
    #[doc = ""]
    #[doc = "A test client starts a test with the \"run\" request. It must not send"]
    #[doc = "another \"run\" request until receiving the \"finished\" event. If the"]
    #[doc = "compositor-side test succeeds, the \"finished\" event is sent. If the"]
    #[doc = "compositor-side test fails, the compositor should send the protocol"]
    #[doc = "error \"test_failed\", but it may also exit with an error (e.g. SEGV)."]
    #[doc = ""]
    #[doc = "Unknown test name will raise \"unknown_test\" protocol error."]
    pub mod weston_test_runner {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "compositor test failed"]
            TestFailed = 0u32,
            #[doc = "unrecognized test name"]
            UnknownTest = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::TestFailed),
                    1u32 => Ok(Self::UnknownTest),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the weston_test_runner interface. See the module level documentation for more info"]
        pub trait WestonTestRunner: crate::server::Dispatcher {
            const INTERFACE: &'static str = "weston_test_runner";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("weston_test_runner#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("weston_test_runner#{}.run()", object.id);
                        self.run(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            async fn run(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                test_name: String,
            ) -> crate::server::Result<()>;
            async fn finished(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> weston_test_runner#{}.finished()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod weston_touch_calibration {
    #[doc = "This is the global interface for calibrating a touchscreen input"]
    #[doc = "coordinate transformation. It is recommended to make this interface"]
    #[doc = "privileged."]
    #[doc = ""]
    #[doc = "This interface can be used by a client to show a calibration pattern and"]
    #[doc = "receive uncalibrated touch coordinates, facilitating the computation of"]
    #[doc = "a calibration transformation that will align actual touch positions"]
    #[doc = "on screen with their expected coordinates."]
    #[doc = ""]
    #[doc = "Immediately after being bound by a client, the compositor sends the"]
    #[doc = "touch_device events."]
    #[doc = ""]
    #[doc = "The client chooses a touch device from the touch_device events, creates a"]
    #[doc = "wl_surface and then a weston_touch_calibrator for the wl_surface and the"]
    #[doc = "chosen touch device. The client waits for the compositor to send a"]
    #[doc = "configure event before it starts drawing the first calibration pattern."]
    #[doc = "After receiving the configure event, the client will iterate drawing a"]
    #[doc = "pattern, getting touch input via weston_touch_calibrator, and converting"]
    #[doc = "pixel coordinates to expected touch coordinates with"]
    #[doc = "weston_touch_calibrator.convert until it has enough correspondences to"]
    #[doc = "compute the calibration transformation or the compositor cancels the"]
    #[doc = "calibration."]
    #[doc = ""]
    #[doc = "Once the client has successfully computed a new calibration, it can use"]
    #[doc = "weston_touch_calibration.save request to load the new calibration into"]
    #[doc = "the compositor. The compositor may take this new calibration into use and"]
    #[doc = "may write it into persistent storage."]
    pub mod weston_touch_calibration {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "the given wl_surface already has a role"]
            InvalidSurface = 0u32,
            #[doc = "the given device is not valid"]
            InvalidDevice = 1u32,
            #[doc = "a calibrator has already been created"]
            AlreadyExists = 2u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidSurface),
                    1u32 => Ok(Self::InvalidDevice),
                    2u32 => Ok(Self::AlreadyExists),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the weston_touch_calibration interface. See the module level documentation for more info"]
        pub trait WestonTouchCalibration: crate::server::Dispatcher {
            const INTERFACE: &'static str = "weston_touch_calibration";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("weston_touch_calibration#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "weston_touch_calibration#{}.create_calibrator()",
                            object.id
                        );
                        self.create_calibrator(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("weston_touch_calibration#{}.save()", object.id);
                        self.save(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.array()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroy the binding to the global interface, does not affect any"]
            #[doc = "objects already created through this interface."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This gives the calibrator role to the surface and ties it with the"]
            #[doc = "given touch input device."]
            #[doc = ""]
            #[doc = "If the surface already has a role, then invalid_surface error is raised."]
            #[doc = ""]
            #[doc = "If the device string is not one advertised with touch_device event's"]
            #[doc = "device argument, then invalid_device error is raised."]
            #[doc = ""]
            #[doc = "If a weston_touch_calibrator protocol object exists in the compositor"]
            #[doc = "already, then already_exists error is raised. This limitation is"]
            #[doc = "compositor-wide and not specific to any particular client."]
            async fn create_calibrator(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
                device: String,
                cal: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This request asks the compositor to save the calibration data for the"]
            #[doc = "given touch input device. The compositor may ignore this request."]
            #[doc = ""]
            #[doc = "If the device string is not one advertised with touch_device event's"]
            #[doc = "device argument, then invalid_device error is raised."]
            #[doc = ""]
            #[doc = "The array must contain exactly six 'float' (the 32-bit floating"]
            #[doc = "point format used by the C language on the system) numbers. For a 3x3"]
            #[doc = "calibration matrix in the form"]
            #[doc = "@code"]
            #[doc = "( a b c )"]
            #[doc = "( d e f )"]
            #[doc = "( 0 0 1 )"]
            #[doc = "@endcode"]
            #[doc = "the array must contain the values { a, b, c, d, e, f }. For the"]
            #[doc = "definition of the coordinate spaces, see"]
            #[doc = "libinput_device_config_calibration_set_matrix()."]
            async fn save(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                device: String,
                matrix: Vec<u8>,
            ) -> crate::server::Result<()>;
            #[doc = "When a client binds to weston_touch_calibration, one touch_device event"]
            #[doc = "is sent for each touchscreen that is available to be calibrated. This"]
            #[doc = "is the only time the event is sent. Touch devices added in the"]
            #[doc = "compositor will not generate events for existing"]
            #[doc = "weston_touch_calibration objects."]
            #[doc = ""]
            #[doc = "An event carries the touch device identification and the associated"]
            #[doc = "output or head (display connector) name."]
            #[doc = ""]
            #[doc = "On platforms using udev, the device identification is the udev sys"]
            #[doc = "path. It is an absolute path and starts with the sys mount point."]
            async fn touch_device(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                device: String,
                head: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> weston_touch_calibration#{}.touch_device()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(device))
                    .put_string(Some(head))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "On creation, this object is tied to a specific touch device. The"]
    #[doc = "compositor sends a configure event which the client must obey with the"]
    #[doc = "associated wl_surface."]
    #[doc = ""]
    #[doc = "Once the client has committed content to the surface, the compositor can"]
    #[doc = "grab the touch input device, prevent it from emitting normal touch"]
    #[doc = "events, show the surface on the correct output, and relay input events"]
    #[doc = "from the touch device via this protocol object."]
    #[doc = ""]
    #[doc = "Touch events from other touch devices than the one tied to this object"]
    #[doc = "must generate wrong_touch events on at least touch-down and must not"]
    #[doc = "generate normal or calibration touch events."]
    #[doc = ""]
    #[doc = "At any time, the compositor can choose to cancel the calibration"]
    #[doc = "procedure by sending the cancel_calibration event. This should also be"]
    #[doc = "used if the touch device disappears or anything else prevents the"]
    #[doc = "calibration from continuing on the compositor side."]
    #[doc = ""]
    #[doc = "If the wl_surface is destroyed, the compositor must cancel the"]
    #[doc = "calibration."]
    #[doc = ""]
    #[doc = "The touch event coordinates and conversion results are delivered in"]
    #[doc = "calibration units. The calibration units cover the device coordinate"]
    #[doc = "range exactly. Calibration units are in the closed interval [0.0, 1.0]"]
    #[doc = "mapped into 32-bit unsigned integers. An integer can be converted into a"]
    #[doc = "real value by dividing by 2^32-1. A calibration matrix must be computed"]
    #[doc = "from the [0.0, 1.0] real values, but the matrix elements do not need to"]
    #[doc = "fall into that range."]
    pub mod weston_touch_calibrator {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "surface size does not match"]
            BadSize = 0u32,
            #[doc = "requested operation is not possible without mapping the surface"]
            NotMapped = 1u32,
            #[doc = "surface-local coordinates are out of bounds"]
            BadCoordinates = 2u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::BadSize),
                    1u32 => Ok(Self::NotMapped),
                    2u32 => Ok(Self::BadCoordinates),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the weston_touch_calibrator interface. See the module level documentation for more info"]
        pub trait WestonTouchCalibrator: crate::server::Dispatcher {
            const INTERFACE: &'static str = "weston_touch_calibrator";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("weston_touch_calibrator#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("weston_touch_calibrator#{}.convert()", object.id);
                        self.convert(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This unmaps the surface if it was mapped. The input device grab"]
            #[doc = "is dropped, if it was present. The surface loses its role as a"]
            #[doc = "calibrator."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This request asks the compositor to convert the surface-local"]
            #[doc = "coordinates into the expected touch input coordinates appropriate for"]
            #[doc = "the associated touch device. The intention is that a client uses this"]
            #[doc = "request to convert marker positions that the user is supposed to touch"]
            #[doc = "during calibration."]
            #[doc = ""]
            #[doc = "If the compositor has cancelled the calibration, the conversion result"]
            #[doc = "shall be zeroes and no errors will be raised."]
            #[doc = ""]
            #[doc = "The coordinates given as arguments to this request are relative to"]
            #[doc = "the associated wl_surface."]
            #[doc = ""]
            #[doc = "If a client asks for conversion before it has committed valid"]
            #[doc = "content to the wl_surface, the not_mapped error is raised."]
            #[doc = ""]
            #[doc = "If the coordinates x, y are outside of the wl_surface content, the"]
            #[doc = "bad_coordinates error is raised."]
            async fn convert(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                reply: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This event tells the client what size to make the surface. The client"]
            #[doc = "must obey the size exactly on the next commit with a wl_buffer."]
            #[doc = ""]
            #[doc = "This event shall be sent once as a response to creating a"]
            #[doc = "weston_touch_calibrator object."]
            async fn configure(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> weston_touch_calibrator#{}.configure()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This is sent when the compositor wants to cancel the calibration and"]
            #[doc = "drop the touch device grab. The compositor unmaps the surface, if it"]
            #[doc = "was mapped."]
            #[doc = ""]
            #[doc = "The weston_touch_calibrator object will not send any more events. The"]
            #[doc = "client should destroy it."]
            async fn cancel_calibration(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> weston_touch_calibrator#{}.cancel_calibration()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "For whatever reason, a touch event resulting from a user action cannot"]
            #[doc = "be used for calibration. The client should show feedback to the user"]
            #[doc = "that the touch was rejected."]
            #[doc = ""]
            #[doc = "Possible causes for this event include the user touching a wrong"]
            #[doc = "touchscreen when there are multiple ones present. This is particularly"]
            #[doc = "useful when the touchscreens are cloned and there is no other way to"]
            #[doc = "identify which screen the user should be touching."]
            #[doc = ""]
            #[doc = "Another cause could be a touch device that sends coordinates beyond its"]
            #[doc = "declared range. If motion takes a touch point outside the range, the"]
            #[doc = "compositor should also send 'cancel' event to undo the touch-down."]
            async fn invalid_touch(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> weston_touch_calibrator#{}.invalid_touch()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "A new touch point has appeared on the surface. This touch point is"]
            #[doc = "assigned a unique ID. Future events from this touch point reference"]
            #[doc = "this ID. The ID ceases to be valid after a touch up event and may be"]
            #[doc = "reused in the future."]
            #[doc = ""]
            #[doc = "For the coordinate units, see weston_touch_calibrator."]
            async fn down(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                id: i32,
                x: u32,
                y: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> weston_touch_calibrator#{}.down()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_int(id)
                    .put_uint(x)
                    .put_uint(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The touch point has disappeared. No further events will be sent for"]
            #[doc = "this touch point and the touch point's ID is released and may be"]
            #[doc = "reused in a future touch down event."]
            async fn up(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                id: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> weston_touch_calibrator#{}.up()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_int(id)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "A touch point has changed coordinates."]
            #[doc = ""]
            #[doc = "For the coordinate units, see weston_touch_calibrator."]
            async fn motion(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                id: i32,
                x: u32,
                y: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> weston_touch_calibrator#{}.motion()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_int(id)
                    .put_uint(x)
                    .put_uint(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Indicates the end of a set of events that logically belong together."]
            #[doc = "A client is expected to accumulate the data in all events within the"]
            #[doc = "frame before proceeding."]
            #[doc = ""]
            #[doc = "A wl_touch.frame terminates at least one event but otherwise no"]
            #[doc = "guarantee is provided about the set of events within a frame. A client"]
            #[doc = "must assume that any state not updated in a frame is unchanged from the"]
            #[doc = "previously known state."]
            async fn frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> weston_touch_calibrator#{}.frame()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 6u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent if the compositor decides the touch stream is a global"]
            #[doc = "gesture. No further events are sent to the clients from that"]
            #[doc = "particular gesture. Touch cancellation applies to all touch points"]
            #[doc = "currently active on this client's surface. The client is"]
            #[doc = "responsible for finalizing the touch points, future touch points on"]
            #[doc = "this surface may reuse the touch point ID."]
            async fn cancel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> weston_touch_calibrator#{}.cancel()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 7u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod weston_touch_coordinate {
        #[doc = "Trait to implement the weston_touch_coordinate interface. See the module level documentation for more info"]
        pub trait WestonTouchCoordinate: crate::server::Dispatcher {
            const INTERFACE: &'static str = "weston_touch_coordinate";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This event returns the conversion result from surface coordinates to"]
            #[doc = "the expected touch device coordinates."]
            #[doc = ""]
            #[doc = "For details, see weston_touch_calibrator.convert. For the coordinate"]
            #[doc = "units, see weston_touch_calibrator."]
            #[doc = ""]
            #[doc = "This event destroys the weston_touch_coordinate object."]
            async fn result(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: u32,
                y: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> weston_touch_coordinate#{}.result()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(x)
                    .put_uint(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "This protocol serves as an intermediary between screen capturing protocols"]
#[doc = "and potential image sources such as outputs and toplevels."]
#[doc = ""]
#[doc = "This protocol may be extended to support more image sources in the future,"]
#[doc = "thereby adding those image sources to other protocols that use the image"]
#[doc = "source object without having to modify those protocols."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is currently in the testing"]
#[doc = "phase. Backward compatible changes may be added together with the"]
#[doc = "corresponding interface version bump. Backward incompatible changes can"]
#[doc = "only be done by creating a new major version of the extension."]
pub mod cosmic_image_source_unstable_v1 {
    #[doc = "The image source object is an opaque descriptor for a capturable resource."]
    #[doc = "This resource may be any sort of entity from which an image may be"]
    #[doc = "derived."]
    #[doc = ""]
    #[doc = "Note, because zcosmic_image_source_v1 objects are created from multiple"]
    #[doc = "independent factory interfaces, the zcosmic_image_source_v1 interface is"]
    #[doc = "frozen at version 1."]
    pub mod zcosmic_image_source_v1 {
        #[doc = "Trait to implement the zcosmic_image_source_v1 interface. See the module level documentation for more info"]
        pub trait ZcosmicImageSourceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zcosmic_image_source_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zcosmic_image_source_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroys the image source. This request may be sent at any time by the"]
            #[doc = "client."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "A manager for creating image source objects for wl_output objects."]
    pub mod zcosmic_output_image_source_manager_v1 {
        #[doc = "Trait to implement the zcosmic_output_image_source_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZcosmicOutputImageSourceManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zcosmic_output_image_source_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zcosmic_output_image_source_manager_v1#{}.create_source()",
                            object.id
                        );
                        self.create_source(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zcosmic_output_image_source_manager_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Creates a source object for an output. Images captured from this source"]
            #[doc = "will show the same content as the output. Some elements may be omitted,"]
            #[doc = "such as cursors and overlays that have been marked as transparent to"]
            #[doc = "capturing."]
            async fn create_source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: crate::wire::ObjectId,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys the manager. This request may be sent at any time by the client"]
            #[doc = "and objects created by the manager will remain valid after its"]
            #[doc = "destruction."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "A manager for creating image source objects for wl_output objects."]
    pub mod zcosmic_workspace_image_source_manager_v1 {
        #[doc = "Trait to implement the zcosmic_workspace_image_source_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZcosmicWorkspaceImageSourceManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zcosmic_workspace_image_source_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zcosmic_workspace_image_source_manager_v1#{}.create_source()",
                            object.id
                        );
                        self.create_source(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zcosmic_workspace_image_source_manager_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Creates a source object for a workspaces. Images captured from this source"]
            #[doc = "will show the same content as the workspace. Some elements may be omitted,"]
            #[doc = "such as cursors and overlays that have been marked as transparent to"]
            #[doc = "capturing."]
            async fn create_source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: crate::wire::ObjectId,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys the manager. This request may be sent at any time by the client"]
            #[doc = "and objects created by the manager will remain valid after its"]
            #[doc = "destruction."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "A manager for creating image source objects for"]
    #[doc = "zcosmic_toplevel_handle_v1 objects."]
    pub mod zcosmic_toplevel_image_source_manager_v1 {
        #[doc = "Trait to implement the zcosmic_toplevel_image_source_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZcosmicToplevelImageSourceManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zcosmic_toplevel_image_source_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zcosmic_toplevel_image_source_manager_v1#{}.create_source()",
                            object.id
                        );
                        self.create_source(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zcosmic_toplevel_image_source_manager_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Creates a source object for a toplevel handle. Images captured"]
            #[doc = "from this source will show the same content as the toplevel."]
            async fn create_source(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: crate::wire::ObjectId,
                toplevel_handle: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys the manager. This request may be sent at any time by the client"]
            #[doc = "and objects created by the manager will remain valid after its"]
            #[doc = "destruction."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
#[doc = "This protocol serves as an extension to wlr-output-management."]
#[doc = ""]
#[doc = "It primarily adds explicit output mirroring,"]
#[doc = "while upstream is figuring out how to best support that."]
#[doc = ""]
#[doc = "It was designed against version 4 of wlr-output-management, but tries"]
#[doc = "it's best to be forward compatible."]
pub mod cosmic_output_management_unstable_v1 {
    #[doc = "This interface provides extension points for wlr-output-management types."]
    pub mod zcosmic_output_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "object already created"]
            AlreadyExtended = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::AlreadyExtended),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zcosmic_output_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZcosmicOutputManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zcosmic_output_manager_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zcosmic_output_manager_v1#{}.get_head()", object.id);
                        self.get_head(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zcosmic_output_manager_v1#{}.get_configuration()",
                            object.id
                        );
                        self.get_configuration(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "zcosmic_output_manager_v1#{}.get_configuration_head()",
                            object.id
                        );
                        self.get_configuration_head(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("zcosmic_output_manager_v1#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Gets an extension object for zwlr_output_head_v1."]
            #[doc = ""]
            #[doc = "As soon as the extended output is created, events will be dispatched with an accompanying"]
            #[doc = "`done`-event delivered to the matching `zwlr_output_manager_v1` afterwards."]
            #[doc = ""]
            #[doc = "Any further updates will produce new events, if properties of the zcosmic_output_head_v1 change,"]
            #[doc = "just like for the original `zwlr_output_head_v1`. Events should be handled as atomic, as denoted"]
            #[doc = "by `zwlr_output_manager_v1::done`."]
            #[doc = ""]
            #[doc = "Trying to create more than one zcosmic_output_head_v1 per zwlr_output_head_v1 will raise an"]
            #[doc = "\"already_extended\" error."]
            async fn get_head(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                extended: crate::wire::ObjectId,
                head: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Gets an extension object for zwlr_output_configuration_v1."]
            #[doc = ""]
            #[doc = "Trying to create more than one zcosmic_output_configuration_v1 per zwlr_output_configuration_v1"]
            #[doc = "will raise an \"already_extended\" error."]
            async fn get_configuration(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                extended: crate::wire::ObjectId,
                config: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Gets an extension object for zwlr_output_configuration_head_v1."]
            #[doc = ""]
            #[doc = "Trying to create more than one zcosmic_output_configuration_head_v1 per"]
            #[doc = "zwlr_output_configuration_head_v1 will raise an \"already_extended\" error."]
            async fn get_configuration_head(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                extended: crate::wire::ObjectId,
                config_head: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys this global. All previously created objects remain valid."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "Extension to zwlr_output_head_v1."]
    #[doc = ""]
    #[doc = "Adds additional read-only properties."]
    #[doc = ""]
    #[doc = "Properties sent via this interface are applied atomically via the wlr_output_manager.done event."]
    #[doc = "No guarantees are made regarding the order in which properties are sent."]
    pub mod zcosmic_output_head_v1 {
        #[doc = "Trait to implement the zcosmic_output_head_v1 interface. See the module level documentation for more info"]
        pub trait ZcosmicOutputHeadV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zcosmic_output_head_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zcosmic_output_head_v1#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Using this request a client can tell the compositor that it is not interested"]
            #[doc = "in the head object anymore."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This events describes the scale of the head in the global compositor"]
            #[doc = "space multiplied by 1000 for additional precision."]
            #[doc = ""]
            #[doc = "It is only sent if the output is enabled."]
            async fn scale_1000(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                scale_1000: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_output_head_v1#{}.scale_1000()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(scale_1000)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This events describes that the head is mirroring another."]
            #[doc = "In these cases `name` contains the unique name of the matching `zwlr_output_head_v1`."]
            #[doc = "If the name is null, no head is being mirrored onto this one."]
            #[doc = ""]
            #[doc = "For mirrored heads the `position`-event is meaningless."]
            #[doc = ""]
            #[doc = "It is only sent if the output is enabled."]
            async fn mirroring(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: Option<String>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_output_head_v1#{}.mirroring()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_string(name).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "Extension to zwlr_output_configuration_v1."]
    #[doc = ""]
    #[doc = "Adds additional parameters to be tested/applyed via the original zwlr_output_configuration_v1."]
    pub mod zcosmic_output_configuration_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "underlying configuration has already been used"]
            AlreadyFinished = 1u32,
            #[doc = "mirrored head is not enabled"]
            MirroredHeadBusy = 2u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::AlreadyFinished),
                    2u32 => Ok(Self::MirroredHeadBusy),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zcosmic_output_configuration_v1 interface. See the module level documentation for more info"]
        pub trait ZcosmicOutputConfigurationV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zcosmic_output_configuration_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zcosmic_output_configuration_v1#{}.mirror_head()",
                            object.id
                        );
                        self.mirror_head(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zcosmic_output_configuration_v1#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Enable a head mirroring another."]
            #[doc = ""]
            #[doc = "This request creates a head configuration object that can be used to change the head's properties."]
            #[doc = ""]
            #[doc = "This is an alternative to `zwlr_output_configuration_v1::enable_head` or `zwlr_output_configuration_v1::disable_head`"]
            #[doc = "Using either with the same `head` argument will result in an `already_configured_head` error on the original"]
            #[doc = "`zwlr_output_configuration_v1` object."]
            #[doc = ""]
            #[doc = "All properties are still required to be set to the resulting `zwlr_output_configuration_head` by the client"]
            #[doc = "as denoted in the original protocol. Some like `set_position` however might be ignored in mirroring configurations."]
            #[doc = ""]
            #[doc = "Trying to set a disabled or mirroring head as `mirroring` or calling `disable_head`/`mirror_head` after using a head"]
            #[doc = "as a `mirroring` argument will raise a `mirrored_head_busy` protocol error."]
            async fn mirror_head(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
                head: crate::wire::ObjectId,
                mirroring: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Using this request a client can tell the compositor that it is not going"]
            #[doc = "to use the configuration object anymore. Any changes to the outputs"]
            #[doc = "will still be attached to the original `zwlr_output_configuration_head_v1`"]
            #[doc = "if it isn't destroyed."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event indicates that the configuration is no longer available."]
            #[doc = ""]
            #[doc = "This usually happens when the original configuration was `cancelled`, `suceeded` or `failed`."]
            #[doc = ""]
            #[doc = "Upon receiving this event, the client should destroy this object."]
            #[doc = ""]
            #[doc = "The configration object becomes inert and any requests other than `destroy` will be ignored."]
            async fn finished(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_output_configuration_v1#{}.finished()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "Extension to zwlr_output_configuration_head_v1."]
    #[doc = ""]
    #[doc = "Adds additional/alternative parameters to the original zwlr_output_configuration_head_v1."]
    #[doc = ""]
    #[doc = "Once the original `zwlr_output_configuration_head_v1` is destroyed this object will also be destroyed."]
    pub mod zcosmic_output_configuration_head_v1 {
        #[doc = "Trait to implement the zcosmic_output_configuration_head_v1 interface. See the module level documentation for more info"]
        pub trait ZcosmicOutputConfigurationHeadV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zcosmic_output_configuration_head_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zcosmic_output_configuration_head_v1#{}.set_scale_1000()",
                            object.id
                        );
                        self.set_scale_1000(object, client, message.int()?).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zcosmic_output_configuration_head_v1#{}.release()",
                            object.id
                        );
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request sets the head's scale multiplied by 1000 for additional precision."]
            #[doc = ""]
            #[doc = "This request is meant to be used in place of `zwlr_output_configuration_head_v1::set_scale`."]
            #[doc = "Using `set_scale` and `set_scale_1000` at once will thus raise an `already_set` error on the"]
            #[doc = "original `zwlr_output_configuration_head_v1`."]
            #[doc = ""]
            #[doc = "Any request conflicting with `set_scale` will also conflict with `set_scale_1000`."]
            async fn set_scale_1000(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                scale_1000: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Using this request a client can tell the compositor that it is not going"]
            #[doc = "to use the configuration object anymore. Already issued requests will"]
            #[doc = "still be attached to the original `zwlr_output_configuration_head_v1`"]
            #[doc = "until it is destroyed."]
            async fn release(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod cosmic_overlap_notify_unstable_v1 {
    #[doc = "The purpose of this protocol is to enable layer-shell client to get"]
    #[doc = "notifications if part of their surfaces are occluded other elements"]
    #[doc = "(currently toplevels and other layer-surfaces)."]
    #[doc = ""]
    #[doc = "You can request a notification object for any of your zwlr_layer_surface_v1"]
    #[doc = "surfaces, which will then emit overlap events."]
    pub mod zcosmic_overlap_notify_v1 {
        #[doc = "Trait to implement the zcosmic_overlap_notify_v1 interface. See the module level documentation for more info"]
        pub trait ZcosmicOverlapNotifyV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zcosmic_overlap_notify_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zcosmic_overlap_notify_v1#{}.notify_on_overlap()",
                            object.id
                        );
                        self.notify_on_overlap(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Requests notifications for toplevels and layer-surfaces entering and leaving the"]
            #[doc = "surface-area of the given zwlr_layer_surface_v1. This can be used e.g. to"]
            #[doc = "implement auto-hide functionality."]
            #[doc = ""]
            #[doc = "To stop receiving notifications, destroy the returned"]
            #[doc = "zcosmic_overlap_notification_v1 object."]
            async fn notify_on_overlap(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                overlap_notification: crate::wire::ObjectId,
                layer_surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zcosmic_overlap_notification_v1 {
        #[doc = "Trait to implement the zcosmic_overlap_notification_v1 interface. See the module level documentation for more info"]
        pub trait ZcosmicOverlapNotificationV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zcosmic_overlap_notification_v1";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zcosmic_overlap_notification_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request should be called when the client has no interest in overlap"]
            #[doc = "notifications anymore."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "A ext_foreign_toplevel_handle_v1 has entered the surface area."]
            #[doc = ""]
            #[doc = "This event will be emitted once for every ext_foreign_toplevel_handle_v1"]
            #[doc = "representing this toplevel."]
            #[doc = ""]
            #[doc = "Compositors are free to update the overlapping area by sending additional"]
            #[doc = "`toplevel_enter` events for the same toplevel without sending `toplevel_leave`"]
            #[doc = "in between."]
            async fn toplevel_enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                toplevel: crate::wire::ObjectId,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_overlap_notification_v1#{}.toplevel_enter()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(toplevel))
                    .put_int(x)
                    .put_int(y)
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "A ext_foreign_toplevel_handle_v1 has left the surface area."]
            #[doc = ""]
            #[doc = "This event will be emitted once for every ext_foreign_toplevel_handle_v1"]
            #[doc = "representing this toplevel."]
            async fn toplevel_leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                toplevel: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_overlap_notification_v1#{}.toplevel_leave()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(toplevel))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "A zwlr_layer_surface_v1 has entered the surface area."]
            #[doc = ""]
            #[doc = "Compositors are free to update the overlapping area by sending additional"]
            #[doc = "`layer_enter` events for the same surface without sending `layer_leave`"]
            #[doc = "in between."]
            #[doc = ""]
            #[doc = "The overlapping region is given surface-relative to the zwlr_layer_surface_v1"]
            #[doc = "used to create this notification object."]
            async fn layer_enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                identifier: String,
                exclusive: u32,
                layer: super::super::wlr_layer_shell_unstable_v1::zwlr_layer_shell_v1::Layer,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_overlap_notification_v1#{}.layer_enter()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(identifier))
                    .put_uint(exclusive)
                    .put_uint(layer as u32)
                    .put_int(x)
                    .put_int(y)
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "A zwlr_layer_surface_v1 has left the surface area."]
            async fn layer_leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                identifier: String,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_overlap_notification_v1#{}.layer_leave()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(identifier))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = "This protocol allows clients to ask the compositor to capture screen"]
#[doc = "contents to user submitted buffers."]
#[doc = ""]
#[doc = "Warning! The protocol described in this file is currently in the testing"]
#[doc = "phase. Backward compatible changes may be added together with the"]
#[doc = "corresponding interface version bump. Backward incompatible changes can"]
#[doc = "only be done by creating a new major version of the extension."]
pub mod cosmic_screencopy_unstable_v2 {
    #[doc = "This object is a manager which offers requests to start capturing from a"]
    #[doc = "source."]
    pub mod zcosmic_screencopy_manager_v2 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "invalid option flag"]
            InvalidOption = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::InvalidOption),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! { # [derive (Debug , PartialEq , Eq , PartialOrd , Ord , Hash , Clone , Copy)] pub struct Options : u32 { # [doc = "paint cursors onto captured frames"] const PaintCursors = 1u32 ; } }
        impl TryFrom<u32> for Options {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = "Trait to implement the zcosmic_screencopy_manager_v2 interface. See the module level documentation for more info"]
        pub trait ZcosmicScreencopyManagerV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zcosmic_screencopy_manager_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zcosmic_screencopy_manager_v2#{}.create_session()",
                            object.id
                        );
                        self.create_session(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zcosmic_screencopy_manager_v2#{}.create_pointer_cursor_session()",
                            object.id
                        );
                        self.create_pointer_cursor_session(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zcosmic_screencopy_manager_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a capturing session for an image source."]
            #[doc = ""]
            #[doc = "If the paint_cursors option is set, cursors shall be composited onto"]
            #[doc = "the captured frame. The cursor shall not be composited onto the frame"]
            #[doc = "if this flag is not set."]
            async fn create_session(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                session: crate::wire::ObjectId,
                source: crate::wire::ObjectId,
                options: Options,
            ) -> crate::server::Result<()>;
            #[doc = "Create a cursor capturing session for the pointer of an image source."]
            #[doc = ""]
            #[doc = "The options argument has no effect and must be set to 0. This is"]
            #[doc = "intended for any future flags that might be added."]
            async fn create_pointer_cursor_session(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                session: crate::wire::ObjectId,
                source: crate::wire::ObjectId,
                pointer: crate::wire::ObjectId,
                options: u32,
            ) -> crate::server::Result<()>;
            #[doc = "Destroy the manager object."]
            #[doc = ""]
            #[doc = "Other objects created via this interface are unaffected."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    #[doc = "This object represents an active screencopy session."]
    #[doc = ""]
    #[doc = "After a screencopy session is created, buffer constraint events will be"]
    #[doc = "emitted from the compositor to tell the client which buffer types and"]
    #[doc = "formats are supported for reading from the session. The compositor may"]
    #[doc = "re-send buffer constraint events whenever they change."]
    #[doc = ""]
    #[doc = "The advertise buffer constraints, the compositor must send in no"]
    #[doc = "particular order: zero or more shm_format and dmabuf_format events, zero"]
    #[doc = "or one dmabuf_device event, and exactly one buffer_size event. Then the"]
    #[doc = "compositor must send a done event."]
    #[doc = ""]
    #[doc = "When the client has received all the buffer constraints, it can create a"]
    #[doc = "buffer accordingly, attach it to the screencopy session using the"]
    #[doc = "attach_buffer request, set the buffer damage using the damage_buffer"]
    #[doc = "request and then send the capture request."]
    pub mod zcosmic_screencopy_session_v2 {
        #[doc = "Trait to implement the zcosmic_screencopy_session_v2 interface. See the module level documentation for more info"]
        pub trait ZcosmicScreencopySessionV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zcosmic_screencopy_session_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zcosmic_screencopy_session_v2#{}.create_frame()",
                            object.id
                        );
                        self.create_frame(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!("zcosmic_screencopy_session_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Create a capture frame for this session."]
            async fn create_frame(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                frame: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys the session. This request can be sent at any time by the"]
            #[doc = "client."]
            #[doc = ""]
            #[doc = "This request doesn't affect zcosmic_screencopy_frame_v2 objects created by"]
            #[doc = "this object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Provides the dimensions of the source image in buffer pixel coordinates."]
            #[doc = ""]
            #[doc = "The client must attach buffers that match this size."]
            async fn buffer_size(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: u32,
                height: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_screencopy_session_v2#{}.buffer_size()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(width)
                    .put_uint(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Provides the format that must be used for shared-memory buffers."]
            #[doc = ""]
            #[doc = "This event may be emitted multiple times, in which case the client may"]
            #[doc = "choose any given format."]
            async fn shm_format(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                format: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_screencopy_session_v2#{}.shm_format()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(format).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event advertises the device buffers must be allocated on for"]
            #[doc = "dma-buf buffers."]
            #[doc = ""]
            #[doc = "In general the device is a DRM node. The DRM node type (primary vs."]
            #[doc = "render) is unspecified. Clients must not rely on the compositor sending"]
            #[doc = "a particular node type. Clients cannot check two devices for equality"]
            #[doc = "by comparing the dev_t value."]
            async fn dmabuf_device(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                device: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_screencopy_session_v2#{}.dmabuf_device()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_array(device).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Provides the format that must be used for dma-buf buffers."]
            #[doc = ""]
            #[doc = "The client may choose any of the modifiers advertised in the array of"]
            #[doc = "64-bit unsigned integers."]
            #[doc = ""]
            #[doc = "This event may be emitted multiple times, in which case the client may"]
            #[doc = "choose any given format."]
            async fn dmabuf_format(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                format: u32,
                modifiers: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_screencopy_session_v2#{}.dmabuf_format()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(format)
                    .put_array(modifiers)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent once when all buffer constraint events have been"]
            #[doc = "sent."]
            #[doc = ""]
            #[doc = "The compositor must always end a batch of buffer constraint events with"]
            #[doc = "this event, regardless of whether it sends the initial constraints or"]
            #[doc = "an update."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_screencopy_session_v2#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates that the capture session has stopped and is no"]
            #[doc = "longer available. This can happen in a number of cases, e.g. when the"]
            #[doc = "underlying source is destroyed, if the user decides to end the screen"]
            #[doc = "capture, or if an unrecoverable runtime error has occurred."]
            #[doc = ""]
            #[doc = "The client should destroy the session after receiving this event."]
            async fn stopped(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_screencopy_session_v2#{}.stopped()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "This object represents a screen capture frame."]
    #[doc = ""]
    #[doc = "The client should attach a buffer, damage the buffer, and then send a"]
    #[doc = "capture request."]
    #[doc = ""]
    #[doc = "If the screen capture is successful, the compositor will send the frame"]
    #[doc = "metadata (transform, damage, presentation_time in any order) followed by"]
    #[doc = "the ready event."]
    #[doc = ""]
    #[doc = "If the screen capture fails, the compositor will send the failed event."]
    pub mod zcosmic_screencopy_frame_v2 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "capture sent without attach_buffer"]
            NoBuffer = 1u32,
            #[doc = "invalid buffer damage"]
            InvalidBufferDamage = 2u32,
            #[doc = "capture request has been sent"]
            AlreadyCaptured = 3u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::NoBuffer),
                    2u32 => Ok(Self::InvalidBufferDamage),
                    3u32 => Ok(Self::AlreadyCaptured),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum FailureReason {
            Unknown = 0u32,
            BufferConstraints = 1u32,
            Stopped = 2u32,
        }
        impl TryFrom<u32> for FailureReason {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Unknown),
                    1u32 => Ok(Self::BufferConstraints),
                    2u32 => Ok(Self::Stopped),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zcosmic_screencopy_frame_v2 interface. See the module level documentation for more info"]
        pub trait ZcosmicScreencopyFrameV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zcosmic_screencopy_frame_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zcosmic_screencopy_frame_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zcosmic_screencopy_frame_v2#{}.attach_buffer()",
                            object.id
                        );
                        self.attach_buffer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!(
                            "zcosmic_screencopy_frame_v2#{}.damage_buffer()",
                            object.id
                        );
                        self.damage_buffer(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!("zcosmic_screencopy_frame_v2#{}.capture()", object.id);
                        self.capture(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroys the session. This request can be sent at any time by the"]
            #[doc = "client."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Attach a buffer to the session."]
            #[doc = ""]
            #[doc = "The wl_buffer.release request is unused."]
            #[doc = ""]
            #[doc = "This request must not be sent after capture, or else the"]
            #[doc = "already_captured protocol error is raised."]
            async fn attach_buffer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Apply damage to the buffer which is to be captured next. This request"]
            #[doc = "may be sent multiple times to describe a region."]
            #[doc = ""]
            #[doc = "The client indicates the accumulated damage since this wl_buffer was"]
            #[doc = "last captured. During capture, the compositor will update the buffer"]
            #[doc = "with at least the union of the region passed by the client and the"]
            #[doc = "region advertised by zcosmic_screencopy_frame_v2.damage."]
            #[doc = ""]
            #[doc = "When a wl_buffer is captured for the first time, or when the client"]
            #[doc = "doesn't track damage, the client must damage the whole buffer."]
            #[doc = ""]
            #[doc = "This is for optimisation purposes. The compositor may use this"]
            #[doc = "information to reduce copying."]
            #[doc = ""]
            #[doc = "These coordinates originate from the upper left corner of the buffer."]
            #[doc = ""]
            #[doc = "If x or y are strictly negative, or if width or height are negative or"]
            #[doc = "zero, the invalid_buffer_damage protocol error is raised."]
            #[doc = ""]
            #[doc = "This request must not be sent after capture, or else the"]
            #[doc = "already_captured protocol error is raised."]
            async fn damage_buffer(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Capture a frame."]
            #[doc = ""]
            #[doc = "Unless this is the first successful captured frame performed in this"]
            #[doc = "session, the compositor may wait an indefinite amount of time for the"]
            #[doc = "source content to change before performing the copy."]
            #[doc = ""]
            #[doc = "This request may only be sent once, or else the already_captured"]
            #[doc = "protocol error is raised. A buffer must be attached before this request"]
            #[doc = "is sent, or else the no_buffer protocol error is raised."]
            async fn capture(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is sent before the ready event and holds the transform of"]
            #[doc = "the source buffer."]
            async fn transform(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                transform: super::super::wayland::wl_output::Transform,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_screencopy_frame_v2#{}.transform()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(transform as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent before the ready event. It may be generated multiple"]
            #[doc = "times to describe a region."]
            #[doc = ""]
            #[doc = "The first captured frame in a session will always carry full damage."]
            #[doc = "Subsequent frames' damaged regions describe which parts of the buffer"]
            #[doc = "have changed since the last ready event."]
            #[doc = ""]
            #[doc = "These coordinates originate in the upper left corner of the buffer."]
            async fn damage(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_screencopy_frame_v2#{}.damage()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(x)
                    .put_int(y)
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates the time at which the frame is presented to the"]
            #[doc = "output in system monotonic time. This event is sent before the ready"]
            #[doc = "event."]
            #[doc = ""]
            #[doc = "The timestamp is expressed as tv_sec_hi, tv_sec_lo, tv_nsec triples,"]
            #[doc = "each component being an unsigned 32-bit value. Whole seconds are in"]
            #[doc = "tv_sec which is a 64-bit value combined from tv_sec_hi and tv_sec_lo,"]
            #[doc = "and the additional fractional part in tv_nsec as nanoseconds. Hence,"]
            #[doc = "for valid timestamps tv_nsec must be in [0, 999999999]."]
            async fn presentation_time(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                tv_sec_hi: u32,
                tv_sec_lo: u32,
                tv_nsec: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_screencopy_frame_v2#{}.presentation_time()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(tv_sec_hi)
                    .put_uint(tv_sec_lo)
                    .put_uint(tv_nsec)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Called as soon as the frame is copied, indicating it is available"]
            #[doc = "for reading."]
            #[doc = ""]
            #[doc = "The buffer may be re-used by the client after this event."]
            #[doc = ""]
            #[doc = "After receiving this event, the client must destroy the object."]
            async fn ready(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_screencopy_frame_v2#{}.ready()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates that the attempted frame copy has failed."]
            #[doc = ""]
            #[doc = "After receiving this event, the client must destroy the object."]
            async fn failed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                reason: FailureReason,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_screencopy_frame_v2#{}.failed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(reason as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "This object represents a cursor capture session. It extends the base"]
    #[doc = "capture session with cursor-specific metadata."]
    pub mod zcosmic_screencopy_cursor_session_v2 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "get_screencopy_session sent twice"]
            DuplicateSession = 1u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::DuplicateSession),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zcosmic_screencopy_cursor_session_v2 interface. See the module level documentation for more info"]
        pub trait ZcosmicScreencopyCursorSessionV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zcosmic_screencopy_cursor_session_v2";
            const VERSION: u32 = 1u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zcosmic_screencopy_cursor_session_v2#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zcosmic_screencopy_cursor_session_v2#{}.get_screencopy_session()",
                            object.id
                        );
                        self.get_screencopy_session(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroys the session. This request can be sent at any time by the"]
            #[doc = "client."]
            #[doc = ""]
            #[doc = "This request doesn't affect zcosmic_screencopy_frame_v2 objects created by"]
            #[doc = "this object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Gets the screencopy session for this cursor session."]
            #[doc = ""]
            #[doc = "The session will produce frames of the cursor image. The compositor may"]
            #[doc = "pause the session when the cursor leaves the captured area."]
            #[doc = ""]
            #[doc = "This request must not be sent more than once, or else the"]
            #[doc = "duplicate_session protocol error is raised."]
            async fn get_screencopy_session(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                session: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "Sent when a cursor enters the captured area. It shall be generated"]
            #[doc = "before the \"position\" and \"hotspot\" events when and only when a cursor"]
            #[doc = "enters the area."]
            #[doc = ""]
            #[doc = "The cursor enters the captured area when the cursor image intersects"]
            #[doc = "with the captured area. Note, this is different from e.g."]
            #[doc = "wl_pointer.enter."]
            async fn enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_screencopy_cursor_session_v2#{}.enter()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Sent when a cursor leaves the captured area. No \"position\" or \"hotspot\""]
            #[doc = "event is generated for the cursor until the cursor enters the captured"]
            #[doc = "area again."]
            async fn leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_screencopy_cursor_session_v2#{}.leave()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Cursors outside the image source do not get captured and no event will"]
            #[doc = "be generated for them."]
            #[doc = ""]
            #[doc = "The given position is the position of the cursor's hotspot and it is"]
            #[doc = "relative to the main buffer's top left corner in transformed buffer"]
            #[doc = "pixel coordinates."]
            #[doc = ""]
            #[doc = "The position coordinates are relative to the main buffer's upper left"]
            #[doc = "corner. The coordinates may be negative or greater than the main buffer"]
            #[doc = "size."]
            async fn position(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_screencopy_cursor_session_v2#{}.position()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(x)
                    .put_int(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "The hotspot describes the offset between the cursor image and the"]
            #[doc = "position of the input device."]
            #[doc = ""]
            #[doc = "The given coordinates are the hotspot's offset from the origin in"]
            #[doc = "buffer coordinates."]
            #[doc = ""]
            #[doc = "Clients should not apply the hotspot immediately: the hotspot becomes"]
            #[doc = "effective when the next zcosmic_screencopy_frame_v2.ready event is received."]
            async fn hotspot(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_screencopy_cursor_session_v2#{}.hotspot()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(x)
                    .put_int(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod cosmic_toplevel_info_unstable_v1 {
    #[doc = "The purpose of this protocol is to enable clients such as taskbars"]
    #[doc = "or docks to access a list of opened applications and basic properties"]
    #[doc = "thereof."]
    #[doc = ""]
    #[doc = "It thus extends ext_foreign_toplevel_v1 to provide more information"]
    #[doc = "and actions on foreign toplevels."]
    pub mod zcosmic_toplevel_info_v1 {
        #[doc = "Trait to implement the zcosmic_toplevel_info_v1 interface. See the module level documentation for more info"]
        pub trait ZcosmicToplevelInfoV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zcosmic_toplevel_info_v1";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zcosmic_toplevel_info_v1#{}.stop()", object.id);
                        self.stop(object, client).await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zcosmic_toplevel_info_v1#{}.get_cosmic_toplevel()",
                            object.id
                        );
                        self.get_cosmic_toplevel(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request indicates that the client no longer wishes to receive"]
            #[doc = "events for new toplevels.  However, the compositor may emit further"]
            #[doc = "toplevel_created events until the finished event is emitted."]
            #[doc = ""]
            #[doc = "The client must not send any more requests after this one."]
            #[doc = ""]
            #[doc = "Note: This request isn't necessary for clients binding version 2"]
            #[doc = "of this protocol and will be ignored."]
            async fn stop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Request a zcosmic_toplevel_handle_v1 extension object for an existing"]
            #[doc = "ext_foreign_toplevel_handle_v1."]
            #[doc = ""]
            #[doc = "All initial properties of the toplevel (states, etc.)"]
            #[doc = "will be sent immediately after this event via the corresponding"]
            #[doc = "events in zcosmic_toplevel_handle_v1."]
            async fn get_cosmic_toplevel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                cosmic_toplevel: crate::wire::ObjectId,
                foreign_toplevel: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This event is never emitted for clients binding version 2"]
            #[doc = "of this protocol, they should use `get_cosmic_toplevel` instead."]
            #[doc = ""]
            #[doc = "This event is emitted for clients binding version 1 whenever a"]
            #[doc = "new toplevel window is created. It is emitted for all toplevels,"]
            #[doc = "regardless of the app that has created them."]
            #[doc = ""]
            #[doc = "All initial properties of the toplevel (title, app_id, states, etc.)"]
            #[doc = "will be sent immediately after this event via the corresponding"]
            #[doc = "events in zcosmic_toplevel_handle_v1."]
            async fn toplevel(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                toplevel: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_toplevel_info_v1#{}.toplevel()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(toplevel))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates that the compositor is done sending events"]
            #[doc = "to the zcosmic_toplevel_info_v1. The server will destroy the"]
            #[doc = "object immediately after sending this request, so it will become"]
            #[doc = "invalid and the client should free any resources associated with it."]
            #[doc = ""]
            #[doc = "Note: This event is emitted immediately after calling `stop` for"]
            #[doc = "clients binding version 2 of this protocol for backwards compatibility."]
            async fn finished(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_toplevel_info_v1#{}.finished()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent after all changes for currently active"]
            #[doc = "zcosmic_toplevel_handle_v1 have been sent."]
            #[doc = ""]
            #[doc = "This allows changes to multiple zcosmic_toplevel_handle_v1 handles"]
            #[doc = "and their properties to be seen as atomic, even if they happen via"]
            #[doc = "multiple events."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_toplevel_info_v1#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A zcosmic_toplevel_handle_v1 object represents an open toplevel"]
    #[doc = "window. A single app may have multiple open toplevels."]
    #[doc = ""]
    #[doc = "Each toplevel has a list of outputs it is visible on, exposed to the"]
    #[doc = "client via the output_enter and output_leave events."]
    pub mod zcosmic_toplevel_handle_v1 {
        #[doc = "The different states that a toplevel may have. These have the same"]
        #[doc = "meaning as the states with the same names defined in xdg-toplevel"]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum State {
            #[doc = "the toplevel is maximized"]
            Maximized = 0u32,
            #[doc = "the toplevel is minimized"]
            Minimized = 1u32,
            #[doc = "the toplevel is active"]
            Activated = 2u32,
            #[doc = "the toplevel is fullscreen"]
            Fullscreen = 3u32,
            #[doc = "the toplevel is sticky"]
            Sticky = 4u32,
        }
        impl TryFrom<u32> for State {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Maximized),
                    1u32 => Ok(Self::Minimized),
                    2u32 => Ok(Self::Activated),
                    3u32 => Ok(Self::Fullscreen),
                    4u32 => Ok(Self::Sticky),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zcosmic_toplevel_handle_v1 interface. See the module level documentation for more info"]
        pub trait ZcosmicToplevelHandleV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zcosmic_toplevel_handle_v1";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zcosmic_toplevel_handle_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request should be called either when the client will no longer"]
            #[doc = "use the zcosmic_toplevel_handle_v1."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "The server will emit no further events on the"]
            #[doc = "zcosmic_toplevel_handle_v1 after this event. Any requests received"]
            #[doc = "aside from the destroy request will be ignored. Upon receiving this"]
            #[doc = "event, the client should make the destroy request to allow freeing"]
            #[doc = "of resources."]
            #[doc = ""]
            #[doc = "Note: This event will not be emitted for clients binding version 2"]
            #[doc = "of this protocol, as `ext_foreign_toplevel_handle_v1.closed` is"]
            #[doc = "equivalent."]
            async fn closed(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_toplevel_handle_v1#{}.closed()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent after all changes in the toplevel state have"]
            #[doc = "been sent."]
            #[doc = ""]
            #[doc = "This allows changes to the zcosmic_toplevel_handle_v1 properties"]
            #[doc = "to be seen as atomic, even if they happen via multiple events."]
            #[doc = ""]
            #[doc = "Note: this is is not sent after the closed event."]
            #[doc = ""]
            #[doc = "Note: This event will not be emitted for clients binding version 2"]
            #[doc = "of this protocol, as `ext_foreign_toplevel_handle_v1.done` is"]
            #[doc = "equivalent."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_toplevel_handle_v1#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is emitted whenever the title of the toplevel changes."]
            #[doc = ""]
            #[doc = "Note: This event will not be emitted for clients binding version 2"]
            #[doc = "of this protocol, as `ext_foreign_toplevel_handle_v1.title` is"]
            #[doc = "equivalent."]
            async fn title(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                title: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_toplevel_handle_v1#{}.title()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(title))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is emitted whenever the app_id of the toplevel changes."]
            #[doc = ""]
            #[doc = "Note: This event will not be emitted for clients binding version 2"]
            #[doc = "of this protocol, as `ext_foreign_toplevel_handle_v1.app_id` is"]
            #[doc = "equivalent."]
            async fn app_id(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                app_id: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_toplevel_handle_v1#{}.app_id()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(app_id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is emitted whenever the toplevel becomes visible on the"]
            #[doc = "given output. A toplevel may be visible on multiple outputs."]
            async fn output_enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_toplevel_handle_v1#{}.output_enter()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(output))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is emitted whenever the toplevel is no longer visible"]
            #[doc = "on a given output. It is guaranteed that an output_enter event with"]
            #[doc = "the same output has been emitted before this event."]
            async fn output_leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_toplevel_handle_v1#{}.output_leave()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(output))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is emitted whenever the toplevel becomes visible on the"]
            #[doc = "given workspace. A toplevel may be visible on multiple workspaces."]
            async fn workspace_enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                workspace: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_toplevel_handle_v1#{}.workspace_enter()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(workspace))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 6u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is emitted whenever the toplevel is no longer visible"]
            #[doc = "on a given workspace. It is guaranteed that an workspace_enter event with"]
            #[doc = "the same workspace has been emitted before this event."]
            async fn workspace_leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                workspace: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_toplevel_handle_v1#{}.workspace_leave()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(workspace))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 7u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is emitted once on creation of the"]
            #[doc = "zcosmic_toplevel_handle_v1 and again whenever the state of the"]
            #[doc = "toplevel changes."]
            async fn state(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                state: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_toplevel_handle_v1#{}.state()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_array(state).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 8u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "Emitted when the geometry of a toplevel (it's position and/or size)"]
            #[doc = "relative to the provided output has changed."]
            #[doc = ""]
            #[doc = "This event is emitted once on creation of the"]
            #[doc = "zcosmic_toplevel_handle_v1 for every entered output and again"]
            #[doc = "whenever the geometry of the toplevel changes relative to any output."]
            async fn geometry(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: crate::wire::ObjectId,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_toplevel_handle_v1#{}.geometry()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(output))
                    .put_int(x)
                    .put_int(y)
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 9u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod cosmic_toplevel_management_unstable_v1 {
    #[doc = "This protocol allows clients such as a taskbar to request the compositor"]
    #[doc = "to preform typical actions on open toplevels. The compositor is in all"]
    #[doc = "cases free to ignore the request."]
    pub mod zcosmic_toplevel_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ZcosmicToplelevelManagementCapabilitiesV1 {
            #[doc = "close request is available"]
            Close = 1u32,
            #[doc = "activate request is available"]
            Activate = 2u32,
            #[doc = "set_maximized and unset_maximized requests are available"]
            Maximize = 3u32,
            #[doc = "set_minimized and unset_minimized requests are available"]
            Minimize = 4u32,
            #[doc = "set_fullscreen and unset_fullscreen requests are available"]
            Fullscreen = 5u32,
            #[doc = "move_to_workspace request is available"]
            MoveToWorkspace = 6u32,
            #[doc = "set_sticky and unset_sticky requests are available"]
            Sticky = 7u32,
        }
        impl TryFrom<u32> for ZcosmicToplelevelManagementCapabilitiesV1 {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::Close),
                    2u32 => Ok(Self::Activate),
                    3u32 => Ok(Self::Maximize),
                    4u32 => Ok(Self::Minimize),
                    5u32 => Ok(Self::Fullscreen),
                    6u32 => Ok(Self::MoveToWorkspace),
                    7u32 => Ok(Self::Sticky),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = "the provided rectangle is invalid"]
            InvalidRectangle = 0u32,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::InvalidRectangle),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zcosmic_toplevel_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZcosmicToplevelManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zcosmic_toplevel_manager_v1";
            const VERSION: u32 = 3u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zcosmic_toplevel_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zcosmic_toplevel_manager_v1#{}.close()", object.id);
                        self.close(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2u16 => {
                        tracing::debug!("zcosmic_toplevel_manager_v1#{}.activate()", object.id);
                        self.activate(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3u16 => {
                        tracing::debug!(
                            "zcosmic_toplevel_manager_v1#{}.set_maximized()",
                            object.id
                        );
                        self.set_maximized(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    4u16 => {
                        tracing::debug!(
                            "zcosmic_toplevel_manager_v1#{}.unset_maximized()",
                            object.id
                        );
                        self.unset_maximized(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    5u16 => {
                        tracing::debug!(
                            "zcosmic_toplevel_manager_v1#{}.set_minimized()",
                            object.id
                        );
                        self.set_minimized(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    6u16 => {
                        tracing::debug!(
                            "zcosmic_toplevel_manager_v1#{}.unset_minimized()",
                            object.id
                        );
                        self.unset_minimized(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    7u16 => {
                        tracing::debug!(
                            "zcosmic_toplevel_manager_v1#{}.set_fullscreen()",
                            object.id
                        );
                        self.set_fullscreen(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.object()?,
                        )
                        .await
                    }
                    8u16 => {
                        tracing::debug!(
                            "zcosmic_toplevel_manager_v1#{}.unset_fullscreen()",
                            object.id
                        );
                        self.unset_fullscreen(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    9u16 => {
                        tracing::debug!(
                            "zcosmic_toplevel_manager_v1#{}.set_rectangle()",
                            object.id
                        );
                        self.set_rectangle(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    10u16 => {
                        tracing::debug!(
                            "zcosmic_toplevel_manager_v1#{}.move_to_workspace()",
                            object.id
                        );
                        self.move_to_workspace(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    11u16 => {
                        tracing::debug!("zcosmic_toplevel_manager_v1#{}.set_sticky()", object.id);
                        self.set_sticky(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    12u16 => {
                        tracing::debug!("zcosmic_toplevel_manager_v1#{}.unset_sticky()", object.id);
                        self.unset_sticky(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "This request indicates that the client has finished using the"]
            #[doc = "zcosmic_toplevel_manager_v1 object and that it can be safely"]
            #[doc = "destroyed."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "If the compositor honors this request, the"]
            #[doc = "zcosmic_toplevel_handle_v1.closed event will be sent."]
            async fn close(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                toplevel: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "If the compositor honors this request, the"]
            #[doc = "zcosmic_toplevel_handle_v1.state event will be sent."]
            async fn activate(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                toplevel: crate::wire::ObjectId,
                seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "If the compositor honors this request, the"]
            #[doc = "zcosmic_toplevel_handle_v1.state event will be sent."]
            async fn set_maximized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                toplevel: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "If the compositor honors this request, the"]
            #[doc = "zcosmic_toplevel_handle_v1.state event will be sent."]
            async fn unset_maximized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                toplevel: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "If the compositor honors this request, the"]
            #[doc = "zcosmic_toplevel_handle_v1.state event will be sent."]
            async fn set_minimized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                toplevel: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "If the compositor honors this request, the"]
            #[doc = "zcosmic_toplevel_handle_v1.state event will be sent."]
            async fn unset_minimized(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                toplevel: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "If the compositor honors this request, the"]
            #[doc = "zcosmic_toplevel_handle_v1.state and potentially the"]
            #[doc = "zcosmic_toplevel_handle_v1.output_enter/output_leave events will"]
            #[doc = "be sent."]
            #[doc = ""]
            #[doc = "The output parameter a hint to the compositor and may be ignored. A"]
            #[doc = "value of NULL indicates that the compositor should choose the target"]
            #[doc = "output, if it honors the fullscreen request."]
            async fn set_fullscreen(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                toplevel: crate::wire::ObjectId,
                output: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = "If the compositor honors this request, the"]
            #[doc = "zcosmic_toplevel_handle_v1.state event will be sent."]
            async fn unset_fullscreen(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                toplevel: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "If a client using this protocol displays UI elements corresponding"]
            #[doc = "to toplevels, it may use this request to inform the server about such"]
            #[doc = "a relation. This information may be used by the server, for example as"]
            #[doc = "the target for a minimize animation."]
            #[doc = ""]
            #[doc = "If the client sets more than one rectangle, only the most recently"]
            #[doc = "set rectangle is considered."]
            #[doc = ""]
            #[doc = "The dimensions are given in surface-local coordinates."]
            #[doc = ""]
            #[doc = "Setting width=height=0 removes the current rectangle if one was set."]
            async fn set_rectangle(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                toplevel: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()>;
            #[doc = "Move window to workspace, on given output."]
            async fn move_to_workspace(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                toplevel: crate::wire::ObjectId,
                workspace: crate::wire::ObjectId,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "If the compositor honors this request, the"]
            #[doc = "zcosmic_toplevel_handle_v1.state event will be sent."]
            async fn set_sticky(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                toplevel: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "If the compositor honors this request, the"]
            #[doc = "zcosmic_toplevel_handle_v1.state event will be sent."]
            async fn unset_sticky(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                toplevel: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = "This event advertises the capabilities supported by the compositor. If"]
            #[doc = "a capability isn't supported, clients should hide or disable the UI"]
            #[doc = "elements that expose this functionality. For instance, if the"]
            #[doc = "compositor doesn't advertise support for closing toplevels, a button"]
            #[doc = "triggering the close request should not be displayed."]
            #[doc = ""]
            #[doc = "The compositor will ignore requests it doesn't support. For instance,"]
            #[doc = "a compositor which doesn't advertise support for closing toplevels will ignore"]
            #[doc = "close requests."]
            #[doc = ""]
            #[doc = "Compositors must send this event once after creation of an"]
            #[doc = "zcosmic_toplevel_manager_v1 . When the capabilities change, compositors"]
            #[doc = "must send this event again."]
            #[doc = ""]
            #[doc = "The capabilities are sent as an array of 32-bit unsigned integers in"]
            #[doc = "native endianness."]
            async fn capabilities(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                capabilities: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_toplevel_manager_v1#{}.capabilities()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_array(capabilities)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod cosmic_workspace_unstable_v1 {
    #[doc = "Workspaces, also called virtual desktops, are groups of surfaces. A"]
    #[doc = "compositor with a concept of workspaces may only show some such groups of"]
    #[doc = "surfaces (those of 'active' workspaces) at a time.\u{a0}'Activating' a"]
    #[doc = "workspace is a request for the compositor to display that workspace's"]
    #[doc = "surfaces as normal, whereas the compositor may hide or otherwise"]
    #[doc = "de-emphasise surfaces that are associated only with 'inactive' workspaces."]
    #[doc = "Workspaces are grouped by which sets of outputs they correspond to, and"]
    #[doc = "may contain surfaces only from those outputs. In this way, it is possible"]
    #[doc = "for each output to have its own set of workspaces, or for all outputs (or"]
    #[doc = "any other arbitrary grouping) to share workspaces. Compositors may"]
    #[doc = "optionally conceptually arrange each group of workspaces in an"]
    #[doc = "N-dimensional grid."]
    #[doc = ""]
    #[doc = "The purpose of this protocol is to enable the creation of taskbars and"]
    #[doc = "docks by providing them with a list of workspaces and their properties,"]
    #[doc = "and allowing them to activate and deactivate workspaces."]
    #[doc = ""]
    #[doc = "After a client binds the zcosmic_workspace_manager_v1, each workspace will be"]
    #[doc = "sent via the workspace event."]
    pub mod zcosmic_workspace_manager_v1 {
        #[doc = "Trait to implement the zcosmic_workspace_manager_v1 interface. See the module level documentation for more info"]
        pub trait ZcosmicWorkspaceManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zcosmic_workspace_manager_v1";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zcosmic_workspace_manager_v1#{}.commit()", object.id);
                        self.commit(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zcosmic_workspace_manager_v1#{}.stop()", object.id);
                        self.stop(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "The client must send this request after it has finished sending other"]
            #[doc = "requests. The compositor must process a series of requests preceding a"]
            #[doc = "commit request atomically."]
            #[doc = ""]
            #[doc = "This allows changes to the workspace properties to be seen as atomic,"]
            #[doc = "even if they happen via multiple events, and even if they involve"]
            #[doc = "multiple zcosmic_workspace_handle_v1 objects, for example, deactivating one"]
            #[doc = "workspace and activating another."]
            async fn commit(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Indicates the client no longer wishes to receive events for new"]
            #[doc = "workspace groups. However the compositor may emit further workspace"]
            #[doc = "events, until the finished event is emitted."]
            #[doc = ""]
            #[doc = "The client must not send any more requests after this one."]
            async fn stop(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event is emitted whenever a new workspace group has been created."]
            #[doc = ""]
            #[doc = "All initial details of the workspace group (workspaces, outputs) will be"]
            #[doc = "sent immediately after this event via the corresponding events in"]
            #[doc = "zcosmic_workspace_group_handle_v1."]
            async fn workspace_group(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                workspace_group: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_workspace_manager_v1#{}.workspace_group()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(workspace_group))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is sent after all changes in all workspace groups have been"]
            #[doc = "sent."]
            #[doc = ""]
            #[doc = "This allows changes to one or more zcosmic_workspace_group_handle_v1"]
            #[doc = "properties and zcosmic_workspace_handle_v1 properties to be seen as atomic,"]
            #[doc = "even if they happen via multiple events."]
            #[doc = "In particular, an output moving from one workspace group to"]
            #[doc = "another sends an output_enter event and an output_leave event to the two"]
            #[doc = "zcosmic_workspace_group_handle_v1 objects in question. The compositor sends"]
            #[doc = "the done event only after updating the output information in both"]
            #[doc = "workspace groups."]
            async fn done(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_workspace_manager_v1#{}.done()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event indicates that the compositor is done sending events to the"]
            #[doc = "zcosmic_workspace_manager_v1. The server will destroy the object"]
            #[doc = "immediately after sending this request, so it will become invalid and"]
            #[doc = "the client should free any resources associated with it."]
            async fn finished(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_workspace_manager_v1#{}.finished()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A zcosmic_workspace_group_handle_v1 object represents a a workspace group"]
    #[doc = "that is assigned a set of outputs and contains a number of workspaces."]
    #[doc = ""]
    #[doc = "The set of outputs assigned to the workspace group is conveyed to the client via"]
    #[doc = "output_enter and output_leave events, and its workspaces are conveyed with"]
    #[doc = "workspace events."]
    #[doc = ""]
    #[doc = "For example, a compositor which has a set of workspaces for each output may"]
    #[doc = "advertise a workspace group (and its workspaces) per output, whereas a compositor"]
    #[doc = "where a workspace spans all outputs may advertise a single workspace group for all"]
    #[doc = "outputs."]
    pub mod zcosmic_workspace_group_handle_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ZcosmicWorkspaceGroupCapabilitiesV1 {
            #[doc = "create_workspace request is available"]
            CreateWorkspace = 1u32,
        }
        impl TryFrom<u32> for ZcosmicWorkspaceGroupCapabilitiesV1 {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::CreateWorkspace),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zcosmic_workspace_group_handle_v1 interface. See the module level documentation for more info"]
        pub trait ZcosmicWorkspaceGroupHandleV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zcosmic_workspace_group_handle_v1";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!(
                            "zcosmic_workspace_group_handle_v1#{}.create_workspace()",
                            object.id
                        );
                        self.create_workspace(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1u16 => {
                        tracing::debug!(
                            "zcosmic_workspace_group_handle_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Request that the compositor create a new workspace with the given name."]
            #[doc = ""]
            #[doc = "There is no guarantee that the compositor will create a new workspace,"]
            #[doc = "or that the created workspace will have the provided name."]
            async fn create_workspace(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                workspace: String,
            ) -> crate::server::Result<()>;
            #[doc = "Destroys the zcosmic_workspace_group_handle_v1 object."]
            #[doc = ""]
            #[doc = "This request should be called either when the client does not want to"]
            #[doc = "use the workspace object any more or after the remove event to finalize"]
            #[doc = "the destruction of the object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "This event advertises the capabilities supported by the compositor. If"]
            #[doc = "a capability isn't supported, clients should hide or disable the UI"]
            #[doc = "elements that expose this functionality. For instance, if the"]
            #[doc = "compositor doesn't advertise support for creating workspaces, a button"]
            #[doc = "triggering the create_workspace request should not be displayed."]
            #[doc = ""]
            #[doc = "The compositor will ignore requests it doesn't support. For instance,"]
            #[doc = "a compositor which doesn't advertise support for creating workspaces will ignore"]
            #[doc = "create_workspace requests."]
            #[doc = ""]
            #[doc = "Compositors must send this event once after creation of an"]
            #[doc = "zcosmic_workspace_group_handle_v1 . When the capabilities change, compositors"]
            #[doc = "must send this event again."]
            #[doc = ""]
            #[doc = "The capabilities are sent as an array of 32-bit unsigned integers in"]
            #[doc = "native endianness."]
            async fn capabilities(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                capabilities: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_workspace_group_handle_v1#{}.capabilities()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_array(capabilities)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is emitted whenever an output is assigned to the workspace"]
            #[doc = "group."]
            async fn output_enter(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_workspace_group_handle_v1#{}.output_enter()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(output))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is emitted whenever an output is removed from the workspace"]
            #[doc = "group."]
            async fn output_leave(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_workspace_group_handle_v1#{}.output_leave()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(output))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is emitted whenever a new workspace has been created."]
            #[doc = "A workspace can only be a member of a single workspace group and cannot"]
            #[doc = "be re-assigned."]
            #[doc = ""]
            #[doc = "All initial details of the workspace (name, coordinates, state) will"]
            #[doc = "be sent immediately after this event via the corresponding events in"]
            #[doc = "zcosmic_workspace_handle_v1."]
            async fn workspace(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                workspace: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_workspace_group_handle_v1#{}.workspace()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(workspace))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event means the zcosmic_workspace_group_handle_v1 has been destroyed."]
            #[doc = "It is guaranteed there won't be any more events for this"]
            #[doc = "zcosmic_workspace_group_handle_v1. The zext_workspace_group_handle_v1 becomes"]
            #[doc = "inert so any requests will be ignored except the destroy request."]
            #[doc = ""]
            #[doc = "The compositor must remove all workspaces belonging to a workspace group"]
            #[doc = "before removing the workspace group."]
            async fn remove(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_workspace_group_handle_v1#{}.remove()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    #[doc = "A zcosmic_workspace_handle_v1 object represents a a workspace that handles a"]
    #[doc = "group of surfaces."]
    #[doc = ""]
    #[doc = "Each workspace has a name, conveyed to the client with the name event; a"]
    #[doc = "list of states, conveyed to the client with the state event; and"]
    #[doc = "optionally a set of coordinates, conveyed to the client with the"]
    #[doc = "coordinates event. The client may request that the compositor activate or"]
    #[doc = "deactivate the workspace."]
    #[doc = ""]
    #[doc = "Each workspace can belong to only a single workspace group."]
    #[doc = "Depepending on the compositor policy, there might be workspaces with"]
    #[doc = "the same name in different workspace groups, but these workspaces are still"]
    #[doc = "separate (e.g. one of them might be active while the other is not)."]
    pub mod zcosmic_workspace_handle_v1 {
        #[doc = "The different states that a workspace can have."]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum State {
            #[doc = "the workspace is active"]
            Active = 0u32,
            #[doc = "the workspace requests attention"]
            Urgent = 1u32,
            Hidden = 2u32,
        }
        impl TryFrom<u32> for State {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::Active),
                    1u32 => Ok(Self::Urgent),
                    2u32 => Ok(Self::Hidden),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ZcosmicWorkspaceCapabilitiesV1 {
            #[doc = "activate request is available"]
            Activate = 1u32,
            #[doc = "deactivate request is available"]
            Deactivate = 2u32,
            #[doc = "remove request is available"]
            Remove = 3u32,
            #[doc = "rename request is available"]
            Rename = 4u32,
            #[doc = "set_tiling_state request is available"]
            SetTilingState = 5u32,
        }
        impl TryFrom<u32> for ZcosmicWorkspaceCapabilitiesV1 {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1u32 => Ok(Self::Activate),
                    2u32 => Ok(Self::Deactivate),
                    3u32 => Ok(Self::Remove),
                    4u32 => Ok(Self::Rename),
                    5u32 => Ok(Self::SetTilingState),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum TilingState {
            #[doc = "The workspace has no active tiling properties"]
            FloatingOnly = 0u32,
            #[doc = "Tiling behavior is enabled for the workspace"]
            TilingEnabled = 1u32,
        }
        impl TryFrom<u32> for TilingState {
            type Error = crate::wire::DecodeError;
            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0u32 => Ok(Self::FloatingOnly),
                    1u32 => Ok(Self::TilingEnabled),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = "Trait to implement the zcosmic_workspace_handle_v1 interface. See the module level documentation for more info"]
        pub trait ZcosmicWorkspaceHandleV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zcosmic_workspace_handle_v1";
            const VERSION: u32 = 2u32;
            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }
            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0u16 => {
                        tracing::debug!("zcosmic_workspace_handle_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1u16 => {
                        tracing::debug!("zcosmic_workspace_handle_v1#{}.activate()", object.id);
                        self.activate(object, client).await
                    }
                    2u16 => {
                        tracing::debug!("zcosmic_workspace_handle_v1#{}.deactivate()", object.id);
                        self.deactivate(object, client).await
                    }
                    3u16 => {
                        tracing::debug!("zcosmic_workspace_handle_v1#{}.remove()", object.id);
                        self.remove(object, client).await
                    }
                    4u16 => {
                        tracing::debug!("zcosmic_workspace_handle_v1#{}.rename()", object.id);
                        self.rename(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    5u16 => {
                        tracing::debug!(
                            "zcosmic_workspace_handle_v1#{}.set_tiling_state()",
                            object.id
                        );
                        self.set_tiling_state(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = "Destroys the zcosmic_workspace_handle_v1 object."]
            #[doc = ""]
            #[doc = "This request should be called either when the client does not want to"]
            #[doc = "use the workspace object any more or after the remove event to finalize"]
            #[doc = "the destruction of the object."]
            async fn destroy(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Request that this workspace be activated."]
            #[doc = ""]
            #[doc = "There is no guarantee the workspace will be actually activated, and"]
            #[doc = "behaviour may be compositor-dependent. For example, activating a"]
            #[doc = "workspace may or may not deactivate all other workspaces in the same"]
            #[doc = "group."]
            async fn activate(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Request that this workspace be deactivated."]
            #[doc = ""]
            #[doc = "There is no guarantee the workspace will be actually deactivated."]
            async fn deactivate(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Request that this workspace be removed."]
            #[doc = ""]
            #[doc = "There is no guarantee the workspace will be actually removed."]
            async fn remove(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = "Request that this workspace is renamed."]
            #[doc = ""]
            #[doc = "There is no guarantee the workspace will actually be renamed."]
            async fn rename(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
            ) -> crate::server::Result<()>;
            #[doc = "Request that this workspace's tiling state is changed."]
            #[doc = ""]
            #[doc = "There is no guarantee the workspace will actually change it's tiling state."]
            async fn set_tiling_state(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                state: TilingState,
            ) -> crate::server::Result<()>;
            #[doc = "This event is emitted immediately after the zcosmic_workspace_handle_v1 is"]
            #[doc = "created and whenever the name of the workspace changes."]
            async fn name(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_workspace_handle_v1#{}.name()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(name))
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 0u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is used to organize workspaces into an N-dimensional grid"]
            #[doc = "within a workspace group, and if supported, is emitted immediately after"]
            #[doc = "the zcosmic_workspace_handle_v1 is created and whenever the coordinates of"]
            #[doc = "the workspace change. Compositors may not send this event if they do not"]
            #[doc = "conceptually arrange workspaces in this way. If compositors simply"]
            #[doc = "number workspaces, without any geometric interpretation, they may send"]
            #[doc = "1D coordinates, which clients should not interpret as implying any"]
            #[doc = "geometry. Sending an empty array means that the compositor no longer"]
            #[doc = "orders the workspace geometrically."]
            #[doc = ""]
            #[doc = "Coordinates have an arbitrary number of dimensions N with an uint32"]
            #[doc = "position along each dimension. By convention if N > 1, the first"]
            #[doc = "dimension is X, the second Y, the third Z, and so on. The compositor may"]
            #[doc = "chose to utilize these events for a more novel workspace layout"]
            #[doc = "convention, however. No guarantee is made about the grid being filled or"]
            #[doc = "bounded; there may be a workspace at coordinate 1 and another at"]
            #[doc = "coordinate 1000 and none in between. Within a workspace group, however,"]
            #[doc = "workspaces must have unique coordinates of equal dimensionality."]
            async fn coordinates(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                coordinates: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_workspace_handle_v1#{}.coordinates()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_array(coordinates)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 1u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is emitted immediately after the zcosmic_workspace_handle_v1 is"]
            #[doc = "created and each time the workspace state changes, either because of a"]
            #[doc = "compositor action or because of a request in this protocol."]
            async fn state(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                state: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_workspace_handle_v1#{}.state()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_array(state).build();
                client
                    .send_message(crate::wire::Message::new(object.id, 2u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event advertises the capabilities supported by the compositor. If"]
            #[doc = "a capability isn't supported, clients should hide or disable the UI"]
            #[doc = "elements that expose this functionality. For instance, if the"]
            #[doc = "compositor doesn't advertise support for removing workspaces, a button"]
            #[doc = "triggering the remove request should not be displayed."]
            #[doc = ""]
            #[doc = "The compositor will ignore requests it doesn't support. For instance,"]
            #[doc = "a compositor which doesn't advertise support for remove will ignore"]
            #[doc = "remove requests."]
            #[doc = ""]
            #[doc = "Compositors must send this event once after creation of an"]
            #[doc = "zcosmic_workspace_handle_v1 . When the capabilities change, compositors"]
            #[doc = "must send this event again."]
            #[doc = ""]
            #[doc = "The capabilities are sent as an array of 32-bit unsigned integers in"]
            #[doc = "native endianness."]
            async fn capabilities(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                capabilities: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_workspace_handle_v1#{}.capabilities()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_array(capabilities)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 3u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event means the zcosmic_workspace_handle_v1 has been destroyed. It is"]
            #[doc = "guaranteed there won't be any more events for this"]
            #[doc = "zcosmic_workspace_handle_v1. The zext_workspace_handle_v1 becomes inert so"]
            #[doc = "any requests will be ignored except the destroy request."]
            async fn remove(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zcosmic_workspace_handle_v1#{}.remove()", object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(object.id, 4u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = "This event is emitted immediately after the zcosmic_workspace_handle_v1 is created"]
            #[doc = "and each time the workspace tiling state changes, either because of a"]
            #[doc = "compositor action or because of a request in this protocol."]
            async fn tiling_state(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                state: TilingState,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zcosmic_workspace_handle_v1#{}.tiling_state()",
                    object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(state as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(object.id, 5u16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
