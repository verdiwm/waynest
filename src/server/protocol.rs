#![allow(unused)]
#![allow(async_fn_in_trait)]
pub mod wayland {
    pub mod wl_display {
        #[doc = r#"These errors are global and can be emitted in response to any"#]
        #[doc = r#"server request."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Server couldn't find object"#]
            InvalidObject = 0,
            #[doc = r#"Method doesn't exist on the specified interface or malformed request"#]
            InvalidMethod = 1,
            #[doc = r#"Server is out of memory"#]
            NoMemory = 2,
            #[doc = r#"Implementation error in compositor"#]
            Implementation = 3,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::InvalidObject),
                    1 => Ok(Self::InvalidMethod),
                    2 => Ok(Self::NoMemory),
                    3 => Ok(Self::Implementation),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"The core global object.  This is a special singleton object.  It"#]
        #[doc = r#"is used for internal Wayland protocol features."#]
        pub trait WlDisplay: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_display";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wl_display#{}.sync()", object.id);
                        self.sync(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("wl_display#{}.get_registry()", object.id);
                        self.get_registry(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"The sync request asks the server to emit the 'done' event"#]
            #[doc = r#"on the returned wl_callback object.  Since requests are"#]
            #[doc = r#"handled in-order and events are delivered in-order, this can"#]
            #[doc = r#"be used as a barrier to ensure all previous requests and the"#]
            #[doc = r#"resulting events have been handled."#]
            #[doc = r#""#]
            #[doc = r#"The object returned by this request will be destroyed by the"#]
            #[doc = r#"compositor after the callback is fired and as such the client must not"#]
            #[doc = r#"attempt to use it after that point."#]
            #[doc = r#""#]
            #[doc = r#"The callback_data passed in the callback is undefined and should be ignored."#]
            async fn sync(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                sync: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request creates a registry object that allows the client"#]
            #[doc = r#"to list and bind the global objects available from the"#]
            #[doc = r#"compositor."#]
            #[doc = r#""#]
            #[doc = r#"It should be noted that the server side resources consumed in"#]
            #[doc = r#"response to a get_registry request can only be released when the"#]
            #[doc = r#"client disconnects, not when the client side proxy is destroyed."#]
            #[doc = r#"Therefore, clients should invoke get_registry as infrequently as"#]
            #[doc = r#"possible to avoid wasting memory."#]
            async fn get_registry(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_registry: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"The error event is sent out when a fatal (non-recoverable)"#]
            #[doc = r#"error has occurred.  The object_id argument is the object"#]
            #[doc = r#"where the error occurred, most often in response to a request"#]
            #[doc = r#"to that object.  The code identifies the error and is defined"#]
            #[doc = r#"by the object interface.  As such, each interface defines its"#]
            #[doc = r#"own set of error codes.  The message is a brief description"#]
            #[doc = r#"of the error, for (debugging) convenience."#]
            async fn error(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                object_id: crate::wire::ObjectId,
                code: u32,
                message: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_display#{}.error()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(object_id))
                    .put_uint(code)
                    .put_string(Some(message))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is used internally by the object ID management"#]
            #[doc = r#"logic. When a client deletes an object that it had created,"#]
            #[doc = r#"the server will send this event to acknowledge that it has"#]
            #[doc = r#"seen the delete request. When the client receives this event,"#]
            #[doc = r#"it will know that it can safely reuse the object ID."#]
            async fn delete_id(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_display#{}.delete_id()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(id).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod wl_registry {
        #[doc = r#"The singleton global registry object.  The server has a number of"#]
        #[doc = r#"global objects that are available to all clients.  These objects"#]
        #[doc = r#"typically represent an actual object in the server (for example,"#]
        #[doc = r#"an input device) or they are singleton objects that provide"#]
        #[doc = r#"extension functionality."#]
        #[doc = r#""#]
        #[doc = r#"When a client creates a registry object, the registry object"#]
        #[doc = r#"will emit a global event for each global currently in the"#]
        #[doc = r#"registry.  Globals come and go as a result of device or"#]
        #[doc = r#"monitor hotplugs, reconfiguration or other events, and the"#]
        #[doc = r#"registry will send out global and global_remove events to"#]
        #[doc = r#"keep the client up to date with the changes.  To mark the end"#]
        #[doc = r#"of the initial burst of events, the client can use the"#]
        #[doc = r#"wl_display.sync request immediately after calling"#]
        #[doc = r#"wl_display.get_registry."#]
        #[doc = r#""#]
        #[doc = r#"A client can bind to a global object by using the bind"#]
        #[doc = r#"request.  This creates a client-side handle that lets the object"#]
        #[doc = r#"emit events to the client and lets the client invoke requests on"#]
        #[doc = r#"the object."#]
        pub trait WlRegistry: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_registry";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wl_registry#{}.bind()", object.id);
                        self.bind(object, client, message.uint()?, message.new_id()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Binds a new, client-created object to the server using the"#]
            #[doc = r#"specified name as the identifier."#]
            async fn bind(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                bind: u32,
                bind: crate::wire::NewId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Notify the client of global objects."#]
            #[doc = r#""#]
            #[doc = r#"The event notifies the client that a global object with"#]
            #[doc = r#"the given name is now available, and it implements the"#]
            #[doc = r#"given version of the given interface."#]
            async fn global(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: u32,
                interface: String,
                version: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_registry#{}.global()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(name)
                    .put_string(Some(interface))
                    .put_uint(version)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notify the client of removed global objects."#]
            #[doc = r#""#]
            #[doc = r#"This event notifies the client that the global identified"#]
            #[doc = r#"by name is no longer available.  If the client bound to"#]
            #[doc = r#"the global using the bind request, the client should now"#]
            #[doc = r#"destroy that object."#]
            #[doc = r#""#]
            #[doc = r#"The object remains valid and requests to the object will be"#]
            #[doc = r#"ignored until the client destroys it, to avoid races between"#]
            #[doc = r#"the global going away and a client sending a request to it."#]
            async fn global_remove(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_registry#{}.global_remove()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(name).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod wl_callback {
        #[doc = r#"Clients can handle the 'done' event to get notified when"#]
        #[doc = r#"the related request is done."#]
        #[doc = r#""#]
        #[doc = r#"Note, because wl_callback objects are created from multiple independent"#]
        #[doc = r#"factory interfaces, the wl_callback interface is frozen at version 1."#]
        pub trait WlCallback: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_callback";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Notify the client when the related request is done."#]
            async fn done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                callback_data: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_callback#{}.done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(callback_data)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod wl_compositor {
        #[doc = r#"A compositor.  This object is a singleton global.  The"#]
        #[doc = r#"compositor is in charge of combining the contents of multiple"#]
        #[doc = r#"surfaces into one displayable output."#]
        pub trait WlCompositor: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_compositor";
            const VERSION: u32 = 6;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wl_compositor#{}.create_surface()", object.id);
                        self.create_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("wl_compositor#{}.create_region()", object.id);
                        self.create_region(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Ask the compositor to create a new surface."#]
            async fn create_surface(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create_surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Ask the compositor to create a new region."#]
            async fn create_region(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create_region: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wl_shm_pool {
        #[doc = r#"The wl_shm_pool object encapsulates a piece of memory shared"#]
        #[doc = r#"between the compositor and client.  Through the wl_shm_pool"#]
        #[doc = r#"object, the client can allocate shared memory wl_buffer objects."#]
        #[doc = r#"All objects created through the same pool share the same"#]
        #[doc = r#"underlying mapped memory. Reusing the mapped memory avoids the"#]
        #[doc = r#"setup/teardown overhead and is useful when interactively resizing"#]
        #[doc = r#"a surface or for many small buffers."#]
        pub trait WlShmPool: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_shm_pool";
            const VERSION: u32 = 2;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wl_shm_pool#{}.create_buffer()", object.id);
                        self.create_buffer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("wl_shm_pool#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    2 => {
                        tracing::debug!("wl_shm_pool#{}.resize()", object.id);
                        self.resize(object, client, message.int()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Create a wl_buffer object from the pool."#]
            #[doc = r#""#]
            #[doc = r#"The buffer is created offset bytes into the pool and has"#]
            #[doc = r#"width and height as specified.  The stride argument specifies"#]
            #[doc = r#"the number of bytes from the beginning of one row to the beginning"#]
            #[doc = r#"of the next.  The format is the pixel format of the buffer and"#]
            #[doc = r#"must be one of those advertised through the wl_shm.format event."#]
            #[doc = r#""#]
            #[doc = r#"A buffer will keep a reference to the pool it was created from"#]
            #[doc = r#"so it is valid to destroy the pool immediately after creating"#]
            #[doc = r#"a buffer from it."#]
            async fn create_buffer(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create_buffer: crate::wire::ObjectId,
                create_buffer: i32,
                create_buffer: i32,
                create_buffer: i32,
                create_buffer: i32,
                create_buffer: super::super::wayland::wl_shm::Format,
            ) -> crate::server::Result<()>;
            #[doc = r#"Destroy the shared memory pool."#]
            #[doc = r#""#]
            #[doc = r#"The mmapped memory will be released when all"#]
            #[doc = r#"buffers that have been created from this pool"#]
            #[doc = r#"are gone."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request will cause the server to remap the backing memory"#]
            #[doc = r#"for the pool from the file descriptor passed when the pool was"#]
            #[doc = r#"created, but using the new size.  This request can only be"#]
            #[doc = r#"used to make the pool bigger."#]
            #[doc = r#""#]
            #[doc = r#"This request only changes the amount of bytes that are mmapped"#]
            #[doc = r#"by the server and does not touch the file corresponding to the"#]
            #[doc = r#"file descriptor passed at creation time. It is the client's"#]
            #[doc = r#"responsibility to ensure that the file is at least as big as"#]
            #[doc = r#"the new pool size."#]
            async fn resize(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                resize: i32,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wl_shm {
        #[doc = r#"These errors can be emitted in response to wl_shm requests."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Buffer format is not known"#]
            InvalidFormat = 0,
            #[doc = r#"Invalid size or stride during pool or buffer creation"#]
            InvalidStride = 1,
            #[doc = r#"Mmapping the file descriptor failed"#]
            InvalidFd = 2,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::InvalidFormat),
                    1 => Ok(Self::InvalidStride),
                    2 => Ok(Self::InvalidFd),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"This describes the memory layout of an individual pixel."#]
        #[doc = r#""#]
        #[doc = r#"All renderers should support argb8888 and xrgb8888 but any other"#]
        #[doc = r#"formats are optional and may not be supported by the particular"#]
        #[doc = r#"renderer in use."#]
        #[doc = r#""#]
        #[doc = r#"The drm format codes match the macros defined in drm_fourcc.h, except"#]
        #[doc = r#"argb8888 and xrgb8888. The formats actually supported by the compositor"#]
        #[doc = r#"will be reported by the format event."#]
        #[doc = r#""#]
        #[doc = r#"For all wl_shm formats and unless specified in another protocol"#]
        #[doc = r#"extension, pre-multiplied alpha is used for pixel values."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Format {
            #[doc = r#"32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian"#]
            Argb8888 = 0,
            #[doc = r#"32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian"#]
            Xrgb8888 = 1,
            #[doc = r#"8-bit color index format, [7:0] C"#]
            C8 = 0x20203843,
            #[doc = r#"8-bit RGB format, [7:0] R:G:B 3:3:2"#]
            Rgb332 = 0x38424752,
            #[doc = r#"8-bit BGR format, [7:0] B:G:R 2:3:3"#]
            Bgr233 = 0x38524742,
            #[doc = r#"16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian"#]
            Xrgb4444 = 0x32315258,
            #[doc = r#"16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian"#]
            Xbgr4444 = 0x32314258,
            #[doc = r#"16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian"#]
            Rgbx4444 = 0x32315852,
            #[doc = r#"16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian"#]
            Bgrx4444 = 0x32315842,
            #[doc = r#"16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian"#]
            Argb4444 = 0x32315241,
            #[doc = r#"16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian"#]
            Abgr4444 = 0x32314241,
            #[doc = r#"16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian"#]
            Rgba4444 = 0x32314152,
            #[doc = r#"16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian"#]
            Bgra4444 = 0x32314142,
            #[doc = r#"16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian"#]
            Xrgb1555 = 0x35315258,
            #[doc = r#"16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian"#]
            Xbgr1555 = 0x35314258,
            #[doc = r#"16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian"#]
            Rgbx5551 = 0x35315852,
            #[doc = r#"16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian"#]
            Bgrx5551 = 0x35315842,
            #[doc = r#"16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian"#]
            Argb1555 = 0x35315241,
            #[doc = r#"16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian"#]
            Abgr1555 = 0x35314241,
            #[doc = r#"16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian"#]
            Rgba5551 = 0x35314152,
            #[doc = r#"16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian"#]
            Bgra5551 = 0x35314142,
            #[doc = r#"16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian"#]
            Rgb565 = 0x36314752,
            #[doc = r#"16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian"#]
            Bgr565 = 0x36314742,
            #[doc = r#"24-bit RGB format, [23:0] R:G:B little endian"#]
            Rgb888 = 0x34324752,
            #[doc = r#"24-bit BGR format, [23:0] B:G:R little endian"#]
            Bgr888 = 0x34324742,
            #[doc = r#"32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian"#]
            Xbgr8888 = 0x34324258,
            #[doc = r#"32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian"#]
            Rgbx8888 = 0x34325852,
            #[doc = r#"32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian"#]
            Bgrx8888 = 0x34325842,
            #[doc = r#"32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian"#]
            Abgr8888 = 0x34324241,
            #[doc = r#"32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian"#]
            Rgba8888 = 0x34324152,
            #[doc = r#"32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian"#]
            Bgra8888 = 0x34324142,
            #[doc = r#"32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian"#]
            Xrgb2101010 = 0x30335258,
            #[doc = r#"32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian"#]
            Xbgr2101010 = 0x30334258,
            #[doc = r#"32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian"#]
            Rgbx1010102 = 0x30335852,
            #[doc = r#"32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian"#]
            Bgrx1010102 = 0x30335842,
            #[doc = r#"32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian"#]
            Argb2101010 = 0x30335241,
            #[doc = r#"32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian"#]
            Abgr2101010 = 0x30334241,
            #[doc = r#"32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian"#]
            Rgba1010102 = 0x30334152,
            #[doc = r#"32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian"#]
            Bgra1010102 = 0x30334142,
            #[doc = r#"Packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian"#]
            Yuyv = 0x56595559,
            #[doc = r#"Packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian"#]
            Yvyu = 0x55595659,
            #[doc = r#"Packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian"#]
            Uyvy = 0x59565955,
            #[doc = r#"Packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian"#]
            Vyuy = 0x59555956,
            #[doc = r#"Packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian"#]
            Ayuv = 0x56555941,
            #[doc = r#"2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane"#]
            Nv12 = 0x3231564e,
            #[doc = r#"2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane"#]
            Nv21 = 0x3132564e,
            #[doc = r#"2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane"#]
            Nv16 = 0x3631564e,
            #[doc = r#"2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane"#]
            Nv61 = 0x3136564e,
            #[doc = r#"3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes"#]
            Yuv410 = 0x39565559,
            #[doc = r#"3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes"#]
            Yvu410 = 0x39555659,
            #[doc = r#"3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes"#]
            Yuv411 = 0x31315559,
            #[doc = r#"3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes"#]
            Yvu411 = 0x31315659,
            #[doc = r#"3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes"#]
            Yuv420 = 0x32315559,
            #[doc = r#"3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes"#]
            Yvu420 = 0x32315659,
            #[doc = r#"3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes"#]
            Yuv422 = 0x36315559,
            #[doc = r#"3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes"#]
            Yvu422 = 0x36315659,
            #[doc = r#"3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes"#]
            Yuv444 = 0x34325559,
            #[doc = r#"3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes"#]
            Yvu444 = 0x34325659,
            #[doc = r#"[7:0] R"#]
            R8 = 0x20203852,
            #[doc = r#"[15:0] R little endian"#]
            R16 = 0x20363152,
            #[doc = r#"[15:0] R:G 8:8 little endian"#]
            Rg88 = 0x38384752,
            #[doc = r#"[15:0] G:R 8:8 little endian"#]
            Gr88 = 0x38385247,
            #[doc = r#"[31:0] R:G 16:16 little endian"#]
            Rg1616 = 0x32334752,
            #[doc = r#"[31:0] G:R 16:16 little endian"#]
            Gr1616 = 0x32335247,
            #[doc = r#"[63:0] x:R:G:B 16:16:16:16 little endian"#]
            Xrgb16161616f = 0x48345258,
            #[doc = r#"[63:0] x:B:G:R 16:16:16:16 little endian"#]
            Xbgr16161616f = 0x48344258,
            #[doc = r#"[63:0] A:R:G:B 16:16:16:16 little endian"#]
            Argb16161616f = 0x48345241,
            #[doc = r#"[63:0] A:B:G:R 16:16:16:16 little endian"#]
            Abgr16161616f = 0x48344241,
            #[doc = r#"[31:0] X:Y:Cb:Cr 8:8:8:8 little endian"#]
            Xyuv8888 = 0x56555958,
            #[doc = r#"[23:0] Cr:Cb:Y 8:8:8 little endian"#]
            Vuy888 = 0x34325556,
            #[doc = r#"Y followed by U then V, 10:10:10. Non-linear modifier only"#]
            Vuy101010 = 0x30335556,
            #[doc = r#"[63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels"#]
            Y210 = 0x30313259,
            #[doc = r#"[63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels"#]
            Y212 = 0x32313259,
            #[doc = r#"[63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels"#]
            Y216 = 0x36313259,
            #[doc = r#"[31:0] A:Cr:Y:Cb 2:10:10:10 little endian"#]
            Y410 = 0x30313459,
            #[doc = r#"[63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian"#]
            Y412 = 0x32313459,
            #[doc = r#"[63:0] A:Cr:Y:Cb 16:16:16:16 little endian"#]
            Y416 = 0x36313459,
            #[doc = r#"[31:0] X:Cr:Y:Cb 2:10:10:10 little endian"#]
            Xvyu2101010 = 0x30335658,
            #[doc = r#"[63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian"#]
            Xvyu1216161616 = 0x36335658,
            #[doc = r#"[63:0] X:Cr:Y:Cb 16:16:16:16 little endian"#]
            Xvyu16161616 = 0x38345658,
            #[doc = r#"[63:0]   A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian"#]
            Y0l0 = 0x304c3059,
            #[doc = r#"[63:0]   X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian"#]
            X0l0 = 0x304c3058,
            #[doc = r#"[63:0]   A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"#]
            Y0l2 = 0x324c3059,
            #[doc = r#"[63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"#]
            X0l2 = 0x324c3058,
            Yuv4208bit = 0x38305559,
            Yuv42010bit = 0x30315559,
            Xrgb8888A8 = 0x38415258,
            Xbgr8888A8 = 0x38414258,
            Rgbx8888A8 = 0x38415852,
            Bgrx8888A8 = 0x38415842,
            Rgb888A8 = 0x38413852,
            Bgr888A8 = 0x38413842,
            Rgb565A8 = 0x38413552,
            Bgr565A8 = 0x38413542,
            #[doc = r#"Non-subsampled Cr:Cb plane"#]
            Nv24 = 0x3432564e,
            #[doc = r#"Non-subsampled Cb:Cr plane"#]
            Nv42 = 0x3234564e,
            #[doc = r#"2x1 subsampled Cr:Cb plane, 10 bit per channel"#]
            P210 = 0x30313250,
            #[doc = r#"2x2 subsampled Cr:Cb plane 10 bits per channel"#]
            P010 = 0x30313050,
            #[doc = r#"2x2 subsampled Cr:Cb plane 12 bits per channel"#]
            P012 = 0x32313050,
            #[doc = r#"2x2 subsampled Cr:Cb plane 16 bits per channel"#]
            P016 = 0x36313050,
            #[doc = r#"[63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian"#]
            Axbxgxrx106106106106 = 0x30314241,
            #[doc = r#"2x2 subsampled Cr:Cb plane"#]
            Nv15 = 0x3531564e,
            Q410 = 0x30313451,
            Q401 = 0x31303451,
            #[doc = r#"[63:0] x:R:G:B 16:16:16:16 little endian"#]
            Xrgb16161616 = 0x38345258,
            #[doc = r#"[63:0] x:B:G:R 16:16:16:16 little endian"#]
            Xbgr16161616 = 0x38344258,
            #[doc = r#"[63:0] A:R:G:B 16:16:16:16 little endian"#]
            Argb16161616 = 0x38345241,
            #[doc = r#"[63:0] A:B:G:R 16:16:16:16 little endian"#]
            Abgr16161616 = 0x38344241,
            #[doc = r#"[7:0] C0:C1:C2:C3:C4:C5:C6:C7 1:1:1:1:1:1:1:1 eight pixels/byte"#]
            C1 = 0x20203143,
            #[doc = r#"[7:0] C0:C1:C2:C3 2:2:2:2 four pixels/byte"#]
            C2 = 0x20203243,
            #[doc = r#"[7:0] C0:C1 4:4 two pixels/byte"#]
            C4 = 0x20203443,
            #[doc = r#"[7:0] D0:D1:D2:D3:D4:D5:D6:D7 1:1:1:1:1:1:1:1 eight pixels/byte"#]
            D1 = 0x20203144,
            #[doc = r#"[7:0] D0:D1:D2:D3 2:2:2:2 four pixels/byte"#]
            D2 = 0x20203244,
            #[doc = r#"[7:0] D0:D1 4:4 two pixels/byte"#]
            D4 = 0x20203444,
            #[doc = r#"[7:0] D"#]
            D8 = 0x20203844,
            #[doc = r#"[7:0] R0:R1:R2:R3:R4:R5:R6:R7 1:1:1:1:1:1:1:1 eight pixels/byte"#]
            R1 = 0x20203152,
            #[doc = r#"[7:0] R0:R1:R2:R3 2:2:2:2 four pixels/byte"#]
            R2 = 0x20203252,
            #[doc = r#"[7:0] R0:R1 4:4 two pixels/byte"#]
            R4 = 0x20203452,
            #[doc = r#"[15:0] x:R 6:10 little endian"#]
            R10 = 0x20303152,
            #[doc = r#"[15:0] x:R 4:12 little endian"#]
            R12 = 0x20323152,
            #[doc = r#"[31:0] A:Cr:Cb:Y 8:8:8:8 little endian"#]
            Avuy8888 = 0x59555641,
            #[doc = r#"[31:0] X:Cr:Cb:Y 8:8:8:8 little endian"#]
            Xvuy8888 = 0x59555658,
            #[doc = r#"2x2 subsampled Cr:Cb plane 10 bits per channel packed"#]
            P030 = 0x30333050,
        }
        impl TryFrom<u32> for Format {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Argb8888),
                    1 => Ok(Self::Xrgb8888),
                    0x20203843 => Ok(Self::C8),
                    0x38424752 => Ok(Self::Rgb332),
                    0x38524742 => Ok(Self::Bgr233),
                    0x32315258 => Ok(Self::Xrgb4444),
                    0x32314258 => Ok(Self::Xbgr4444),
                    0x32315852 => Ok(Self::Rgbx4444),
                    0x32315842 => Ok(Self::Bgrx4444),
                    0x32315241 => Ok(Self::Argb4444),
                    0x32314241 => Ok(Self::Abgr4444),
                    0x32314152 => Ok(Self::Rgba4444),
                    0x32314142 => Ok(Self::Bgra4444),
                    0x35315258 => Ok(Self::Xrgb1555),
                    0x35314258 => Ok(Self::Xbgr1555),
                    0x35315852 => Ok(Self::Rgbx5551),
                    0x35315842 => Ok(Self::Bgrx5551),
                    0x35315241 => Ok(Self::Argb1555),
                    0x35314241 => Ok(Self::Abgr1555),
                    0x35314152 => Ok(Self::Rgba5551),
                    0x35314142 => Ok(Self::Bgra5551),
                    0x36314752 => Ok(Self::Rgb565),
                    0x36314742 => Ok(Self::Bgr565),
                    0x34324752 => Ok(Self::Rgb888),
                    0x34324742 => Ok(Self::Bgr888),
                    0x34324258 => Ok(Self::Xbgr8888),
                    0x34325852 => Ok(Self::Rgbx8888),
                    0x34325842 => Ok(Self::Bgrx8888),
                    0x34324241 => Ok(Self::Abgr8888),
                    0x34324152 => Ok(Self::Rgba8888),
                    0x34324142 => Ok(Self::Bgra8888),
                    0x30335258 => Ok(Self::Xrgb2101010),
                    0x30334258 => Ok(Self::Xbgr2101010),
                    0x30335852 => Ok(Self::Rgbx1010102),
                    0x30335842 => Ok(Self::Bgrx1010102),
                    0x30335241 => Ok(Self::Argb2101010),
                    0x30334241 => Ok(Self::Abgr2101010),
                    0x30334152 => Ok(Self::Rgba1010102),
                    0x30334142 => Ok(Self::Bgra1010102),
                    0x56595559 => Ok(Self::Yuyv),
                    0x55595659 => Ok(Self::Yvyu),
                    0x59565955 => Ok(Self::Uyvy),
                    0x59555956 => Ok(Self::Vyuy),
                    0x56555941 => Ok(Self::Ayuv),
                    0x3231564e => Ok(Self::Nv12),
                    0x3132564e => Ok(Self::Nv21),
                    0x3631564e => Ok(Self::Nv16),
                    0x3136564e => Ok(Self::Nv61),
                    0x39565559 => Ok(Self::Yuv410),
                    0x39555659 => Ok(Self::Yvu410),
                    0x31315559 => Ok(Self::Yuv411),
                    0x31315659 => Ok(Self::Yvu411),
                    0x32315559 => Ok(Self::Yuv420),
                    0x32315659 => Ok(Self::Yvu420),
                    0x36315559 => Ok(Self::Yuv422),
                    0x36315659 => Ok(Self::Yvu422),
                    0x34325559 => Ok(Self::Yuv444),
                    0x34325659 => Ok(Self::Yvu444),
                    0x20203852 => Ok(Self::R8),
                    0x20363152 => Ok(Self::R16),
                    0x38384752 => Ok(Self::Rg88),
                    0x38385247 => Ok(Self::Gr88),
                    0x32334752 => Ok(Self::Rg1616),
                    0x32335247 => Ok(Self::Gr1616),
                    0x48345258 => Ok(Self::Xrgb16161616f),
                    0x48344258 => Ok(Self::Xbgr16161616f),
                    0x48345241 => Ok(Self::Argb16161616f),
                    0x48344241 => Ok(Self::Abgr16161616f),
                    0x56555958 => Ok(Self::Xyuv8888),
                    0x34325556 => Ok(Self::Vuy888),
                    0x30335556 => Ok(Self::Vuy101010),
                    0x30313259 => Ok(Self::Y210),
                    0x32313259 => Ok(Self::Y212),
                    0x36313259 => Ok(Self::Y216),
                    0x30313459 => Ok(Self::Y410),
                    0x32313459 => Ok(Self::Y412),
                    0x36313459 => Ok(Self::Y416),
                    0x30335658 => Ok(Self::Xvyu2101010),
                    0x36335658 => Ok(Self::Xvyu1216161616),
                    0x38345658 => Ok(Self::Xvyu16161616),
                    0x304c3059 => Ok(Self::Y0l0),
                    0x304c3058 => Ok(Self::X0l0),
                    0x324c3059 => Ok(Self::Y0l2),
                    0x324c3058 => Ok(Self::X0l2),
                    0x38305559 => Ok(Self::Yuv4208bit),
                    0x30315559 => Ok(Self::Yuv42010bit),
                    0x38415258 => Ok(Self::Xrgb8888A8),
                    0x38414258 => Ok(Self::Xbgr8888A8),
                    0x38415852 => Ok(Self::Rgbx8888A8),
                    0x38415842 => Ok(Self::Bgrx8888A8),
                    0x38413852 => Ok(Self::Rgb888A8),
                    0x38413842 => Ok(Self::Bgr888A8),
                    0x38413552 => Ok(Self::Rgb565A8),
                    0x38413542 => Ok(Self::Bgr565A8),
                    0x3432564e => Ok(Self::Nv24),
                    0x3234564e => Ok(Self::Nv42),
                    0x30313250 => Ok(Self::P210),
                    0x30313050 => Ok(Self::P010),
                    0x32313050 => Ok(Self::P012),
                    0x36313050 => Ok(Self::P016),
                    0x30314241 => Ok(Self::Axbxgxrx106106106106),
                    0x3531564e => Ok(Self::Nv15),
                    0x30313451 => Ok(Self::Q410),
                    0x31303451 => Ok(Self::Q401),
                    0x38345258 => Ok(Self::Xrgb16161616),
                    0x38344258 => Ok(Self::Xbgr16161616),
                    0x38345241 => Ok(Self::Argb16161616),
                    0x38344241 => Ok(Self::Abgr16161616),
                    0x20203143 => Ok(Self::C1),
                    0x20203243 => Ok(Self::C2),
                    0x20203443 => Ok(Self::C4),
                    0x20203144 => Ok(Self::D1),
                    0x20203244 => Ok(Self::D2),
                    0x20203444 => Ok(Self::D4),
                    0x20203844 => Ok(Self::D8),
                    0x20203152 => Ok(Self::R1),
                    0x20203252 => Ok(Self::R2),
                    0x20203452 => Ok(Self::R4),
                    0x20303152 => Ok(Self::R10),
                    0x20323152 => Ok(Self::R12),
                    0x59555641 => Ok(Self::Avuy8888),
                    0x59555658 => Ok(Self::Xvuy8888),
                    0x30333050 => Ok(Self::P030),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"A singleton global object that provides support for shared"#]
        #[doc = r#"memory."#]
        #[doc = r#""#]
        #[doc = r#"Clients can create wl_shm_pool objects using the create_pool"#]
        #[doc = r#"request."#]
        #[doc = r#""#]
        #[doc = r#"On binding the wl_shm object one or more format events"#]
        #[doc = r#"are emitted to inform clients about the valid pixel formats"#]
        #[doc = r#"that can be used for buffers."#]
        pub trait WlShm: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_shm";
            const VERSION: u32 = 2;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wl_shm#{}.create_pool()", object.id);
                        self.create_pool(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.fd()?,
                            message.int()?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("wl_shm#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Create a new wl_shm_pool object."#]
            #[doc = r#""#]
            #[doc = r#"The pool can be used to create shared memory based buffer"#]
            #[doc = r#"objects.  The server will mmap size bytes of the passed file"#]
            #[doc = r#"descriptor, to use as backing memory for the pool."#]
            async fn create_pool(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create_pool: crate::wire::ObjectId,
                create_pool: rustix::fd::OwnedFd,
                create_pool: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Using this request a client can tell the server that it is not going to"#]
            #[doc = r#"use the shm object anymore."#]
            #[doc = r#""#]
            #[doc = r#"Objects created via this interface remain unaffected."#]
            async fn release(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Informs the client about a valid pixel format that"#]
            #[doc = r#"can be used for buffers. Known formats include"#]
            #[doc = r#"argb8888 and xrgb8888."#]
            async fn format(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                format: Format,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_shm#{}.format()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(format as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod wl_buffer {
        #[doc = r#"A buffer provides the content for a wl_surface. Buffers are"#]
        #[doc = r#"created through factory interfaces such as wl_shm, wp_linux_buffer_params"#]
        #[doc = r#"(from the linux-dmabuf protocol extension) or similar. It has a width and"#]
        #[doc = r#"a height and can be attached to a wl_surface, but the mechanism by which a"#]
        #[doc = r#"client provides and updates the contents is defined by the buffer factory"#]
        #[doc = r#"interface."#]
        #[doc = r#""#]
        #[doc = r#"Color channels are assumed to be electrical rather than optical (in other"#]
        #[doc = r#"words, encoded with a transfer function) unless otherwise specified. If"#]
        #[doc = r#"the buffer uses a format that has an alpha channel, the alpha channel is"#]
        #[doc = r#"assumed to be premultiplied into the electrical color channel values"#]
        #[doc = r#"(after transfer function encoding) unless otherwise specified."#]
        #[doc = r#""#]
        #[doc = r#"Note, because wl_buffer objects are created from multiple independent"#]
        #[doc = r#"factory interfaces, the wl_buffer interface is frozen at version 1."#]
        pub trait WlBuffer: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_buffer";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wl_buffer#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy a buffer. If and how you need to release the backing"#]
            #[doc = r#"storage is defined by the buffer factory interface."#]
            #[doc = r#""#]
            #[doc = r#"For possible side-effects to a surface, see wl_surface.attach."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Sent when this wl_buffer is no longer used by the compositor."#]
            #[doc = r#"The client is now free to reuse or destroy this buffer and its"#]
            #[doc = r#"backing storage."#]
            #[doc = r#""#]
            #[doc = r#"If a client receives a release event before the frame callback"#]
            #[doc = r#"requested in the same wl_surface.commit that attaches this"#]
            #[doc = r#"wl_buffer to a surface, then the client is immediately free to"#]
            #[doc = r#"reuse the buffer and its backing storage, and does not need a"#]
            #[doc = r#"second buffer for the next surface content update. Typically"#]
            #[doc = r#"this is possible, when the compositor maintains a copy of the"#]
            #[doc = r#"wl_surface contents, e.g. as a GL texture. This is an important"#]
            #[doc = r#"optimization for GL(ES) compositors with wl_shm clients."#]
            async fn release(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_buffer#{}.release()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod wl_data_offer {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Finish request was called untimely"#]
            InvalidFinish = 0,
            #[doc = r#"Action mask contains invalid values"#]
            InvalidActionMask = 1,
            #[doc = r#"Action argument has an invalid value"#]
            InvalidAction = 2,
            #[doc = r#"Offer doesn't accept this request"#]
            InvalidOffer = 3,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::InvalidFinish),
                    1 => Ok(Self::InvalidActionMask),
                    2 => Ok(Self::InvalidAction),
                    3 => Ok(Self::InvalidOffer),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"A wl_data_offer represents a piece of data offered for transfer"#]
        #[doc = r#"by another client (the source client).  It is used by the"#]
        #[doc = r#"copy-and-paste and drag-and-drop mechanisms.  The offer"#]
        #[doc = r#"describes the different mime types that the data can be"#]
        #[doc = r#"converted to and provides the mechanism for transferring the"#]
        #[doc = r#"data directly from the source client."#]
        pub trait WlDataOffer: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_data_offer";
            const VERSION: u32 = 3;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wl_data_offer#{}.accept()", object.id);
                        self.accept(object, client, message.uint()?, message.string()?)
                            .await
                    }
                    1 => {
                        tracing::debug!("wl_data_offer#{}.receive()", object.id);
                        self.receive(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.fd()?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("wl_data_offer#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    3 => {
                        tracing::debug!("wl_data_offer#{}.finish()", object.id);
                        self.finish(object, client).await
                    }
                    4 => {
                        tracing::debug!("wl_data_offer#{}.set_actions()", object.id);
                        self.set_actions(
                            object,
                            client,
                            message.uint()?.try_into()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Indicate that the client can accept the given mime type, or"#]
            #[doc = r#"NULL for not accepted."#]
            #[doc = r#""#]
            #[doc = r#"For objects of version 2 or older, this request is used by the"#]
            #[doc = r#"client to give feedback whether the client can receive the given"#]
            #[doc = r#"mime type, or NULL if none is accepted; the feedback does not"#]
            #[doc = r#"determine whether the drag-and-drop operation succeeds or not."#]
            #[doc = r#""#]
            #[doc = r#"For objects of version 3 or newer, this request determines the"#]
            #[doc = r#"final result of the drag-and-drop operation. If the end result"#]
            #[doc = r#"is that no mime types were accepted, the drag-and-drop operation"#]
            #[doc = r#"will be cancelled and the corresponding drag source will receive"#]
            #[doc = r#"wl_data_source.cancelled. Clients may still use this event in"#]
            #[doc = r#"conjunction with wl_data_source.action for feedback."#]
            async fn accept(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                accept: u32,
                accept: Option<String>,
            ) -> crate::server::Result<()>;
            #[doc = r#"To transfer the offered data, the client issues this request"#]
            #[doc = r#"and indicates the mime type it wants to receive.  The transfer"#]
            #[doc = r#"happens through the passed file descriptor (typically created"#]
            #[doc = r#"with the pipe system call).  The source client writes the data"#]
            #[doc = r#"in the mime type representation requested and then closes the"#]
            #[doc = r#"file descriptor."#]
            #[doc = r#""#]
            #[doc = r#"The receiving client reads from the read end of the pipe until"#]
            #[doc = r#"EOF and then closes its end, at which point the transfer is"#]
            #[doc = r#"complete."#]
            #[doc = r#""#]
            #[doc = r#"This request may happen multiple times for different mime types,"#]
            #[doc = r#"both before and after wl_data_device.drop. Drag-and-drop destination"#]
            #[doc = r#"clients may preemptively fetch data or examine it more closely to"#]
            #[doc = r#"determine acceptance."#]
            async fn receive(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                receive: String,
                receive: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()>;
            #[doc = r#"Destroy the data offer."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Notifies the compositor that the drag destination successfully"#]
            #[doc = r#"finished the drag-and-drop operation."#]
            #[doc = r#""#]
            #[doc = r#"Upon receiving this request, the compositor will emit"#]
            #[doc = r#"wl_data_source.dnd_finished on the drag source client."#]
            #[doc = r#""#]
            #[doc = r#"It is a client error to perform other requests than"#]
            #[doc = r#"wl_data_offer.destroy after this one. It is also an error to perform"#]
            #[doc = r#"this request after a NULL mime type has been set in"#]
            #[doc = r#"wl_data_offer.accept or no action was received through"#]
            #[doc = r#"wl_data_offer.action."#]
            #[doc = r#""#]
            #[doc = r#"If wl_data_offer.finish request is received for a non drag and drop"#]
            #[doc = r#"operation, the invalid_finish protocol error is raised."#]
            async fn finish(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Sets the actions that the destination side client supports for"#]
            #[doc = r#"this operation. This request may trigger the emission of"#]
            #[doc = r#"wl_data_source.action and wl_data_offer.action events if the compositor"#]
            #[doc = r#"needs to change the selected action."#]
            #[doc = r#""#]
            #[doc = r#"This request can be called multiple times throughout the"#]
            #[doc = r#"drag-and-drop operation, typically in response to wl_data_device.enter"#]
            #[doc = r#"or wl_data_device.motion events."#]
            #[doc = r#""#]
            #[doc = r#"This request determines the final result of the drag-and-drop"#]
            #[doc = r#"operation. If the end result is that no action is accepted,"#]
            #[doc = r#"the drag source will receive wl_data_source.cancelled."#]
            #[doc = r#""#]
            #[doc = r#"The dnd_actions argument must contain only values expressed in the"#]
            #[doc = r#"wl_data_device_manager.dnd_actions enum, and the preferred_action"#]
            #[doc = r#"argument must only contain one of those values set, otherwise it"#]
            #[doc = r#"will result in a protocol error."#]
            #[doc = r#""#]
            #[doc = r#"While managing an "ask" action, the destination drag-and-drop client"#]
            #[doc = r#"may perform further wl_data_offer.receive requests, and is expected"#]
            #[doc = r#"to perform one last wl_data_offer.set_actions request with a preferred"#]
            #[doc = r#"action other than "ask" (and optionally wl_data_offer.accept) before"#]
            #[doc = r#"requesting wl_data_offer.finish, in order to convey the action selected"#]
            #[doc = r#"by the user. If the preferred action is not in the"#]
            #[doc = r#"wl_data_offer.source_actions mask, an error will be raised."#]
            #[doc = r#""#]
            #[doc = r#"If the "ask" action is dismissed (e.g. user cancellation), the client"#]
            #[doc = r#"is expected to perform wl_data_offer.destroy right away."#]
            #[doc = r#""#]
            #[doc = r#"This request can only be made on drag-and-drop offers, a protocol error"#]
            #[doc = r#"will be raised otherwise."#]
            async fn set_actions(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_actions: super::super::wayland::wl_data_device_manager::DndAction,
                set_actions: super::super::wayland::wl_data_device_manager::DndAction,
            ) -> crate::server::Result<()>;
            #[doc = r#"Sent immediately after creating the wl_data_offer object.  One"#]
            #[doc = r#"event per offered mime type."#]
            async fn offer(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_offer#{}.offer()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(mime_type))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event indicates the actions offered by the data source. It"#]
            #[doc = r#"will be sent immediately after creating the wl_data_offer object,"#]
            #[doc = r#"or anytime the source side changes its offered actions through"#]
            #[doc = r#"wl_data_source.set_actions."#]
            async fn source_actions(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                source_actions: super::super::wayland::wl_data_device_manager::DndAction,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_offer#{}.source_actions()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(source_actions.bits())
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event indicates the action selected by the compositor after"#]
            #[doc = r#"matching the source/destination side actions. Only one action (or"#]
            #[doc = r#"none) will be offered here."#]
            #[doc = r#""#]
            #[doc = r#"This event can be emitted multiple times during the drag-and-drop"#]
            #[doc = r#"operation in response to destination side action changes through"#]
            #[doc = r#"wl_data_offer.set_actions."#]
            #[doc = r#""#]
            #[doc = r#"This event will no longer be emitted after wl_data_device.drop"#]
            #[doc = r#"happened on the drag-and-drop destination, the client must"#]
            #[doc = r#"honor the last action received, or the last preferred one set"#]
            #[doc = r#"through wl_data_offer.set_actions when handling an "ask" action."#]
            #[doc = r#""#]
            #[doc = r#"Compositors may also change the selected action on the fly, mainly"#]
            #[doc = r#"in response to keyboard modifier changes during the drag-and-drop"#]
            #[doc = r#"operation."#]
            #[doc = r#""#]
            #[doc = r#"The most recent action received is always the valid one. Prior to"#]
            #[doc = r#"receiving wl_data_device.drop, the chosen action may change (e.g."#]
            #[doc = r#"due to keyboard modifiers being pressed). At the time of receiving"#]
            #[doc = r#"wl_data_device.drop the drag-and-drop destination must honor the"#]
            #[doc = r#"last action received."#]
            #[doc = r#""#]
            #[doc = r#"Action changes may still happen after wl_data_device.drop,"#]
            #[doc = r#"especially on "ask" actions, where the drag-and-drop destination"#]
            #[doc = r#"may choose another action afterwards. Action changes happening"#]
            #[doc = r#"at this stage are always the result of inter-client negotiation, the"#]
            #[doc = r#"compositor shall no longer be able to induce a different action."#]
            #[doc = r#""#]
            #[doc = r#"Upon "ask" actions, it is expected that the drag-and-drop destination"#]
            #[doc = r#"may potentially choose a different action and/or mime type,"#]
            #[doc = r#"based on wl_data_offer.source_actions and finally chosen by the"#]
            #[doc = r#"user (e.g. popping up a menu with the available options). The"#]
            #[doc = r#"final wl_data_offer.set_actions and wl_data_offer.accept requests"#]
            #[doc = r#"must happen before the call to wl_data_offer.finish."#]
            async fn action(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                dnd_action: super::super::wayland::wl_data_device_manager::DndAction,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_offer#{}.action()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(dnd_action.bits())
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod wl_data_source {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Action mask contains invalid values"#]
            InvalidActionMask = 0,
            #[doc = r#"Source doesn't accept this request"#]
            InvalidSource = 1,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::InvalidActionMask),
                    1 => Ok(Self::InvalidSource),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"The wl_data_source object is the source side of a wl_data_offer."#]
        #[doc = r#"It is created by the source client in a data transfer and"#]
        #[doc = r#"provides a way to describe the offered data and a way to respond"#]
        #[doc = r#"to requests to transfer the data."#]
        pub trait WlDataSource: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_data_source";
            const VERSION: u32 = 3;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wl_data_source#{}.offer()", object.id);
                        self.offer(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("wl_data_source#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    2 => {
                        tracing::debug!("wl_data_source#{}.set_actions()", object.id);
                        self.set_actions(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"This request adds a mime type to the set of mime types"#]
            #[doc = r#"advertised to targets.  Can be called several times to offer"#]
            #[doc = r#"multiple types."#]
            async fn offer(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                offer: String,
            ) -> crate::server::Result<()>;
            #[doc = r#"Destroy the data source."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Sets the actions that the source side client supports for this"#]
            #[doc = r#"operation. This request may trigger wl_data_source.action and"#]
            #[doc = r#"wl_data_offer.action events if the compositor needs to change the"#]
            #[doc = r#"selected action."#]
            #[doc = r#""#]
            #[doc = r#"The dnd_actions argument must contain only values expressed in the"#]
            #[doc = r#"wl_data_device_manager.dnd_actions enum, otherwise it will result"#]
            #[doc = r#"in a protocol error."#]
            #[doc = r#""#]
            #[doc = r#"This request must be made once only, and can only be made on sources"#]
            #[doc = r#"used in drag-and-drop, so it must be performed before"#]
            #[doc = r#"wl_data_device.start_drag. Attempting to use the source other than"#]
            #[doc = r#"for drag-and-drop will raise a protocol error."#]
            async fn set_actions(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_actions: super::super::wayland::wl_data_device_manager::DndAction,
            ) -> crate::server::Result<()>;
            #[doc = r#"Sent when a target accepts pointer_focus or motion events.  If"#]
            #[doc = r#"a target does not accept any of the offered types, type is NULL."#]
            #[doc = r#""#]
            #[doc = r#"Used for feedback during drag-and-drop."#]
            async fn target(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: Option<String>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_source#{}.target()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(mime_type)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Request for data from the client.  Send the data as the"#]
            #[doc = r#"specified mime type over the passed file descriptor, then"#]
            #[doc = r#"close it."#]
            async fn send(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
                fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_source#{}.send()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(mime_type))
                    .put_fd(fd)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This data source is no longer valid. There are several reasons why"#]
            #[doc = r#"this could happen:"#]
            #[doc = r#""#]
            #[doc = r#"- The data source has been replaced by another data source."#]
            #[doc = r#"- The drag-and-drop operation was performed, but the drop destination"#]
            #[doc = r#"did not accept any of the mime types offered through"#]
            #[doc = r#"wl_data_source.target."#]
            #[doc = r#"- The drag-and-drop operation was performed, but the drop destination"#]
            #[doc = r#"did not select any of the actions present in the mask offered through"#]
            #[doc = r#"wl_data_source.action."#]
            #[doc = r#"- The drag-and-drop operation was performed but didn't happen over a"#]
            #[doc = r#"surface."#]
            #[doc = r#"- The compositor cancelled the drag-and-drop operation (e.g. compositor"#]
            #[doc = r#"dependent timeouts to avoid stale drag-and-drop transfers)."#]
            #[doc = r#""#]
            #[doc = r#"The client should clean up and destroy this data source."#]
            #[doc = r#""#]
            #[doc = r#"For objects of version 2 or older, wl_data_source.cancelled will"#]
            #[doc = r#"only be emitted if the data source was replaced by another data"#]
            #[doc = r#"source."#]
            async fn cancelled(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_source#{}.cancelled()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The user performed the drop action. This event does not indicate"#]
            #[doc = r#"acceptance, wl_data_source.cancelled may still be emitted afterwards"#]
            #[doc = r#"if the drop destination does not accept any mime type."#]
            #[doc = r#""#]
            #[doc = r#"However, this event might however not be received if the compositor"#]
            #[doc = r#"cancelled the drag-and-drop operation before this event could happen."#]
            #[doc = r#""#]
            #[doc = r#"Note that the data_source may still be used in the future and should"#]
            #[doc = r#"not be destroyed here."#]
            async fn dnd_drop_performed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_source#{}.dnd_drop_performed()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The drop destination finished interoperating with this data"#]
            #[doc = r#"source, so the client is now free to destroy this data source and"#]
            #[doc = r#"free all associated data."#]
            #[doc = r#""#]
            #[doc = r#"If the action used to perform the operation was "move", the"#]
            #[doc = r#"source can now delete the transferred data."#]
            async fn dnd_finished(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_source#{}.dnd_finished()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event indicates the action selected by the compositor after"#]
            #[doc = r#"matching the source/destination side actions. Only one action (or"#]
            #[doc = r#"none) will be offered here."#]
            #[doc = r#""#]
            #[doc = r#"This event can be emitted multiple times during the drag-and-drop"#]
            #[doc = r#"operation, mainly in response to destination side changes through"#]
            #[doc = r#"wl_data_offer.set_actions, and as the data device enters/leaves"#]
            #[doc = r#"surfaces."#]
            #[doc = r#""#]
            #[doc = r#"It is only possible to receive this event after"#]
            #[doc = r#"wl_data_source.dnd_drop_performed if the drag-and-drop operation"#]
            #[doc = r#"ended in an "ask" action, in which case the final wl_data_source.action"#]
            #[doc = r#"event will happen immediately before wl_data_source.dnd_finished."#]
            #[doc = r#""#]
            #[doc = r#"Compositors may also change the selected action on the fly, mainly"#]
            #[doc = r#"in response to keyboard modifier changes during the drag-and-drop"#]
            #[doc = r#"operation."#]
            #[doc = r#""#]
            #[doc = r#"The most recent action received is always the valid one. The chosen"#]
            #[doc = r#"action may change alongside negotiation (e.g. an "ask" action can turn"#]
            #[doc = r#"into a "move" operation), so the effects of the final action must"#]
            #[doc = r#"always be applied in wl_data_offer.dnd_finished."#]
            #[doc = r#""#]
            #[doc = r#"Clients can trigger cursor surface changes from this point, so"#]
            #[doc = r#"they reflect the current action."#]
            async fn action(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                dnd_action: super::super::wayland::wl_data_device_manager::DndAction,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_source#{}.action()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(dnd_action.bits())
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 5, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod wl_data_device {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Given wl_surface has another role"#]
            Role = 0,
            #[doc = r#"Source has already been used"#]
            UsedSource = 1,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Role),
                    1 => Ok(Self::UsedSource),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"There is one wl_data_device per seat which can be obtained"#]
        #[doc = r#"from the global wl_data_device_manager singleton."#]
        #[doc = r#""#]
        #[doc = r#"A wl_data_device provides access to inter-client data transfer"#]
        #[doc = r#"mechanisms such as copy-and-paste and drag-and-drop."#]
        pub trait WlDataDevice: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_data_device";
            const VERSION: u32 = 3;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wl_data_device#{}.start_drag()", object.id);
                        self.start_drag(
                            object,
                            client,
                            message.object()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.object()?,
                            message.uint()?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("wl_data_device#{}.set_selection()", object.id);
                        self.set_selection(object, client, message.object()?, message.uint()?)
                            .await
                    }
                    2 => {
                        tracing::debug!("wl_data_device#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"This request asks the compositor to start a drag-and-drop"#]
            #[doc = r#"operation on behalf of the client."#]
            #[doc = r#""#]
            #[doc = r#"The source argument is the data source that provides the data"#]
            #[doc = r#"for the eventual data transfer. If source is NULL, enter, leave"#]
            #[doc = r#"and motion events are sent only to the client that initiated the"#]
            #[doc = r#"drag and the client is expected to handle the data passing"#]
            #[doc = r#"internally. If source is destroyed, the drag-and-drop session will be"#]
            #[doc = r#"cancelled."#]
            #[doc = r#""#]
            #[doc = r#"The origin surface is the surface where the drag originates and"#]
            #[doc = r#"the client must have an active implicit grab that matches the"#]
            #[doc = r#"serial."#]
            #[doc = r#""#]
            #[doc = r#"The icon surface is an optional (can be NULL) surface that"#]
            #[doc = r#"provides an icon to be moved around with the cursor.  Initially,"#]
            #[doc = r#"the top-left corner of the icon surface is placed at the cursor"#]
            #[doc = r#"hotspot, but subsequent wl_surface.offset requests can move the"#]
            #[doc = r#"relative position. Attach requests must be confirmed with"#]
            #[doc = r#"wl_surface.commit as usual. The icon surface is given the role of"#]
            #[doc = r#"a drag-and-drop icon. If the icon surface already has another role,"#]
            #[doc = r#"it raises a protocol error."#]
            #[doc = r#""#]
            #[doc = r#"The input region is ignored for wl_surfaces with the role of a"#]
            #[doc = r#"drag-and-drop icon."#]
            #[doc = r#""#]
            #[doc = r#"The given source may not be used in any further set_selection or"#]
            #[doc = r#"start_drag requests. Attempting to reuse a previously-used source"#]
            #[doc = r#"may send a used_source error."#]
            async fn start_drag(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                start_drag: Option<crate::wire::ObjectId>,
                start_drag: crate::wire::ObjectId,
                start_drag: Option<crate::wire::ObjectId>,
                start_drag: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request asks the compositor to set the selection"#]
            #[doc = r#"to the data from the source on behalf of the client."#]
            #[doc = r#""#]
            #[doc = r#"To unset the selection, set the source to NULL."#]
            #[doc = r#""#]
            #[doc = r#"The given source may not be used in any further set_selection or"#]
            #[doc = r#"start_drag requests. Attempting to reuse a previously-used source"#]
            #[doc = r#"may send a used_source error."#]
            async fn set_selection(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_selection: Option<crate::wire::ObjectId>,
                set_selection: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request destroys the data device."#]
            async fn release(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"The data_offer event introduces a new wl_data_offer object,"#]
            #[doc = r#"which will subsequently be used in either the"#]
            #[doc = r#"data_device.enter event (for drag-and-drop) or the"#]
            #[doc = r#"data_device.selection event (for selections).  Immediately"#]
            #[doc = r#"following the data_device.data_offer event, the new data_offer"#]
            #[doc = r#"object will send out data_offer.offer events to describe the"#]
            #[doc = r#"mime types it offers."#]
            async fn data_offer(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_device#{}.data_offer()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent when an active drag-and-drop pointer enters"#]
            #[doc = r#"a surface owned by the client.  The position of the pointer at"#]
            #[doc = r#"enter time is provided by the x and y arguments, in surface-local"#]
            #[doc = r#"coordinates."#]
            async fn enter(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: crate::wire::ObjectId,
                x: crate::wire::Fixed,
                y: crate::wire::Fixed,
                id: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_device#{}.enter()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(surface))
                    .put_fixed(x)
                    .put_fixed(y)
                    .put_object(id)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent when the drag-and-drop pointer leaves the"#]
            #[doc = r#"surface and the session ends.  The client must destroy the"#]
            #[doc = r#"wl_data_offer introduced at enter time at this point."#]
            async fn leave(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_device#{}.leave()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent when the drag-and-drop pointer moves within"#]
            #[doc = r#"the currently focused surface. The new position of the pointer"#]
            #[doc = r#"is provided by the x and y arguments, in surface-local"#]
            #[doc = r#"coordinates."#]
            async fn motion(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                x: crate::wire::Fixed,
                y: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_device#{}.motion()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_fixed(x)
                    .put_fixed(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The event is sent when a drag-and-drop operation is ended"#]
            #[doc = r#"because the implicit grab is removed."#]
            #[doc = r#""#]
            #[doc = r#"The drag-and-drop destination is expected to honor the last action"#]
            #[doc = r#"received through wl_data_offer.action, if the resulting action is"#]
            #[doc = r#""copy" or "move", the destination can still perform"#]
            #[doc = r#"wl_data_offer.receive requests, and is expected to end all"#]
            #[doc = r#"transfers with a wl_data_offer.finish request."#]
            #[doc = r#""#]
            #[doc = r#"If the resulting action is "ask", the action will not be considered"#]
            #[doc = r#"final. The drag-and-drop destination is expected to perform one last"#]
            #[doc = r#"wl_data_offer.set_actions request, or wl_data_offer.destroy in order"#]
            #[doc = r#"to cancel the operation."#]
            async fn drop(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_device#{}.drop()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The selection event is sent out to notify the client of a new"#]
            #[doc = r#"wl_data_offer for the selection for this device.  The"#]
            #[doc = r#"data_device.data_offer and the data_offer.offer events are"#]
            #[doc = r#"sent out immediately before this event to introduce the data"#]
            #[doc = r#"offer object.  The selection event is sent to a client"#]
            #[doc = r#"immediately before receiving keyboard focus and when a new"#]
            #[doc = r#"selection is set while the client has keyboard focus.  The"#]
            #[doc = r#"data_offer is valid until a new data_offer or NULL is received"#]
            #[doc = r#"or until the client loses keyboard focus.  Switching surface with"#]
            #[doc = r#"keyboard focus within the same client doesn't mean a new selection"#]
            #[doc = r#"will be sent.  The client must destroy the previous selection"#]
            #[doc = r#"data_offer, if any, upon receiving this event."#]
            async fn selection(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_data_device#{}.selection()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_object(id).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 5, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod wl_data_device_manager {
        #[doc = r#"This is a bitmask of the available/preferred actions in a"#]
        #[doc = r#"drag-and-drop operation."#]
        #[doc = r#""#]
        #[doc = r#"In the compositor, the selected action is a result of matching the"#]
        #[doc = r#"actions offered by the source and destination sides.  "action" events"#]
        #[doc = r#"with a "none" action will be sent to both source and destination if"#]
        #[doc = r#"there is no match. All further checks will effectively happen on"#]
        #[doc = r#"(source actions  destination actions)."#]
        #[doc = r#""#]
        #[doc = r#"In addition, compositors may also pick different actions in"#]
        #[doc = r#"reaction to key modifiers being pressed. One common design that"#]
        #[doc = r#"is used in major toolkits (and the behavior recommended for"#]
        #[doc = r#"compositors) is:"#]
        #[doc = r#""#]
        #[doc = r#"- If no modifiers are pressed, the first match (in bit order)"#]
        #[doc = r#"will be used."#]
        #[doc = r#"- Pressing Shift selects "move", if enabled in the mask."#]
        #[doc = r#"- Pressing Control selects "copy", if enabled in the mask."#]
        #[doc = r#""#]
        #[doc = r#"Behavior beyond that is considered implementation-dependent."#]
        #[doc = r#"Compositors may for example bind other modifiers (like Alt/Meta)"#]
        #[doc = r#"or drags initiated with other buttons than BTN_LEFT to specific"#]
        #[doc = r#"actions (e.g. "ask")."#]
        bitflags::bitflags! {
                                    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
                                    pub struct DndAction: u32 {#[doc = r#"No action"#]
        const None = 0;#[doc = r#"Copy action"#]
        const Copy = 1;#[doc = r#"Move action"#]
        const Move = 2;#[doc = r#"Ask action"#]
        const Ask = 4;}
                                }
        impl TryFrom<u32> for DndAction {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = r#"The wl_data_device_manager is a singleton global object that"#]
        #[doc = r#"provides access to inter-client data transfer mechanisms such as"#]
        #[doc = r#"copy-and-paste and drag-and-drop.  These mechanisms are tied to"#]
        #[doc = r#"a wl_seat and this interface lets a client get a wl_data_device"#]
        #[doc = r#"corresponding to a wl_seat."#]
        #[doc = r#""#]
        #[doc = r#"Depending on the version bound, the objects created from the bound"#]
        #[doc = r#"wl_data_device_manager object will have different requirements for"#]
        #[doc = r#"functioning properly. See wl_data_source.set_actions,"#]
        #[doc = r#"wl_data_offer.accept and wl_data_offer.finish for details."#]
        pub trait WlDataDeviceManager: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_data_device_manager";
            const VERSION: u32 = 3;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "wl_data_device_manager#{}.create_data_source()",
                            object.id
                        );
                        self.create_data_source(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("wl_data_device_manager#{}.get_data_device()", object.id);
                        self.get_data_device(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Create a new data source."#]
            async fn create_data_source(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create_data_source: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Create a new data device for a given seat."#]
            async fn get_data_device(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_data_device: crate::wire::ObjectId,
                get_data_device: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wl_shell {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Given wl_surface has another role"#]
            Role = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Role),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"This interface is implemented by servers that provide"#]
        #[doc = r#"desktop-style user interfaces."#]
        #[doc = r#""#]
        #[doc = r#"It allows clients to associate a wl_shell_surface with"#]
        #[doc = r#"a basic surface."#]
        #[doc = r#""#]
        #[doc = r#"Note! This protocol is deprecated and not intended for production use."#]
        #[doc = r#"For desktop-style user interfaces, use xdg_shell. Compositors and clients"#]
        #[doc = r#"should not implement this interface."#]
        pub trait WlShell: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_shell";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wl_shell#{}.get_shell_surface()", object.id);
                        self.get_shell_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Create a shell surface for an existing surface. This gives"#]
            #[doc = r#"the wl_surface the role of a shell surface. If the wl_surface"#]
            #[doc = r#"already has another role, it raises a protocol error."#]
            #[doc = r#""#]
            #[doc = r#"Only one shell surface can be associated with a given surface."#]
            async fn get_shell_surface(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_shell_surface: crate::wire::ObjectId,
                get_shell_surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wl_shell_surface {
        #[doc = r#"These values are used to indicate which edge of a surface"#]
        #[doc = r#"is being dragged in a resize operation. The server may"#]
        #[doc = r#"use this information to adapt its behavior, e.g. choose"#]
        #[doc = r#"an appropriate cursor image."#]
        bitflags::bitflags! {
                                    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
                                    pub struct Resize: u32 {#[doc = r#"No edge"#]
        const None = 0;#[doc = r#"Top edge"#]
        const Top = 1;#[doc = r#"Bottom edge"#]
        const Bottom = 2;#[doc = r#"Left edge"#]
        const Left = 4;#[doc = r#"Top and left edges"#]
        const TopLeft = 5;#[doc = r#"Bottom and left edges"#]
        const BottomLeft = 6;#[doc = r#"Right edge"#]
        const Right = 8;#[doc = r#"Top and right edges"#]
        const TopRight = 9;#[doc = r#"Bottom and right edges"#]
        const BottomRight = 10;}
                                }
        impl TryFrom<u32> for Resize {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = r#"These flags specify details of the expected behaviour"#]
        #[doc = r#"of transient surfaces. Used in the set_transient request."#]
        bitflags::bitflags! {
                                    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
                                    pub struct Transient: u32 {#[doc = r#"Do not set keyboard focus"#]
        const Inactive = 0x1;}
                                }
        impl TryFrom<u32> for Transient {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = r#"Hints to indicate to the compositor how to deal with a conflict"#]
        #[doc = r#"between the dimensions of the surface and the dimensions of the"#]
        #[doc = r#"output. The compositor is free to ignore this parameter."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum FullscreenMethod {
            #[doc = r#"No preference, apply default policy"#]
            Default = 0,
            #[doc = r#"Scale, preserve the surface's aspect ratio and center on output"#]
            Scale = 1,
            #[doc = r#"Switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch"#]
            Driver = 2,
            #[doc = r#"No upscaling, center on output and add black borders to compensate size mismatch"#]
            Fill = 3,
        }
        impl TryFrom<u32> for FullscreenMethod {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Default),
                    1 => Ok(Self::Scale),
                    2 => Ok(Self::Driver),
                    3 => Ok(Self::Fill),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"An interface that may be implemented by a wl_surface, for"#]
        #[doc = r#"implementations that provide a desktop-style user interface."#]
        #[doc = r#""#]
        #[doc = r#"It provides requests to treat surfaces like toplevel, fullscreen"#]
        #[doc = r#"or popup windows, move, resize or maximize them, associate"#]
        #[doc = r#"metadata like title and class, etc."#]
        #[doc = r#""#]
        #[doc = r#"On the server side the object is automatically destroyed when"#]
        #[doc = r#"the related wl_surface is destroyed. On the client side,"#]
        #[doc = r#"wl_shell_surface_destroy() must be called before destroying"#]
        #[doc = r#"the wl_surface object."#]
        pub trait WlShellSurface: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_shell_surface";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wl_shell_surface#{}.pong()", object.id);
                        self.pong(object, client, message.uint()?).await
                    }
                    1 => {
                        tracing::debug!("wl_shell_surface#{}.move()", object.id);
                        self.r#move(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("wl_shell_surface#{}.resize()", object.id);
                        self.resize(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    3 => {
                        tracing::debug!("wl_shell_surface#{}.set_toplevel()", object.id);
                        self.set_toplevel(object, client).await
                    }
                    4 => {
                        tracing::debug!("wl_shell_surface#{}.set_transient()", object.id);
                        self.set_transient(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    5 => {
                        tracing::debug!("wl_shell_surface#{}.set_fullscreen()", object.id);
                        self.set_fullscreen(
                            object,
                            client,
                            message.uint()?.try_into()?,
                            message.uint()?,
                            message.object()?,
                        )
                        .await
                    }
                    6 => {
                        tracing::debug!("wl_shell_surface#{}.set_popup()", object.id);
                        self.set_popup(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    7 => {
                        tracing::debug!("wl_shell_surface#{}.set_maximized()", object.id);
                        self.set_maximized(object, client, message.object()?).await
                    }
                    8 => {
                        tracing::debug!("wl_shell_surface#{}.set_title()", object.id);
                        self.set_title(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    9 => {
                        tracing::debug!("wl_shell_surface#{}.set_class()", object.id);
                        self.set_class(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"A client must respond to a ping event with a pong request or"#]
            #[doc = r#"the client may be deemed unresponsive."#]
            async fn pong(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                pong: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Start a pointer-driven move of the surface."#]
            #[doc = r#""#]
            #[doc = r#"This request must be used in response to a button press event."#]
            #[doc = r#"The server may ignore move requests depending on the state of"#]
            #[doc = r#"the surface (e.g. fullscreen or maximized)."#]
            async fn r#move(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                r#move: crate::wire::ObjectId,
                r#move: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Start a pointer-driven resizing of the surface."#]
            #[doc = r#""#]
            #[doc = r#"This request must be used in response to a button press event."#]
            #[doc = r#"The server may ignore resize requests depending on the state of"#]
            #[doc = r#"the surface (e.g. fullscreen or maximized)."#]
            async fn resize(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                resize: crate::wire::ObjectId,
                resize: u32,
                resize: Resize,
            ) -> crate::server::Result<()>;
            #[doc = r#"Map the surface as a toplevel surface."#]
            #[doc = r#""#]
            #[doc = r#"A toplevel surface is not fullscreen, maximized or transient."#]
            async fn set_toplevel(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Map the surface relative to an existing surface."#]
            #[doc = r#""#]
            #[doc = r#"The x and y arguments specify the location of the upper left"#]
            #[doc = r#"corner of the surface relative to the upper left corner of the"#]
            #[doc = r#"parent surface, in surface-local coordinates."#]
            #[doc = r#""#]
            #[doc = r#"The flags argument controls details of the transient behaviour."#]
            async fn set_transient(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_transient: crate::wire::ObjectId,
                set_transient: i32,
                set_transient: i32,
                set_transient: Transient,
            ) -> crate::server::Result<()>;
            #[doc = r#"Map the surface as a fullscreen surface."#]
            #[doc = r#""#]
            #[doc = r#"If an output parameter is given then the surface will be made"#]
            #[doc = r#"fullscreen on that output. If the client does not specify the"#]
            #[doc = r#"output then the compositor will apply its policy - usually"#]
            #[doc = r#"choosing the output on which the surface has the biggest surface"#]
            #[doc = r#"area."#]
            #[doc = r#""#]
            #[doc = r#"The client may specify a method to resolve a size conflict"#]
            #[doc = r#"between the output size and the surface size - this is provided"#]
            #[doc = r#"through the method parameter."#]
            #[doc = r#""#]
            #[doc = r#"The framerate parameter is used only when the method is set"#]
            #[doc = r#"to "driver", to indicate the preferred framerate. A value of 0"#]
            #[doc = r#"indicates that the client does not care about framerate.  The"#]
            #[doc = r#"framerate is specified in mHz, that is framerate of 60000 is 60Hz."#]
            #[doc = r#""#]
            #[doc = r#"A method of "scale" or "driver" implies a scaling operation of"#]
            #[doc = r#"the surface, either via a direct scaling operation or a change of"#]
            #[doc = r#"the output mode. This will override any kind of output scaling, so"#]
            #[doc = r#"that mapping a surface with a buffer size equal to the mode can"#]
            #[doc = r#"fill the screen independent of buffer_scale."#]
            #[doc = r#""#]
            #[doc = r#"A method of "fill" means we don't scale up the buffer, however"#]
            #[doc = r#"any output scale is applied. This means that you may run into"#]
            #[doc = r#"an edge case where the application maps a buffer with the same"#]
            #[doc = r#"size of the output mode but buffer_scale 1 (thus making a"#]
            #[doc = r#"surface larger than the output). In this case it is allowed to"#]
            #[doc = r#"downscale the results to fit the screen."#]
            #[doc = r#""#]
            #[doc = r#"The compositor must reply to this request with a configure event"#]
            #[doc = r#"with the dimensions for the output on which the surface will"#]
            #[doc = r#"be made fullscreen."#]
            async fn set_fullscreen(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_fullscreen: FullscreenMethod,
                set_fullscreen: u32,
                set_fullscreen: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = r#"Map the surface as a popup."#]
            #[doc = r#""#]
            #[doc = r#"A popup surface is a transient surface with an added pointer"#]
            #[doc = r#"grab."#]
            #[doc = r#""#]
            #[doc = r#"An existing implicit grab will be changed to owner-events mode,"#]
            #[doc = r#"and the popup grab will continue after the implicit grab ends"#]
            #[doc = r#"(i.e. releasing the mouse button does not cause the popup to"#]
            #[doc = r#"be unmapped)."#]
            #[doc = r#""#]
            #[doc = r#"The popup grab continues until the window is destroyed or a"#]
            #[doc = r#"mouse button is pressed in any other client's window. A click"#]
            #[doc = r#"in any of the client's surfaces is reported as normal, however,"#]
            #[doc = r#"clicks in other clients' surfaces will be discarded and trigger"#]
            #[doc = r#"the callback."#]
            #[doc = r#""#]
            #[doc = r#"The x and y arguments specify the location of the upper left"#]
            #[doc = r#"corner of the surface relative to the upper left corner of the"#]
            #[doc = r#"parent surface, in surface-local coordinates."#]
            async fn set_popup(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_popup: crate::wire::ObjectId,
                set_popup: u32,
                set_popup: crate::wire::ObjectId,
                set_popup: i32,
                set_popup: i32,
                set_popup: Transient,
            ) -> crate::server::Result<()>;
            #[doc = r#"Map the surface as a maximized surface."#]
            #[doc = r#""#]
            #[doc = r#"If an output parameter is given then the surface will be"#]
            #[doc = r#"maximized on that output. If the client does not specify the"#]
            #[doc = r#"output then the compositor will apply its policy - usually"#]
            #[doc = r#"choosing the output on which the surface has the biggest surface"#]
            #[doc = r#"area."#]
            #[doc = r#""#]
            #[doc = r#"The compositor will reply with a configure event telling"#]
            #[doc = r#"the expected new surface size. The operation is completed"#]
            #[doc = r#"on the next buffer attach to this surface."#]
            #[doc = r#""#]
            #[doc = r#"A maximized surface typically fills the entire output it is"#]
            #[doc = r#"bound to, except for desktop elements such as panels. This is"#]
            #[doc = r#"the main difference between a maximized shell surface and a"#]
            #[doc = r#"fullscreen shell surface."#]
            #[doc = r#""#]
            #[doc = r#"The details depend on the compositor implementation."#]
            async fn set_maximized(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_maximized: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set a short title for the surface."#]
            #[doc = r#""#]
            #[doc = r#"This string may be used to identify the surface in a task bar,"#]
            #[doc = r#"window list, or other user interface elements provided by the"#]
            #[doc = r#"compositor."#]
            #[doc = r#""#]
            #[doc = r#"The string must be encoded in UTF-8."#]
            async fn set_title(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_title: String,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set a class for the surface."#]
            #[doc = r#""#]
            #[doc = r#"The surface class identifies the general class of applications"#]
            #[doc = r#"to which the surface belongs. A common convention is to use the"#]
            #[doc = r#"file name (or the full path if it is a non-standard location) of"#]
            #[doc = r#"the application's .desktop file as the class."#]
            async fn set_class(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_class: String,
            ) -> crate::server::Result<()>;
            #[doc = r#"Ping a client to check if it is receiving events and sending"#]
            #[doc = r#"requests. A client is expected to reply with a pong request."#]
            async fn ping(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_shell_surface#{}.ping()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The configure event asks the client to resize its surface."#]
            #[doc = r#""#]
            #[doc = r#"The size is a hint, in the sense that the client is free to"#]
            #[doc = r#"ignore it if it doesn't resize, pick a smaller size (to"#]
            #[doc = r#"satisfy aspect ratio or resize in steps of NxM pixels)."#]
            #[doc = r#""#]
            #[doc = r#"The edges parameter provides a hint about how the surface"#]
            #[doc = r#"was resized. The client may use this information to decide"#]
            #[doc = r#"how to adjust its content to the new size (e.g. a scrolling"#]
            #[doc = r#"area might adjust its content position to leave the viewable"#]
            #[doc = r#"content unmoved)."#]
            #[doc = r#""#]
            #[doc = r#"The client is free to dismiss all but the last configure"#]
            #[doc = r#"event it received."#]
            #[doc = r#""#]
            #[doc = r#"The width and height arguments specify the size of the window"#]
            #[doc = r#"in surface-local coordinates."#]
            async fn configure(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                edges: Resize,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_shell_surface#{}.configure()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(edges.bits())
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The popup_done event is sent out when a popup grab is broken,"#]
            #[doc = r#"that is, when the user clicks a surface that doesn't belong"#]
            #[doc = r#"to the client owning the popup surface."#]
            async fn popup_done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_shell_surface#{}.popup_done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod wl_surface {
        #[doc = r#"These errors can be emitted in response to wl_surface requests."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Buffer scale value is invalid"#]
            InvalidScale = 0,
            #[doc = r#"Buffer transform value is invalid"#]
            InvalidTransform = 1,
            #[doc = r#"Buffer size is invalid"#]
            InvalidSize = 2,
            #[doc = r#"Buffer offset is invalid"#]
            InvalidOffset = 3,
            #[doc = r#"Surface was destroyed before its role object"#]
            DefunctRoleObject = 4,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::InvalidScale),
                    1 => Ok(Self::InvalidTransform),
                    2 => Ok(Self::InvalidSize),
                    3 => Ok(Self::InvalidOffset),
                    4 => Ok(Self::DefunctRoleObject),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"A surface is a rectangular area that may be displayed on zero"#]
        #[doc = r#"or more outputs, and shown any number of times at the compositor's"#]
        #[doc = r#"discretion. They can present wl_buffers, receive user input, and"#]
        #[doc = r#"define a local coordinate system."#]
        #[doc = r#""#]
        #[doc = r#"The size of a surface (and relative positions on it) is described"#]
        #[doc = r#"in surface-local coordinates, which may differ from the buffer"#]
        #[doc = r#"coordinates of the pixel content, in case a buffer_transform"#]
        #[doc = r#"or a buffer_scale is used."#]
        #[doc = r#""#]
        #[doc = r#"A surface without a "role" is fairly useless: a compositor does"#]
        #[doc = r#"not know where, when or how to present it. The role is the"#]
        #[doc = r#"purpose of a wl_surface. Examples of roles are a cursor for a"#]
        #[doc = r#"pointer (as set by wl_pointer.set_cursor), a drag icon"#]
        #[doc = r#"(wl_data_device.start_drag), a sub-surface"#]
        #[doc = r#"(wl_subcompositor.get_subsurface), and a window as defined by a"#]
        #[doc = r#"shell protocol (e.g. wl_shell.get_shell_surface)."#]
        #[doc = r#""#]
        #[doc = r#"A surface can have only one role at a time. Initially a"#]
        #[doc = r#"wl_surface does not have a role. Once a wl_surface is given a"#]
        #[doc = r#"role, it is set permanently for the whole lifetime of the"#]
        #[doc = r#"wl_surface object. Giving the current role again is allowed,"#]
        #[doc = r#"unless explicitly forbidden by the relevant interface"#]
        #[doc = r#"specification."#]
        #[doc = r#""#]
        #[doc = r#"Surface roles are given by requests in other interfaces such as"#]
        #[doc = r#"wl_pointer.set_cursor. The request should explicitly mention"#]
        #[doc = r#"that this request gives a role to a wl_surface. Often, this"#]
        #[doc = r#"request also creates a new protocol object that represents the"#]
        #[doc = r#"role and adds additional functionality to wl_surface. When a"#]
        #[doc = r#"client wants to destroy a wl_surface, they must destroy this role"#]
        #[doc = r#"object before the wl_surface, otherwise a defunct_role_object error is"#]
        #[doc = r#"sent."#]
        #[doc = r#""#]
        #[doc = r#"Destroying the role object does not remove the role from the"#]
        #[doc = r#"wl_surface, but it may stop the wl_surface from "playing the role"."#]
        #[doc = r#"For instance, if a wl_subsurface object is destroyed, the wl_surface"#]
        #[doc = r#"it was created for will be unmapped and forget its position and"#]
        #[doc = r#"z-order. It is allowed to create a wl_subsurface for the same"#]
        #[doc = r#"wl_surface again, but it is not allowed to use the wl_surface as"#]
        #[doc = r#"a cursor (cursor is a different role than sub-surface, and role"#]
        #[doc = r#"switching is not allowed)."#]
        pub trait WlSurface: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_surface";
            const VERSION: u32 = 6;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wl_surface#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("wl_surface#{}.attach()", object.id);
                        self.attach(
                            object,
                            client,
                            message.object()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("wl_surface#{}.damage()", object.id);
                        self.damage(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    3 => {
                        tracing::debug!("wl_surface#{}.frame()", object.id);
                        self.frame(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    4 => {
                        tracing::debug!("wl_surface#{}.set_opaque_region()", object.id);
                        self.set_opaque_region(object, client, message.object()?)
                            .await
                    }
                    5 => {
                        tracing::debug!("wl_surface#{}.set_input_region()", object.id);
                        self.set_input_region(object, client, message.object()?)
                            .await
                    }
                    6 => {
                        tracing::debug!("wl_surface#{}.commit()", object.id);
                        self.commit(object, client).await
                    }
                    7 => {
                        tracing::debug!("wl_surface#{}.set_buffer_transform()", object.id);
                        self.set_buffer_transform(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    8 => {
                        tracing::debug!("wl_surface#{}.set_buffer_scale()", object.id);
                        self.set_buffer_scale(object, client, message.int()?).await
                    }
                    9 => {
                        tracing::debug!("wl_surface#{}.damage_buffer()", object.id);
                        self.damage_buffer(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    10 => {
                        tracing::debug!("wl_surface#{}.offset()", object.id);
                        self.offset(object, client, message.int()?, message.int()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Deletes the surface and invalidates its object ID."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set a buffer as the content of this surface."#]
            #[doc = r#""#]
            #[doc = r#"The new size of the surface is calculated based on the buffer"#]
            #[doc = r#"size transformed by the inverse buffer_transform and the"#]
            #[doc = r#"inverse buffer_scale. This means that at commit time the supplied"#]
            #[doc = r#"buffer size must be an integer multiple of the buffer_scale. If"#]
            #[doc = r#"that's not the case, an invalid_size error is sent."#]
            #[doc = r#""#]
            #[doc = r#"The x and y arguments specify the location of the new pending"#]
            #[doc = r#"buffer's upper left corner, relative to the current buffer's upper"#]
            #[doc = r#"left corner, in surface-local coordinates. In other words, the"#]
            #[doc = r#"x and y, combined with the new surface size define in which"#]
            #[doc = r#"directions the surface's size changes. Setting anything other than 0"#]
            #[doc = r#"as x and y arguments is discouraged, and should instead be replaced"#]
            #[doc = r#"with using the separate wl_surface.offset request."#]
            #[doc = r#""#]
            #[doc = r#"When the bound wl_surface version is 5 or higher, passing any"#]
            #[doc = r#"non-zero x or y is a protocol violation, and will result in an"#]
            #[doc = r#"'invalid_offset' error being raised. The x and y arguments are ignored"#]
            #[doc = r#"and do not change the pending state. To achieve equivalent semantics,"#]
            #[doc = r#"use wl_surface.offset."#]
            #[doc = r#""#]
            #[doc = r#"Surface contents are double-buffered state, see wl_surface.commit."#]
            #[doc = r#""#]
            #[doc = r#"The initial surface contents are void; there is no content."#]
            #[doc = r#"wl_surface.attach assigns the given wl_buffer as the pending"#]
            #[doc = r#"wl_buffer. wl_surface.commit makes the pending wl_buffer the new"#]
            #[doc = r#"surface contents, and the size of the surface becomes the size"#]
            #[doc = r#"calculated from the wl_buffer, as described above. After commit,"#]
            #[doc = r#"there is no pending buffer until the next attach."#]
            #[doc = r#""#]
            #[doc = r#"Committing a pending wl_buffer allows the compositor to read the"#]
            #[doc = r#"pixels in the wl_buffer. The compositor may access the pixels at"#]
            #[doc = r#"any time after the wl_surface.commit request. When the compositor"#]
            #[doc = r#"will not access the pixels anymore, it will send the"#]
            #[doc = r#"wl_buffer.release event. Only after receiving wl_buffer.release,"#]
            #[doc = r#"the client may reuse the wl_buffer. A wl_buffer that has been"#]
            #[doc = r#"attached and then replaced by another attach instead of committed"#]
            #[doc = r#"will not receive a release event, and is not used by the"#]
            #[doc = r#"compositor."#]
            #[doc = r#""#]
            #[doc = r#"If a pending wl_buffer has been committed to more than one wl_surface,"#]
            #[doc = r#"the delivery of wl_buffer.release events becomes undefined. A well"#]
            #[doc = r#"behaved client should not rely on wl_buffer.release events in this"#]
            #[doc = r#"case. Alternatively, a client could create multiple wl_buffer objects"#]
            #[doc = r#"from the same backing storage or use wp_linux_buffer_release."#]
            #[doc = r#""#]
            #[doc = r#"Destroying the wl_buffer after wl_buffer.release does not change"#]
            #[doc = r#"the surface contents. Destroying the wl_buffer before wl_buffer.release"#]
            #[doc = r#"is allowed as long as the underlying buffer storage isn't re-used (this"#]
            #[doc = r#"can happen e.g. on client process termination). However, if the client"#]
            #[doc = r#"destroys the wl_buffer before receiving the wl_buffer.release event and"#]
            #[doc = r#"mutates the underlying buffer storage, the surface contents become"#]
            #[doc = r#"undefined immediately."#]
            #[doc = r#""#]
            #[doc = r#"If wl_surface.attach is sent with a NULL wl_buffer, the"#]
            #[doc = r#"following wl_surface.commit will remove the surface content."#]
            #[doc = r#""#]
            #[doc = r#"If a pending wl_buffer has been destroyed, the result is not specified."#]
            #[doc = r#"Many compositors are known to remove the surface content on the following"#]
            #[doc = r#"wl_surface.commit, but this behaviour is not universal. Clients seeking to"#]
            #[doc = r#"maximise compatibility should not destroy pending buffers and should"#]
            #[doc = r#"ensure that they explicitly remove content from surfaces, even after"#]
            #[doc = r#"destroying buffers."#]
            async fn attach(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                attach: Option<crate::wire::ObjectId>,
                attach: i32,
                attach: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request is used to describe the regions where the pending"#]
            #[doc = r#"buffer is different from the current surface contents, and where"#]
            #[doc = r#"the surface therefore needs to be repainted. The compositor"#]
            #[doc = r#"ignores the parts of the damage that fall outside of the surface."#]
            #[doc = r#""#]
            #[doc = r#"Damage is double-buffered state, see wl_surface.commit."#]
            #[doc = r#""#]
            #[doc = r#"The damage rectangle is specified in surface-local coordinates,"#]
            #[doc = r#"where x and y specify the upper left corner of the damage rectangle."#]
            #[doc = r#""#]
            #[doc = r#"The initial value for pending damage is empty: no damage."#]
            #[doc = r#"wl_surface.damage adds pending damage: the new pending damage"#]
            #[doc = r#"is the union of old pending damage and the given rectangle."#]
            #[doc = r#""#]
            #[doc = r#"wl_surface.commit assigns pending damage as the current damage,"#]
            #[doc = r#"and clears pending damage. The server will clear the current"#]
            #[doc = r#"damage as it repaints the surface."#]
            #[doc = r#""#]
            #[doc = r#"Note! New clients should not use this request. Instead damage can be"#]
            #[doc = r#"posted with wl_surface.damage_buffer which uses buffer coordinates"#]
            #[doc = r#"instead of surface coordinates."#]
            async fn damage(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                damage: i32,
                damage: i32,
                damage: i32,
                damage: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Request a notification when it is a good time to start drawing a new"#]
            #[doc = r#"frame, by creating a frame callback. This is useful for throttling"#]
            #[doc = r#"redrawing operations, and driving animations."#]
            #[doc = r#""#]
            #[doc = r#"When a client is animating on a wl_surface, it can use the 'frame'"#]
            #[doc = r#"request to get notified when it is a good time to draw and commit the"#]
            #[doc = r#"next frame of animation. If the client commits an update earlier than"#]
            #[doc = r#"that, it is likely that some updates will not make it to the display,"#]
            #[doc = r#"and the client is wasting resources by drawing too often."#]
            #[doc = r#""#]
            #[doc = r#"The frame request will take effect on the next wl_surface.commit."#]
            #[doc = r#"The notification will only be posted for one frame unless"#]
            #[doc = r#"requested again. For a wl_surface, the notifications are posted in"#]
            #[doc = r#"the order the frame requests were committed."#]
            #[doc = r#""#]
            #[doc = r#"The server must send the notifications so that a client"#]
            #[doc = r#"will not send excessive updates, while still allowing"#]
            #[doc = r#"the highest possible update rate for clients that wait for the reply"#]
            #[doc = r#"before drawing again. The server should give some time for the client"#]
            #[doc = r#"to draw and commit after sending the frame callback events to let it"#]
            #[doc = r#"hit the next output refresh."#]
            #[doc = r#""#]
            #[doc = r#"A server should avoid signaling the frame callbacks if the"#]
            #[doc = r#"surface is not visible in any way, e.g. the surface is off-screen,"#]
            #[doc = r#"or completely obscured by other opaque surfaces."#]
            #[doc = r#""#]
            #[doc = r#"The object returned by this request will be destroyed by the"#]
            #[doc = r#"compositor after the callback is fired and as such the client must not"#]
            #[doc = r#"attempt to use it after that point."#]
            #[doc = r#""#]
            #[doc = r#"The callback_data passed in the callback is the current time, in"#]
            #[doc = r#"milliseconds, with an undefined base."#]
            async fn frame(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                frame: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request sets the region of the surface that contains"#]
            #[doc = r#"opaque content."#]
            #[doc = r#""#]
            #[doc = r#"The opaque region is an optimization hint for the compositor"#]
            #[doc = r#"that lets it optimize the redrawing of content behind opaque"#]
            #[doc = r#"regions.  Setting an opaque region is not required for correct"#]
            #[doc = r#"behaviour, but marking transparent content as opaque will result"#]
            #[doc = r#"in repaint artifacts."#]
            #[doc = r#""#]
            #[doc = r#"The opaque region is specified in surface-local coordinates."#]
            #[doc = r#""#]
            #[doc = r#"The compositor ignores the parts of the opaque region that fall"#]
            #[doc = r#"outside of the surface."#]
            #[doc = r#""#]
            #[doc = r#"Opaque region is double-buffered state, see wl_surface.commit."#]
            #[doc = r#""#]
            #[doc = r#"wl_surface.set_opaque_region changes the pending opaque region."#]
            #[doc = r#"wl_surface.commit copies the pending region to the current region."#]
            #[doc = r#"Otherwise, the pending and current regions are never changed."#]
            #[doc = r#""#]
            #[doc = r#"The initial value for an opaque region is empty. Setting the pending"#]
            #[doc = r#"opaque region has copy semantics, and the wl_region object can be"#]
            #[doc = r#"destroyed immediately. A NULL wl_region causes the pending opaque"#]
            #[doc = r#"region to be set to empty."#]
            async fn set_opaque_region(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_opaque_region: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request sets the region of the surface that can receive"#]
            #[doc = r#"pointer and touch events."#]
            #[doc = r#""#]
            #[doc = r#"Input events happening outside of this region will try the next"#]
            #[doc = r#"surface in the server surface stack. The compositor ignores the"#]
            #[doc = r#"parts of the input region that fall outside of the surface."#]
            #[doc = r#""#]
            #[doc = r#"The input region is specified in surface-local coordinates."#]
            #[doc = r#""#]
            #[doc = r#"Input region is double-buffered state, see wl_surface.commit."#]
            #[doc = r#""#]
            #[doc = r#"wl_surface.set_input_region changes the pending input region."#]
            #[doc = r#"wl_surface.commit copies the pending region to the current region."#]
            #[doc = r#"Otherwise the pending and current regions are never changed,"#]
            #[doc = r#"except cursor and icon surfaces are special cases, see"#]
            #[doc = r#"wl_pointer.set_cursor and wl_data_device.start_drag."#]
            #[doc = r#""#]
            #[doc = r#"The initial value for an input region is infinite. That means the"#]
            #[doc = r#"whole surface will accept input. Setting the pending input region"#]
            #[doc = r#"has copy semantics, and the wl_region object can be destroyed"#]
            #[doc = r#"immediately. A NULL wl_region causes the input region to be set"#]
            #[doc = r#"to infinite."#]
            async fn set_input_region(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_input_region: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = r#"Surface state (input, opaque, and damage regions, attached buffers,"#]
            #[doc = r#"etc.) is double-buffered. Protocol requests modify the pending state,"#]
            #[doc = r#"as opposed to the active state in use by the compositor."#]
            #[doc = r#""#]
            #[doc = r#"A commit request atomically creates a content update from the pending"#]
            #[doc = r#"state, even if the pending state has not been touched. The content"#]
            #[doc = r#"update is placed in a queue until it becomes active. After commit, the"#]
            #[doc = r#"new pending state is as documented for each related request."#]
            #[doc = r#""#]
            #[doc = r#"When the content update is applied, the wl_buffer is applied before all"#]
            #[doc = r#"other state. This means that all coordinates in double-buffered state"#]
            #[doc = r#"are relative to the newly attached wl_buffers, except for"#]
            #[doc = r#"wl_surface.attach itself. If there is no newly attached wl_buffer, the"#]
            #[doc = r#"coordinates are relative to the previous content update."#]
            #[doc = r#""#]
            #[doc = r#"All requests that need a commit to become effective are documented"#]
            #[doc = r#"to affect double-buffered state."#]
            #[doc = r#""#]
            #[doc = r#"Other interfaces may add further double-buffered surface state."#]
            async fn commit(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request sets the transformation that the client has already applied"#]
            #[doc = r#"to the content of the buffer. The accepted values for the transform"#]
            #[doc = r#"parameter are the values for wl_output.transform."#]
            #[doc = r#""#]
            #[doc = r#"The compositor applies the inverse of this transformation whenever it"#]
            #[doc = r#"uses the buffer contents."#]
            #[doc = r#""#]
            #[doc = r#"Buffer transform is double-buffered state, see wl_surface.commit."#]
            #[doc = r#""#]
            #[doc = r#"A newly created surface has its buffer transformation set to normal."#]
            #[doc = r#""#]
            #[doc = r#"wl_surface.set_buffer_transform changes the pending buffer"#]
            #[doc = r#"transformation. wl_surface.commit copies the pending buffer"#]
            #[doc = r#"transformation to the current one. Otherwise, the pending and current"#]
            #[doc = r#"values are never changed."#]
            #[doc = r#""#]
            #[doc = r#"The purpose of this request is to allow clients to render content"#]
            #[doc = r#"according to the output transform, thus permitting the compositor to"#]
            #[doc = r#"use certain optimizations even if the display is rotated. Using"#]
            #[doc = r#"hardware overlays and scanning out a client buffer for fullscreen"#]
            #[doc = r#"surfaces are examples of such optimizations. Those optimizations are"#]
            #[doc = r#"highly dependent on the compositor implementation, so the use of this"#]
            #[doc = r#"request should be considered on a case-by-case basis."#]
            #[doc = r#""#]
            #[doc = r#"Note that if the transform value includes 90 or 270 degree rotation,"#]
            #[doc = r#"the width of the buffer will become the surface height and the height"#]
            #[doc = r#"of the buffer will become the surface width."#]
            #[doc = r#""#]
            #[doc = r#"If transform is not one of the values from the"#]
            #[doc = r#"wl_output.transform enum the invalid_transform protocol error"#]
            #[doc = r#"is raised."#]
            async fn set_buffer_transform(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_buffer_transform: super::super::wayland::wl_output::Transform,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request sets an optional scaling factor on how the compositor"#]
            #[doc = r#"interprets the contents of the buffer attached to the window."#]
            #[doc = r#""#]
            #[doc = r#"Buffer scale is double-buffered state, see wl_surface.commit."#]
            #[doc = r#""#]
            #[doc = r#"A newly created surface has its buffer scale set to 1."#]
            #[doc = r#""#]
            #[doc = r#"wl_surface.set_buffer_scale changes the pending buffer scale."#]
            #[doc = r#"wl_surface.commit copies the pending buffer scale to the current one."#]
            #[doc = r#"Otherwise, the pending and current values are never changed."#]
            #[doc = r#""#]
            #[doc = r#"The purpose of this request is to allow clients to supply higher"#]
            #[doc = r#"resolution buffer data for use on high resolution outputs. It is"#]
            #[doc = r#"intended that you pick the same buffer scale as the scale of the"#]
            #[doc = r#"output that the surface is displayed on. This means the compositor"#]
            #[doc = r#"can avoid scaling when rendering the surface on that output."#]
            #[doc = r#""#]
            #[doc = r#"Note that if the scale is larger than 1, then you have to attach"#]
            #[doc = r#"a buffer that is larger (by a factor of scale in each dimension)"#]
            #[doc = r#"than the desired surface size."#]
            #[doc = r#""#]
            #[doc = r#"If scale is not greater than 0 the invalid_scale protocol error is"#]
            #[doc = r#"raised."#]
            async fn set_buffer_scale(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_buffer_scale: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request is used to describe the regions where the pending"#]
            #[doc = r#"buffer is different from the current surface contents, and where"#]
            #[doc = r#"the surface therefore needs to be repainted. The compositor"#]
            #[doc = r#"ignores the parts of the damage that fall outside of the surface."#]
            #[doc = r#""#]
            #[doc = r#"Damage is double-buffered state, see wl_surface.commit."#]
            #[doc = r#""#]
            #[doc = r#"The damage rectangle is specified in buffer coordinates,"#]
            #[doc = r#"where x and y specify the upper left corner of the damage rectangle."#]
            #[doc = r#""#]
            #[doc = r#"The initial value for pending damage is empty: no damage."#]
            #[doc = r#"wl_surface.damage_buffer adds pending damage: the new pending"#]
            #[doc = r#"damage is the union of old pending damage and the given rectangle."#]
            #[doc = r#""#]
            #[doc = r#"wl_surface.commit assigns pending damage as the current damage,"#]
            #[doc = r#"and clears pending damage. The server will clear the current"#]
            #[doc = r#"damage as it repaints the surface."#]
            #[doc = r#""#]
            #[doc = r#"This request differs from wl_surface.damage in only one way - it"#]
            #[doc = r#"takes damage in buffer coordinates instead of surface-local"#]
            #[doc = r#"coordinates. While this generally is more intuitive than surface"#]
            #[doc = r#"coordinates, it is especially desirable when using wp_viewport"#]
            #[doc = r#"or when a drawing library (like EGL) is unaware of buffer scale"#]
            #[doc = r#"and buffer transform."#]
            #[doc = r#""#]
            #[doc = r#"Note: Because buffer transformation changes and damage requests may"#]
            #[doc = r#"be interleaved in the protocol stream, it is impossible to determine"#]
            #[doc = r#"the actual mapping between surface and buffer damage until"#]
            #[doc = r#"wl_surface.commit time. Therefore, compositors wishing to take both"#]
            #[doc = r#"kinds of damage into account will have to accumulate damage from the"#]
            #[doc = r#"two requests separately and only transform from one to the other"#]
            #[doc = r#"after receiving the wl_surface.commit."#]
            async fn damage_buffer(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                damage_buffer: i32,
                damage_buffer: i32,
                damage_buffer: i32,
                damage_buffer: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"The x and y arguments specify the location of the new pending"#]
            #[doc = r#"buffer's upper left corner, relative to the current buffer's upper"#]
            #[doc = r#"left corner, in surface-local coordinates. In other words, the"#]
            #[doc = r#"x and y, combined with the new surface size define in which"#]
            #[doc = r#"directions the surface's size changes."#]
            #[doc = r#""#]
            #[doc = r#"Surface location offset is double-buffered state, see"#]
            #[doc = r#"wl_surface.commit."#]
            #[doc = r#""#]
            #[doc = r#"This request is semantically equivalent to and the replaces the x and y"#]
            #[doc = r#"arguments in the wl_surface.attach request in wl_surface versions prior"#]
            #[doc = r#"to 5. See wl_surface.attach for details."#]
            async fn offset(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                offset: i32,
                offset: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"This is emitted whenever a surface's creation, movement, or resizing"#]
            #[doc = r#"results in some part of it being within the scanout region of an"#]
            #[doc = r#"output."#]
            #[doc = r#""#]
            #[doc = r#"Note that a surface may be overlapping with zero or more outputs."#]
            async fn enter(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_surface#{}.enter()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(output))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This is emitted whenever a surface's creation, movement, or resizing"#]
            #[doc = r#"results in it no longer having any part of it within the scanout region"#]
            #[doc = r#"of an output."#]
            #[doc = r#""#]
            #[doc = r#"Clients should not use the number of outputs the surface is on for frame"#]
            #[doc = r#"throttling purposes. The surface might be hidden even if no leave event"#]
            #[doc = r#"has been sent, and the compositor might expect new surface content"#]
            #[doc = r#"updates even if no enter event has been sent. The frame event should be"#]
            #[doc = r#"used instead."#]
            async fn leave(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_surface#{}.leave()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(output))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event indicates the preferred buffer scale for this surface. It is"#]
            #[doc = r#"sent whenever the compositor's preference changes."#]
            #[doc = r#""#]
            #[doc = r#"Before receiving this event the preferred buffer scale for this surface"#]
            #[doc = r#"is 1."#]
            #[doc = r#""#]
            #[doc = r#"It is intended that scaling aware clients use this event to scale their"#]
            #[doc = r#"content and use wl_surface.set_buffer_scale to indicate the scale they"#]
            #[doc = r#"have rendered with. This allows clients to supply a higher detail"#]
            #[doc = r#"buffer."#]
            #[doc = r#""#]
            #[doc = r#"The compositor shall emit a scale value greater than 0."#]
            async fn preferred_buffer_scale(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                factor: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_surface#{}.preferred_buffer_scale()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(factor).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event indicates the preferred buffer transform for this surface."#]
            #[doc = r#"It is sent whenever the compositor's preference changes."#]
            #[doc = r#""#]
            #[doc = r#"Before receiving this event the preferred buffer transform for this"#]
            #[doc = r#"surface is normal."#]
            #[doc = r#""#]
            #[doc = r#"Applying this transformation to the surface buffer contents and using"#]
            #[doc = r#"wl_surface.set_buffer_transform might allow the compositor to use the"#]
            #[doc = r#"surface buffer more efficiently."#]
            async fn preferred_buffer_transform(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                transform: super::super::wayland::wl_output::Transform,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_surface#{}.preferred_buffer_transform()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(transform as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod wl_seat {
        #[doc = r#"This is a bitmask of capabilities this seat has; if a member is"#]
        #[doc = r#"set, then it is present on the seat."#]
        bitflags::bitflags! {
                                    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
                                    pub struct Capability: u32 {#[doc = r#"The seat has pointer devices"#]
        const Pointer = 1;#[doc = r#"The seat has one or more keyboards"#]
        const Keyboard = 2;#[doc = r#"The seat has touch devices"#]
        const Touch = 4;}
                                }
        impl TryFrom<u32> for Capability {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = r#"These errors can be emitted in response to wl_seat requests."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Get_pointer, get_keyboard or get_touch called on seat without the matching capability"#]
            MissingCapability = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::MissingCapability),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"A seat is a group of keyboards, pointer and touch devices. This"#]
        #[doc = r#"object is published as a global during start up, or when such a"#]
        #[doc = r#"device is hot plugged.  A seat typically has a pointer and"#]
        #[doc = r#"maintains a keyboard focus and a pointer focus."#]
        pub trait WlSeat: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_seat";
            const VERSION: u32 = 9;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wl_seat#{}.get_pointer()", object.id);
                        self.get_pointer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("wl_seat#{}.get_keyboard()", object.id);
                        self.get_keyboard(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("wl_seat#{}.get_touch()", object.id);
                        self.get_touch(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3 => {
                        tracing::debug!("wl_seat#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"The ID provided will be initialized to the wl_pointer interface"#]
            #[doc = r#"for this seat."#]
            #[doc = r#""#]
            #[doc = r#"This request only takes effect if the seat has the pointer"#]
            #[doc = r#"capability, or has had the pointer capability in the past."#]
            #[doc = r#"It is a protocol violation to issue this request on a seat that has"#]
            #[doc = r#"never had the pointer capability. The missing_capability error will"#]
            #[doc = r#"be sent in this case."#]
            async fn get_pointer(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_pointer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"The ID provided will be initialized to the wl_keyboard interface"#]
            #[doc = r#"for this seat."#]
            #[doc = r#""#]
            #[doc = r#"This request only takes effect if the seat has the keyboard"#]
            #[doc = r#"capability, or has had the keyboard capability in the past."#]
            #[doc = r#"It is a protocol violation to issue this request on a seat that has"#]
            #[doc = r#"never had the keyboard capability. The missing_capability error will"#]
            #[doc = r#"be sent in this case."#]
            async fn get_keyboard(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_keyboard: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"The ID provided will be initialized to the wl_touch interface"#]
            #[doc = r#"for this seat."#]
            #[doc = r#""#]
            #[doc = r#"This request only takes effect if the seat has the touch"#]
            #[doc = r#"capability, or has had the touch capability in the past."#]
            #[doc = r#"It is a protocol violation to issue this request on a seat that has"#]
            #[doc = r#"never had the touch capability. The missing_capability error will"#]
            #[doc = r#"be sent in this case."#]
            async fn get_touch(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_touch: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Using this request a client can tell the server that it is not going to"#]
            #[doc = r#"use the seat object anymore."#]
            async fn release(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This is emitted whenever a seat gains or loses the pointer,"#]
            #[doc = r#"keyboard or touch capabilities.  The argument is a capability"#]
            #[doc = r#"enum containing the complete set of capabilities this seat has."#]
            #[doc = r#""#]
            #[doc = r#"When the pointer capability is added, a client may create a"#]
            #[doc = r#"wl_pointer object using the wl_seat.get_pointer request. This object"#]
            #[doc = r#"will receive pointer events until the capability is removed in the"#]
            #[doc = r#"future."#]
            #[doc = r#""#]
            #[doc = r#"When the pointer capability is removed, a client should destroy the"#]
            #[doc = r#"wl_pointer objects associated with the seat where the capability was"#]
            #[doc = r#"removed, using the wl_pointer.release request. No further pointer"#]
            #[doc = r#"events will be received on these objects."#]
            #[doc = r#""#]
            #[doc = r#"In some compositors, if a seat regains the pointer capability and a"#]
            #[doc = r#"client has a previously obtained wl_pointer object of version 4 or"#]
            #[doc = r#"less, that object may start sending pointer events again. This"#]
            #[doc = r#"behavior is considered a misinterpretation of the intended behavior"#]
            #[doc = r#"and must not be relied upon by the client. wl_pointer objects of"#]
            #[doc = r#"version 5 or later must not send events if created before the most"#]
            #[doc = r#"recent event notifying the client of an added pointer capability."#]
            #[doc = r#""#]
            #[doc = r#"The above behavior also applies to wl_keyboard and wl_touch with the"#]
            #[doc = r#"keyboard and touch capabilities, respectively."#]
            async fn capabilities(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                capabilities: Capability,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_seat#{}.capabilities()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(capabilities.bits())
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"In a multi-seat configuration the seat name can be used by clients to"#]
            #[doc = r#"help identify which physical devices the seat represents."#]
            #[doc = r#""#]
            #[doc = r#"The seat name is a UTF-8 string with no convention defined for its"#]
            #[doc = r#"contents. Each name is unique among all wl_seat globals. The name is"#]
            #[doc = r#"only guaranteed to be unique for the current compositor instance."#]
            #[doc = r#""#]
            #[doc = r#"The same seat names are used for all clients. Thus, the name can be"#]
            #[doc = r#"shared across processes to refer to a specific wl_seat global."#]
            #[doc = r#""#]
            #[doc = r#"The name event is sent after binding to the seat global. This event is"#]
            #[doc = r#"only sent once per seat object, and the name does not change over the"#]
            #[doc = r#"lifetime of the wl_seat global."#]
            #[doc = r#""#]
            #[doc = r#"Compositors may re-use the same seat name if the wl_seat global is"#]
            #[doc = r#"destroyed and re-created later."#]
            async fn name(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_seat#{}.name()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(name))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod wl_pointer {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Given wl_surface has another role"#]
            Role = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Role),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"Describes the physical state of a button that produced the button"#]
        #[doc = r#"event."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ButtonState {
            #[doc = r#"The button is not pressed"#]
            Released = 0,
            #[doc = r#"The button is pressed"#]
            Pressed = 1,
        }
        impl TryFrom<u32> for ButtonState {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Released),
                    1 => Ok(Self::Pressed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"Describes the axis types of scroll events."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Axis {
            #[doc = r#"Vertical axis"#]
            VerticalScroll = 0,
            #[doc = r#"Horizontal axis"#]
            HorizontalScroll = 1,
        }
        impl TryFrom<u32> for Axis {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::VerticalScroll),
                    1 => Ok(Self::HorizontalScroll),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"Describes the source types for axis events. This indicates to the"#]
        #[doc = r#"client how an axis event was physically generated; a client may"#]
        #[doc = r#"adjust the user interface accordingly. For example, scroll events"#]
        #[doc = r#"from a "finger" source may be in a smooth coordinate space with"#]
        #[doc = r#"kinetic scrolling whereas a "wheel" source may be in discrete steps"#]
        #[doc = r#"of a number of lines."#]
        #[doc = r#""#]
        #[doc = r#"The "continuous" axis source is a device generating events in a"#]
        #[doc = r#"continuous coordinate space, but using something other than a"#]
        #[doc = r#"finger. One example for this source is button-based scrolling where"#]
        #[doc = r#"the vertical motion of a device is converted to scroll events while"#]
        #[doc = r#"a button is held down."#]
        #[doc = r#""#]
        #[doc = r#"The "wheel tilt" axis source indicates that the actual device is a"#]
        #[doc = r#"wheel but the scroll event is not caused by a rotation but a"#]
        #[doc = r#"(usually sideways) tilt of the wheel."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum AxisSource {
            #[doc = r#"A physical wheel rotation"#]
            Wheel = 0,
            #[doc = r#"Finger on a touch surface"#]
            Finger = 1,
            #[doc = r#"Continuous coordinate space"#]
            Continuous = 2,
            #[doc = r#"A physical wheel tilt"#]
            WheelTilt = 3,
        }
        impl TryFrom<u32> for AxisSource {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Wheel),
                    1 => Ok(Self::Finger),
                    2 => Ok(Self::Continuous),
                    3 => Ok(Self::WheelTilt),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"This specifies the direction of the physical motion that caused a"#]
        #[doc = r#"wl_pointer.axis event, relative to the wl_pointer.axis direction."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum AxisRelativeDirection {
            #[doc = r#"Physical motion matches axis direction"#]
            Identical = 0,
            #[doc = r#"Physical motion is the inverse of the axis direction"#]
            Inverted = 1,
        }
        impl TryFrom<u32> for AxisRelativeDirection {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Identical),
                    1 => Ok(Self::Inverted),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"The wl_pointer interface represents one or more input devices,"#]
        #[doc = r#"such as mice, which control the pointer location and pointer_focus"#]
        #[doc = r#"of a seat."#]
        #[doc = r#""#]
        #[doc = r#"The wl_pointer interface generates motion, enter and leave"#]
        #[doc = r#"events for the surfaces that the pointer is located over,"#]
        #[doc = r#"and button and axis events for button presses, button releases"#]
        #[doc = r#"and scrolling."#]
        pub trait WlPointer: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_pointer";
            const VERSION: u32 = 9;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wl_pointer#{}.set_cursor()", object.id);
                        self.set_cursor(
                            object,
                            client,
                            message.uint()?,
                            message.object()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("wl_pointer#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Set the pointer surface, i.e., the surface that contains the"#]
            #[doc = r#"pointer image (cursor). This request gives the surface the role"#]
            #[doc = r#"of a cursor. If the surface already has another role, it raises"#]
            #[doc = r#"a protocol error."#]
            #[doc = r#""#]
            #[doc = r#"The cursor actually changes only if the pointer"#]
            #[doc = r#"focus for this device is one of the requesting client's surfaces"#]
            #[doc = r#"or the surface parameter is the current pointer surface. If"#]
            #[doc = r#"there was a previous surface set with this request it is"#]
            #[doc = r#"replaced. If surface is NULL, the pointer image is hidden."#]
            #[doc = r#""#]
            #[doc = r#"The parameters hotspot_x and hotspot_y define the position of"#]
            #[doc = r#"the pointer surface relative to the pointer location. Its"#]
            #[doc = r#"top-left corner is always at (x, y) - (hotspot_x, hotspot_y),"#]
            #[doc = r#"where (x, y) are the coordinates of the pointer location, in"#]
            #[doc = r#"surface-local coordinates."#]
            #[doc = r#""#]
            #[doc = r#"On wl_surface.offset requests to the pointer surface, hotspot_x"#]
            #[doc = r#"and hotspot_y are decremented by the x and y parameters"#]
            #[doc = r#"passed to the request. The offset must be applied by"#]
            #[doc = r#"wl_surface.commit as usual."#]
            #[doc = r#""#]
            #[doc = r#"The hotspot can also be updated by passing the currently set"#]
            #[doc = r#"pointer surface to this request with new values for hotspot_x"#]
            #[doc = r#"and hotspot_y."#]
            #[doc = r#""#]
            #[doc = r#"The input region is ignored for wl_surfaces with the role of"#]
            #[doc = r#"a cursor. When the use as a cursor ends, the wl_surface is"#]
            #[doc = r#"unmapped."#]
            #[doc = r#""#]
            #[doc = r#"The serial parameter must match the latest wl_pointer.enter"#]
            #[doc = r#"serial number sent to the client. Otherwise the request will be"#]
            #[doc = r#"ignored."#]
            async fn set_cursor(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_cursor: u32,
                set_cursor: Option<crate::wire::ObjectId>,
                set_cursor: i32,
                set_cursor: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Using this request a client can tell the server that it is not going to"#]
            #[doc = r#"use the pointer object anymore."#]
            #[doc = r#""#]
            #[doc = r#"This request destroys the pointer proxy object, so clients must not call"#]
            #[doc = r#"wl_pointer_destroy() after using this request."#]
            async fn release(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Notification that this seat's pointer is focused on a certain"#]
            #[doc = r#"surface."#]
            #[doc = r#""#]
            #[doc = r#"When a seat's focus enters a surface, the pointer image"#]
            #[doc = r#"is undefined and a client should respond to this event by setting"#]
            #[doc = r#"an appropriate pointer image with the set_cursor request."#]
            async fn enter(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: crate::wire::ObjectId,
                surface_x: crate::wire::Fixed,
                surface_y: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_pointer#{}.enter()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(surface))
                    .put_fixed(surface_x)
                    .put_fixed(surface_y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notification that this seat's pointer is no longer focused on"#]
            #[doc = r#"a certain surface."#]
            #[doc = r#""#]
            #[doc = r#"The leave notification is sent before the enter notification"#]
            #[doc = r#"for the new focus."#]
            async fn leave(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_pointer#{}.leave()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notification of pointer location change. The arguments"#]
            #[doc = r#"surface_x and surface_y are the location relative to the"#]
            #[doc = r#"focused surface."#]
            async fn motion(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                surface_x: crate::wire::Fixed,
                surface_y: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_pointer#{}.motion()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_fixed(surface_x)
                    .put_fixed(surface_y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Mouse button click and release notifications."#]
            #[doc = r#""#]
            #[doc = r#"The location of the click is given by the last motion or"#]
            #[doc = r#"enter event."#]
            #[doc = r#"The time argument is a timestamp with millisecond"#]
            #[doc = r#"granularity, with an undefined base."#]
            #[doc = r#""#]
            #[doc = r#"The button is a button code as defined in the Linux kernel's"#]
            #[doc = r#"linux/input-event-codes.h header file, e.g. BTN_LEFT."#]
            #[doc = r#""#]
            #[doc = r#"Any 16-bit button code value is reserved for future additions to the"#]
            #[doc = r#"kernel's event code list. All other button codes above 0xFFFF are"#]
            #[doc = r#"currently undefined but may be used in future versions of this"#]
            #[doc = r#"protocol."#]
            async fn button(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                button: u32,
                state: ButtonState,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_pointer#{}.button()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(time)
                    .put_uint(button)
                    .put_uint(state as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Scroll and other axis notifications."#]
            #[doc = r#""#]
            #[doc = r#"For scroll events (vertical and horizontal scroll axes), the"#]
            #[doc = r#"value parameter is the length of a vector along the specified"#]
            #[doc = r#"axis in a coordinate space identical to those of motion events,"#]
            #[doc = r#"representing a relative movement along the specified axis."#]
            #[doc = r#""#]
            #[doc = r#"For devices that support movements non-parallel to axes multiple"#]
            #[doc = r#"axis events will be emitted."#]
            #[doc = r#""#]
            #[doc = r#"When applicable, for example for touch pads, the server can"#]
            #[doc = r#"choose to emit scroll events where the motion vector is"#]
            #[doc = r#"equivalent to a motion event vector."#]
            #[doc = r#""#]
            #[doc = r#"When applicable, a client can transform its content relative to the"#]
            #[doc = r#"scroll distance."#]
            async fn axis(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                axis: Axis,
                value: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_pointer#{}.axis()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_uint(axis as u32)
                    .put_fixed(value)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Indicates the end of a set of events that logically belong together."#]
            #[doc = r#"A client is expected to accumulate the data in all events within the"#]
            #[doc = r#"frame before proceeding."#]
            #[doc = r#""#]
            #[doc = r#"All wl_pointer events before a wl_pointer.frame event belong"#]
            #[doc = r#"logically together. For example, in a diagonal scroll motion the"#]
            #[doc = r#"compositor will send an optional wl_pointer.axis_source event, two"#]
            #[doc = r#"wl_pointer.axis events (horizontal and vertical) and finally a"#]
            #[doc = r#"wl_pointer.frame event. The client may use this information to"#]
            #[doc = r#"calculate a diagonal vector for scrolling."#]
            #[doc = r#""#]
            #[doc = r#"When multiple wl_pointer.axis events occur within the same frame,"#]
            #[doc = r#"the motion vector is the combined motion of all events."#]
            #[doc = r#"When a wl_pointer.axis and a wl_pointer.axis_stop event occur within"#]
            #[doc = r#"the same frame, this indicates that axis movement in one axis has"#]
            #[doc = r#"stopped but continues in the other axis."#]
            #[doc = r#"When multiple wl_pointer.axis_stop events occur within the same"#]
            #[doc = r#"frame, this indicates that these axes stopped in the same instance."#]
            #[doc = r#""#]
            #[doc = r#"A wl_pointer.frame event is sent for every logical event group,"#]
            #[doc = r#"even if the group only contains a single wl_pointer event."#]
            #[doc = r#"Specifically, a client may get a sequence: motion, frame, button,"#]
            #[doc = r#"frame, axis, frame, axis_stop, frame."#]
            #[doc = r#""#]
            #[doc = r#"The wl_pointer.enter and wl_pointer.leave events are logical events"#]
            #[doc = r#"generated by the compositor and not the hardware. These events are"#]
            #[doc = r#"also grouped by a wl_pointer.frame. When a pointer moves from one"#]
            #[doc = r#"surface to another, a compositor should group the"#]
            #[doc = r#"wl_pointer.leave event within the same wl_pointer.frame."#]
            #[doc = r#"However, a client must not rely on wl_pointer.leave and"#]
            #[doc = r#"wl_pointer.enter being in the same wl_pointer.frame."#]
            #[doc = r#"Compositor-specific policies may require the wl_pointer.leave and"#]
            #[doc = r#"wl_pointer.enter event being split across multiple wl_pointer.frame"#]
            #[doc = r#"groups."#]
            async fn frame(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_pointer#{}.frame()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 5, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Source information for scroll and other axes."#]
            #[doc = r#""#]
            #[doc = r#"This event does not occur on its own. It is sent before a"#]
            #[doc = r#"wl_pointer.frame event and carries the source information for"#]
            #[doc = r#"all events within that frame."#]
            #[doc = r#""#]
            #[doc = r#"The source specifies how this event was generated. If the source is"#]
            #[doc = r#"wl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be"#]
            #[doc = r#"sent when the user lifts the finger off the device."#]
            #[doc = r#""#]
            #[doc = r#"If the source is wl_pointer.axis_source.wheel,"#]
            #[doc = r#"wl_pointer.axis_source.wheel_tilt or"#]
            #[doc = r#"wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may"#]
            #[doc = r#"or may not be sent. Whether a compositor sends an axis_stop event"#]
            #[doc = r#"for these sources is hardware-specific and implementation-dependent;"#]
            #[doc = r#"clients must not rely on receiving an axis_stop event for these"#]
            #[doc = r#"scroll sources and should treat scroll sequences from these scroll"#]
            #[doc = r#"sources as unterminated by default."#]
            #[doc = r#""#]
            #[doc = r#"This event is optional. If the source is unknown for a particular"#]
            #[doc = r#"axis event sequence, no event is sent."#]
            #[doc = r#"Only one wl_pointer.axis_source event is permitted per frame."#]
            #[doc = r#""#]
            #[doc = r#"The order of wl_pointer.axis_discrete and wl_pointer.axis_source is"#]
            #[doc = r#"not guaranteed."#]
            async fn axis_source(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                axis_source: AxisSource,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_pointer#{}.axis_source()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(axis_source as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 6, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Stop notification for scroll and other axes."#]
            #[doc = r#""#]
            #[doc = r#"For some wl_pointer.axis_source types, a wl_pointer.axis_stop event"#]
            #[doc = r#"is sent to notify a client that the axis sequence has terminated."#]
            #[doc = r#"This enables the client to implement kinetic scrolling."#]
            #[doc = r#"See the wl_pointer.axis_source documentation for information on when"#]
            #[doc = r#"this event may be generated."#]
            #[doc = r#""#]
            #[doc = r#"Any wl_pointer.axis events with the same axis_source after this"#]
            #[doc = r#"event should be considered as the start of a new axis motion."#]
            #[doc = r#""#]
            #[doc = r#"The timestamp is to be interpreted identical to the timestamp in the"#]
            #[doc = r#"wl_pointer.axis event. The timestamp value may be the same as a"#]
            #[doc = r#"preceding wl_pointer.axis event."#]
            async fn axis_stop(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                axis: Axis,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_pointer#{}.axis_stop()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_uint(axis as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 7, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Discrete step information for scroll and other axes."#]
            #[doc = r#""#]
            #[doc = r#"This event carries the axis value of the wl_pointer.axis event in"#]
            #[doc = r#"discrete steps (e.g. mouse wheel clicks)."#]
            #[doc = r#""#]
            #[doc = r#"This event is deprecated with wl_pointer version 8 - this event is not"#]
            #[doc = r#"sent to clients supporting version 8 or later."#]
            #[doc = r#""#]
            #[doc = r#"This event does not occur on its own, it is coupled with a"#]
            #[doc = r#"wl_pointer.axis event that represents this axis value on a"#]
            #[doc = r#"continuous scale. The protocol guarantees that each axis_discrete"#]
            #[doc = r#"event is always followed by exactly one axis event with the same"#]
            #[doc = r#"axis number within the same wl_pointer.frame. Note that the protocol"#]
            #[doc = r#"allows for other events to occur between the axis_discrete and"#]
            #[doc = r#"its coupled axis event, including other axis_discrete or axis"#]
            #[doc = r#"events. A wl_pointer.frame must not contain more than one axis_discrete"#]
            #[doc = r#"event per axis type."#]
            #[doc = r#""#]
            #[doc = r#"This event is optional; continuous scrolling devices"#]
            #[doc = r#"like two-finger scrolling on touchpads do not have discrete"#]
            #[doc = r#"steps and do not generate this event."#]
            #[doc = r#""#]
            #[doc = r#"The discrete value carries the directional information. e.g. a value"#]
            #[doc = r#"of -2 is two steps towards the negative direction of this axis."#]
            #[doc = r#""#]
            #[doc = r#"The axis number is identical to the axis number in the associated"#]
            #[doc = r#"axis event."#]
            #[doc = r#""#]
            #[doc = r#"The order of wl_pointer.axis_discrete and wl_pointer.axis_source is"#]
            #[doc = r#"not guaranteed."#]
            async fn axis_discrete(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                axis: Axis,
                discrete: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_pointer#{}.axis_discrete()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(axis as u32)
                    .put_int(discrete)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 8, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Discrete high-resolution scroll information."#]
            #[doc = r#""#]
            #[doc = r#"This event carries high-resolution wheel scroll information,"#]
            #[doc = r#"with each multiple of 120 representing one logical scroll step"#]
            #[doc = r#"(a wheel detent). For example, an axis_value120 of 30 is one quarter of"#]
            #[doc = r#"a logical scroll step in the positive direction, a value120 of"#]
            #[doc = r#"-240 are two logical scroll steps in the negative direction within the"#]
            #[doc = r#"same hardware event."#]
            #[doc = r#"Clients that rely on discrete scrolling should accumulate the"#]
            #[doc = r#"value120 to multiples of 120 before processing the event."#]
            #[doc = r#""#]
            #[doc = r#"The value120 must not be zero."#]
            #[doc = r#""#]
            #[doc = r#"This event replaces the wl_pointer.axis_discrete event in clients"#]
            #[doc = r#"supporting wl_pointer version 8 or later."#]
            #[doc = r#""#]
            #[doc = r#"Where a wl_pointer.axis_source event occurs in the same"#]
            #[doc = r#"wl_pointer.frame, the axis source applies to this event."#]
            #[doc = r#""#]
            #[doc = r#"The order of wl_pointer.axis_value120 and wl_pointer.axis_source is"#]
            #[doc = r#"not guaranteed."#]
            async fn axis_value120(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                axis: Axis,
                value120: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_pointer#{}.axis_value120()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(axis as u32)
                    .put_int(value120)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 9, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Relative directional information of the entity causing the axis"#]
            #[doc = r#"motion."#]
            #[doc = r#""#]
            #[doc = r#"For a wl_pointer.axis event, the wl_pointer.axis_relative_direction"#]
            #[doc = r#"event specifies the movement direction of the entity causing the"#]
            #[doc = r#"wl_pointer.axis event. For example:"#]
            #[doc = r#"- if a user's fingers on a touchpad move down and this"#]
            #[doc = r#"causes a wl_pointer.axis vertical_scroll down event, the physical"#]
            #[doc = r#"direction is 'identical'"#]
            #[doc = r#"- if a user's fingers on a touchpad move down and this causes a"#]
            #[doc = r#"wl_pointer.axis vertical_scroll up scroll up event ('natural"#]
            #[doc = r#"scrolling'), the physical direction is 'inverted'."#]
            #[doc = r#""#]
            #[doc = r#"A client may use this information to adjust scroll motion of"#]
            #[doc = r#"components. Specifically, enabling natural scrolling causes the"#]
            #[doc = r#"content to change direction compared to traditional scrolling."#]
            #[doc = r#"Some widgets like volume control sliders should usually match the"#]
            #[doc = r#"physical direction regardless of whether natural scrolling is"#]
            #[doc = r#"active. This event enables clients to match the scroll direction of"#]
            #[doc = r#"a widget to the physical direction."#]
            #[doc = r#""#]
            #[doc = r#"This event does not occur on its own, it is coupled with a"#]
            #[doc = r#"wl_pointer.axis event that represents this axis value."#]
            #[doc = r#"The protocol guarantees that each axis_relative_direction event is"#]
            #[doc = r#"always followed by exactly one axis event with the same"#]
            #[doc = r#"axis number within the same wl_pointer.frame. Note that the protocol"#]
            #[doc = r#"allows for other events to occur between the axis_relative_direction"#]
            #[doc = r#"and its coupled axis event."#]
            #[doc = r#""#]
            #[doc = r#"The axis number is identical to the axis number in the associated"#]
            #[doc = r#"axis event."#]
            #[doc = r#""#]
            #[doc = r#"The order of wl_pointer.axis_relative_direction,"#]
            #[doc = r#"wl_pointer.axis_discrete and wl_pointer.axis_source is not"#]
            #[doc = r#"guaranteed."#]
            async fn axis_relative_direction(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                axis: Axis,
                direction: AxisRelativeDirection,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_pointer#{}.axis_relative_direction()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(axis as u32)
                    .put_uint(direction as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 10, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod wl_keyboard {
        #[doc = r#"This specifies the format of the keymap provided to the"#]
        #[doc = r#"client with the wl_keyboard.keymap event."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum KeymapFormat {
            #[doc = r#"No keymap; client must understand how to interpret the raw keycode"#]
            NoKeymap = 0,
            #[doc = r#"Libxkbcommon compatible, null-terminated string; to determine the xkb keycode, clients must add 8 to the key event keycode"#]
            XkbV1 = 1,
        }
        impl TryFrom<u32> for KeymapFormat {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::NoKeymap),
                    1 => Ok(Self::XkbV1),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"Describes the physical state of a key that produced the key event."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum KeyState {
            #[doc = r#"Key is not pressed"#]
            Released = 0,
            #[doc = r#"Key is pressed"#]
            Pressed = 1,
        }
        impl TryFrom<u32> for KeyState {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Released),
                    1 => Ok(Self::Pressed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"The wl_keyboard interface represents one or more keyboards"#]
        #[doc = r#"associated with a seat."#]
        #[doc = r#""#]
        #[doc = r#"Each wl_keyboard has the following logical state:"#]
        #[doc = r#""#]
        #[doc = r#"- an active surface (possibly null),"#]
        #[doc = r#"- the keys currently logically down,"#]
        #[doc = r#"- the active modifiers,"#]
        #[doc = r#"- the active group."#]
        #[doc = r#""#]
        #[doc = r#"By default, the active surface is null, the keys currently logically down"#]
        #[doc = r#"are empty, the active modifiers and the active group are 0."#]
        pub trait WlKeyboard: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_keyboard";
            const VERSION: u32 = 9;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wl_keyboard#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn release(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event provides a file descriptor to the client which can be"#]
            #[doc = r#"memory-mapped in read-only mode to provide a keyboard mapping"#]
            #[doc = r#"description."#]
            #[doc = r#""#]
            #[doc = r#"From version 7 onwards, the fd must be mapped with MAP_PRIVATE by"#]
            #[doc = r#"the recipient, as MAP_SHARED may fail."#]
            async fn keymap(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                format: KeymapFormat,
                fd: rustix::fd::OwnedFd,
                size: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_keyboard#{}.keymap()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(format as u32)
                    .put_fd(fd)
                    .put_uint(size)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notification that this seat's keyboard focus is on a certain"#]
            #[doc = r#"surface."#]
            #[doc = r#""#]
            #[doc = r#"The compositor must send the wl_keyboard.modifiers event after this"#]
            #[doc = r#"event."#]
            #[doc = r#""#]
            #[doc = r#"In the wl_keyboard logical state, this event sets the active surface to"#]
            #[doc = r#"the surface argument and the keys currently logically down to the keys"#]
            #[doc = r#"in the keys argument. The compositor must not send this event if the"#]
            #[doc = r#"wl_keyboard already had an active surface immediately before this event."#]
            async fn enter(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: crate::wire::ObjectId,
                keys: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_keyboard#{}.enter()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(surface))
                    .put_array(keys)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notification that this seat's keyboard focus is no longer on"#]
            #[doc = r#"a certain surface."#]
            #[doc = r#""#]
            #[doc = r#"The leave notification is sent before the enter notification"#]
            #[doc = r#"for the new focus."#]
            #[doc = r#""#]
            #[doc = r#"In the wl_keyboard logical state, this event resets all values to their"#]
            #[doc = r#"defaults. The compositor must not send this event if the active surface"#]
            #[doc = r#"of the wl_keyboard was not equal to the surface argument immediately"#]
            #[doc = r#"before this event."#]
            async fn leave(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_keyboard#{}.leave()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"A key was pressed or released."#]
            #[doc = r#"The time argument is a timestamp with millisecond"#]
            #[doc = r#"granularity, with an undefined base."#]
            #[doc = r#""#]
            #[doc = r#"The key is a platform-specific key code that can be interpreted"#]
            #[doc = r#"by feeding it to the keyboard mapping (see the keymap event)."#]
            #[doc = r#""#]
            #[doc = r#"If this event produces a change in modifiers, then the resulting"#]
            #[doc = r#"wl_keyboard.modifiers event must be sent after this event."#]
            #[doc = r#""#]
            #[doc = r#"In the wl_keyboard logical state, this event adds the key to the keys"#]
            #[doc = r#"currently logically down (if the state argument is pressed) or removes"#]
            #[doc = r#"the key from the keys currently logically down (if the state argument is"#]
            #[doc = r#"released). The compositor must not send this event if the wl_keyboard"#]
            #[doc = r#"did not have an active surface immediately before this event. The"#]
            #[doc = r#"compositor must not send this event if state is pressed (resp. released)"#]
            #[doc = r#"and the key was already logically down (resp. was not logically down)"#]
            #[doc = r#"immediately before this event."#]
            async fn key(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                key: u32,
                state: KeyState,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_keyboard#{}.key()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(time)
                    .put_uint(key)
                    .put_uint(state as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notifies clients that the modifier and/or group state has"#]
            #[doc = r#"changed, and it should update its local state."#]
            #[doc = r#""#]
            #[doc = r#"The compositor may send this event without a surface of the client"#]
            #[doc = r#"having keyboard focus, for example to tie modifier information to"#]
            #[doc = r#"pointer focus instead. If a modifier event with pressed modifiers is sent"#]
            #[doc = r#"without a prior enter event, the client can assume the modifier state is"#]
            #[doc = r#"valid until it receives the next wl_keyboard.modifiers event. In order to"#]
            #[doc = r#"reset the modifier state again, the compositor can send a"#]
            #[doc = r#"wl_keyboard.modifiers event with no pressed modifiers."#]
            #[doc = r#""#]
            #[doc = r#"In the wl_keyboard logical state, this event updates the modifiers and"#]
            #[doc = r#"group."#]
            async fn modifiers(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                mods_depressed: u32,
                mods_latched: u32,
                mods_locked: u32,
                group: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_keyboard#{}.modifiers()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(mods_depressed)
                    .put_uint(mods_latched)
                    .put_uint(mods_locked)
                    .put_uint(group)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Informs the client about the keyboard's repeat rate and delay."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent as soon as the wl_keyboard object has been created,"#]
            #[doc = r#"and is guaranteed to be received by the client before any key press"#]
            #[doc = r#"event."#]
            #[doc = r#""#]
            #[doc = r#"Negative values for either rate or delay are illegal. A rate of zero"#]
            #[doc = r#"will disable any repeating (regardless of the value of delay)."#]
            #[doc = r#""#]
            #[doc = r#"This event can be sent later on as well with a new value if necessary,"#]
            #[doc = r#"so clients should continue listening for the event past the creation"#]
            #[doc = r#"of wl_keyboard."#]
            async fn repeat_info(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                rate: i32,
                delay: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_keyboard#{}.repeat_info()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(rate)
                    .put_int(delay)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 5, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod wl_touch {
        #[doc = r#"The wl_touch interface represents a touchscreen"#]
        #[doc = r#"associated with a seat."#]
        #[doc = r#""#]
        #[doc = r#"Touch interactions can consist of one or more contacts."#]
        #[doc = r#"For each contact, a series of events is generated, starting"#]
        #[doc = r#"with a down event, followed by zero or more motion events,"#]
        #[doc = r#"and ending with an up event. Events relating to the same"#]
        #[doc = r#"contact point can be identified by the ID of the sequence."#]
        pub trait WlTouch: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_touch";
            const VERSION: u32 = 9;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wl_touch#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn release(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"A new touch point has appeared on the surface. This touch point is"#]
            #[doc = r#"assigned a unique ID. Future events from this touch point reference"#]
            #[doc = r#"this ID. The ID ceases to be valid after a touch up event and may be"#]
            #[doc = r#"reused in the future."#]
            async fn down(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                surface: crate::wire::ObjectId,
                id: i32,
                x: crate::wire::Fixed,
                y: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_touch#{}.down()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(time)
                    .put_object(Some(surface))
                    .put_int(id)
                    .put_fixed(x)
                    .put_fixed(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The touch point has disappeared. No further events will be sent for"#]
            #[doc = r#"this touch point and the touch point's ID is released and may be"#]
            #[doc = r#"reused in a future touch down event."#]
            async fn up(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                id: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_touch#{}.up()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(time)
                    .put_int(id)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"A touch point has changed coordinates."#]
            async fn motion(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                id: i32,
                x: crate::wire::Fixed,
                y: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_touch#{}.motion()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_int(id)
                    .put_fixed(x)
                    .put_fixed(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Indicates the end of a set of events that logically belong together."#]
            #[doc = r#"A client is expected to accumulate the data in all events within the"#]
            #[doc = r#"frame before proceeding."#]
            #[doc = r#""#]
            #[doc = r#"A wl_touch.frame terminates at least one event but otherwise no"#]
            #[doc = r#"guarantee is provided about the set of events within a frame. A client"#]
            #[doc = r#"must assume that any state not updated in a frame is unchanged from the"#]
            #[doc = r#"previously known state."#]
            async fn frame(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_touch#{}.frame()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent if the compositor decides the touch stream is a global"#]
            #[doc = r#"gesture. No further events are sent to the clients from that"#]
            #[doc = r#"particular gesture. Touch cancellation applies to all touch points"#]
            #[doc = r#"currently active on this client's surface. The client is"#]
            #[doc = r#"responsible for finalizing the touch points, future touch points on"#]
            #[doc = r#"this surface may reuse the touch point ID."#]
            #[doc = r#""#]
            #[doc = r#"No frame event is required after the cancel event."#]
            async fn cancel(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_touch#{}.cancel()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent when a touchpoint has changed its shape."#]
            #[doc = r#""#]
            #[doc = r#"This event does not occur on its own. It is sent before a"#]
            #[doc = r#"wl_touch.frame event and carries the new shape information for"#]
            #[doc = r#"any previously reported, or new touch points of that frame."#]
            #[doc = r#""#]
            #[doc = r#"Other events describing the touch point such as wl_touch.down,"#]
            #[doc = r#"wl_touch.motion or wl_touch.orientation may be sent within the"#]
            #[doc = r#"same wl_touch.frame. A client should treat these events as a single"#]
            #[doc = r#"logical touch point update. The order of wl_touch.shape,"#]
            #[doc = r#"wl_touch.orientation and wl_touch.motion is not guaranteed."#]
            #[doc = r#"A wl_touch.down event is guaranteed to occur before the first"#]
            #[doc = r#"wl_touch.shape event for this touch ID but both events may occur within"#]
            #[doc = r#"the same wl_touch.frame."#]
            #[doc = r#""#]
            #[doc = r#"A touchpoint shape is approximated by an ellipse through the major and"#]
            #[doc = r#"minor axis length. The major axis length describes the longer diameter"#]
            #[doc = r#"of the ellipse, while the minor axis length describes the shorter"#]
            #[doc = r#"diameter. Major and minor are orthogonal and both are specified in"#]
            #[doc = r#"surface-local coordinates. The center of the ellipse is always at the"#]
            #[doc = r#"touchpoint location as reported by wl_touch.down or wl_touch.move."#]
            #[doc = r#""#]
            #[doc = r#"This event is only sent by the compositor if the touch device supports"#]
            #[doc = r#"shape reports. The client has to make reasonable assumptions about the"#]
            #[doc = r#"shape if it did not receive this event."#]
            async fn shape(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: i32,
                major: crate::wire::Fixed,
                minor: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_touch#{}.shape()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(id)
                    .put_fixed(major)
                    .put_fixed(minor)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 5, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent when a touchpoint has changed its orientation."#]
            #[doc = r#""#]
            #[doc = r#"This event does not occur on its own. It is sent before a"#]
            #[doc = r#"wl_touch.frame event and carries the new shape information for"#]
            #[doc = r#"any previously reported, or new touch points of that frame."#]
            #[doc = r#""#]
            #[doc = r#"Other events describing the touch point such as wl_touch.down,"#]
            #[doc = r#"wl_touch.motion or wl_touch.shape may be sent within the"#]
            #[doc = r#"same wl_touch.frame. A client should treat these events as a single"#]
            #[doc = r#"logical touch point update. The order of wl_touch.shape,"#]
            #[doc = r#"wl_touch.orientation and wl_touch.motion is not guaranteed."#]
            #[doc = r#"A wl_touch.down event is guaranteed to occur before the first"#]
            #[doc = r#"wl_touch.orientation event for this touch ID but both events may occur"#]
            #[doc = r#"within the same wl_touch.frame."#]
            #[doc = r#""#]
            #[doc = r#"The orientation describes the clockwise angle of a touchpoint's major"#]
            #[doc = r#"axis to the positive surface y-axis and is normalized to the -180 to"#]
            #[doc = r#"+180 degree range. The granularity of orientation depends on the touch"#]
            #[doc = r#"device, some devices only support binary rotation values between 0 and"#]
            #[doc = r#"90 degrees."#]
            #[doc = r#""#]
            #[doc = r#"This event is only sent by the compositor if the touch device supports"#]
            #[doc = r#"orientation reports."#]
            async fn orientation(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: i32,
                orientation: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_touch#{}.orientation()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(id)
                    .put_fixed(orientation)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 6, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod wl_output {
        #[doc = r#"This enumeration describes how the physical"#]
        #[doc = r#"pixels on an output are laid out."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Subpixel {
            #[doc = r#"Unknown geometry"#]
            Unknown = 0,
            #[doc = r#"No geometry"#]
            None = 1,
            #[doc = r#"Horizontal RGB"#]
            HorizontalRgb = 2,
            #[doc = r#"Horizontal BGR"#]
            HorizontalBgr = 3,
            #[doc = r#"Vertical RGB"#]
            VerticalRgb = 4,
            #[doc = r#"Vertical BGR"#]
            VerticalBgr = 5,
        }
        impl TryFrom<u32> for Subpixel {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Unknown),
                    1 => Ok(Self::None),
                    2 => Ok(Self::HorizontalRgb),
                    3 => Ok(Self::HorizontalBgr),
                    4 => Ok(Self::VerticalRgb),
                    5 => Ok(Self::VerticalBgr),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"This describes transformations that clients and compositors apply to"#]
        #[doc = r#"buffer contents."#]
        #[doc = r#""#]
        #[doc = r#"The flipped values correspond to an initial flip around a"#]
        #[doc = r#"vertical axis followed by rotation."#]
        #[doc = r#""#]
        #[doc = r#"The purpose is mainly to allow clients to render accordingly and"#]
        #[doc = r#"tell the compositor, so that for fullscreen surfaces, the"#]
        #[doc = r#"compositor will still be able to scan out directly from client"#]
        #[doc = r#"surfaces."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Transform {
            #[doc = r#"No transform"#]
            Normal = 0,
            #[doc = r#"90 degrees counter-clockwise"#]
            _90 = 1,
            #[doc = r#"180 degrees counter-clockwise"#]
            _180 = 2,
            #[doc = r#"270 degrees counter-clockwise"#]
            _270 = 3,
            #[doc = r#"180 degree flip around a vertical axis"#]
            Flipped = 4,
            #[doc = r#"Flip and rotate 90 degrees counter-clockwise"#]
            Flipped90 = 5,
            #[doc = r#"Flip and rotate 180 degrees counter-clockwise"#]
            Flipped180 = 6,
            #[doc = r#"Flip and rotate 270 degrees counter-clockwise"#]
            Flipped270 = 7,
        }
        impl TryFrom<u32> for Transform {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Normal),
                    1 => Ok(Self::_90),
                    2 => Ok(Self::_180),
                    3 => Ok(Self::_270),
                    4 => Ok(Self::Flipped),
                    5 => Ok(Self::Flipped90),
                    6 => Ok(Self::Flipped180),
                    7 => Ok(Self::Flipped270),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"These flags describe properties of an output mode."#]
        #[doc = r#"They are used in the flags bitfield of the mode event."#]
        bitflags::bitflags! {
                                    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
                                    pub struct Mode: u32 {#[doc = r#"Indicates this is the current mode"#]
        const Current = 0x1;#[doc = r#"Indicates this is the preferred mode"#]
        const Preferred = 0x2;}
                                }
        impl TryFrom<u32> for Mode {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = r#"An output describes part of the compositor geometry.  The"#]
        #[doc = r#"compositor works in the 'compositor coordinate system' and an"#]
        #[doc = r#"output corresponds to a rectangular area in that space that is"#]
        #[doc = r#"actually visible.  This typically corresponds to a monitor that"#]
        #[doc = r#"displays part of the compositor space.  This object is published"#]
        #[doc = r#"as global during start up, or when a monitor is hotplugged."#]
        pub trait WlOutput: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_output";
            const VERSION: u32 = 4;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wl_output#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Using this request a client can tell the server that it is not going to"#]
            #[doc = r#"use the output object anymore."#]
            async fn release(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"The geometry event describes geometric properties of the output."#]
            #[doc = r#"The event is sent when binding to the output object and whenever"#]
            #[doc = r#"any of the properties change."#]
            #[doc = r#""#]
            #[doc = r#"The physical size can be set to zero if it doesn't make sense for this"#]
            #[doc = r#"output (e.g. for projectors or virtual outputs)."#]
            #[doc = r#""#]
            #[doc = r#"The geometry event will be followed by a done event (starting from"#]
            #[doc = r#"version 2)."#]
            #[doc = r#""#]
            #[doc = r#"Clients should use wl_surface.preferred_buffer_transform instead of the"#]
            #[doc = r#"transform advertised by this event to find the preferred buffer"#]
            #[doc = r#"transform to use for a surface."#]
            #[doc = r#""#]
            #[doc = r#"Note: wl_output only advertises partial information about the output"#]
            #[doc = r#"position and identification. Some compositors, for instance those not"#]
            #[doc = r#"implementing a desktop-style output layout or those exposing virtual"#]
            #[doc = r#"outputs, might fake this information. Instead of using x and y, clients"#]
            #[doc = r#"should use xdg_output.logical_position. Instead of using make and model,"#]
            #[doc = r#"clients should use name and description."#]
            async fn geometry(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                physical_width: i32,
                physical_height: i32,
                subpixel: Subpixel,
                make: String,
                model: String,
                transform: Transform,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_output#{}.geometry()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(x)
                    .put_int(y)
                    .put_int(physical_width)
                    .put_int(physical_height)
                    .put_uint(subpixel as u32)
                    .put_string(Some(make))
                    .put_string(Some(model))
                    .put_uint(transform as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The mode event describes an available mode for the output."#]
            #[doc = r#""#]
            #[doc = r#"The event is sent when binding to the output object and there"#]
            #[doc = r#"will always be one mode, the current mode.  The event is sent"#]
            #[doc = r#"again if an output changes mode, for the mode that is now"#]
            #[doc = r#"current.  In other words, the current mode is always the last"#]
            #[doc = r#"mode that was received with the current flag set."#]
            #[doc = r#""#]
            #[doc = r#"Non-current modes are deprecated. A compositor can decide to only"#]
            #[doc = r#"advertise the current mode and never send other modes. Clients"#]
            #[doc = r#"should not rely on non-current modes."#]
            #[doc = r#""#]
            #[doc = r#"The size of a mode is given in physical hardware units of"#]
            #[doc = r#"the output device. This is not necessarily the same as"#]
            #[doc = r#"the output size in the global compositor space. For instance,"#]
            #[doc = r#"the output may be scaled, as described in wl_output.scale,"#]
            #[doc = r#"or transformed, as described in wl_output.transform. Clients"#]
            #[doc = r#"willing to retrieve the output size in the global compositor"#]
            #[doc = r#"space should use xdg_output.logical_size instead."#]
            #[doc = r#""#]
            #[doc = r#"The vertical refresh rate can be set to zero if it doesn't make"#]
            #[doc = r#"sense for this output (e.g. for virtual outputs)."#]
            #[doc = r#""#]
            #[doc = r#"The mode event will be followed by a done event (starting from"#]
            #[doc = r#"version 2)."#]
            #[doc = r#""#]
            #[doc = r#"Clients should not use the refresh rate to schedule frames. Instead,"#]
            #[doc = r#"they should use the wl_surface.frame event or the presentation-time"#]
            #[doc = r#"protocol."#]
            #[doc = r#""#]
            #[doc = r#"Note: this information is not always meaningful for all outputs. Some"#]
            #[doc = r#"compositors, such as those exposing virtual outputs, might fake the"#]
            #[doc = r#"refresh rate or the size."#]
            async fn mode(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                flags: Mode,
                width: i32,
                height: i32,
                refresh: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_output#{}.mode()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(flags.bits())
                    .put_int(width)
                    .put_int(height)
                    .put_int(refresh)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent after all other properties have been"#]
            #[doc = r#"sent after binding to the output object and after any"#]
            #[doc = r#"other property changes done after that. This allows"#]
            #[doc = r#"changes to the output properties to be seen as"#]
            #[doc = r#"atomic, even if they happen via multiple events."#]
            async fn done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_output#{}.done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event contains scaling geometry information"#]
            #[doc = r#"that is not in the geometry event. It may be sent after"#]
            #[doc = r#"binding the output object or if the output scale changes"#]
            #[doc = r#"later. The compositor will emit a non-zero, positive"#]
            #[doc = r#"value for scale. If it is not sent, the client should"#]
            #[doc = r#"assume a scale of 1."#]
            #[doc = r#""#]
            #[doc = r#"A scale larger than 1 means that the compositor will"#]
            #[doc = r#"automatically scale surface buffers by this amount"#]
            #[doc = r#"when rendering. This is used for very high resolution"#]
            #[doc = r#"displays where applications rendering at the native"#]
            #[doc = r#"resolution would be too small to be legible."#]
            #[doc = r#""#]
            #[doc = r#"Clients should use wl_surface.preferred_buffer_scale"#]
            #[doc = r#"instead of this event to find the preferred buffer"#]
            #[doc = r#"scale to use for a surface."#]
            #[doc = r#""#]
            #[doc = r#"The scale event will be followed by a done event."#]
            async fn scale(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                factor: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_output#{}.scale()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(factor).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Many compositors will assign user-friendly names to their outputs, show"#]
            #[doc = r#"them to the user, allow the user to refer to an output, etc. The client"#]
            #[doc = r#"may wish to know this name as well to offer the user similar behaviors."#]
            #[doc = r#""#]
            #[doc = r#"The name is a UTF-8 string with no convention defined for its contents."#]
            #[doc = r#"Each name is unique among all wl_output globals. The name is only"#]
            #[doc = r#"guaranteed to be unique for the compositor instance."#]
            #[doc = r#""#]
            #[doc = r#"The same output name is used for all clients for a given wl_output"#]
            #[doc = r#"global. Thus, the name can be shared across processes to refer to a"#]
            #[doc = r#"specific wl_output global."#]
            #[doc = r#""#]
            #[doc = r#"The name is not guaranteed to be persistent across sessions, thus cannot"#]
            #[doc = r#"be used to reliably identify an output in e.g. configuration files."#]
            #[doc = r#""#]
            #[doc = r#"Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do"#]
            #[doc = r#"not assume that the name is a reflection of an underlying DRM connector,"#]
            #[doc = r#"X11 connection, etc."#]
            #[doc = r#""#]
            #[doc = r#"The name event is sent after binding the output object. This event is"#]
            #[doc = r#"only sent once per output object, and the name does not change over the"#]
            #[doc = r#"lifetime of the wl_output global."#]
            #[doc = r#""#]
            #[doc = r#"Compositors may re-use the same output name if the wl_output global is"#]
            #[doc = r#"destroyed and re-created later. Compositors should avoid re-using the"#]
            #[doc = r#"same name if possible."#]
            #[doc = r#""#]
            #[doc = r#"The name event will be followed by a done event."#]
            async fn name(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_output#{}.name()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(name))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Many compositors can produce human-readable descriptions of their"#]
            #[doc = r#"outputs. The client may wish to know this description as well, e.g. for"#]
            #[doc = r#"output selection purposes."#]
            #[doc = r#""#]
            #[doc = r#"The description is a UTF-8 string with no convention defined for its"#]
            #[doc = r#"contents. The description is not guaranteed to be unique among all"#]
            #[doc = r#"wl_output globals. Examples might include 'Foocorp 11" Display' or"#]
            #[doc = r#"'Virtual X11 output via :1'."#]
            #[doc = r#""#]
            #[doc = r#"The description event is sent after binding the output object and"#]
            #[doc = r#"whenever the description changes. The description is optional, and may"#]
            #[doc = r#"not be sent at all."#]
            #[doc = r#""#]
            #[doc = r#"The description event will be followed by a done event."#]
            async fn description(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                description: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wl_output#{}.description()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(description))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 5, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod wl_region {
        #[doc = r#"A region object describes an area."#]
        #[doc = r#""#]
        #[doc = r#"Region objects are used to describe the opaque and input"#]
        #[doc = r#"regions of a surface."#]
        pub trait WlRegion: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_region";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wl_region#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("wl_region#{}.add()", object.id);
                        self.add(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("wl_region#{}.subtract()", object.id);
                        self.subtract(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the region.  This will invalidate the object ID."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Add the specified rectangle to the region."#]
            async fn add(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                add: i32,
                add: i32,
                add: i32,
                add: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Subtract the specified rectangle from the region."#]
            async fn subtract(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                subtract: i32,
                subtract: i32,
                subtract: i32,
                subtract: i32,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wl_subcompositor {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"The to-be sub-surface is invalid"#]
            BadSurface = 0,
            #[doc = r#"The to-be sub-surface parent is invalid"#]
            BadParent = 1,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::BadSurface),
                    1 => Ok(Self::BadParent),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"The global interface exposing sub-surface compositing capabilities."#]
        #[doc = r#"A wl_surface, that has sub-surfaces associated, is called the"#]
        #[doc = r#"parent surface. Sub-surfaces can be arbitrarily nested and create"#]
        #[doc = r#"a tree of sub-surfaces."#]
        #[doc = r#""#]
        #[doc = r#"The root surface in a tree of sub-surfaces is the main"#]
        #[doc = r#"surface. The main surface cannot be a sub-surface, because"#]
        #[doc = r#"sub-surfaces must always have a parent."#]
        #[doc = r#""#]
        #[doc = r#"A main surface with its sub-surfaces forms a (compound) window."#]
        #[doc = r#"For window management purposes, this set of wl_surface objects is"#]
        #[doc = r#"to be considered as a single window, and it should also behave as"#]
        #[doc = r#"such."#]
        #[doc = r#""#]
        #[doc = r#"The aim of sub-surfaces is to offload some of the compositing work"#]
        #[doc = r#"within a window from clients to the compositor. A prime example is"#]
        #[doc = r#"a video player with decorations and video in separate wl_surface"#]
        #[doc = r#"objects. This should allow the compositor to pass YUV video buffer"#]
        #[doc = r#"processing to dedicated overlay hardware when possible."#]
        pub trait WlSubcompositor: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_subcompositor";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wl_subcompositor#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("wl_subcompositor#{}.get_subsurface()", object.id);
                        self.get_subsurface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Informs the server that the client will not be using this"#]
            #[doc = r#"protocol object anymore. This does not affect any other"#]
            #[doc = r#"objects, wl_subsurface objects included."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Create a sub-surface interface for the given surface, and"#]
            #[doc = r#"associate it with the given parent surface. This turns a"#]
            #[doc = r#"plain wl_surface into a sub-surface."#]
            #[doc = r#""#]
            #[doc = r#"The to-be sub-surface must not already have another role, and it"#]
            #[doc = r#"must not have an existing wl_subsurface object. Otherwise the"#]
            #[doc = r#"bad_surface protocol error is raised."#]
            #[doc = r#""#]
            #[doc = r#"Adding sub-surfaces to a parent is a double-buffered operation on the"#]
            #[doc = r#"parent (see wl_surface.commit). The effect of adding a sub-surface"#]
            #[doc = r#"becomes visible on the next time the state of the parent surface is"#]
            #[doc = r#"applied."#]
            #[doc = r#""#]
            #[doc = r#"The parent surface must not be one of the child surface's descendants,"#]
            #[doc = r#"and the parent must be different from the child surface, otherwise the"#]
            #[doc = r#"bad_parent protocol error is raised."#]
            #[doc = r#""#]
            #[doc = r#"This request modifies the behaviour of wl_surface.commit request on"#]
            #[doc = r#"the sub-surface, see the documentation on wl_subsurface interface."#]
            async fn get_subsurface(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_subsurface: crate::wire::ObjectId,
                get_subsurface: crate::wire::ObjectId,
                get_subsurface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wl_subsurface {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Wl_surface is not a sibling or the parent"#]
            BadSurface = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::BadSurface),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"An additional interface to a wl_surface object, which has been"#]
        #[doc = r#"made a sub-surface. A sub-surface has one parent surface. A"#]
        #[doc = r#"sub-surface's size and position are not limited to that of the parent."#]
        #[doc = r#"Particularly, a sub-surface is not automatically clipped to its"#]
        #[doc = r#"parent's area."#]
        #[doc = r#""#]
        #[doc = r#"A sub-surface becomes mapped, when a non-NULL wl_buffer is applied"#]
        #[doc = r#"and the parent surface is mapped. The order of which one happens"#]
        #[doc = r#"first is irrelevant. A sub-surface is hidden if the parent becomes"#]
        #[doc = r#"hidden, or if a NULL wl_buffer is applied. These rules apply"#]
        #[doc = r#"recursively through the tree of surfaces."#]
        #[doc = r#""#]
        #[doc = r#"The behaviour of a wl_surface.commit request on a sub-surface"#]
        #[doc = r#"depends on the sub-surface's mode. The possible modes are"#]
        #[doc = r#"synchronized and desynchronized, see methods"#]
        #[doc = r#"wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized"#]
        #[doc = r#"mode caches the wl_surface state to be applied when the parent's"#]
        #[doc = r#"state gets applied, and desynchronized mode applies the pending"#]
        #[doc = r#"wl_surface state directly. A sub-surface is initially in the"#]
        #[doc = r#"synchronized mode."#]
        #[doc = r#""#]
        #[doc = r#"Sub-surfaces also have another kind of state, which is managed by"#]
        #[doc = r#"wl_subsurface requests, as opposed to wl_surface requests. This"#]
        #[doc = r#"state includes the sub-surface position relative to the parent"#]
        #[doc = r#"surface (wl_subsurface.set_position), and the stacking order of"#]
        #[doc = r#"the parent and its sub-surfaces (wl_subsurface.place_above and"#]
        #[doc = r#".place_below). This state is applied when the parent surface's"#]
        #[doc = r#"wl_surface state is applied, regardless of the sub-surface's mode."#]
        #[doc = r#"As the exception, set_sync and set_desync are effective immediately."#]
        #[doc = r#""#]
        #[doc = r#"The main surface can be thought to be always in desynchronized mode,"#]
        #[doc = r#"since it does not have a parent in the sub-surfaces sense."#]
        #[doc = r#""#]
        #[doc = r#"Even if a sub-surface is in desynchronized mode, it will behave as"#]
        #[doc = r#"in synchronized mode, if its parent surface behaves as in"#]
        #[doc = r#"synchronized mode. This rule is applied recursively throughout the"#]
        #[doc = r#"tree of surfaces. This means, that one can set a sub-surface into"#]
        #[doc = r#"synchronized mode, and then assume that all its child and grand-child"#]
        #[doc = r#"sub-surfaces are synchronized, too, without explicitly setting them."#]
        #[doc = r#""#]
        #[doc = r#"Destroying a sub-surface takes effect immediately. If you need to"#]
        #[doc = r#"synchronize the removal of a sub-surface to the parent surface update,"#]
        #[doc = r#"unmap the sub-surface first by attaching a NULL wl_buffer, update parent,"#]
        #[doc = r#"and then destroy the sub-surface."#]
        #[doc = r#""#]
        #[doc = r#"If the parent wl_surface object is destroyed, the sub-surface is"#]
        #[doc = r#"unmapped."#]
        #[doc = r#""#]
        #[doc = r#"A sub-surface never has the keyboard focus of any seat."#]
        #[doc = r#""#]
        #[doc = r#"The wl_surface.offset request is ignored: clients must use set_position"#]
        #[doc = r#"instead to move the sub-surface."#]
        pub trait WlSubsurface: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wl_subsurface";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wl_subsurface#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("wl_subsurface#{}.set_position()", object.id);
                        self.set_position(object, client, message.int()?, message.int()?)
                            .await
                    }
                    2 => {
                        tracing::debug!("wl_subsurface#{}.place_above()", object.id);
                        self.place_above(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3 => {
                        tracing::debug!("wl_subsurface#{}.place_below()", object.id);
                        self.place_below(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    4 => {
                        tracing::debug!("wl_subsurface#{}.set_sync()", object.id);
                        self.set_sync(object, client).await
                    }
                    5 => {
                        tracing::debug!("wl_subsurface#{}.set_desync()", object.id);
                        self.set_desync(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"The sub-surface interface is removed from the wl_surface object"#]
            #[doc = r#"that was turned into a sub-surface with a"#]
            #[doc = r#"wl_subcompositor.get_subsurface request. The wl_surface's association"#]
            #[doc = r#"to the parent is deleted. The wl_surface is unmapped immediately."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This schedules a sub-surface position change."#]
            #[doc = r#"The sub-surface will be moved so that its origin (top left"#]
            #[doc = r#"corner pixel) will be at the location x, y of the parent surface"#]
            #[doc = r#"coordinate system. The coordinates are not restricted to the parent"#]
            #[doc = r#"surface area. Negative values are allowed."#]
            #[doc = r#""#]
            #[doc = r#"The scheduled coordinates will take effect whenever the state of the"#]
            #[doc = r#"parent surface is applied."#]
            #[doc = r#""#]
            #[doc = r#"If more than one set_position request is invoked by the client before"#]
            #[doc = r#"the commit of the parent surface, the position of a new request always"#]
            #[doc = r#"replaces the scheduled position from any previous request."#]
            #[doc = r#""#]
            #[doc = r#"The initial position is 0, 0."#]
            async fn set_position(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_position: i32,
                set_position: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"This sub-surface is taken from the stack, and put back just"#]
            #[doc = r#"above the reference surface, changing the z-order of the sub-surfaces."#]
            #[doc = r#"The reference surface must be one of the sibling surfaces, or the"#]
            #[doc = r#"parent surface. Using any other surface, including this sub-surface,"#]
            #[doc = r#"will cause a protocol error."#]
            #[doc = r#""#]
            #[doc = r#"The z-order is double-buffered. Requests are handled in order and"#]
            #[doc = r#"applied immediately to a pending state. The final pending state is"#]
            #[doc = r#"copied to the active state the next time the state of the parent"#]
            #[doc = r#"surface is applied."#]
            #[doc = r#""#]
            #[doc = r#"A new sub-surface is initially added as the top-most in the stack"#]
            #[doc = r#"of its siblings and parent."#]
            async fn place_above(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                place_above: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"The sub-surface is placed just below the reference surface."#]
            #[doc = r#"See wl_subsurface.place_above."#]
            async fn place_below(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                place_below: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Change the commit behaviour of the sub-surface to synchronized"#]
            #[doc = r#"mode, also described as the parent dependent mode."#]
            #[doc = r#""#]
            #[doc = r#"In synchronized mode, wl_surface.commit on a sub-surface will"#]
            #[doc = r#"accumulate the committed state in a cache, but the state will"#]
            #[doc = r#"not be applied and hence will not change the compositor output."#]
            #[doc = r#"The cached state is applied to the sub-surface immediately after"#]
            #[doc = r#"the parent surface's state is applied. This ensures atomic"#]
            #[doc = r#"updates of the parent and all its synchronized sub-surfaces."#]
            #[doc = r#"Applying the cached state will invalidate the cache, so further"#]
            #[doc = r#"parent surface commits do not (re-)apply old state."#]
            #[doc = r#""#]
            #[doc = r#"See wl_subsurface for the recursive effect of this mode."#]
            async fn set_sync(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Change the commit behaviour of the sub-surface to desynchronized"#]
            #[doc = r#"mode, also described as independent or freely running mode."#]
            #[doc = r#""#]
            #[doc = r#"In desynchronized mode, wl_surface.commit on a sub-surface will"#]
            #[doc = r#"apply the pending state directly, without caching, as happens"#]
            #[doc = r#"normally with a wl_surface. Calling wl_surface.commit on the"#]
            #[doc = r#"parent surface has no effect on the sub-surface's wl_surface"#]
            #[doc = r#"state. This mode allows a sub-surface to be updated on its own."#]
            #[doc = r#""#]
            #[doc = r#"If cached state exists when wl_surface.commit is called in"#]
            #[doc = r#"desynchronized mode, the pending state is added to the cached"#]
            #[doc = r#"state, and applied as a whole. This invalidates the cache."#]
            #[doc = r#""#]
            #[doc = r#"Note: even if a sub-surface is set to desynchronized, a parent"#]
            #[doc = r#"sub-surface may override it to behave as synchronized. For details,"#]
            #[doc = r#"see wl_subsurface."#]
            #[doc = r#""#]
            #[doc = r#"If a surface's parent surface behaves as desynchronized, then"#]
            #[doc = r#"the cached state is applied on set_desync."#]
            async fn set_desync(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod linux_dmabuf_v1 {
    pub mod zwp_linux_dmabuf_v1 {
        #[doc = r#"Following the interfaces from:"#]
        #[doc = r#"https://www.khronos.org/registry/egl/extensions/EXT/EGL_EXT_image_dma_buf_import.txt"#]
        #[doc = r#"https://www.khronos.org/registry/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import_modifiers.txt"#]
        #[doc = r#"and the Linux DRM sub-system's AddFb2 ioctl."#]
        #[doc = r#""#]
        #[doc = r#"This interface offers ways to create generic dmabuf-based wl_buffers."#]
        #[doc = r#""#]
        #[doc = r#"Clients can use the get_surface_feedback request to get dmabuf feedback"#]
        #[doc = r#"for a particular surface. If the client wants to retrieve feedback not"#]
        #[doc = r#"tied to a surface, they can use the get_default_feedback request."#]
        #[doc = r#""#]
        #[doc = r#"The following are required from clients:"#]
        #[doc = r#""#]
        #[doc = r#"- Clients must ensure that either all data in the dma-buf is"#]
        #[doc = r#"coherent for all subsequent read access or that coherency is"#]
        #[doc = r#"correctly handled by the underlying kernel-side dma-buf"#]
        #[doc = r#"implementation."#]
        #[doc = r#""#]
        #[doc = r#"- Don't make any more attachments after sending the buffer to the"#]
        #[doc = r#"compositor. Making more attachments later increases the risk of"#]
        #[doc = r#"the compositor not being able to use (re-import) an existing"#]
        #[doc = r#"dmabuf-based wl_buffer."#]
        #[doc = r#""#]
        #[doc = r#"The underlying graphics stack must ensure the following:"#]
        #[doc = r#""#]
        #[doc = r#"- The dmabuf file descriptors relayed to the server will stay valid"#]
        #[doc = r#"for the whole lifetime of the wl_buffer. This means the server may"#]
        #[doc = r#"at any time use those fds to import the dmabuf into any kernel"#]
        #[doc = r#"sub-system that might accept it."#]
        #[doc = r#""#]
        #[doc = r#"However, when the underlying graphics stack fails to deliver the"#]
        #[doc = r#"promise, because of e.g. a device hot-unplug which raises internal"#]
        #[doc = r#"errors, after the wl_buffer has been successfully created the"#]
        #[doc = r#"compositor must not raise protocol errors to the client when dmabuf"#]
        #[doc = r#"import later fails."#]
        #[doc = r#""#]
        #[doc = r#"To create a wl_buffer from one or more dmabufs, a client creates a"#]
        #[doc = r#"zwp_linux_dmabuf_params_v1 object with a zwp_linux_dmabuf_v1.create_params"#]
        #[doc = r#"request. All planes required by the intended format are added with"#]
        #[doc = r#"the 'add' request. Finally, a 'create' or 'create_immed' request is"#]
        #[doc = r#"issued, which has the following outcome depending on the import success."#]
        #[doc = r#""#]
        #[doc = r#"The 'create' request,"#]
        #[doc = r#"- on success, triggers a 'created' event which provides the final"#]
        #[doc = r#"wl_buffer to the client."#]
        #[doc = r#"- on failure, triggers a 'failed' event to convey that the server"#]
        #[doc = r#"cannot use the dmabufs received from the client."#]
        #[doc = r#""#]
        #[doc = r#"For the 'create_immed' request,"#]
        #[doc = r#"- on success, the server immediately imports the added dmabufs to"#]
        #[doc = r#"create a wl_buffer. No event is sent from the server in this case."#]
        #[doc = r#"- on failure, the server can choose to either:"#]
        #[doc = r#"- terminate the client by raising a fatal error."#]
        #[doc = r#"- mark the wl_buffer as failed, and send a 'failed' event to the"#]
        #[doc = r#"client. If the client uses a failed wl_buffer as an argument to any"#]
        #[doc = r#"request, the behaviour is compositor implementation-defined."#]
        #[doc = r#""#]
        #[doc = r#"For all DRM formats and unless specified in another protocol extension,"#]
        #[doc = r#"pre-multiplied alpha is used for pixel values."#]
        #[doc = r#""#]
        #[doc = r#"Unless specified otherwise in another protocol extension, implicit"#]
        #[doc = r#"synchronization is used. In other words, compositors and clients must"#]
        #[doc = r#"wait and signal fences implicitly passed via the DMA-BUF's reservation"#]
        #[doc = r#"mechanism."#]
        pub trait ZwpLinuxDmabufV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_dmabuf_v1";
            const VERSION: u32 = 5;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.create_params()", object.id);
                        self.create_params(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.get_default_feedback()", object.id);
                        self.get_default_feedback(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.get_surface_feedback()", object.id);
                        self.get_surface_feedback(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Objects created through this interface, especially wl_buffers, will"#]
            #[doc = r#"remain valid."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This temporary object is used to collect multiple dmabuf handles into"#]
            #[doc = r#"a single batch to create a wl_buffer. It can only be used once and"#]
            #[doc = r#"should be destroyed after a 'created' or 'failed' event has been"#]
            #[doc = r#"received."#]
            async fn create_params(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create_params: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request creates a new wp_linux_dmabuf_feedback object not bound"#]
            #[doc = r#"to a particular surface. This object will deliver feedback about dmabuf"#]
            #[doc = r#"parameters to use if the client doesn't support per-surface feedback"#]
            #[doc = r#"(see get_surface_feedback)."#]
            async fn get_default_feedback(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_default_feedback: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request creates a new wp_linux_dmabuf_feedback object for the"#]
            #[doc = r#"specified wl_surface. This object will deliver feedback about dmabuf"#]
            #[doc = r#"parameters to use for buffers attached to this surface."#]
            #[doc = r#""#]
            #[doc = r#"If the surface is destroyed before the wp_linux_dmabuf_feedback object,"#]
            #[doc = r#"the feedback object becomes inert."#]
            async fn get_surface_feedback(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_surface_feedback: crate::wire::ObjectId,
                get_surface_feedback: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event advertises one buffer format that the server supports."#]
            #[doc = r#"All the supported formats are advertised once when the client"#]
            #[doc = r#"binds to this interface. A roundtrip after binding guarantees"#]
            #[doc = r#"that the client has received all supported formats."#]
            #[doc = r#""#]
            #[doc = r#"For the definition of the format codes, see the"#]
            #[doc = r#"zwp_linux_buffer_params_v1::create request."#]
            #[doc = r#""#]
            #[doc = r#"Starting version 4, the format event is deprecated and must not be"#]
            #[doc = r#"sent by compositors. Instead, use get_default_feedback or"#]
            #[doc = r#"get_surface_feedback."#]
            async fn format(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                format: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_linux_dmabuf_v1#{}.format()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(format).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event advertises the formats that the server supports, along with"#]
            #[doc = r#"the modifiers supported for each format. All the supported modifiers"#]
            #[doc = r#"for all the supported formats are advertised once when the client"#]
            #[doc = r#"binds to this interface. A roundtrip after binding guarantees that"#]
            #[doc = r#"the client has received all supported format-modifier pairs."#]
            #[doc = r#""#]
            #[doc = r#"For legacy support, DRM_FORMAT_MOD_INVALID (that is, modifier_hi =="#]
            #[doc = r#"0x00ffffff and modifier_lo == 0xffffffff) is allowed in this event."#]
            #[doc = r#"It indicates that the server can support the format with an implicit"#]
            #[doc = r#"modifier. When a plane has DRM_FORMAT_MOD_INVALID as its modifier, it"#]
            #[doc = r#"is as if no explicit modifier is specified. The effective modifier"#]
            #[doc = r#"will be derived from the dmabuf."#]
            #[doc = r#""#]
            #[doc = r#"A compositor that sends valid modifiers and DRM_FORMAT_MOD_INVALID for"#]
            #[doc = r#"a given format supports both explicit modifiers and implicit modifiers."#]
            #[doc = r#""#]
            #[doc = r#"For the definition of the format and modifier codes, see the"#]
            #[doc = r#"zwp_linux_buffer_params_v1::create and zwp_linux_buffer_params_v1::add"#]
            #[doc = r#"requests."#]
            #[doc = r#""#]
            #[doc = r#"Starting version 4, the modifier event is deprecated and must not be"#]
            #[doc = r#"sent by compositors. Instead, use get_default_feedback or"#]
            #[doc = r#"get_surface_feedback."#]
            async fn modifier(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                format: u32,
                modifier_hi: u32,
                modifier_lo: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_linux_dmabuf_v1#{}.modifier()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(format)
                    .put_uint(modifier_hi)
                    .put_uint(modifier_lo)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_linux_buffer_params_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"The dmabuf_batch object has already been used to create a wl_buffer"#]
            AlreadyUsed = 0,
            #[doc = r#"Plane index out of bounds"#]
            PlaneIdx = 1,
            #[doc = r#"The plane index was already set"#]
            PlaneSet = 2,
            #[doc = r#"Missing or too many planes to create a buffer"#]
            Incomplete = 3,
            #[doc = r#"Format not supported"#]
            InvalidFormat = 4,
            #[doc = r#"Invalid width or height"#]
            InvalidDimensions = 5,
            #[doc = r#"Offset + stride * height goes out of dmabuf bounds"#]
            OutOfBounds = 6,
            #[doc = r#"Invalid wl_buffer resulted from importing dmabufs via"#]
            #[doc = r#"The create_immed request on given buffer_params"#]
            InvalidWlBuffer = 7,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::AlreadyUsed),
                    1 => Ok(Self::PlaneIdx),
                    2 => Ok(Self::PlaneSet),
                    3 => Ok(Self::Incomplete),
                    4 => Ok(Self::InvalidFormat),
                    5 => Ok(Self::InvalidDimensions),
                    6 => Ok(Self::OutOfBounds),
                    7 => Ok(Self::InvalidWlBuffer),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! {
                                    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
                                    pub struct Flags: u32 {#[doc = r#"Contents are y-inverted"#]
        const YInvert = 1;#[doc = r#"Content is interlaced"#]
        const Interlaced = 2;#[doc = r#"Bottom field first"#]
        const BottomFirst = 4;}
                                }
        impl TryFrom<u32> for Flags {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = r#"This temporary object is a collection of dmabufs and other"#]
        #[doc = r#"parameters that together form a single logical buffer. The temporary"#]
        #[doc = r#"object may eventually create one wl_buffer unless cancelled by"#]
        #[doc = r#"destroying it before requesting 'create'."#]
        #[doc = r#""#]
        #[doc = r#"Single-planar formats only require one dmabuf, however"#]
        #[doc = r#"multi-planar formats may require more than one dmabuf. For all"#]
        #[doc = r#"formats, an 'add' request must be called once per plane (even if the"#]
        #[doc = r#"underlying dmabuf fd is identical)."#]
        #[doc = r#""#]
        #[doc = r#"You must use consecutive plane indices ('plane_idx' argument for 'add')"#]
        #[doc = r#"from zero to the number of planes used by the drm_fourcc format code."#]
        #[doc = r#"All planes required by the format must be given exactly once, but can"#]
        #[doc = r#"be given in any order. Each plane index can be set only once."#]
        pub trait ZwpLinuxBufferParamsV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_buffer_params_v1";
            const VERSION: u32 = 5;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.add()", object.id);
                        self.add(
                            object,
                            client,
                            message.fd()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.create()", object.id);
                        self.create(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.uint()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    3 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.create_immed()", object.id);
                        self.create_immed(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.uint()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Cleans up the temporary data sent to the server for dmabuf-based"#]
            #[doc = r#"wl_buffer creation."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request adds one dmabuf to the set in this"#]
            #[doc = r#"zwp_linux_buffer_params_v1."#]
            #[doc = r#""#]
            #[doc = r#"The 64-bit unsigned value combined from modifier_hi and modifier_lo"#]
            #[doc = r#"is the dmabuf layout modifier. DRM AddFB2 ioctl calls this the"#]
            #[doc = r#"fb modifier, which is defined in drm_mode.h of Linux UAPI."#]
            #[doc = r#"This is an opaque token. Drivers use this token to express tiling,"#]
            #[doc = r#"compression, etc. driver-specific modifications to the base format"#]
            #[doc = r#"defined by the DRM fourcc code."#]
            #[doc = r#""#]
            #[doc = r#"Starting from version 4, the invalid_format protocol error is sent if"#]
            #[doc = r#"the format + modifier pair was not advertised as supported."#]
            #[doc = r#""#]
            #[doc = r#"Starting from version 5, the invalid_format protocol error is sent if"#]
            #[doc = r#"all planes don't use the same modifier."#]
            #[doc = r#""#]
            #[doc = r#"This request raises the PLANE_IDX error if plane_idx is too large."#]
            #[doc = r#"The error PLANE_SET is raised if attempting to set a plane that"#]
            #[doc = r#"was already set."#]
            async fn add(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                add: rustix::fd::OwnedFd,
                add: u32,
                add: u32,
                add: u32,
                add: u32,
                add: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"This asks for creation of a wl_buffer from the added dmabuf"#]
            #[doc = r#"buffers. The wl_buffer is not created immediately but returned via"#]
            #[doc = r#"the 'created' event if the dmabuf sharing succeeds. The sharing"#]
            #[doc = r#"may fail at runtime for reasons a client cannot predict, in"#]
            #[doc = r#"which case the 'failed' event is triggered."#]
            #[doc = r#""#]
            #[doc = r#"The 'format' argument is a DRM_FORMAT code, as defined by the"#]
            #[doc = r#"libdrm's drm_fourcc.h. The Linux kernel's DRM sub-system is the"#]
            #[doc = r#"authoritative source on how the format codes should work."#]
            #[doc = r#""#]
            #[doc = r#"The 'flags' is a bitfield of the flags defined in enum "flags"."#]
            #[doc = r#"'y_invert' means the that the image needs to be y-flipped."#]
            #[doc = r#""#]
            #[doc = r#"Flag 'interlaced' means that the frame in the buffer is not"#]
            #[doc = r#"progressive as usual, but interlaced. An interlaced buffer as"#]
            #[doc = r#"supported here must always contain both top and bottom fields."#]
            #[doc = r#"The top field always begins on the first pixel row. The temporal"#]
            #[doc = r#"ordering between the two fields is top field first, unless"#]
            #[doc = r#"'bottom_first' is specified. It is undefined whether 'bottom_first'"#]
            #[doc = r#"is ignored if 'interlaced' is not set."#]
            #[doc = r#""#]
            #[doc = r#"This protocol does not convey any information about field rate,"#]
            #[doc = r#"duration, or timing, other than the relative ordering between the"#]
            #[doc = r#"two fields in one buffer. A compositor may have to estimate the"#]
            #[doc = r#"intended field rate from the incoming buffer rate. It is undefined"#]
            #[doc = r#"whether the time of receiving wl_surface.commit with a new buffer"#]
            #[doc = r#"attached, applying the wl_surface state, wl_surface.frame callback"#]
            #[doc = r#"trigger, presentation, or any other point in the compositor cycle"#]
            #[doc = r#"is used to measure the frame or field times. There is no support"#]
            #[doc = r#"for detecting missed or late frames/fields/buffers either, and"#]
            #[doc = r#"there is no support whatsoever for cooperating with interlaced"#]
            #[doc = r#"compositor output."#]
            #[doc = r#""#]
            #[doc = r#"The composited image quality resulting from the use of interlaced"#]
            #[doc = r#"buffers is explicitly undefined. A compositor may use elaborate"#]
            #[doc = r#"hardware features or software to deinterlace and create progressive"#]
            #[doc = r#"output frames from a sequence of interlaced input buffers, or it"#]
            #[doc = r#"may produce substandard image quality. However, compositors that"#]
            #[doc = r#"cannot guarantee reasonable image quality in all cases are recommended"#]
            #[doc = r#"to just reject all interlaced buffers."#]
            #[doc = r#""#]
            #[doc = r#"Any argument errors, including non-positive width or height,"#]
            #[doc = r#"mismatch between the number of planes and the format, bad"#]
            #[doc = r#"format, bad offset or stride, may be indicated by fatal protocol"#]
            #[doc = r#"errors: INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS,"#]
            #[doc = r#"OUT_OF_BOUNDS."#]
            #[doc = r#""#]
            #[doc = r#"Dmabuf import errors in the server that are not obvious client"#]
            #[doc = r#"bugs are returned via the 'failed' event as non-fatal. This"#]
            #[doc = r#"allows attempting dmabuf sharing and falling back in the client"#]
            #[doc = r#"if it fails."#]
            #[doc = r#""#]
            #[doc = r#"This request can be sent only once in the object's lifetime, after"#]
            #[doc = r#"which the only legal request is destroy. This object should be"#]
            #[doc = r#"destroyed after issuing a 'create' request. Attempting to use this"#]
            #[doc = r#"object after issuing 'create' raises ALREADY_USED protocol error."#]
            #[doc = r#""#]
            #[doc = r#"It is not mandatory to issue 'create'. If a client wants to"#]
            #[doc = r#"cancel the buffer creation, it can just destroy this object."#]
            async fn create(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create: i32,
                create: i32,
                create: u32,
                create: Flags,
            ) -> crate::server::Result<()>;
            #[doc = r#"This asks for immediate creation of a wl_buffer by importing the"#]
            #[doc = r#"added dmabufs."#]
            #[doc = r#""#]
            #[doc = r#"In case of import success, no event is sent from the server, and the"#]
            #[doc = r#"wl_buffer is ready to be used by the client."#]
            #[doc = r#""#]
            #[doc = r#"Upon import failure, either of the following may happen, as seen fit"#]
            #[doc = r#"by the implementation:"#]
            #[doc = r#"- the client is terminated with one of the following fatal protocol"#]
            #[doc = r#"errors:"#]
            #[doc = r#"- INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS, OUT_OF_BOUNDS,"#]
            #[doc = r#"in case of argument errors such as mismatch between the number"#]
            #[doc = r#"of planes and the format, bad format, non-positive width or"#]
            #[doc = r#"height, or bad offset or stride."#]
            #[doc = r#"- INVALID_WL_BUFFER, in case the cause for failure is unknown or"#]
            #[doc = r#"plaform specific."#]
            #[doc = r#"- the server creates an invalid wl_buffer, marks it as failed and"#]
            #[doc = r#"sends a 'failed' event to the client. The result of using this"#]
            #[doc = r#"invalid wl_buffer as an argument in any request by the client is"#]
            #[doc = r#"defined by the compositor implementation."#]
            #[doc = r#""#]
            #[doc = r#"This takes the same arguments as a 'create' request, and obeys the"#]
            #[doc = r#"same restrictions."#]
            async fn create_immed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create_immed: crate::wire::ObjectId,
                create_immed: i32,
                create_immed: i32,
                create_immed: u32,
                create_immed: Flags,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event indicates that the attempted buffer creation was"#]
            #[doc = r#"successful. It provides the new wl_buffer referencing the dmabuf(s)."#]
            #[doc = r#""#]
            #[doc = r#"Upon receiving this event, the client should destroy the"#]
            #[doc = r#"zwp_linux_buffer_params_v1 object."#]
            async fn created(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_linux_buffer_params_v1#{}.created()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(buffer))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event indicates that the attempted buffer creation has"#]
            #[doc = r#"failed. It usually means that one of the dmabuf constraints"#]
            #[doc = r#"has not been fulfilled."#]
            #[doc = r#""#]
            #[doc = r#"Upon receiving this event, the client should destroy the"#]
            #[doc = r#"zwp_linux_buffer_params_v1 object."#]
            async fn failed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_linux_buffer_params_v1#{}.failed()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_linux_dmabuf_feedback_v1 {
        bitflags::bitflags! {
                                    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
                                    pub struct TrancheFlags: u32 {#[doc = r#"Direct scan-out tranche"#]
        const Scanout = 1;}
                                }
        impl TryFrom<u32> for TrancheFlags {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = r#"This object advertises dmabuf parameters feedback. This includes the"#]
        #[doc = r#"preferred devices and the supported formats/modifiers."#]
        #[doc = r#""#]
        #[doc = r#"The parameters are sent once when this object is created and whenever they"#]
        #[doc = r#"change. The done event is always sent once after all parameters have been"#]
        #[doc = r#"sent. When a single parameter changes, all parameters are re-sent by the"#]
        #[doc = r#"compositor."#]
        #[doc = r#""#]
        #[doc = r#"Compositors can re-send the parameters when the current client buffer"#]
        #[doc = r#"allocations are sub-optimal. Compositors should not re-send the"#]
        #[doc = r#"parameters if re-allocating the buffers would not result in a more optimal"#]
        #[doc = r#"configuration. In particular, compositors should avoid sending the exact"#]
        #[doc = r#"same parameters multiple times in a row."#]
        #[doc = r#""#]
        #[doc = r#"The tranche_target_device and tranche_formats events are grouped by"#]
        #[doc = r#"tranches of preference. For each tranche, a tranche_target_device, one"#]
        #[doc = r#"tranche_flags and one or more tranche_formats events are sent, followed"#]
        #[doc = r#"by a tranche_done event finishing the list. The tranches are sent in"#]
        #[doc = r#"descending order of preference. All formats and modifiers in the same"#]
        #[doc = r#"tranche have the same preference."#]
        #[doc = r#""#]
        #[doc = r#"To send parameters, the compositor sends one main_device event, tranches"#]
        #[doc = r#"(each consisting of one tranche_target_device event, one tranche_flags"#]
        #[doc = r#"event, tranche_formats events and then a tranche_done event), then one"#]
        #[doc = r#"done event."#]
        pub trait ZwpLinuxDmabufFeedbackV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_dmabuf_feedback_v1";
            const VERSION: u32 = 5;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_linux_dmabuf_feedback_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Using this request a client can tell the server that it is not going to"#]
            #[doc = r#"use the wp_linux_dmabuf_feedback object anymore."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event is sent after all parameters of a wp_linux_dmabuf_feedback"#]
            #[doc = r#"object have been sent."#]
            #[doc = r#""#]
            #[doc = r#"This allows changes to the wp_linux_dmabuf_feedback parameters to be"#]
            #[doc = r#"seen as atomic, even if they happen via multiple events."#]
            async fn done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_linux_dmabuf_feedback_v1#{}.done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event provides a file descriptor which can be memory-mapped to"#]
            #[doc = r#"access the format and modifier table."#]
            #[doc = r#""#]
            #[doc = r#"The table contains a tightly packed array of consecutive format +"#]
            #[doc = r#"modifier pairs. Each pair is 16 bytes wide. It contains a format as a"#]
            #[doc = r#"32-bit unsigned integer, followed by 4 bytes of unused padding, and a"#]
            #[doc = r#"modifier as a 64-bit unsigned integer. The native endianness is used."#]
            #[doc = r#""#]
            #[doc = r#"The client must map the file descriptor in read-only private mode."#]
            #[doc = r#""#]
            #[doc = r#"Compositors are not allowed to mutate the table file contents once this"#]
            #[doc = r#"event has been sent. Instead, compositors must create a new, separate"#]
            #[doc = r#"table file and re-send feedback parameters. Compositors are allowed to"#]
            #[doc = r#"store duplicate format + modifier pairs in the table."#]
            async fn format_table(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                fd: rustix::fd::OwnedFd,
                size: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.format_table()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fd(fd)
                    .put_uint(size)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event advertises the main device that the server prefers to use"#]
            #[doc = r#"when direct scan-out to the target device isn't possible. The"#]
            #[doc = r#"advertised main device may be different for each"#]
            #[doc = r#"wp_linux_dmabuf_feedback object, and may change over time."#]
            #[doc = r#""#]
            #[doc = r#"There is exactly one main device. The compositor must send at least"#]
            #[doc = r#"one preference tranche with tranche_target_device equal to main_device."#]
            #[doc = r#""#]
            #[doc = r#"Clients need to create buffers that the main device can import and"#]
            #[doc = r#"read from, otherwise creating the dmabuf wl_buffer will fail (see the"#]
            #[doc = r#"wp_linux_buffer_params.create and create_immed requests for details)."#]
            #[doc = r#"The main device will also likely be kept active by the compositor,"#]
            #[doc = r#"so clients can use it instead of waking up another device for power"#]
            #[doc = r#"savings."#]
            #[doc = r#""#]
            #[doc = r#"In general the device is a DRM node. The DRM node type (primary vs."#]
            #[doc = r#"render) is unspecified. Clients must not rely on the compositor sending"#]
            #[doc = r#"a particular node type. Clients cannot check two devices for equality"#]
            #[doc = r#"by comparing the dev_t value."#]
            #[doc = r#""#]
            #[doc = r#"If explicit modifiers are not supported and the client performs buffer"#]
            #[doc = r#"allocations on a different device than the main device, then the client"#]
            #[doc = r#"must force the buffer to have a linear layout."#]
            async fn main_device(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                device: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.main_device()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_array(device).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event splits tranche_target_device and tranche_formats events in"#]
            #[doc = r#"preference tranches. It is sent after a set of tranche_target_device"#]
            #[doc = r#"and tranche_formats events; it represents the end of a tranche. The"#]
            #[doc = r#"next tranche will have a lower preference."#]
            async fn tranche_done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.tranche_done()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event advertises the target device that the server prefers to use"#]
            #[doc = r#"for a buffer created given this tranche. The advertised target device"#]
            #[doc = r#"may be different for each preference tranche, and may change over time."#]
            #[doc = r#""#]
            #[doc = r#"There is exactly one target device per tranche."#]
            #[doc = r#""#]
            #[doc = r#"The target device may be a scan-out device, for example if the"#]
            #[doc = r#"compositor prefers to directly scan-out a buffer created given this"#]
            #[doc = r#"tranche. The target device may be a rendering device, for example if"#]
            #[doc = r#"the compositor prefers to texture from said buffer."#]
            #[doc = r#""#]
            #[doc = r#"The client can use this hint to allocate the buffer in a way that makes"#]
            #[doc = r#"it accessible from the target device, ideally directly. The buffer must"#]
            #[doc = r#"still be accessible from the main device, either through direct import"#]
            #[doc = r#"or through a potentially more expensive fallback path. If the buffer"#]
            #[doc = r#"can't be directly imported from the main device then clients must be"#]
            #[doc = r#"prepared for the compositor changing the tranche priority or making"#]
            #[doc = r#"wl_buffer creation fail (see the wp_linux_buffer_params.create and"#]
            #[doc = r#"create_immed requests for details)."#]
            #[doc = r#""#]
            #[doc = r#"If the device is a DRM node, the DRM node type (primary vs. render) is"#]
            #[doc = r#"unspecified. Clients must not rely on the compositor sending a"#]
            #[doc = r#"particular node type. Clients cannot check two devices for equality by"#]
            #[doc = r#"comparing the dev_t value."#]
            #[doc = r#""#]
            #[doc = r#"This event is tied to a preference tranche, see the tranche_done event."#]
            async fn tranche_target_device(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                device: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.tranche_target_device()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_array(device).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event advertises the format + modifier combinations that the"#]
            #[doc = r#"compositor supports."#]
            #[doc = r#""#]
            #[doc = r#"It carries an array of indices, each referring to a format + modifier"#]
            #[doc = r#"pair in the last received format table (see the format_table event)."#]
            #[doc = r#"Each index is a 16-bit unsigned integer in native endianness."#]
            #[doc = r#""#]
            #[doc = r#"For legacy support, DRM_FORMAT_MOD_INVALID is an allowed modifier."#]
            #[doc = r#"It indicates that the server can support the format with an implicit"#]
            #[doc = r#"modifier. When a buffer has DRM_FORMAT_MOD_INVALID as its modifier, it"#]
            #[doc = r#"is as if no explicit modifier is specified. The effective modifier"#]
            #[doc = r#"will be derived from the dmabuf."#]
            #[doc = r#""#]
            #[doc = r#"A compositor that sends valid modifiers and DRM_FORMAT_MOD_INVALID for"#]
            #[doc = r#"a given format supports both explicit modifiers and implicit modifiers."#]
            #[doc = r#""#]
            #[doc = r#"Compositors must not send duplicate format + modifier pairs within the"#]
            #[doc = r#"same tranche or across two different tranches with the same target"#]
            #[doc = r#"device and flags."#]
            #[doc = r#""#]
            #[doc = r#"This event is tied to a preference tranche, see the tranche_done event."#]
            #[doc = r#""#]
            #[doc = r#"For the definition of the format and modifier codes, see the"#]
            #[doc = r#"wp_linux_buffer_params.create request."#]
            async fn tranche_formats(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                indices: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.tranche_formats()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_array(indices)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 5, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event sets tranche-specific flags."#]
            #[doc = r#""#]
            #[doc = r#"The scanout flag is a hint that direct scan-out may be attempted by the"#]
            #[doc = r#"compositor on the target device if the client appropriately allocates a"#]
            #[doc = r#"buffer. How to allocate a buffer that can be scanned out on the target"#]
            #[doc = r#"device is implementation-defined."#]
            #[doc = r#""#]
            #[doc = r#"This event is tied to a preference tranche, see the tranche_done event."#]
            async fn tranche_flags(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                flags: TrancheFlags,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.tranche_flags()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(flags.bits())
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 6, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod presentation_time {
    pub mod wp_presentation {
        #[doc = r#"These fatal protocol errors may be emitted in response to"#]
        #[doc = r#"illegal presentation requests."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Invalid value in tv_nsec"#]
            InvalidTimestamp = 0,
            #[doc = r#"Invalid flag"#]
            InvalidFlag = 1,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::InvalidTimestamp),
                    1 => Ok(Self::InvalidFlag),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"The main feature of this interface is accurate presentation"#]
        #[doc = r#"timing feedback to ensure smooth video playback while maintaining"#]
        #[doc = r#"audio/video synchronization. Some features use the concept of a"#]
        #[doc = r#"presentation clock, which is defined in the"#]
        #[doc = r#"presentation.clock_id event."#]
        #[doc = r#""#]
        #[doc = r#"A content update for a wl_surface is submitted by a"#]
        #[doc = r#"wl_surface.commit request. Request 'feedback' associates with"#]
        #[doc = r#"the wl_surface.commit and provides feedback on the content"#]
        #[doc = r#"update, particularly the final realized presentation time."#]
        #[doc = r#""#]
        #[doc = r#""#]
        #[doc = r#""#]
        #[doc = r#"When the final realized presentation time is available, e.g."#]
        #[doc = r#"after a framebuffer flip completes, the requested"#]
        #[doc = r#"presentation_feedback.presented events are sent. The final"#]
        #[doc = r#"presentation time can differ from the compositor's predicted"#]
        #[doc = r#"display update time and the update's target time, especially"#]
        #[doc = r#"when the compositor misses its target vertical blanking period."#]
        pub trait WpPresentation: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_presentation";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wp_presentation#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("wp_presentation#{}.feedback()", object.id);
                        self.feedback(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Informs the server that the client will no longer be using"#]
            #[doc = r#"this protocol object. Existing objects created by this object"#]
            #[doc = r#"are not affected."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Request presentation feedback for the current content submission"#]
            #[doc = r#"on the given surface. This creates a new presentation_feedback"#]
            #[doc = r#"object, which will deliver the feedback information once. If"#]
            #[doc = r#"multiple presentation_feedback objects are created for the same"#]
            #[doc = r#"submission, they will all deliver the same information."#]
            #[doc = r#""#]
            #[doc = r#"For details on what information is returned, see the"#]
            #[doc = r#"presentation_feedback interface."#]
            async fn feedback(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                feedback: crate::wire::ObjectId,
                feedback: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event tells the client in which clock domain the"#]
            #[doc = r#"compositor interprets the timestamps used by the presentation"#]
            #[doc = r#"extension. This clock is called the presentation clock."#]
            #[doc = r#""#]
            #[doc = r#"The compositor sends this event when the client binds to the"#]
            #[doc = r#"presentation interface. The presentation clock does not change"#]
            #[doc = r#"during the lifetime of the client connection."#]
            #[doc = r#""#]
            #[doc = r#"The clock identifier is platform dependent. On POSIX platforms, the"#]
            #[doc = r#"identifier value is one of the clockid_t values accepted by"#]
            #[doc = r#"clock_gettime(). clock_gettime() is defined by POSIX.1-2001."#]
            #[doc = r#""#]
            #[doc = r#"Timestamps in this clock domain are expressed as tv_sec_hi,"#]
            #[doc = r#"tv_sec_lo, tv_nsec triples, each component being an unsigned"#]
            #[doc = r#"32-bit value. Whole seconds are in tv_sec which is a 64-bit"#]
            #[doc = r#"value combined from tv_sec_hi and tv_sec_lo, and the"#]
            #[doc = r#"additional fractional part in tv_nsec as nanoseconds. Hence,"#]
            #[doc = r#"for valid timestamps tv_nsec must be in [0, 999999999]."#]
            #[doc = r#""#]
            #[doc = r#"Note that clock_id applies only to the presentation clock,"#]
            #[doc = r#"and implies nothing about e.g. the timestamps used in the"#]
            #[doc = r#"Wayland core protocol input events."#]
            #[doc = r#""#]
            #[doc = r#"Compositors should prefer a clock which does not jump and is"#]
            #[doc = r#"not slewed e.g. by NTP. The absolute value of the clock is"#]
            #[doc = r#"irrelevant. Precision of one millisecond or better is"#]
            #[doc = r#"recommended. Clients must be able to query the current clock"#]
            #[doc = r#"value directly, not by asking the compositor."#]
            async fn clock_id(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                clk_id: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_presentation#{}.clock_id()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(clk_id).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod wp_presentation_feedback {
        #[doc = r#"These flags provide information about how the presentation of"#]
        #[doc = r#"the related content update was done. The intent is to help"#]
        #[doc = r#"clients assess the reliability of the feedback and the visual"#]
        #[doc = r#"quality with respect to possible tearing and timings."#]
        bitflags::bitflags! {
            #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
            pub struct Kind: u32 {const Vsync = 0x1;const HwClock = 0x2;const HwCompletion = 0x4;const ZeroCopy = 0x8;}
        }
        impl TryFrom<u32> for Kind {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = r#"A presentation_feedback object returns an indication that a"#]
        #[doc = r#"wl_surface content update has become visible to the user."#]
        #[doc = r#"One object corresponds to one content update submission"#]
        #[doc = r#"(wl_surface.commit). There are two possible outcomes: the"#]
        #[doc = r#"content update is presented to the user, and a presentation"#]
        #[doc = r#"timestamp delivered; or, the user did not see the content"#]
        #[doc = r#"update because it was superseded or its surface destroyed,"#]
        #[doc = r#"and the content update is discarded."#]
        #[doc = r#""#]
        #[doc = r#"Once a presentation_feedback object has delivered a 'presented'"#]
        #[doc = r#"or 'discarded' event it is automatically destroyed."#]
        pub trait WpPresentationFeedback: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_presentation_feedback";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"As presentation can be synchronized to only one output at a"#]
            #[doc = r#"time, this event tells which output it was. This event is only"#]
            #[doc = r#"sent prior to the presented event."#]
            #[doc = r#""#]
            #[doc = r#"As clients may bind to the same global wl_output multiple"#]
            #[doc = r#"times, this event is sent for each bound instance that matches"#]
            #[doc = r#"the synchronized output. If a client has not bound to the"#]
            #[doc = r#"right wl_output global at all, this event is not sent."#]
            async fn sync_output(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_presentation_feedback#{}.sync_output()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(output))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The associated content update was displayed to the user at the"#]
            #[doc = r#"indicated time (tv_sec_hi/lo, tv_nsec). For the interpretation of"#]
            #[doc = r#"the timestamp, see presentation.clock_id event."#]
            #[doc = r#""#]
            #[doc = r#"The timestamp corresponds to the time when the content update"#]
            #[doc = r#"turned into light the first time on the surface's main output."#]
            #[doc = r#"Compositors may approximate this from the framebuffer flip"#]
            #[doc = r#"completion events from the system, and the latency of the"#]
            #[doc = r#"physical display path if known."#]
            #[doc = r#""#]
            #[doc = r#"This event is preceded by all related sync_output events"#]
            #[doc = r#"telling which output's refresh cycle the feedback corresponds"#]
            #[doc = r#"to, i.e. the main output for the surface. Compositors are"#]
            #[doc = r#"recommended to choose the output containing the largest part"#]
            #[doc = r#"of the wl_surface, or keeping the output they previously"#]
            #[doc = r#"chose. Having a stable presentation output association helps"#]
            #[doc = r#"clients predict future output refreshes (vblank)."#]
            #[doc = r#""#]
            #[doc = r#"The 'refresh' argument gives the compositor's prediction of how"#]
            #[doc = r#"many nanoseconds after tv_sec, tv_nsec the very next output"#]
            #[doc = r#"refresh may occur. This is to further aid clients in"#]
            #[doc = r#"predicting future refreshes, i.e., estimating the timestamps"#]
            #[doc = r#"targeting the next few vblanks. If such prediction cannot"#]
            #[doc = r#"usefully be done, the argument is zero."#]
            #[doc = r#""#]
            #[doc = r#"If the output does not have a constant refresh rate, explicit"#]
            #[doc = r#"video mode switches excluded, then the refresh argument must"#]
            #[doc = r#"be zero."#]
            #[doc = r#""#]
            #[doc = r#"The 64-bit value combined from seq_hi and seq_lo is the value"#]
            #[doc = r#"of the output's vertical retrace counter when the content"#]
            #[doc = r#"update was first scanned out to the display. This value must"#]
            #[doc = r#"be compatible with the definition of MSC in"#]
            #[doc = r#"GLX_OML_sync_control specification. Note, that if the display"#]
            #[doc = r#"path has a non-zero latency, the time instant specified by"#]
            #[doc = r#"this counter may differ from the timestamp's."#]
            #[doc = r#""#]
            #[doc = r#"If the output does not have a concept of vertical retrace or a"#]
            #[doc = r#"refresh cycle, or the output device is self-refreshing without"#]
            #[doc = r#"a way to query the refresh count, then the arguments seq_hi"#]
            #[doc = r#"and seq_lo must be zero."#]
            async fn presented(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                tv_sec_hi: u32,
                tv_sec_lo: u32,
                tv_nsec: u32,
                refresh: u32,
                seq_hi: u32,
                seq_lo: u32,
                flags: Kind,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_presentation_feedback#{}.presented()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(tv_sec_hi)
                    .put_uint(tv_sec_lo)
                    .put_uint(tv_nsec)
                    .put_uint(refresh)
                    .put_uint(seq_hi)
                    .put_uint(seq_lo)
                    .put_uint(flags.bits())
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The content update was never displayed to the user."#]
            async fn discarded(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_presentation_feedback#{}.discarded()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = r#"This description provides a high-level overview of the interplay between"#]
#[doc = r#"the interfaces defined this protocol. For details, see the protocol"#]
#[doc = r#"specification."#]
#[doc = r#""#]
#[doc = r#"More than one tablet may exist, and device-specifics matter. Tablets are"#]
#[doc = r#"not represented by a single virtual device like wl_pointer. A client"#]
#[doc = r#"binds to the tablet manager object which is just a proxy object. From"#]
#[doc = r#"that, the client requests wp_tablet_manager.get_tablet_seat(wl_seat)"#]
#[doc = r#"and that returns the actual interface that has all the tablets. With"#]
#[doc = r#"this indirection, we can avoid merging wp_tablet into the actual Wayland"#]
#[doc = r#"protocol, a long-term benefit."#]
#[doc = r#""#]
#[doc = r#"The wp_tablet_seat sends a "tablet added" event for each tablet"#]
#[doc = r#"connected. That event is followed by descriptive events about the"#]
#[doc = r#"hardware; currently that includes events for name, vid/pid and"#]
#[doc = r#"a wp_tablet.path event that describes a local path. This path can be"#]
#[doc = r#"used to uniquely identify a tablet or get more information through"#]
#[doc = r#"libwacom. Emulated or nested tablets can skip any of those, e.g. a"#]
#[doc = r#"virtual tablet may not have a vid/pid. The sequence of descriptive"#]
#[doc = r#"events is terminated by a wp_tablet.done event to signal that a client"#]
#[doc = r#"may now finalize any initialization for that tablet."#]
#[doc = r#""#]
#[doc = r#"Events from tablets require a tool in proximity. Tools are also managed"#]
#[doc = r#"by the tablet seat; a "tool added" event is sent whenever a tool is new"#]
#[doc = r#"to the compositor. That event is followed by a number of descriptive"#]
#[doc = r#"events about the hardware; currently that includes capabilities,"#]
#[doc = r#"hardware id and serial number, and tool type. Similar to the tablet"#]
#[doc = r#"interface, a wp_tablet_tool.done event is sent to terminate that initial"#]
#[doc = r#"sequence."#]
#[doc = r#""#]
#[doc = r#"Any event from a tool happens on the wp_tablet_tool interface. When the"#]
#[doc = r#"tool gets into proximity of the tablet, a proximity_in event is sent on"#]
#[doc = r#"the wp_tablet_tool interface, listing the tablet and the surface. That"#]
#[doc = r#"event is followed by a motion event with the coordinates. After that,"#]
#[doc = r#"it's the usual motion, axis, button, etc. events. The protocol's"#]
#[doc = r#"serialisation means events are grouped by wp_tablet_tool.frame events."#]
#[doc = r#""#]
#[doc = r#"Two special events (that don't exist in X) are down and up. They signal"#]
#[doc = r#""tip touching the surface". For tablets without real proximity"#]
#[doc = r#"detection, the sequence is: proximity_in, motion, down, frame."#]
#[doc = r#""#]
#[doc = r#"When the tool leaves proximity, a proximity_out event is sent. If any"#]
#[doc = r#"button is still down, a button release event is sent before this"#]
#[doc = r#"proximity event. These button events are sent in the same frame as the"#]
#[doc = r#"proximity event to signal to the client that the buttons were held when"#]
#[doc = r#"the tool left proximity."#]
#[doc = r#""#]
#[doc = r#"If the tool moves out of the surface but stays in proximity (i.e."#]
#[doc = r#"between windows), compositor-specific grab policies apply. This usually"#]
#[doc = r#"means that the proximity-out is delayed until all buttons are released."#]
#[doc = r#""#]
#[doc = r#"Moving a tool physically from one tablet to the other has no real effect"#]
#[doc = r#"on the protocol, since we already have the tool object from the "tool"#]
#[doc = r#"added" event. All the information is already there and the proximity"#]
#[doc = r#"events on both tablets are all a client needs to reconstruct what"#]
#[doc = r#"happened."#]
#[doc = r#""#]
#[doc = r#"Some extra axes are normalized, i.e. the client knows the range as"#]
#[doc = r#"specified in the protocol (e.g. [0, 65535]), the granularity however is"#]
#[doc = r#"unknown. The current normalized axes are pressure, distance, and slider."#]
#[doc = r#""#]
#[doc = r#"Other extra axes are in physical units as specified in the protocol."#]
#[doc = r#"The current extra axes with physical units are tilt, rotation and"#]
#[doc = r#"wheel rotation."#]
#[doc = r#""#]
#[doc = r#"Since tablets work independently of the pointer controlled by the mouse,"#]
#[doc = r#"the focus handling is independent too and controlled by proximity."#]
#[doc = r#"The wp_tablet_tool.set_cursor request sets a tool-specific cursor."#]
#[doc = r#"This cursor surface may be the same as the mouse cursor, and it may be"#]
#[doc = r#"the same across tools but it is possible to be more fine-grained. For"#]
#[doc = r#"example, a client may set different cursors for the pen and eraser."#]
#[doc = r#""#]
#[doc = r#"Tools are generally independent of tablets and it is"#]
#[doc = r#"compositor-specific policy when a tool can be removed. Common approaches"#]
#[doc = r#"will likely include some form of removing a tool when all tablets the"#]
#[doc = r#"tool was used on are removed."#]
pub mod tablet_v2 {
    pub mod zwp_tablet_manager_v2 {
        #[doc = r#"An object that provides access to the graphics tablets available on this"#]
        #[doc = r#"system. All tablets are associated with a seat, to get access to the"#]
        #[doc = r#"actual tablets, use wp_tablet_manager.get_tablet_seat."#]
        pub trait ZwpTabletManagerV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_manager_v2";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_tablet_manager_v2#{}.get_tablet_seat()", object.id);
                        self.get_tablet_seat(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwp_tablet_manager_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Get the wp_tablet_seat object for the given seat. This object"#]
            #[doc = r#"provides access to all graphics tablets in this seat."#]
            async fn get_tablet_seat(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_tablet_seat: crate::wire::ObjectId,
                get_tablet_seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Destroy the wp_tablet_manager object. Objects created from this"#]
            #[doc = r#"object are unaffected and should be destroyed separately."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_tablet_seat_v2 {
        #[doc = r#"An object that provides access to the graphics tablets available on this"#]
        #[doc = r#"seat. After binding to this interface, the compositor sends a set of"#]
        #[doc = r#"wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events."#]
        pub trait ZwpTabletSeatV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_seat_v2";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_tablet_seat_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the wp_tablet_seat object. Objects created from this"#]
            #[doc = r#"object are unaffected and should be destroyed separately."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event is sent whenever a new tablet becomes available on this"#]
            #[doc = r#"seat. This event only provides the object id of the tablet, any"#]
            #[doc = r#"static information about the tablet (device name, vid/pid, etc.) is"#]
            #[doc = r#"sent through the wp_tablet interface."#]
            async fn tablet_added(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_seat_v2#{}.tablet_added()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent whenever a tool that has not previously been used"#]
            #[doc = r#"with a tablet comes into use. This event only provides the object id"#]
            #[doc = r#"of the tool; any static information about the tool (capabilities,"#]
            #[doc = r#"type, etc.) is sent through the wp_tablet_tool interface."#]
            async fn tool_added(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_seat_v2#{}.tool_added()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent whenever a new pad is known to the system. Typically,"#]
            #[doc = r#"pads are physically attached to tablets and a pad_added event is"#]
            #[doc = r#"sent immediately after the wp_tablet_seat.tablet_added."#]
            #[doc = r#"However, some standalone pad devices logically attach to tablets at"#]
            #[doc = r#"runtime, and the client must wait for wp_tablet_pad.enter to know"#]
            #[doc = r#"the tablet a pad is attached to."#]
            #[doc = r#""#]
            #[doc = r#"This event only provides the object id of the pad. All further"#]
            #[doc = r#"features (buttons, strips, rings) are sent through the wp_tablet_pad"#]
            #[doc = r#"interface."#]
            async fn pad_added(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_seat_v2#{}.pad_added()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_tablet_tool_v2 {
        #[doc = r#"Describes the physical type of a tool. The physical type of a tool"#]
        #[doc = r#"generally defines its base usage."#]
        #[doc = r#""#]
        #[doc = r#"The mouse tool represents a mouse-shaped tool that is not a relative"#]
        #[doc = r#"device but bound to the tablet's surface, providing absolute"#]
        #[doc = r#"coordinates."#]
        #[doc = r#""#]
        #[doc = r#"The lens tool is a mouse-shaped tool with an attached lens to"#]
        #[doc = r#"provide precision focus."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Type {
            #[doc = r#"Pen"#]
            Pen = 0x140,
            #[doc = r#"Eraser"#]
            Eraser = 0x141,
            #[doc = r#"Brush"#]
            Brush = 0x142,
            #[doc = r#"Pencil"#]
            Pencil = 0x143,
            #[doc = r#"Airbrush"#]
            Airbrush = 0x144,
            #[doc = r#"Finger"#]
            Finger = 0x145,
            #[doc = r#"Mouse"#]
            Mouse = 0x146,
            #[doc = r#"Lens"#]
            Lens = 0x147,
        }
        impl TryFrom<u32> for Type {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0x140 => Ok(Self::Pen),
                    0x141 => Ok(Self::Eraser),
                    0x142 => Ok(Self::Brush),
                    0x143 => Ok(Self::Pencil),
                    0x144 => Ok(Self::Airbrush),
                    0x145 => Ok(Self::Finger),
                    0x146 => Ok(Self::Mouse),
                    0x147 => Ok(Self::Lens),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"Describes extra capabilities on a tablet."#]
        #[doc = r#""#]
        #[doc = r#"Any tool must provide x and y values, extra axes are"#]
        #[doc = r#"device-specific."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Capability {
            #[doc = r#"Tilt axes"#]
            Tilt = 1,
            #[doc = r#"Pressure axis"#]
            Pressure = 2,
            #[doc = r#"Distance axis"#]
            Distance = 3,
            #[doc = r#"Z-rotation axis"#]
            Rotation = 4,
            #[doc = r#"Slider axis"#]
            Slider = 5,
            #[doc = r#"Wheel axis"#]
            Wheel = 6,
        }
        impl TryFrom<u32> for Capability {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::Tilt),
                    2 => Ok(Self::Pressure),
                    3 => Ok(Self::Distance),
                    4 => Ok(Self::Rotation),
                    5 => Ok(Self::Slider),
                    6 => Ok(Self::Wheel),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"Describes the physical state of a button that produced the button event."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ButtonState {
            #[doc = r#"Button is not pressed"#]
            Released = 0,
            #[doc = r#"Button is pressed"#]
            Pressed = 1,
        }
        impl TryFrom<u32> for ButtonState {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Released),
                    1 => Ok(Self::Pressed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Given wl_surface has another role"#]
            Role = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Role),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"An object that represents a physical tool that has been, or is"#]
        #[doc = r#"currently in use with a tablet in this seat. Each wp_tablet_tool"#]
        #[doc = r#"object stays valid until the client destroys it; the compositor"#]
        #[doc = r#"reuses the wp_tablet_tool object to indicate that the object's"#]
        #[doc = r#"respective physical tool has come into proximity of a tablet again."#]
        #[doc = r#""#]
        #[doc = r#"A wp_tablet_tool object's relation to a physical tool depends on the"#]
        #[doc = r#"tablet's ability to report serial numbers. If the tablet supports"#]
        #[doc = r#"this capability, then the object represents a specific physical tool"#]
        #[doc = r#"and can be identified even when used on multiple tablets."#]
        #[doc = r#""#]
        #[doc = r#"A tablet tool has a number of static characteristics, e.g. tool type,"#]
        #[doc = r#"hardware_serial and capabilities. These capabilities are sent in an"#]
        #[doc = r#"event sequence after the wp_tablet_seat.tool_added event before any"#]
        #[doc = r#"actual events from this tool. This initial event sequence is"#]
        #[doc = r#"terminated by a wp_tablet_tool.done event."#]
        #[doc = r#""#]
        #[doc = r#"Tablet tool events are grouped by wp_tablet_tool.frame events."#]
        #[doc = r#"Any events received before a wp_tablet_tool.frame event should be"#]
        #[doc = r#"considered part of the same hardware state change."#]
        pub trait ZwpTabletToolV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_tool_v2";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_tablet_tool_v2#{}.set_cursor()", object.id);
                        self.set_cursor(
                            object,
                            client,
                            message.uint()?,
                            message.object()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwp_tablet_tool_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Sets the surface of the cursor used for this tool on the given"#]
            #[doc = r#"tablet. This request only takes effect if the tool is in proximity"#]
            #[doc = r#"of one of the requesting client's surfaces or the surface parameter"#]
            #[doc = r#"is the current pointer surface. If there was a previous surface set"#]
            #[doc = r#"with this request it is replaced. If surface is NULL, the cursor"#]
            #[doc = r#"image is hidden."#]
            #[doc = r#""#]
            #[doc = r#"The parameters hotspot_x and hotspot_y define the position of the"#]
            #[doc = r#"pointer surface relative to the pointer location. Its top-left corner"#]
            #[doc = r#"is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the"#]
            #[doc = r#"coordinates of the pointer location, in surface-local coordinates."#]
            #[doc = r#""#]
            #[doc = r#"On surface.attach requests to the pointer surface, hotspot_x and"#]
            #[doc = r#"hotspot_y are decremented by the x and y parameters passed to the"#]
            #[doc = r#"request. Attach must be confirmed by wl_surface.commit as usual."#]
            #[doc = r#""#]
            #[doc = r#"The hotspot can also be updated by passing the currently set pointer"#]
            #[doc = r#"surface to this request with new values for hotspot_x and hotspot_y."#]
            #[doc = r#""#]
            #[doc = r#"The current and pending input regions of the wl_surface are cleared,"#]
            #[doc = r#"and wl_surface.set_input_region is ignored until the wl_surface is no"#]
            #[doc = r#"longer used as the cursor. When the use as a cursor ends, the current"#]
            #[doc = r#"and pending input regions become undefined, and the wl_surface is"#]
            #[doc = r#"unmapped."#]
            #[doc = r#""#]
            #[doc = r#"This request gives the surface the role of a wp_tablet_tool cursor. A"#]
            #[doc = r#"surface may only ever be used as the cursor surface for one"#]
            #[doc = r#"wp_tablet_tool. If the surface already has another role or has"#]
            #[doc = r#"previously been used as cursor surface for a different tool, a"#]
            #[doc = r#"protocol error is raised."#]
            async fn set_cursor(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_cursor: u32,
                set_cursor: Option<crate::wire::ObjectId>,
                set_cursor: i32,
                set_cursor: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"This destroys the client's resource for this tool object."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"The tool type is the high-level type of the tool and usually decides"#]
            #[doc = r#"the interaction expected from this tool."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_tool.done event."#]
            async fn r#type(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                tool_type: Type,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.type()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(tool_type as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"If the physical tool can be identified by a unique 64-bit serial"#]
            #[doc = r#"number, this event notifies the client of this serial number."#]
            #[doc = r#""#]
            #[doc = r#"If multiple tablets are available in the same seat and the tool is"#]
            #[doc = r#"uniquely identifiable by the serial number, that tool may move"#]
            #[doc = r#"between tablets."#]
            #[doc = r#""#]
            #[doc = r#"Otherwise, if the tool has no serial number and this event is"#]
            #[doc = r#"missing, the tool is tied to the tablet it first comes into"#]
            #[doc = r#"proximity with. Even if the physical tool is used on multiple"#]
            #[doc = r#"tablets, separate wp_tablet_tool objects will be created, one per"#]
            #[doc = r#"tablet."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_tool.done event."#]
            async fn hardware_serial(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                hardware_serial_hi: u32,
                hardware_serial_lo: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.hardware_serial()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(hardware_serial_hi)
                    .put_uint(hardware_serial_lo)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event notifies the client of a hardware id available on this tool."#]
            #[doc = r#""#]
            #[doc = r#"The hardware id is a device-specific 64-bit id that provides extra"#]
            #[doc = r#"information about the tool in use, beyond the wl_tool.type"#]
            #[doc = r#"enumeration. The format of the id is specific to tablets made by"#]
            #[doc = r#"Wacom Inc. For example, the hardware id of a Wacom Grip"#]
            #[doc = r#"Pen (a stylus) is 0x802."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_tool.done event."#]
            async fn hardware_id_wacom(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                hardware_id_hi: u32,
                hardware_id_lo: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.hardware_id_wacom()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(hardware_id_hi)
                    .put_uint(hardware_id_lo)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event notifies the client of any capabilities of this tool,"#]
            #[doc = r#"beyond the main set of x/y axes and tip up/down detection."#]
            #[doc = r#""#]
            #[doc = r#"One event is sent for each extra capability available on this tool."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_tool.done event."#]
            async fn capability(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                capability: Capability,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.capability()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(capability as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event signals the end of the initial burst of descriptive"#]
            #[doc = r#"events. A client may consider the static description of the tool to"#]
            #[doc = r#"be complete and finalize initialization of the tool."#]
            async fn done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent when the tool is removed from the system and will"#]
            #[doc = r#"send no further events. Should the physical tool come back into"#]
            #[doc = r#"proximity later, a new wp_tablet_tool object will be created."#]
            #[doc = r#""#]
            #[doc = r#"It is compositor-dependent when a tool is removed. A compositor may"#]
            #[doc = r#"remove a tool on proximity out, tablet removal or any other reason."#]
            #[doc = r#"A compositor may also keep a tool alive until shutdown."#]
            #[doc = r#""#]
            #[doc = r#"If the tool is currently in proximity, a proximity_out event will be"#]
            #[doc = r#"sent before the removed event. See wp_tablet_tool.proximity_out for"#]
            #[doc = r#"the handling of any buttons logically down."#]
            #[doc = r#""#]
            #[doc = r#"When this event is received, the client must wp_tablet_tool.destroy"#]
            #[doc = r#"the object."#]
            async fn removed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.removed()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 5, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notification that this tool is focused on a certain surface."#]
            #[doc = r#""#]
            #[doc = r#"This event can be received when the tool has moved from one surface to"#]
            #[doc = r#"another, or when the tool has come back into proximity above the"#]
            #[doc = r#"surface."#]
            #[doc = r#""#]
            #[doc = r#"If any button is logically down when the tool comes into proximity,"#]
            #[doc = r#"the respective button event is sent after the proximity_in event but"#]
            #[doc = r#"within the same frame as the proximity_in event."#]
            async fn proximity_in(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                tablet: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.proximity_in()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(tablet))
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 6, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notification that this tool has either left proximity, or is no"#]
            #[doc = r#"longer focused on a certain surface."#]
            #[doc = r#""#]
            #[doc = r#"When the tablet tool leaves proximity of the tablet, button release"#]
            #[doc = r#"events are sent for each button that was held down at the time of"#]
            #[doc = r#"leaving proximity. These events are sent before the proximity_out"#]
            #[doc = r#"event but within the same wp_tablet.frame."#]
            #[doc = r#""#]
            #[doc = r#"If the tool stays within proximity of the tablet, but the focus"#]
            #[doc = r#"changes from one surface to another, a button release event may not"#]
            #[doc = r#"be sent until the button is actually released or the tool leaves the"#]
            #[doc = r#"proximity of the tablet."#]
            async fn proximity_out(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.proximity_out()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 7, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the tablet tool comes in contact with the surface of the"#]
            #[doc = r#"tablet."#]
            #[doc = r#""#]
            #[doc = r#"If the tool is already in contact with the tablet when entering the"#]
            #[doc = r#"input region, the client owning said region will receive a"#]
            #[doc = r#"wp_tablet.proximity_in event, followed by a wp_tablet.down"#]
            #[doc = r#"event and a wp_tablet.frame event."#]
            #[doc = r#""#]
            #[doc = r#"Note that this event describes logical contact, not physical"#]
            #[doc = r#"contact. On some devices, a compositor may not consider a tool in"#]
            #[doc = r#"logical contact until a minimum physical pressure threshold is"#]
            #[doc = r#"exceeded."#]
            async fn down(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.down()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 8, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the tablet tool stops making contact with the surface of"#]
            #[doc = r#"the tablet, or when the tablet tool moves out of the input region"#]
            #[doc = r#"and the compositor grab (if any) is dismissed."#]
            #[doc = r#""#]
            #[doc = r#"If the tablet tool moves out of the input region while in contact"#]
            #[doc = r#"with the surface of the tablet and the compositor does not have an"#]
            #[doc = r#"ongoing grab on the surface, the client owning said region will"#]
            #[doc = r#"receive a wp_tablet.up event, followed by a wp_tablet.proximity_out"#]
            #[doc = r#"event and a wp_tablet.frame event. If the compositor has an ongoing"#]
            #[doc = r#"grab on this device, this event sequence is sent whenever the grab"#]
            #[doc = r#"is dismissed in the future."#]
            #[doc = r#""#]
            #[doc = r#"Note that this event describes logical contact, not physical"#]
            #[doc = r#"contact. On some devices, a compositor may not consider a tool out"#]
            #[doc = r#"of logical contact until physical pressure falls below a specific"#]
            #[doc = r#"threshold."#]
            async fn up(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.up()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 9, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever a tablet tool moves."#]
            async fn motion(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: crate::wire::Fixed,
                y: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.motion()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fixed(x)
                    .put_fixed(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 10, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the pressure axis on a tool changes. The value of this"#]
            #[doc = r#"event is normalized to a value between 0 and 65535."#]
            #[doc = r#""#]
            #[doc = r#"Note that pressure may be nonzero even when a tool is not in logical"#]
            #[doc = r#"contact. See the down and up events for more details."#]
            async fn pressure(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                pressure: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.pressure()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(pressure)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 11, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the distance axis on a tool changes. The value of this"#]
            #[doc = r#"event is normalized to a value between 0 and 65535."#]
            #[doc = r#""#]
            #[doc = r#"Note that distance may be nonzero even when a tool is not in logical"#]
            #[doc = r#"contact. See the down and up events for more details."#]
            async fn distance(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                distance: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.distance()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(distance)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 12, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever one or both of the tilt axes on a tool change. Each tilt"#]
            #[doc = r#"value is in degrees, relative to the z-axis of the tablet."#]
            #[doc = r#"The angle is positive when the top of a tool tilts along the"#]
            #[doc = r#"positive x or y axis."#]
            async fn tilt(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                tilt_x: crate::wire::Fixed,
                tilt_y: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.tilt()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fixed(tilt_x)
                    .put_fixed(tilt_y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 13, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the z-rotation axis on the tool changes. The"#]
            #[doc = r#"rotation value is in degrees clockwise from the tool's"#]
            #[doc = r#"logical neutral position."#]
            async fn rotation(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                degrees: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.rotation()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fixed(degrees)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 14, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the slider position on the tool changes. The"#]
            #[doc = r#"value is normalized between -65535 and 65535, with 0 as the logical"#]
            #[doc = r#"neutral position of the slider."#]
            #[doc = r#""#]
            #[doc = r#"The slider is available on e.g. the Wacom Airbrush tool."#]
            async fn slider(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                position: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.slider()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(position).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 15, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the wheel on the tool emits an event. This event"#]
            #[doc = r#"contains two values for the same axis change. The degrees value is"#]
            #[doc = r#"in the same orientation as the wl_pointer.vertical_scroll axis. The"#]
            #[doc = r#"clicks value is in discrete logical clicks of the mouse wheel. This"#]
            #[doc = r#"value may be zero if the movement of the wheel was less"#]
            #[doc = r#"than one logical click."#]
            #[doc = r#""#]
            #[doc = r#"Clients should choose either value and avoid mixing degrees and"#]
            #[doc = r#"clicks. The compositor may accumulate values smaller than a logical"#]
            #[doc = r#"click and emulate click events when a certain threshold is met."#]
            #[doc = r#"Thus, wl_tablet_tool.wheel events with non-zero clicks values may"#]
            #[doc = r#"have different degrees values."#]
            async fn wheel(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                degrees: crate::wire::Fixed,
                clicks: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.wheel()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fixed(degrees)
                    .put_int(clicks)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever a button on the tool is pressed or released."#]
            #[doc = r#""#]
            #[doc = r#"If a button is held down when the tool moves in or out of proximity,"#]
            #[doc = r#"button events are generated by the compositor. See"#]
            #[doc = r#"wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for"#]
            #[doc = r#"details."#]
            async fn button(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                button: u32,
                state: ButtonState,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.button()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(button)
                    .put_uint(state as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 17, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Marks the end of a series of axis and/or button updates from the"#]
            #[doc = r#"tablet. The Wayland protocol requires axis updates to be sent"#]
            #[doc = r#"sequentially, however all events within a frame should be considered"#]
            #[doc = r#"one hardware event."#]
            async fn frame(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.frame()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(time).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 18, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_tablet_v2 {
        #[doc = r#"The wp_tablet interface represents one graphics tablet device. The"#]
        #[doc = r#"tablet interface itself does not generate events; all events are"#]
        #[doc = r#"generated by wp_tablet_tool objects when in proximity above a tablet."#]
        #[doc = r#""#]
        #[doc = r#"A tablet has a number of static characteristics, e.g. device name and"#]
        #[doc = r#"pid/vid. These capabilities are sent in an event sequence after the"#]
        #[doc = r#"wp_tablet_seat.tablet_added event. This initial event sequence is"#]
        #[doc = r#"terminated by a wp_tablet.done event."#]
        pub trait ZwpTabletV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_v2";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_tablet_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"This destroys the client's resource for this tablet object."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"A descriptive name for the tablet device."#]
            #[doc = r#""#]
            #[doc = r#"If the device has no descriptive name, this event is not sent."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet.done event."#]
            async fn name(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v2#{}.name()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(name))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The USB vendor and product IDs for the tablet device."#]
            #[doc = r#""#]
            #[doc = r#"If the device has no USB vendor/product ID, this event is not sent."#]
            #[doc = r#"This can happen for virtual devices or non-USB devices, for instance."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet.done event."#]
            async fn id(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                vid: u32,
                pid: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v2#{}.id()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(vid)
                    .put_uint(pid)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"A system-specific device path that indicates which device is behind"#]
            #[doc = r#"this wp_tablet. This information may be used to gather additional"#]
            #[doc = r#"information about the device, e.g. through libwacom."#]
            #[doc = r#""#]
            #[doc = r#"A device may have more than one device path. If so, multiple"#]
            #[doc = r#"wp_tablet.path events are sent. A device may be emulated and not"#]
            #[doc = r#"have a device path, and in that case this event will not be sent."#]
            #[doc = r#""#]
            #[doc = r#"The format of the path is unspecified, it may be a device node, a"#]
            #[doc = r#"sysfs path, or some other identifier. It is up to the client to"#]
            #[doc = r#"identify the string provided."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet.done event."#]
            async fn path(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                path: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v2#{}.path()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(path))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent immediately to signal the end of the initial"#]
            #[doc = r#"burst of descriptive events. A client may consider the static"#]
            #[doc = r#"description of the tablet to be complete and finalize initialization"#]
            #[doc = r#"of the tablet."#]
            async fn done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v2#{}.done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent when the tablet has been removed from the system. When a tablet"#]
            #[doc = r#"is removed, some tools may be removed."#]
            #[doc = r#""#]
            #[doc = r#"When this event is received, the client must wp_tablet.destroy"#]
            #[doc = r#"the object."#]
            async fn removed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v2#{}.removed()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_tablet_pad_ring_v2 {
        #[doc = r#"Describes the source types for ring events. This indicates to the"#]
        #[doc = r#"client how a ring event was physically generated; a client may"#]
        #[doc = r#"adjust the user interface accordingly. For example, events"#]
        #[doc = r#"from a "finger" source may trigger kinetic scrolling."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Source {
            #[doc = r#"Finger"#]
            Finger = 1,
        }
        impl TryFrom<u32> for Source {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::Finger),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"A circular interaction area, such as the touch ring on the Wacom Intuos"#]
        #[doc = r#"Pro series tablets."#]
        #[doc = r#""#]
        #[doc = r#"Events on a ring are logically grouped by the wl_tablet_pad_ring.frame"#]
        #[doc = r#"event."#]
        pub trait ZwpTabletPadRingV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_ring_v2";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_tablet_pad_ring_v2#{}.set_feedback()", object.id);
                        self.set_feedback(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwp_tablet_pad_ring_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Request that the compositor use the provided feedback string"#]
            #[doc = r#"associated with this ring. This request should be issued immediately"#]
            #[doc = r#"after a wp_tablet_pad_group.mode_switch event from the corresponding"#]
            #[doc = r#"group is received, or whenever the ring is mapped to a different"#]
            #[doc = r#"action. See wp_tablet_pad_group.mode_switch for more details."#]
            #[doc = r#""#]
            #[doc = r#"Clients are encouraged to provide context-aware descriptions for"#]
            #[doc = r#"the actions associated with the ring; compositors may use this"#]
            #[doc = r#"information to offer visual feedback about the button layout"#]
            #[doc = r#"(eg. on-screen displays)."#]
            #[doc = r#""#]
            #[doc = r#"The provided string 'description' is a UTF-8 encoded string to be"#]
            #[doc = r#"associated with this ring, and is considered user-visible; general"#]
            #[doc = r#"internationalization rules apply."#]
            #[doc = r#""#]
            #[doc = r#"The serial argument will be that of the last"#]
            #[doc = r#"wp_tablet_pad_group.mode_switch event received for the group of this"#]
            #[doc = r#"ring. Requests providing other serials than the most recent one will be"#]
            #[doc = r#"ignored."#]
            async fn set_feedback(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_feedback: String,
                set_feedback: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"This destroys the client's resource for this ring object."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Source information for ring events."#]
            #[doc = r#""#]
            #[doc = r#"This event does not occur on its own. It is sent before a"#]
            #[doc = r#"wp_tablet_pad_ring.frame event and carries the source information"#]
            #[doc = r#"for all events within that frame."#]
            #[doc = r#""#]
            #[doc = r#"The source specifies how this event was generated. If the source is"#]
            #[doc = r#"wp_tablet_pad_ring.source.finger, a wp_tablet_pad_ring.stop event"#]
            #[doc = r#"will be sent when the user lifts the finger off the device."#]
            #[doc = r#""#]
            #[doc = r#"This event is optional. If the source is unknown for an interaction,"#]
            #[doc = r#"no event is sent."#]
            async fn source(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: Source,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_ring_v2#{}.source()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(source as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the angle on a ring changes."#]
            #[doc = r#""#]
            #[doc = r#"The angle is provided in degrees clockwise from the logical"#]
            #[doc = r#"north of the ring in the pad's current rotation."#]
            async fn angle(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                degrees: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_ring_v2#{}.angle()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fixed(degrees)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Stop notification for ring events."#]
            #[doc = r#""#]
            #[doc = r#"For some wp_tablet_pad_ring.source types, a wp_tablet_pad_ring.stop"#]
            #[doc = r#"event is sent to notify a client that the interaction with the ring"#]
            #[doc = r#"has terminated. This enables the client to implement kinetic scrolling."#]
            #[doc = r#"See the wp_tablet_pad_ring.source documentation for information on"#]
            #[doc = r#"when this event may be generated."#]
            #[doc = r#""#]
            #[doc = r#"Any wp_tablet_pad_ring.angle events with the same source after this"#]
            #[doc = r#"event should be considered as the start of a new interaction."#]
            async fn stop(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_ring_v2#{}.stop()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Indicates the end of a set of ring events that logically belong"#]
            #[doc = r#"together. A client is expected to accumulate the data in all events"#]
            #[doc = r#"within the frame before proceeding."#]
            #[doc = r#""#]
            #[doc = r#"All wp_tablet_pad_ring events before a wp_tablet_pad_ring.frame event belong"#]
            #[doc = r#"logically together. For example, on termination of a finger interaction"#]
            #[doc = r#"on a ring the compositor will send a wp_tablet_pad_ring.source event,"#]
            #[doc = r#"a wp_tablet_pad_ring.stop event and a wp_tablet_pad_ring.frame event."#]
            #[doc = r#""#]
            #[doc = r#"A wp_tablet_pad_ring.frame event is sent for every logical event"#]
            #[doc = r#"group, even if the group only contains a single wp_tablet_pad_ring"#]
            #[doc = r#"event. Specifically, a client may get a sequence: angle, frame,"#]
            #[doc = r#"angle, frame, etc."#]
            async fn frame(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_ring_v2#{}.frame()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(time).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_tablet_pad_strip_v2 {
        #[doc = r#"Describes the source types for strip events. This indicates to the"#]
        #[doc = r#"client how a strip event was physically generated; a client may"#]
        #[doc = r#"adjust the user interface accordingly. For example, events"#]
        #[doc = r#"from a "finger" source may trigger kinetic scrolling."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Source {
            #[doc = r#"Finger"#]
            Finger = 1,
        }
        impl TryFrom<u32> for Source {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::Finger),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"A linear interaction area, such as the strips found in Wacom Cintiq"#]
        #[doc = r#"models."#]
        #[doc = r#""#]
        #[doc = r#"Events on a strip are logically grouped by the wl_tablet_pad_strip.frame"#]
        #[doc = r#"event."#]
        pub trait ZwpTabletPadStripV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_strip_v2";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_tablet_pad_strip_v2#{}.set_feedback()", object.id);
                        self.set_feedback(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwp_tablet_pad_strip_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Requests the compositor to use the provided feedback string"#]
            #[doc = r#"associated with this strip. This request should be issued immediately"#]
            #[doc = r#"after a wp_tablet_pad_group.mode_switch event from the corresponding"#]
            #[doc = r#"group is received, or whenever the strip is mapped to a different"#]
            #[doc = r#"action. See wp_tablet_pad_group.mode_switch for more details."#]
            #[doc = r#""#]
            #[doc = r#"Clients are encouraged to provide context-aware descriptions for"#]
            #[doc = r#"the actions associated with the strip, and compositors may use this"#]
            #[doc = r#"information to offer visual feedback about the button layout"#]
            #[doc = r#"(eg. on-screen displays)."#]
            #[doc = r#""#]
            #[doc = r#"The provided string 'description' is a UTF-8 encoded string to be"#]
            #[doc = r#"associated with this ring, and is considered user-visible; general"#]
            #[doc = r#"internationalization rules apply."#]
            #[doc = r#""#]
            #[doc = r#"The serial argument will be that of the last"#]
            #[doc = r#"wp_tablet_pad_group.mode_switch event received for the group of this"#]
            #[doc = r#"strip. Requests providing other serials than the most recent one will be"#]
            #[doc = r#"ignored."#]
            async fn set_feedback(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_feedback: String,
                set_feedback: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"This destroys the client's resource for this strip object."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Source information for strip events."#]
            #[doc = r#""#]
            #[doc = r#"This event does not occur on its own. It is sent before a"#]
            #[doc = r#"wp_tablet_pad_strip.frame event and carries the source information"#]
            #[doc = r#"for all events within that frame."#]
            #[doc = r#""#]
            #[doc = r#"The source specifies how this event was generated. If the source is"#]
            #[doc = r#"wp_tablet_pad_strip.source.finger, a wp_tablet_pad_strip.stop event"#]
            #[doc = r#"will be sent when the user lifts their finger off the device."#]
            #[doc = r#""#]
            #[doc = r#"This event is optional. If the source is unknown for an interaction,"#]
            #[doc = r#"no event is sent."#]
            async fn source(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: Source,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_strip_v2#{}.source()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(source as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the position on a strip changes."#]
            #[doc = r#""#]
            #[doc = r#"The position is normalized to a range of [0, 65535], the 0-value"#]
            #[doc = r#"represents the top-most and/or left-most position of the strip in"#]
            #[doc = r#"the pad's current rotation."#]
            async fn position(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                position: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_strip_v2#{}.position()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(position)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Stop notification for strip events."#]
            #[doc = r#""#]
            #[doc = r#"For some wp_tablet_pad_strip.source types, a wp_tablet_pad_strip.stop"#]
            #[doc = r#"event is sent to notify a client that the interaction with the strip"#]
            #[doc = r#"has terminated. This enables the client to implement kinetic"#]
            #[doc = r#"scrolling. See the wp_tablet_pad_strip.source documentation for"#]
            #[doc = r#"information on when this event may be generated."#]
            #[doc = r#""#]
            #[doc = r#"Any wp_tablet_pad_strip.position events with the same source after this"#]
            #[doc = r#"event should be considered as the start of a new interaction."#]
            async fn stop(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_strip_v2#{}.stop()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Indicates the end of a set of events that represent one logical"#]
            #[doc = r#"hardware strip event. A client is expected to accumulate the data"#]
            #[doc = r#"in all events within the frame before proceeding."#]
            #[doc = r#""#]
            #[doc = r#"All wp_tablet_pad_strip events before a wp_tablet_pad_strip.frame event belong"#]
            #[doc = r#"logically together. For example, on termination of a finger interaction"#]
            #[doc = r#"on a strip the compositor will send a wp_tablet_pad_strip.source event,"#]
            #[doc = r#"a wp_tablet_pad_strip.stop event and a wp_tablet_pad_strip.frame"#]
            #[doc = r#"event."#]
            #[doc = r#""#]
            #[doc = r#"A wp_tablet_pad_strip.frame event is sent for every logical event"#]
            #[doc = r#"group, even if the group only contains a single wp_tablet_pad_strip"#]
            #[doc = r#"event. Specifically, a client may get a sequence: position, frame,"#]
            #[doc = r#"position, frame, etc."#]
            async fn frame(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_strip_v2#{}.frame()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(time).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_tablet_pad_group_v2 {
        #[doc = r#"A pad group describes a distinct (sub)set of buttons, rings and strips"#]
        #[doc = r#"present in the tablet. The criteria of this grouping is usually positional,"#]
        #[doc = r#"eg. if a tablet has buttons on the left and right side, 2 groups will be"#]
        #[doc = r#"presented. The physical arrangement of groups is undisclosed and may"#]
        #[doc = r#"change on the fly."#]
        #[doc = r#""#]
        #[doc = r#"Pad groups will announce their features during pad initialization. Between"#]
        #[doc = r#"the corresponding wp_tablet_pad.group event and wp_tablet_pad_group.done, the"#]
        #[doc = r#"pad group will announce the buttons, rings and strips contained in it,"#]
        #[doc = r#"plus the number of supported modes."#]
        #[doc = r#""#]
        #[doc = r#"Modes are a mechanism to allow multiple groups of actions for every element"#]
        #[doc = r#"in the pad group. The number of groups and available modes in each is"#]
        #[doc = r#"persistent across device plugs. The current mode is user-switchable, it"#]
        #[doc = r#"will be announced through the wp_tablet_pad_group.mode_switch event both"#]
        #[doc = r#"whenever it is switched, and after wp_tablet_pad.enter."#]
        #[doc = r#""#]
        #[doc = r#"The current mode logically applies to all elements in the pad group,"#]
        #[doc = r#"although it is at clients' discretion whether to actually perform different"#]
        #[doc = r#"actions, and/or issue the respective .set_feedback requests to notify the"#]
        #[doc = r#"compositor. See the wp_tablet_pad_group.mode_switch event for more details."#]
        pub trait ZwpTabletPadGroupV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_group_v2";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_tablet_pad_group_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the wp_tablet_pad_group object. Objects created from this object"#]
            #[doc = r#"are unaffected and should be destroyed separately."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Sent on wp_tablet_pad_group initialization to announce the available"#]
            #[doc = r#"buttons in the group. Button indices start at 0, a button may only be"#]
            #[doc = r#"in one group at a time."#]
            #[doc = r#""#]
            #[doc = r#"This event is first sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_pad_group.done event."#]
            #[doc = r#""#]
            #[doc = r#"Some buttons are reserved by the compositor. These buttons may not be"#]
            #[doc = r#"assigned to any wp_tablet_pad_group. Compositors may broadcast this"#]
            #[doc = r#"event in the case of changes to the mapping of these reserved buttons."#]
            #[doc = r#"If the compositor happens to reserve all buttons in a group, this event"#]
            #[doc = r#"will be sent with an empty array."#]
            async fn buttons(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                buttons: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.buttons()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_array(buttons)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent on wp_tablet_pad_group initialization to announce available rings."#]
            #[doc = r#"One event is sent for each ring available on this pad group."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_pad_group.done event."#]
            async fn ring(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                ring: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.ring()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(ring))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent on wp_tablet_pad initialization to announce available strips."#]
            #[doc = r#"One event is sent for each strip available on this pad group."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_pad_group.done event."#]
            async fn strip(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                strip: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.strip()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(strip))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent on wp_tablet_pad_group initialization to announce that the pad"#]
            #[doc = r#"group may switch between modes. A client may use a mode to store a"#]
            #[doc = r#"specific configuration for buttons, rings and strips and use the"#]
            #[doc = r#"wl_tablet_pad_group.mode_switch event to toggle between these"#]
            #[doc = r#"configurations. Mode indices start at 0."#]
            #[doc = r#""#]
            #[doc = r#"Switching modes is compositor-dependent. See the"#]
            #[doc = r#"wp_tablet_pad_group.mode_switch event for more details."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_pad_group.done event. This event is only sent when more than"#]
            #[doc = r#"more than one mode is available."#]
            async fn modes(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                modes: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.modes()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(modes).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent immediately to signal the end of the initial"#]
            #[doc = r#"burst of descriptive events. A client may consider the static"#]
            #[doc = r#"description of the tablet to be complete and finalize initialization"#]
            #[doc = r#"of the tablet group."#]
            async fn done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notification that the mode was switched."#]
            #[doc = r#""#]
            #[doc = r#"A mode applies to all buttons, rings and strips in a group"#]
            #[doc = r#"simultaneously, but a client is not required to assign different actions"#]
            #[doc = r#"for each mode. For example, a client may have mode-specific button"#]
            #[doc = r#"mappings but map the ring to vertical scrolling in all modes. Mode"#]
            #[doc = r#"indices start at 0."#]
            #[doc = r#""#]
            #[doc = r#"Switching modes is compositor-dependent. The compositor may provide"#]
            #[doc = r#"visual cues to the client about the mode, e.g. by toggling LEDs on"#]
            #[doc = r#"the tablet device. Mode-switching may be software-controlled or"#]
            #[doc = r#"controlled by one or more physical buttons. For example, on a Wacom"#]
            #[doc = r#"Intuos Pro, the button inside the ring may be assigned to switch"#]
            #[doc = r#"between modes."#]
            #[doc = r#""#]
            #[doc = r#"The compositor will also send this event after wp_tablet_pad.enter on"#]
            #[doc = r#"each group in order to notify of the current mode. Groups that only"#]
            #[doc = r#"feature one mode will use mode=0 when emitting this event."#]
            #[doc = r#""#]
            #[doc = r#"If a button action in the new mode differs from the action in the"#]
            #[doc = r#"previous mode, the client should immediately issue a"#]
            #[doc = r#"wp_tablet_pad.set_feedback request for each changed button."#]
            #[doc = r#""#]
            #[doc = r#"If a ring or strip action in the new mode differs from the action"#]
            #[doc = r#"in the previous mode, the client should immediately issue a"#]
            #[doc = r#"wp_tablet_ring.set_feedback or wp_tablet_strip.set_feedback request"#]
            #[doc = r#"for each changed ring or strip."#]
            async fn mode_switch(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                serial: u32,
                mode: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.mode_switch()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_uint(serial)
                    .put_uint(mode)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 5, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_tablet_pad_v2 {
        #[doc = r#"Describes the physical state of a button that caused the button"#]
        #[doc = r#"event."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ButtonState {
            #[doc = r#"The button is not pressed"#]
            Released = 0,
            #[doc = r#"The button is pressed"#]
            Pressed = 1,
        }
        impl TryFrom<u32> for ButtonState {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Released),
                    1 => Ok(Self::Pressed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"A pad device is a set of buttons, rings and strips"#]
        #[doc = r#"usually physically present on the tablet device itself. Some"#]
        #[doc = r#"exceptions exist where the pad device is physically detached, e.g. the"#]
        #[doc = r#"Wacom ExpressKey Remote."#]
        #[doc = r#""#]
        #[doc = r#"Pad devices have no axes that control the cursor and are generally"#]
        #[doc = r#"auxiliary devices to the tool devices used on the tablet surface."#]
        #[doc = r#""#]
        #[doc = r#"A pad device has a number of static characteristics, e.g. the number"#]
        #[doc = r#"of rings. These capabilities are sent in an event sequence after the"#]
        #[doc = r#"wp_tablet_seat.pad_added event before any actual events from this pad."#]
        #[doc = r#"This initial event sequence is terminated by a wp_tablet_pad.done"#]
        #[doc = r#"event."#]
        #[doc = r#""#]
        #[doc = r#"All pad features (buttons, rings and strips) are logically divided into"#]
        #[doc = r#"groups and all pads have at least one group. The available groups are"#]
        #[doc = r#"notified through the wp_tablet_pad.group event; the compositor will"#]
        #[doc = r#"emit one event per group before emitting wp_tablet_pad.done."#]
        #[doc = r#""#]
        #[doc = r#"Groups may have multiple modes. Modes allow clients to map multiple"#]
        #[doc = r#"actions to a single pad feature. Only one mode can be active per group,"#]
        #[doc = r#"although different groups may have different active modes."#]
        pub trait ZwpTabletPadV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_v2";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_tablet_pad_v2#{}.set_feedback()", object.id);
                        self.set_feedback(
                            object,
                            client,
                            message.uint()?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwp_tablet_pad_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Requests the compositor to use the provided feedback string"#]
            #[doc = r#"associated with this button. This request should be issued immediately"#]
            #[doc = r#"after a wp_tablet_pad_group.mode_switch event from the corresponding"#]
            #[doc = r#"group is received, or whenever a button is mapped to a different"#]
            #[doc = r#"action. See wp_tablet_pad_group.mode_switch for more details."#]
            #[doc = r#""#]
            #[doc = r#"Clients are encouraged to provide context-aware descriptions for"#]
            #[doc = r#"the actions associated with each button, and compositors may use"#]
            #[doc = r#"this information to offer visual feedback on the button layout"#]
            #[doc = r#"(e.g. on-screen displays)."#]
            #[doc = r#""#]
            #[doc = r#"Button indices start at 0. Setting the feedback string on a button"#]
            #[doc = r#"that is reserved by the compositor (i.e. not belonging to any"#]
            #[doc = r#"wp_tablet_pad_group) does not generate an error but the compositor"#]
            #[doc = r#"is free to ignore the request."#]
            #[doc = r#""#]
            #[doc = r#"The provided string 'description' is a UTF-8 encoded string to be"#]
            #[doc = r#"associated with this ring, and is considered user-visible; general"#]
            #[doc = r#"internationalization rules apply."#]
            #[doc = r#""#]
            #[doc = r#"The serial argument will be that of the last"#]
            #[doc = r#"wp_tablet_pad_group.mode_switch event received for the group of this"#]
            #[doc = r#"button. Requests providing other serials than the most recent one will"#]
            #[doc = r#"be ignored."#]
            async fn set_feedback(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_feedback: u32,
                set_feedback: String,
                set_feedback: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Destroy the wp_tablet_pad object. Objects created from this object"#]
            #[doc = r#"are unaffected and should be destroyed separately."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Sent on wp_tablet_pad initialization to announce available groups."#]
            #[doc = r#"One event is sent for each pad group available."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_pad.done event. At least one group will be announced."#]
            async fn group(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                pad_group: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.group()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(pad_group))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"A system-specific device path that indicates which device is behind"#]
            #[doc = r#"this wp_tablet_pad. This information may be used to gather additional"#]
            #[doc = r#"information about the device, e.g. through libwacom."#]
            #[doc = r#""#]
            #[doc = r#"The format of the path is unspecified, it may be a device node, a"#]
            #[doc = r#"sysfs path, or some other identifier. It is up to the client to"#]
            #[doc = r#"identify the string provided."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_pad.done event."#]
            async fn path(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                path: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.path()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(path))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent on wp_tablet_pad initialization to announce the available"#]
            #[doc = r#"buttons."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_pad.done event. This event is only sent when at least one"#]
            #[doc = r#"button is available."#]
            async fn buttons(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                buttons: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.buttons()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(buttons).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event signals the end of the initial burst of descriptive"#]
            #[doc = r#"events. A client may consider the static description of the pad to"#]
            #[doc = r#"be complete and finalize initialization of the pad."#]
            async fn done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the physical state of a button changes."#]
            async fn button(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                button: u32,
                state: ButtonState,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.button()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_uint(button)
                    .put_uint(state as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notification that this pad is focused on the specified surface."#]
            async fn enter(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                tablet: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.enter()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(tablet))
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 5, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notification that this pad is no longer focused on the specified"#]
            #[doc = r#"surface."#]
            async fn leave(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.leave()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 6, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent when the pad has been removed from the system. When a tablet"#]
            #[doc = r#"is removed its pad(s) will be removed too."#]
            #[doc = r#""#]
            #[doc = r#"When this event is received, the client must destroy all rings, strips"#]
            #[doc = r#"and groups that were offered by this pad, and issue wp_tablet_pad.destroy"#]
            #[doc = r#"the pad itself."#]
            async fn removed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.removed()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 7, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod viewporter {
    pub mod wp_viewporter {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"The surface already has a viewport object associated"#]
            ViewportExists = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::ViewportExists),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"The global interface exposing surface cropping and scaling"#]
        #[doc = r#"capabilities is used to instantiate an interface extension for a"#]
        #[doc = r#"wl_surface object. This extended interface will then allow"#]
        #[doc = r#"cropping and scaling the surface contents, effectively"#]
        #[doc = r#"disconnecting the direct relationship between the buffer and the"#]
        #[doc = r#"surface size."#]
        pub trait WpViewporter: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_viewporter";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wp_viewporter#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("wp_viewporter#{}.get_viewport()", object.id);
                        self.get_viewport(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Informs the server that the client will not be using this"#]
            #[doc = r#"protocol object anymore. This does not affect any other objects,"#]
            #[doc = r#"wp_viewport objects included."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Instantiate an interface extension for the given wl_surface to"#]
            #[doc = r#"crop and scale its content. If the given wl_surface already has"#]
            #[doc = r#"a wp_viewport object associated, the viewport_exists"#]
            #[doc = r#"protocol error is raised."#]
            async fn get_viewport(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_viewport: crate::wire::ObjectId,
                get_viewport: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wp_viewport {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Negative or zero values in width or height"#]
            BadValue = 0,
            #[doc = r#"Destination size is not integer"#]
            BadSize = 1,
            #[doc = r#"Source rectangle extends outside of the content area"#]
            OutOfBuffer = 2,
            #[doc = r#"The wl_surface was destroyed"#]
            NoSurface = 3,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::BadValue),
                    1 => Ok(Self::BadSize),
                    2 => Ok(Self::OutOfBuffer),
                    3 => Ok(Self::NoSurface),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"An additional interface to a wl_surface object, which allows the"#]
        #[doc = r#"client to specify the cropping and scaling of the surface"#]
        #[doc = r#"contents."#]
        #[doc = r#""#]
        #[doc = r#"This interface works with two concepts: the source rectangle (src_x,"#]
        #[doc = r#"src_y, src_width, src_height), and the destination size (dst_width,"#]
        #[doc = r#"dst_height). The contents of the source rectangle are scaled to the"#]
        #[doc = r#"destination size, and content outside the source rectangle is ignored."#]
        #[doc = r#"This state is double-buffered, and is applied on the next"#]
        #[doc = r#"wl_surface.commit."#]
        #[doc = r#""#]
        #[doc = r#"The two parts of crop and scale state are independent: the source"#]
        #[doc = r#"rectangle, and the destination size. Initially both are unset, that"#]
        #[doc = r#"is, no scaling is applied. The whole of the current wl_buffer is"#]
        #[doc = r#"used as the source, and the surface size is as defined in"#]
        #[doc = r#"wl_surface.attach."#]
        #[doc = r#""#]
        #[doc = r#"If the destination size is set, it causes the surface size to become"#]
        #[doc = r#"dst_width, dst_height. The source (rectangle) is scaled to exactly"#]
        #[doc = r#"this size. This overrides whatever the attached wl_buffer size is,"#]
        #[doc = r#"unless the wl_buffer is NULL. If the wl_buffer is NULL, the surface"#]
        #[doc = r#"has no content and therefore no size. Otherwise, the size is always"#]
        #[doc = r#"at least 1x1 in surface local coordinates."#]
        #[doc = r#""#]
        #[doc = r#"If the source rectangle is set, it defines what area of the wl_buffer is"#]
        #[doc = r#"taken as the source. If the source rectangle is set and the destination"#]
        #[doc = r#"size is not set, then src_width and src_height must be integers, and the"#]
        #[doc = r#"surface size becomes the source rectangle size. This results in cropping"#]
        #[doc = r#"without scaling. If src_width or src_height are not integers and"#]
        #[doc = r#"destination size is not set, the bad_size protocol error is raised when"#]
        #[doc = r#"the surface state is applied."#]
        #[doc = r#""#]
        #[doc = r#"The coordinate transformations from buffer pixel coordinates up to"#]
        #[doc = r#"the surface-local coordinates happen in the following order:"#]
        #[doc = r#"1. buffer_transform (wl_surface.set_buffer_transform)"#]
        #[doc = r#"2. buffer_scale (wl_surface.set_buffer_scale)"#]
        #[doc = r#"3. crop and scale (wp_viewport.set*)"#]
        #[doc = r#"This means, that the source rectangle coordinates of crop and scale"#]
        #[doc = r#"are given in the coordinates after the buffer transform and scale,"#]
        #[doc = r#"i.e. in the coordinates that would be the surface-local coordinates"#]
        #[doc = r#"if the crop and scale was not applied."#]
        #[doc = r#""#]
        #[doc = r#"If src_x or src_y are negative, the bad_value protocol error is raised."#]
        #[doc = r#"Otherwise, if the source rectangle is partially or completely outside of"#]
        #[doc = r#"the non-NULL wl_buffer, then the out_of_buffer protocol error is raised"#]
        #[doc = r#"when the surface state is applied. A NULL wl_buffer does not raise the"#]
        #[doc = r#"out_of_buffer error."#]
        #[doc = r#""#]
        #[doc = r#"If the wl_surface associated with the wp_viewport is destroyed,"#]
        #[doc = r#"all wp_viewport requests except 'destroy' raise the protocol error"#]
        #[doc = r#"no_surface."#]
        #[doc = r#""#]
        #[doc = r#"If the wp_viewport object is destroyed, the crop and scale"#]
        #[doc = r#"state is removed from the wl_surface. The change will be applied"#]
        #[doc = r#"on the next wl_surface.commit."#]
        pub trait WpViewport: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_viewport";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wp_viewport#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("wp_viewport#{}.set_source()", object.id);
                        self.set_source(
                            object,
                            client,
                            message.fixed()?,
                            message.fixed()?,
                            message.fixed()?,
                            message.fixed()?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("wp_viewport#{}.set_destination()", object.id);
                        self.set_destination(object, client, message.int()?, message.int()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"The associated wl_surface's crop and scale state is removed."#]
            #[doc = r#"The change is applied on the next wl_surface.commit."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set the source rectangle of the associated wl_surface. See"#]
            #[doc = r#"wp_viewport for the description, and relation to the wl_buffer"#]
            #[doc = r#"size."#]
            #[doc = r#""#]
            #[doc = r#"If all of x, y, width and height are -1.0, the source rectangle is"#]
            #[doc = r#"unset instead. Any other set of values where width or height are zero"#]
            #[doc = r#"or negative, or x or y are negative, raise the bad_value protocol"#]
            #[doc = r#"error."#]
            #[doc = r#""#]
            #[doc = r#"The crop and scale state is double-buffered state, and will be"#]
            #[doc = r#"applied on the next wl_surface.commit."#]
            async fn set_source(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_source: crate::wire::Fixed,
                set_source: crate::wire::Fixed,
                set_source: crate::wire::Fixed,
                set_source: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set the destination size of the associated wl_surface. See"#]
            #[doc = r#"wp_viewport for the description, and relation to the wl_buffer"#]
            #[doc = r#"size."#]
            #[doc = r#""#]
            #[doc = r#"If width is -1 and height is -1, the destination size is unset"#]
            #[doc = r#"instead. Any other pair of values for width and height that"#]
            #[doc = r#"contains zero or negative values raises the bad_value protocol"#]
            #[doc = r#"error."#]
            #[doc = r#""#]
            #[doc = r#"The crop and scale state is double-buffered state, and will be"#]
            #[doc = r#"applied on the next wl_surface.commit."#]
            async fn set_destination(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_destination: i32,
                set_destination: i32,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod xdg_shell {
    pub mod xdg_wm_base {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Given wl_surface has another role"#]
            Role = 0,
            #[doc = r#"Xdg_wm_base was destroyed before children"#]
            DefunctSurfaces = 1,
            #[doc = r#"The client tried to map or destroy a non-topmost popup"#]
            NotTheTopmostPopup = 2,
            #[doc = r#"The client specified an invalid popup parent surface"#]
            InvalidPopupParent = 3,
            #[doc = r#"The client provided an invalid surface state"#]
            InvalidSurfaceState = 4,
            #[doc = r#"The client provided an invalid positioner"#]
            InvalidPositioner = 5,
            #[doc = r#"The client didnt respond to a ping event in time"#]
            Unresponsive = 6,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Role),
                    1 => Ok(Self::DefunctSurfaces),
                    2 => Ok(Self::NotTheTopmostPopup),
                    3 => Ok(Self::InvalidPopupParent),
                    4 => Ok(Self::InvalidSurfaceState),
                    5 => Ok(Self::InvalidPositioner),
                    6 => Ok(Self::Unresponsive),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"The xdg_wm_base interface is exposed as a global object enabling clients"#]
        #[doc = r#"to turn their wl_surfaces into windows in a desktop environment. It"#]
        #[doc = r#"defines the basic functionality needed for clients and the compositor to"#]
        #[doc = r#"create windows that can be dragged, resized, maximized, etc, as well as"#]
        #[doc = r#"creating transient windows such as popup menus."#]
        pub trait XdgWmBase: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_wm_base";
            const VERSION: u32 = 6;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("xdg_wm_base#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("xdg_wm_base#{}.create_positioner()", object.id);
                        self.create_positioner(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("xdg_wm_base#{}.get_xdg_surface()", object.id);
                        self.get_xdg_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3 => {
                        tracing::debug!("xdg_wm_base#{}.pong()", object.id);
                        self.pong(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy this xdg_wm_base object."#]
            #[doc = r#""#]
            #[doc = r#"Destroying a bound xdg_wm_base object while there are surfaces"#]
            #[doc = r#"still alive created by this xdg_wm_base object instance is illegal"#]
            #[doc = r#"and will result in a defunct_surfaces error."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Create a positioner object. A positioner object is used to position"#]
            #[doc = r#"surfaces relative to some parent surface. See the interface description"#]
            #[doc = r#"and xdg_surface.get_popup for details."#]
            async fn create_positioner(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create_positioner: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"This creates an xdg_surface for the given surface. While xdg_surface"#]
            #[doc = r#"itself is not a role, the corresponding surface may only be assigned"#]
            #[doc = r#"a role extending xdg_surface, such as xdg_toplevel or xdg_popup. It is"#]
            #[doc = r#"illegal to create an xdg_surface for a wl_surface which already has an"#]
            #[doc = r#"assigned role and this will result in a role error."#]
            #[doc = r#""#]
            #[doc = r#"This creates an xdg_surface for the given surface. An xdg_surface is"#]
            #[doc = r#"used as basis to define a role to a given surface, such as xdg_toplevel"#]
            #[doc = r#"or xdg_popup. It also manages functionality shared between xdg_surface"#]
            #[doc = r#"based surface roles."#]
            #[doc = r#""#]
            #[doc = r#"See the documentation of xdg_surface for more details about what an"#]
            #[doc = r#"xdg_surface is and how it is used."#]
            async fn get_xdg_surface(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_xdg_surface: crate::wire::ObjectId,
                get_xdg_surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"A client must respond to a ping event with a pong request or"#]
            #[doc = r#"the client may be deemed unresponsive. See xdg_wm_base.ping"#]
            #[doc = r#"and xdg_wm_base.error.unresponsive."#]
            async fn pong(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                pong: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"The ping event asks the client if it's still alive. Pass the"#]
            #[doc = r#"serial specified in the event back to the compositor by sending"#]
            #[doc = r#"a "pong" request back with the specified serial. See xdg_wm_base.pong."#]
            #[doc = r#""#]
            #[doc = r#"Compositors can use this to determine if the client is still"#]
            #[doc = r#"alive. It's unspecified what will happen if the client doesn't"#]
            #[doc = r#"respond to the ping request, or in what timeframe. Clients should"#]
            #[doc = r#"try to respond in a reasonable amount of time. The unresponsive"#]
            #[doc = r#"error is provided for compositors that wish to disconnect unresponsive"#]
            #[doc = r#"clients."#]
            #[doc = r#""#]
            #[doc = r#"A compositor is free to ping in any way it wants, but a client must"#]
            #[doc = r#"always respond to any xdg_wm_base object it created."#]
            async fn ping(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_wm_base#{}.ping()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod xdg_positioner {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Invalid input provided"#]
            InvalidInput = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::InvalidInput),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Anchor {
            None = 0,
            Top = 1,
            Bottom = 2,
            Left = 3,
            Right = 4,
            TopLeft = 5,
            BottomLeft = 6,
            TopRight = 7,
            BottomRight = 8,
        }
        impl TryFrom<u32> for Anchor {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::None),
                    1 => Ok(Self::Top),
                    2 => Ok(Self::Bottom),
                    3 => Ok(Self::Left),
                    4 => Ok(Self::Right),
                    5 => Ok(Self::TopLeft),
                    6 => Ok(Self::BottomLeft),
                    7 => Ok(Self::TopRight),
                    8 => Ok(Self::BottomRight),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Gravity {
            None = 0,
            Top = 1,
            Bottom = 2,
            Left = 3,
            Right = 4,
            TopLeft = 5,
            BottomLeft = 6,
            TopRight = 7,
            BottomRight = 8,
        }
        impl TryFrom<u32> for Gravity {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::None),
                    1 => Ok(Self::Top),
                    2 => Ok(Self::Bottom),
                    3 => Ok(Self::Left),
                    4 => Ok(Self::Right),
                    5 => Ok(Self::TopLeft),
                    6 => Ok(Self::BottomLeft),
                    7 => Ok(Self::TopRight),
                    8 => Ok(Self::BottomRight),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"The constraint adjustment value define ways the compositor will adjust"#]
        #[doc = r#"the position of the surface, if the unadjusted position would result"#]
        #[doc = r#"in the surface being partly constrained."#]
        #[doc = r#""#]
        #[doc = r#"Whether a surface is considered 'constrained' is left to the compositor"#]
        #[doc = r#"to determine. For example, the surface may be partly outside the"#]
        #[doc = r#"compositor's defined 'work area', thus necessitating the child surface's"#]
        #[doc = r#"position be adjusted until it is entirely inside the work area."#]
        #[doc = r#""#]
        #[doc = r#"The adjustments can be combined, according to a defined precedence: 1)"#]
        #[doc = r#"Flip, 2) Slide, 3) Resize."#]
        bitflags::bitflags! {
            #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
            pub struct ConstraintAdjustment: u32 {const None = 0;const SlideX = 1;const SlideY = 2;const FlipX = 4;const FlipY = 8;const ResizeX = 16;const ResizeY = 32;}
        }
        impl TryFrom<u32> for ConstraintAdjustment {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = r#"The xdg_positioner provides a collection of rules for the placement of a"#]
        #[doc = r#"child surface relative to a parent surface. Rules can be defined to ensure"#]
        #[doc = r#"the child surface remains within the visible area's borders, and to"#]
        #[doc = r#"specify how the child surface changes its position, such as sliding along"#]
        #[doc = r#"an axis, or flipping around a rectangle. These positioner-created rules are"#]
        #[doc = r#"constrained by the requirement that a child surface must intersect with or"#]
        #[doc = r#"be at least partially adjacent to its parent surface."#]
        #[doc = r#""#]
        #[doc = r#"See the various requests for details about possible rules."#]
        #[doc = r#""#]
        #[doc = r#"At the time of the request, the compositor makes a copy of the rules"#]
        #[doc = r#"specified by the xdg_positioner. Thus, after the request is complete the"#]
        #[doc = r#"xdg_positioner object can be destroyed or reused; further changes to the"#]
        #[doc = r#"object will have no effect on previous usages."#]
        #[doc = r#""#]
        #[doc = r#"For an xdg_positioner object to be considered complete, it must have a"#]
        #[doc = r#"non-zero size set by set_size, and a non-zero anchor rectangle set by"#]
        #[doc = r#"set_anchor_rect. Passing an incomplete xdg_positioner object when"#]
        #[doc = r#"positioning a surface raises an invalid_positioner error."#]
        pub trait XdgPositioner: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_positioner";
            const VERSION: u32 = 6;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("xdg_positioner#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("xdg_positioner#{}.set_size()", object.id);
                        self.set_size(object, client, message.int()?, message.int()?)
                            .await
                    }
                    2 => {
                        tracing::debug!("xdg_positioner#{}.set_anchor_rect()", object.id);
                        self.set_anchor_rect(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    3 => {
                        tracing::debug!("xdg_positioner#{}.set_anchor()", object.id);
                        self.set_anchor(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    4 => {
                        tracing::debug!("xdg_positioner#{}.set_gravity()", object.id);
                        self.set_gravity(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    5 => {
                        tracing::debug!("xdg_positioner#{}.set_constraint_adjustment()", object.id);
                        self.set_constraint_adjustment(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    6 => {
                        tracing::debug!("xdg_positioner#{}.set_offset()", object.id);
                        self.set_offset(object, client, message.int()?, message.int()?)
                            .await
                    }
                    7 => {
                        tracing::debug!("xdg_positioner#{}.set_reactive()", object.id);
                        self.set_reactive(object, client).await
                    }
                    8 => {
                        tracing::debug!("xdg_positioner#{}.set_parent_size()", object.id);
                        self.set_parent_size(object, client, message.int()?, message.int()?)
                            .await
                    }
                    9 => {
                        tracing::debug!("xdg_positioner#{}.set_parent_configure()", object.id);
                        self.set_parent_configure(object, client, message.uint()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Notify the compositor that the xdg_positioner will no longer be used."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set the size of the surface that is to be positioned with the positioner"#]
            #[doc = r#"object. The size is in surface-local coordinates and corresponds to the"#]
            #[doc = r#"window geometry. See xdg_surface.set_window_geometry."#]
            #[doc = r#""#]
            #[doc = r#"If a zero or negative size is set the invalid_input error is raised."#]
            async fn set_size(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_size: i32,
                set_size: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Specify the anchor rectangle within the parent surface that the child"#]
            #[doc = r#"surface will be placed relative to. The rectangle is relative to the"#]
            #[doc = r#"window geometry as defined by xdg_surface.set_window_geometry of the"#]
            #[doc = r#"parent surface."#]
            #[doc = r#""#]
            #[doc = r#"When the xdg_positioner object is used to position a child surface, the"#]
            #[doc = r#"anchor rectangle may not extend outside the window geometry of the"#]
            #[doc = r#"positioned child's parent surface."#]
            #[doc = r#""#]
            #[doc = r#"If a negative size is set the invalid_input error is raised."#]
            async fn set_anchor_rect(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_anchor_rect: i32,
                set_anchor_rect: i32,
                set_anchor_rect: i32,
                set_anchor_rect: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Defines the anchor point for the anchor rectangle. The specified anchor"#]
            #[doc = r#"is used derive an anchor point that the child surface will be"#]
            #[doc = r#"positioned relative to. If a corner anchor is set (e.g. 'top_left' or"#]
            #[doc = r#"'bottom_right'), the anchor point will be at the specified corner;"#]
            #[doc = r#"otherwise, the derived anchor point will be centered on the specified"#]
            #[doc = r#"edge, or in the center of the anchor rectangle if no edge is specified."#]
            async fn set_anchor(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_anchor: Anchor,
            ) -> crate::server::Result<()>;
            #[doc = r#"Defines in what direction a surface should be positioned, relative to"#]
            #[doc = r#"the anchor point of the parent surface. If a corner gravity is"#]
            #[doc = r#"specified (e.g. 'bottom_right' or 'top_left'), then the child surface"#]
            #[doc = r#"will be placed towards the specified gravity; otherwise, the child"#]
            #[doc = r#"surface will be centered over the anchor point on any axis that had no"#]
            #[doc = r#"gravity specified. If the gravity is not in the gravity enum, an"#]
            #[doc = r#"invalid_input error is raised."#]
            async fn set_gravity(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_gravity: Gravity,
            ) -> crate::server::Result<()>;
            #[doc = r#"Specify how the window should be positioned if the originally intended"#]
            #[doc = r#"position caused the surface to be constrained, meaning at least"#]
            #[doc = r#"partially outside positioning boundaries set by the compositor. The"#]
            #[doc = r#"adjustment is set by constructing a bitmask describing the adjustment to"#]
            #[doc = r#"be made when the surface is constrained on that axis."#]
            #[doc = r#""#]
            #[doc = r#"If no bit for one axis is set, the compositor will assume that the child"#]
            #[doc = r#"surface should not change its position on that axis when constrained."#]
            #[doc = r#""#]
            #[doc = r#"If more than one bit for one axis is set, the order of how adjustments"#]
            #[doc = r#"are applied is specified in the corresponding adjustment descriptions."#]
            #[doc = r#""#]
            #[doc = r#"The default adjustment is none."#]
            async fn set_constraint_adjustment(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_constraint_adjustment: ConstraintAdjustment,
            ) -> crate::server::Result<()>;
            #[doc = r#"Specify the surface position offset relative to the position of the"#]
            #[doc = r#"anchor on the anchor rectangle and the anchor on the surface. For"#]
            #[doc = r#"example if the anchor of the anchor rectangle is at (x, y), the surface"#]
            #[doc = r#"has the gravity bottom|right, and the offset is (ox, oy), the calculated"#]
            #[doc = r#"surface position will be (x + ox, y + oy). The offset position of the"#]
            #[doc = r#"surface is the one used for constraint testing. See"#]
            #[doc = r#"set_constraint_adjustment."#]
            #[doc = r#""#]
            #[doc = r#"An example use case is placing a popup menu on top of a user interface"#]
            #[doc = r#"element, while aligning the user interface element of the parent surface"#]
            #[doc = r#"with some user interface element placed somewhere in the popup surface."#]
            async fn set_offset(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_offset: i32,
                set_offset: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"When set reactive, the surface is reconstrained if the conditions used"#]
            #[doc = r#"for constraining changed, e.g. the parent window moved."#]
            #[doc = r#""#]
            #[doc = r#"If the conditions changed and the popup was reconstrained, an"#]
            #[doc = r#"xdg_popup.configure event is sent with updated geometry, followed by an"#]
            #[doc = r#"xdg_surface.configure event."#]
            async fn set_reactive(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set the parent window geometry the compositor should use when"#]
            #[doc = r#"positioning the popup. The compositor may use this information to"#]
            #[doc = r#"determine the future state the popup should be constrained using. If"#]
            #[doc = r#"this doesn't match the dimension of the parent the popup is eventually"#]
            #[doc = r#"positioned against, the behavior is undefined."#]
            #[doc = r#""#]
            #[doc = r#"The arguments are given in the surface-local coordinate space."#]
            async fn set_parent_size(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_parent_size: i32,
                set_parent_size: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set the serial of an xdg_surface.configure event this positioner will be"#]
            #[doc = r#"used in response to. The compositor may use this information together"#]
            #[doc = r#"with set_parent_size to determine what future state the popup should be"#]
            #[doc = r#"constrained using."#]
            async fn set_parent_configure(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_parent_configure: u32,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod xdg_surface {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Surface was not fully constructed"#]
            NotConstructed = 1,
            #[doc = r#"Surface was already constructed"#]
            AlreadyConstructed = 2,
            #[doc = r#"Attaching a buffer to an unconfigured surface"#]
            UnconfiguredBuffer = 3,
            #[doc = r#"Invalid serial number when acking a configure event"#]
            InvalidSerial = 4,
            #[doc = r#"Width or height was zero or negative"#]
            InvalidSize = 5,
            #[doc = r#"Surface was destroyed before its role object"#]
            DefunctRoleObject = 6,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::NotConstructed),
                    2 => Ok(Self::AlreadyConstructed),
                    3 => Ok(Self::UnconfiguredBuffer),
                    4 => Ok(Self::InvalidSerial),
                    5 => Ok(Self::InvalidSize),
                    6 => Ok(Self::DefunctRoleObject),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"An interface that may be implemented by a wl_surface, for"#]
        #[doc = r#"implementations that provide a desktop-style user interface."#]
        #[doc = r#""#]
        #[doc = r#"It provides a base set of functionality required to construct user"#]
        #[doc = r#"interface elements requiring management by the compositor, such as"#]
        #[doc = r#"toplevel windows, menus, etc. The types of functionality are split into"#]
        #[doc = r#"xdg_surface roles."#]
        #[doc = r#""#]
        #[doc = r#"Creating an xdg_surface does not set the role for a wl_surface. In order"#]
        #[doc = r#"to map an xdg_surface, the client must create a role-specific object"#]
        #[doc = r#"using, e.g., get_toplevel, get_popup. The wl_surface for any given"#]
        #[doc = r#"xdg_surface can have at most one role, and may not be assigned any role"#]
        #[doc = r#"not based on xdg_surface."#]
        #[doc = r#""#]
        #[doc = r#"A role must be assigned before any other requests are made to the"#]
        #[doc = r#"xdg_surface object."#]
        #[doc = r#""#]
        #[doc = r#"The client must call wl_surface.commit on the corresponding wl_surface"#]
        #[doc = r#"for the xdg_surface state to take effect."#]
        #[doc = r#""#]
        #[doc = r#"Creating an xdg_surface from a wl_surface which has a buffer attached or"#]
        #[doc = r#"committed is a client error, and any attempts by a client to attach or"#]
        #[doc = r#"manipulate a buffer prior to the first xdg_surface.configure call must"#]
        #[doc = r#"also be treated as errors."#]
        #[doc = r#""#]
        #[doc = r#"After creating a role-specific object and setting it up, the client must"#]
        #[doc = r#"perform an initial commit without any buffer attached. The compositor"#]
        #[doc = r#"will reply with initial wl_surface state such as"#]
        #[doc = r#"wl_surface.preferred_buffer_scale followed by an xdg_surface.configure"#]
        #[doc = r#"event. The client must acknowledge it and is then allowed to attach a"#]
        #[doc = r#"buffer to map the surface."#]
        #[doc = r#""#]
        #[doc = r#"Mapping an xdg_surface-based role surface is defined as making it"#]
        #[doc = r#"possible for the surface to be shown by the compositor. Note that"#]
        #[doc = r#"a mapped surface is not guaranteed to be visible once it is mapped."#]
        #[doc = r#""#]
        #[doc = r#"For an xdg_surface to be mapped by the compositor, the following"#]
        #[doc = r#"conditions must be met:"#]
        #[doc = r#"(1) the client has assigned an xdg_surface-based role to the surface"#]
        #[doc = r#"(2) the client has set and committed the xdg_surface state and the"#]
        #[doc = r#"role-dependent state to the surface"#]
        #[doc = r#"(3) the client has committed a buffer to the surface"#]
        #[doc = r#""#]
        #[doc = r#"A newly-unmapped surface is considered to have met condition (1) out"#]
        #[doc = r#"of the 3 required conditions for mapping a surface if its role surface"#]
        #[doc = r#"has not been destroyed, i.e. the client must perform the initial commit"#]
        #[doc = r#"again before attaching a buffer."#]
        pub trait XdgSurface: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_surface";
            const VERSION: u32 = 6;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("xdg_surface#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("xdg_surface#{}.get_toplevel()", object.id);
                        self.get_toplevel(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("xdg_surface#{}.get_popup()", object.id);
                        self.get_popup(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.object()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3 => {
                        tracing::debug!("xdg_surface#{}.set_window_geometry()", object.id);
                        self.set_window_geometry(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    4 => {
                        tracing::debug!("xdg_surface#{}.ack_configure()", object.id);
                        self.ack_configure(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the xdg_surface object. An xdg_surface must only be destroyed"#]
            #[doc = r#"after its role object has been destroyed, otherwise"#]
            #[doc = r#"a defunct_role_object error is raised."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This creates an xdg_toplevel object for the given xdg_surface and gives"#]
            #[doc = r#"the associated wl_surface the xdg_toplevel role."#]
            #[doc = r#""#]
            #[doc = r#"See the documentation of xdg_toplevel for more details about what an"#]
            #[doc = r#"xdg_toplevel is and how it is used."#]
            async fn get_toplevel(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_toplevel: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"This creates an xdg_popup object for the given xdg_surface and gives"#]
            #[doc = r#"the associated wl_surface the xdg_popup role."#]
            #[doc = r#""#]
            #[doc = r#"If null is passed as a parent, a parent surface must be specified using"#]
            #[doc = r#"some other protocol, before committing the initial state."#]
            #[doc = r#""#]
            #[doc = r#"See the documentation of xdg_popup for more details about what an"#]
            #[doc = r#"xdg_popup is and how it is used."#]
            async fn get_popup(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_popup: crate::wire::ObjectId,
                get_popup: Option<crate::wire::ObjectId>,
                get_popup: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"The window geometry of a surface is its "visible bounds" from the"#]
            #[doc = r#"user's perspective. Client-side decorations often have invisible"#]
            #[doc = r#"portions like drop-shadows which should be ignored for the"#]
            #[doc = r#"purposes of aligning, placing and constraining windows."#]
            #[doc = r#""#]
            #[doc = r#"The window geometry is double buffered, and will be applied at the"#]
            #[doc = r#"time wl_surface.commit of the corresponding wl_surface is called."#]
            #[doc = r#""#]
            #[doc = r#"When maintaining a position, the compositor should treat the (x, y)"#]
            #[doc = r#"coordinate of the window geometry as the top left corner of the window."#]
            #[doc = r#"A client changing the (x, y) window geometry coordinate should in"#]
            #[doc = r#"general not alter the position of the window."#]
            #[doc = r#""#]
            #[doc = r#"Once the window geometry of the surface is set, it is not possible to"#]
            #[doc = r#"unset it, and it will remain the same until set_window_geometry is"#]
            #[doc = r#"called again, even if a new subsurface or buffer is attached."#]
            #[doc = r#""#]
            #[doc = r#"If never set, the value is the full bounds of the surface,"#]
            #[doc = r#"including any subsurfaces. This updates dynamically on every"#]
            #[doc = r#"commit. This unset is meant for extremely simple clients."#]
            #[doc = r#""#]
            #[doc = r#"The arguments are given in the surface-local coordinate space of"#]
            #[doc = r#"the wl_surface associated with this xdg_surface, and may extend outside"#]
            #[doc = r#"of the wl_surface itself to mark parts of the subsurface tree as part of"#]
            #[doc = r#"the window geometry."#]
            #[doc = r#""#]
            #[doc = r#"When applied, the effective window geometry will be the set window"#]
            #[doc = r#"geometry clamped to the bounding rectangle of the combined"#]
            #[doc = r#"geometry of the surface of the xdg_surface and the associated"#]
            #[doc = r#"subsurfaces."#]
            #[doc = r#""#]
            #[doc = r#"The effective geometry will not be recalculated unless a new call to"#]
            #[doc = r#"set_window_geometry is done and the new pending surface state is"#]
            #[doc = r#"subsequently applied."#]
            #[doc = r#""#]
            #[doc = r#"The width and height of the effective window geometry must be"#]
            #[doc = r#"greater than zero. Setting an invalid size will raise an"#]
            #[doc = r#"invalid_size error."#]
            async fn set_window_geometry(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_window_geometry: i32,
                set_window_geometry: i32,
                set_window_geometry: i32,
                set_window_geometry: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"When a configure event is received, if a client commits the"#]
            #[doc = r#"surface in response to the configure event, then the client"#]
            #[doc = r#"must make an ack_configure request sometime before the commit"#]
            #[doc = r#"request, passing along the serial of the configure event."#]
            #[doc = r#""#]
            #[doc = r#"For instance, for toplevel surfaces the compositor might use this"#]
            #[doc = r#"information to move a surface to the top left only when the client has"#]
            #[doc = r#"drawn itself for the maximized or fullscreen state."#]
            #[doc = r#""#]
            #[doc = r#"If the client receives multiple configure events before it"#]
            #[doc = r#"can respond to one, it only has to ack the last configure event."#]
            #[doc = r#"Acking a configure event that was never sent raises an invalid_serial"#]
            #[doc = r#"error."#]
            #[doc = r#""#]
            #[doc = r#"A client is not required to commit immediately after sending"#]
            #[doc = r#"an ack_configure request - it may even ack_configure several times"#]
            #[doc = r#"before its next surface commit."#]
            #[doc = r#""#]
            #[doc = r#"A client may send multiple ack_configure requests before committing, but"#]
            #[doc = r#"only the last request sent before a commit indicates which configure"#]
            #[doc = r#"event the client really is responding to."#]
            #[doc = r#""#]
            #[doc = r#"Sending an ack_configure request consumes the serial number sent with"#]
            #[doc = r#"the request, as well as serial numbers sent by all configure events"#]
            #[doc = r#"sent on this xdg_surface prior to the configure event referenced by"#]
            #[doc = r#"the committed serial."#]
            #[doc = r#""#]
            #[doc = r#"It is an error to issue multiple ack_configure requests referencing a"#]
            #[doc = r#"serial from the same configure event, or to issue an ack_configure"#]
            #[doc = r#"request referencing a serial from a configure event issued before the"#]
            #[doc = r#"event identified by the last ack_configure request for the same"#]
            #[doc = r#"xdg_surface. Doing so will raise an invalid_serial error."#]
            async fn ack_configure(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                ack_configure: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"The configure event marks the end of a configure sequence. A configure"#]
            #[doc = r#"sequence is a set of one or more events configuring the state of the"#]
            #[doc = r#"xdg_surface, including the final xdg_surface.configure event."#]
            #[doc = r#""#]
            #[doc = r#"Where applicable, xdg_surface surface roles will during a configure"#]
            #[doc = r#"sequence extend this event as a latched state sent as events before the"#]
            #[doc = r#"xdg_surface.configure event. Such events should be considered to make up"#]
            #[doc = r#"a set of atomically applied configuration states, where the"#]
            #[doc = r#"xdg_surface.configure commits the accumulated state."#]
            #[doc = r#""#]
            #[doc = r#"Clients should arrange their surface for the new states, and then send"#]
            #[doc = r#"an ack_configure request with the serial sent in this configure event at"#]
            #[doc = r#"some point before committing the new surface."#]
            #[doc = r#""#]
            #[doc = r#"If the client receives multiple configure events before it can respond"#]
            #[doc = r#"to one, it is free to discard all but the last event it received."#]
            async fn configure(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_surface#{}.configure()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod xdg_toplevel {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Provided value is"#]
            #[doc = r#"Not a valid variant of the resize_edge enum"#]
            InvalidResizeEdge = 0,
            #[doc = r#"Invalid parent toplevel"#]
            InvalidParent = 1,
            #[doc = r#"Client provided an invalid min or max size"#]
            InvalidSize = 2,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::InvalidResizeEdge),
                    1 => Ok(Self::InvalidParent),
                    2 => Ok(Self::InvalidSize),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"These values are used to indicate which edge of a surface"#]
        #[doc = r#"is being dragged in a resize operation."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ResizeEdge {
            None = 0,
            Top = 1,
            Bottom = 2,
            Left = 4,
            TopLeft = 5,
            BottomLeft = 6,
            Right = 8,
            TopRight = 9,
            BottomRight = 10,
        }
        impl TryFrom<u32> for ResizeEdge {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::None),
                    1 => Ok(Self::Top),
                    2 => Ok(Self::Bottom),
                    4 => Ok(Self::Left),
                    5 => Ok(Self::TopLeft),
                    6 => Ok(Self::BottomLeft),
                    8 => Ok(Self::Right),
                    9 => Ok(Self::TopRight),
                    10 => Ok(Self::BottomRight),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"The different state values used on the surface. This is designed for"#]
        #[doc = r#"state values like maximized, fullscreen. It is paired with the"#]
        #[doc = r#"configure event to ensure that both the client and the compositor"#]
        #[doc = r#"setting the state can be synchronized."#]
        #[doc = r#""#]
        #[doc = r#"States set in this way are double-buffered. They will get applied on"#]
        #[doc = r#"the next commit."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum State {
            #[doc = r#"The surface is maximized"#]
            Maximized = 1,
            #[doc = r#"The surface is fullscreen"#]
            Fullscreen = 2,
            #[doc = r#"The surface is being resized"#]
            Resizing = 3,
            #[doc = r#"The surface is now activated"#]
            Activated = 4,
            TiledLeft = 5,
            TiledRight = 6,
            TiledTop = 7,
            TiledBottom = 8,
            Suspended = 9,
        }
        impl TryFrom<u32> for State {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::Maximized),
                    2 => Ok(Self::Fullscreen),
                    3 => Ok(Self::Resizing),
                    4 => Ok(Self::Activated),
                    5 => Ok(Self::TiledLeft),
                    6 => Ok(Self::TiledRight),
                    7 => Ok(Self::TiledTop),
                    8 => Ok(Self::TiledBottom),
                    9 => Ok(Self::Suspended),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum WmCapabilities {
            #[doc = r#"Show_window_menu is available"#]
            WindowMenu = 1,
            #[doc = r#"Set_maximized and unset_maximized are available"#]
            Maximize = 2,
            #[doc = r#"Set_fullscreen and unset_fullscreen are available"#]
            Fullscreen = 3,
            #[doc = r#"Set_minimized is available"#]
            Minimize = 4,
        }
        impl TryFrom<u32> for WmCapabilities {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::WindowMenu),
                    2 => Ok(Self::Maximize),
                    3 => Ok(Self::Fullscreen),
                    4 => Ok(Self::Minimize),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"This interface defines an xdg_surface role which allows a surface to,"#]
        #[doc = r#"among other things, set window-like properties such as maximize,"#]
        #[doc = r#"fullscreen, and minimize, set application-specific metadata like title and"#]
        #[doc = r#"id, and well as trigger user interactive operations such as interactive"#]
        #[doc = r#"resize and move."#]
        #[doc = r#""#]
        #[doc = r#"A xdg_toplevel by default is responsible for providing the full intended"#]
        #[doc = r#"visual representation of the toplevel, which depending on the window"#]
        #[doc = r#"state, may mean things like a title bar, window controls and drop shadow."#]
        #[doc = r#""#]
        #[doc = r#"Unmapping an xdg_toplevel means that the surface cannot be shown"#]
        #[doc = r#"by the compositor until it is explicitly mapped again."#]
        #[doc = r#"All active operations (e.g., move, resize) are canceled and all"#]
        #[doc = r#"attributes (e.g. title, state, stacking, ...) are discarded for"#]
        #[doc = r#"an xdg_toplevel surface when it is unmapped. The xdg_toplevel returns to"#]
        #[doc = r#"the state it had right after xdg_surface.get_toplevel. The client"#]
        #[doc = r#"can re-map the toplevel by perfoming a commit without any buffer"#]
        #[doc = r#"attached, waiting for a configure event and handling it as usual (see"#]
        #[doc = r#"xdg_surface description)."#]
        #[doc = r#""#]
        #[doc = r#"Attaching a null buffer to a toplevel unmaps the surface."#]
        pub trait XdgToplevel: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_toplevel";
            const VERSION: u32 = 6;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("xdg_toplevel#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("xdg_toplevel#{}.set_parent()", object.id);
                        self.set_parent(object, client, message.object()?).await
                    }
                    2 => {
                        tracing::debug!("xdg_toplevel#{}.set_title()", object.id);
                        self.set_title(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3 => {
                        tracing::debug!("xdg_toplevel#{}.set_app_id()", object.id);
                        self.set_app_id(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    4 => {
                        tracing::debug!("xdg_toplevel#{}.show_window_menu()", object.id);
                        self.show_window_menu(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    5 => {
                        tracing::debug!("xdg_toplevel#{}.move()", object.id);
                        self.r#move(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    6 => {
                        tracing::debug!("xdg_toplevel#{}.resize()", object.id);
                        self.resize(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    7 => {
                        tracing::debug!("xdg_toplevel#{}.set_max_size()", object.id);
                        self.set_max_size(object, client, message.int()?, message.int()?)
                            .await
                    }
                    8 => {
                        tracing::debug!("xdg_toplevel#{}.set_min_size()", object.id);
                        self.set_min_size(object, client, message.int()?, message.int()?)
                            .await
                    }
                    9 => {
                        tracing::debug!("xdg_toplevel#{}.set_maximized()", object.id);
                        self.set_maximized(object, client).await
                    }
                    10 => {
                        tracing::debug!("xdg_toplevel#{}.unset_maximized()", object.id);
                        self.unset_maximized(object, client).await
                    }
                    11 => {
                        tracing::debug!("xdg_toplevel#{}.set_fullscreen()", object.id);
                        self.set_fullscreen(object, client, message.object()?).await
                    }
                    12 => {
                        tracing::debug!("xdg_toplevel#{}.unset_fullscreen()", object.id);
                        self.unset_fullscreen(object, client).await
                    }
                    13 => {
                        tracing::debug!("xdg_toplevel#{}.set_minimized()", object.id);
                        self.set_minimized(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"This request destroys the role surface and unmaps the surface;"#]
            #[doc = r#"see "Unmapping" behavior in interface section for details."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set the "parent" of this surface. This surface should be stacked"#]
            #[doc = r#"above the parent surface and all other ancestor surfaces."#]
            #[doc = r#""#]
            #[doc = r#"Parent surfaces should be set on dialogs, toolboxes, or other"#]
            #[doc = r#""auxiliary" surfaces, so that the parent is raised when the dialog"#]
            #[doc = r#"is raised."#]
            #[doc = r#""#]
            #[doc = r#"Setting a null parent for a child surface unsets its parent. Setting"#]
            #[doc = r#"a null parent for a surface which currently has no parent is a no-op."#]
            #[doc = r#""#]
            #[doc = r#"Only mapped surfaces can have child surfaces. Setting a parent which"#]
            #[doc = r#"is not mapped is equivalent to setting a null parent. If a surface"#]
            #[doc = r#"becomes unmapped, its children's parent is set to the parent of"#]
            #[doc = r#"the now-unmapped surface. If the now-unmapped surface has no parent,"#]
            #[doc = r#"its children's parent is unset. If the now-unmapped surface becomes"#]
            #[doc = r#"mapped again, its parent-child relationship is not restored."#]
            #[doc = r#""#]
            #[doc = r#"The parent toplevel must not be one of the child toplevel's"#]
            #[doc = r#"descendants, and the parent must be different from the child toplevel,"#]
            #[doc = r#"otherwise the invalid_parent protocol error is raised."#]
            async fn set_parent(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_parent: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set a short title for the surface."#]
            #[doc = r#""#]
            #[doc = r#"This string may be used to identify the surface in a task bar,"#]
            #[doc = r#"window list, or other user interface elements provided by the"#]
            #[doc = r#"compositor."#]
            #[doc = r#""#]
            #[doc = r#"The string must be encoded in UTF-8."#]
            async fn set_title(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_title: String,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set an application identifier for the surface."#]
            #[doc = r#""#]
            #[doc = r#"The app ID identifies the general class of applications to which"#]
            #[doc = r#"the surface belongs. The compositor can use this to group multiple"#]
            #[doc = r#"surfaces together, or to determine how to launch a new application."#]
            #[doc = r#""#]
            #[doc = r#"For D-Bus activatable applications, the app ID is used as the D-Bus"#]
            #[doc = r#"service name."#]
            #[doc = r#""#]
            #[doc = r#"The compositor shell will try to group application surfaces together"#]
            #[doc = r#"by their app ID. As a best practice, it is suggested to select app"#]
            #[doc = r#"ID's that match the basename of the application's .desktop file."#]
            #[doc = r#"For example, "org.freedesktop.FooViewer" where the .desktop file is"#]
            #[doc = r#""org.freedesktop.FooViewer.desktop"."#]
            #[doc = r#""#]
            #[doc = r#"Like other properties, a set_app_id request can be sent after the"#]
            #[doc = r#"xdg_toplevel has been mapped to update the property."#]
            #[doc = r#""#]
            #[doc = r#"See the desktop-entry specification [0] for more details on"#]
            #[doc = r#"application identifiers and how they relate to well-known D-Bus"#]
            #[doc = r#"names and .desktop files."#]
            #[doc = r#""#]
            #[doc = r#"[0] https://standards.freedesktop.org/desktop-entry-spec/"#]
            async fn set_app_id(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_app_id: String,
            ) -> crate::server::Result<()>;
            #[doc = r#"Clients implementing client-side decorations might want to show"#]
            #[doc = r#"a context menu when right-clicking on the decorations, giving the"#]
            #[doc = r#"user a menu that they can use to maximize or minimize the window."#]
            #[doc = r#""#]
            #[doc = r#"This request asks the compositor to pop up such a window menu at"#]
            #[doc = r#"the given position, relative to the local surface coordinates of"#]
            #[doc = r#"the parent surface. There are no guarantees as to what menu items"#]
            #[doc = r#"the window menu contains, or even if a window menu will be drawn"#]
            #[doc = r#"at all."#]
            #[doc = r#""#]
            #[doc = r#"This request must be used in response to some sort of user action"#]
            #[doc = r#"like a button press, key press, or touch down event."#]
            async fn show_window_menu(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                show_window_menu: crate::wire::ObjectId,
                show_window_menu: u32,
                show_window_menu: i32,
                show_window_menu: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Start an interactive, user-driven move of the surface."#]
            #[doc = r#""#]
            #[doc = r#"This request must be used in response to some sort of user action"#]
            #[doc = r#"like a button press, key press, or touch down event. The passed"#]
            #[doc = r#"serial is used to determine the type of interactive move (touch,"#]
            #[doc = r#"pointer, etc)."#]
            #[doc = r#""#]
            #[doc = r#"The server may ignore move requests depending on the state of"#]
            #[doc = r#"the surface (e.g. fullscreen or maximized), or if the passed serial"#]
            #[doc = r#"is no longer valid."#]
            #[doc = r#""#]
            #[doc = r#"If triggered, the surface will lose the focus of the device"#]
            #[doc = r#"(wl_pointer, wl_touch, etc) used for the move. It is up to the"#]
            #[doc = r#"compositor to visually indicate that the move is taking place, such as"#]
            #[doc = r#"updating a pointer cursor, during the move. There is no guarantee"#]
            #[doc = r#"that the device focus will return when the move is completed."#]
            async fn r#move(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                r#move: crate::wire::ObjectId,
                r#move: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Start a user-driven, interactive resize of the surface."#]
            #[doc = r#""#]
            #[doc = r#"This request must be used in response to some sort of user action"#]
            #[doc = r#"like a button press, key press, or touch down event. The passed"#]
            #[doc = r#"serial is used to determine the type of interactive resize (touch,"#]
            #[doc = r#"pointer, etc)."#]
            #[doc = r#""#]
            #[doc = r#"The server may ignore resize requests depending on the state of"#]
            #[doc = r#"the surface (e.g. fullscreen or maximized)."#]
            #[doc = r#""#]
            #[doc = r#"If triggered, the client will receive configure events with the"#]
            #[doc = r#""resize" state enum value and the expected sizes. See the "resize""#]
            #[doc = r#"enum value for more details about what is required. The client"#]
            #[doc = r#"must also acknowledge configure events using "ack_configure". After"#]
            #[doc = r#"the resize is completed, the client will receive another "configure""#]
            #[doc = r#"event without the resize state."#]
            #[doc = r#""#]
            #[doc = r#"If triggered, the surface also will lose the focus of the device"#]
            #[doc = r#"(wl_pointer, wl_touch, etc) used for the resize. It is up to the"#]
            #[doc = r#"compositor to visually indicate that the resize is taking place,"#]
            #[doc = r#"such as updating a pointer cursor, during the resize. There is no"#]
            #[doc = r#"guarantee that the device focus will return when the resize is"#]
            #[doc = r#"completed."#]
            #[doc = r#""#]
            #[doc = r#"The edges parameter specifies how the surface should be resized, and"#]
            #[doc = r#"is one of the values of the resize_edge enum. Values not matching"#]
            #[doc = r#"a variant of the enum will cause the invalid_resize_edge protocol error."#]
            #[doc = r#"The compositor may use this information to update the surface position"#]
            #[doc = r#"for example when dragging the top left corner. The compositor may also"#]
            #[doc = r#"use this information to adapt its behavior, e.g. choose an appropriate"#]
            #[doc = r#"cursor image."#]
            async fn resize(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                resize: crate::wire::ObjectId,
                resize: u32,
                resize: ResizeEdge,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set a maximum size for the window."#]
            #[doc = r#""#]
            #[doc = r#"The client can specify a maximum size so that the compositor does"#]
            #[doc = r#"not try to configure the window beyond this size."#]
            #[doc = r#""#]
            #[doc = r#"The width and height arguments are in window geometry coordinates."#]
            #[doc = r#"See xdg_surface.set_window_geometry."#]
            #[doc = r#""#]
            #[doc = r#"Values set in this way are double-buffered. They will get applied"#]
            #[doc = r#"on the next commit."#]
            #[doc = r#""#]
            #[doc = r#"The compositor can use this information to allow or disallow"#]
            #[doc = r#"different states like maximize or fullscreen and draw accurate"#]
            #[doc = r#"animations."#]
            #[doc = r#""#]
            #[doc = r#"Similarly, a tiling window manager may use this information to"#]
            #[doc = r#"place and resize client windows in a more effective way."#]
            #[doc = r#""#]
            #[doc = r#"The client should not rely on the compositor to obey the maximum"#]
            #[doc = r#"size. The compositor may decide to ignore the values set by the"#]
            #[doc = r#"client and request a larger size."#]
            #[doc = r#""#]
            #[doc = r#"If never set, or a value of zero in the request, means that the"#]
            #[doc = r#"client has no expected maximum size in the given dimension."#]
            #[doc = r#"As a result, a client wishing to reset the maximum size"#]
            #[doc = r#"to an unspecified state can use zero for width and height in the"#]
            #[doc = r#"request."#]
            #[doc = r#""#]
            #[doc = r#"Requesting a maximum size to be smaller than the minimum size of"#]
            #[doc = r#"a surface is illegal and will result in an invalid_size error."#]
            #[doc = r#""#]
            #[doc = r#"The width and height must be greater than or equal to zero. Using"#]
            #[doc = r#"strictly negative values for width or height will result in a"#]
            #[doc = r#"invalid_size error."#]
            async fn set_max_size(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_max_size: i32,
                set_max_size: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set a minimum size for the window."#]
            #[doc = r#""#]
            #[doc = r#"The client can specify a minimum size so that the compositor does"#]
            #[doc = r#"not try to configure the window below this size."#]
            #[doc = r#""#]
            #[doc = r#"The width and height arguments are in window geometry coordinates."#]
            #[doc = r#"See xdg_surface.set_window_geometry."#]
            #[doc = r#""#]
            #[doc = r#"Values set in this way are double-buffered. They will get applied"#]
            #[doc = r#"on the next commit."#]
            #[doc = r#""#]
            #[doc = r#"The compositor can use this information to allow or disallow"#]
            #[doc = r#"different states like maximize or fullscreen and draw accurate"#]
            #[doc = r#"animations."#]
            #[doc = r#""#]
            #[doc = r#"Similarly, a tiling window manager may use this information to"#]
            #[doc = r#"place and resize client windows in a more effective way."#]
            #[doc = r#""#]
            #[doc = r#"The client should not rely on the compositor to obey the minimum"#]
            #[doc = r#"size. The compositor may decide to ignore the values set by the"#]
            #[doc = r#"client and request a smaller size."#]
            #[doc = r#""#]
            #[doc = r#"If never set, or a value of zero in the request, means that the"#]
            #[doc = r#"client has no expected minimum size in the given dimension."#]
            #[doc = r#"As a result, a client wishing to reset the minimum size"#]
            #[doc = r#"to an unspecified state can use zero for width and height in the"#]
            #[doc = r#"request."#]
            #[doc = r#""#]
            #[doc = r#"Requesting a minimum size to be larger than the maximum size of"#]
            #[doc = r#"a surface is illegal and will result in an invalid_size error."#]
            #[doc = r#""#]
            #[doc = r#"The width and height must be greater than or equal to zero. Using"#]
            #[doc = r#"strictly negative values for width and height will result in a"#]
            #[doc = r#"invalid_size error."#]
            async fn set_min_size(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_min_size: i32,
                set_min_size: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Maximize the surface."#]
            #[doc = r#""#]
            #[doc = r#"After requesting that the surface should be maximized, the compositor"#]
            #[doc = r#"will respond by emitting a configure event. Whether this configure"#]
            #[doc = r#"actually sets the window maximized is subject to compositor policies."#]
            #[doc = r#"The client must then update its content, drawing in the configured"#]
            #[doc = r#"state. The client must also acknowledge the configure when committing"#]
            #[doc = r#"the new content (see ack_configure)."#]
            #[doc = r#""#]
            #[doc = r#"It is up to the compositor to decide how and where to maximize the"#]
            #[doc = r#"surface, for example which output and what region of the screen should"#]
            #[doc = r#"be used."#]
            #[doc = r#""#]
            #[doc = r#"If the surface was already maximized, the compositor will still emit"#]
            #[doc = r#"a configure event with the "maximized" state."#]
            #[doc = r#""#]
            #[doc = r#"If the surface is in a fullscreen state, this request has no direct"#]
            #[doc = r#"effect. It may alter the state the surface is returned to when"#]
            #[doc = r#"unmaximized unless overridden by the compositor."#]
            async fn set_maximized(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Unmaximize the surface."#]
            #[doc = r#""#]
            #[doc = r#"After requesting that the surface should be unmaximized, the compositor"#]
            #[doc = r#"will respond by emitting a configure event. Whether this actually"#]
            #[doc = r#"un-maximizes the window is subject to compositor policies."#]
            #[doc = r#"If available and applicable, the compositor will include the window"#]
            #[doc = r#"geometry dimensions the window had prior to being maximized in the"#]
            #[doc = r#"configure event. The client must then update its content, drawing it in"#]
            #[doc = r#"the configured state. The client must also acknowledge the configure"#]
            #[doc = r#"when committing the new content (see ack_configure)."#]
            #[doc = r#""#]
            #[doc = r#"It is up to the compositor to position the surface after it was"#]
            #[doc = r#"unmaximized; usually the position the surface had before maximizing, if"#]
            #[doc = r#"applicable."#]
            #[doc = r#""#]
            #[doc = r#"If the surface was already not maximized, the compositor will still"#]
            #[doc = r#"emit a configure event without the "maximized" state."#]
            #[doc = r#""#]
            #[doc = r#"If the surface is in a fullscreen state, this request has no direct"#]
            #[doc = r#"effect. It may alter the state the surface is returned to when"#]
            #[doc = r#"unmaximized unless overridden by the compositor."#]
            async fn unset_maximized(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Make the surface fullscreen."#]
            #[doc = r#""#]
            #[doc = r#"After requesting that the surface should be fullscreened, the"#]
            #[doc = r#"compositor will respond by emitting a configure event. Whether the"#]
            #[doc = r#"client is actually put into a fullscreen state is subject to compositor"#]
            #[doc = r#"policies. The client must also acknowledge the configure when"#]
            #[doc = r#"committing the new content (see ack_configure)."#]
            #[doc = r#""#]
            #[doc = r#"The output passed by the request indicates the client's preference as"#]
            #[doc = r#"to which display it should be set fullscreen on. If this value is NULL,"#]
            #[doc = r#"it's up to the compositor to choose which display will be used to map"#]
            #[doc = r#"this surface."#]
            #[doc = r#""#]
            #[doc = r#"If the surface doesn't cover the whole output, the compositor will"#]
            #[doc = r#"position the surface in the center of the output and compensate with"#]
            #[doc = r#"with border fill covering the rest of the output. The content of the"#]
            #[doc = r#"border fill is undefined, but should be assumed to be in some way that"#]
            #[doc = r#"attempts to blend into the surrounding area (e.g. solid black)."#]
            #[doc = r#""#]
            #[doc = r#"If the fullscreened surface is not opaque, the compositor must make"#]
            #[doc = r#"sure that other screen content not part of the same surface tree (made"#]
            #[doc = r#"up of subsurfaces, popups or similarly coupled surfaces) are not"#]
            #[doc = r#"visible below the fullscreened surface."#]
            async fn set_fullscreen(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_fullscreen: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = r#"Make the surface no longer fullscreen."#]
            #[doc = r#""#]
            #[doc = r#"After requesting that the surface should be unfullscreened, the"#]
            #[doc = r#"compositor will respond by emitting a configure event."#]
            #[doc = r#"Whether this actually removes the fullscreen state of the client is"#]
            #[doc = r#"subject to compositor policies."#]
            #[doc = r#""#]
            #[doc = r#"Making a surface unfullscreen sets states for the surface based on the following:"#]
            #[doc = r#"* the state(s) it may have had before becoming fullscreen"#]
            #[doc = r#"* any state(s) decided by the compositor"#]
            #[doc = r#"* any state(s) requested by the client while the surface was fullscreen"#]
            #[doc = r#""#]
            #[doc = r#"The compositor may include the previous window geometry dimensions in"#]
            #[doc = r#"the configure event, if applicable."#]
            #[doc = r#""#]
            #[doc = r#"The client must also acknowledge the configure when committing the new"#]
            #[doc = r#"content (see ack_configure)."#]
            async fn unset_fullscreen(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Request that the compositor minimize your surface. There is no"#]
            #[doc = r#"way to know if the surface is currently minimized, nor is there"#]
            #[doc = r#"any way to unset minimization on this surface."#]
            #[doc = r#""#]
            #[doc = r#"If you are looking to throttle redrawing when minimized, please"#]
            #[doc = r#"instead use the wl_surface.frame event for this, as this will"#]
            #[doc = r#"also work with live previews on windows in Alt-Tab, Expose or"#]
            #[doc = r#"similar compositor features."#]
            async fn set_minimized(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This configure event asks the client to resize its toplevel surface or"#]
            #[doc = r#"to change its state. The configured state should not be applied"#]
            #[doc = r#"immediately. See xdg_surface.configure for details."#]
            #[doc = r#""#]
            #[doc = r#"The width and height arguments specify a hint to the window"#]
            #[doc = r#"about how its surface should be resized in window geometry"#]
            #[doc = r#"coordinates. See set_window_geometry."#]
            #[doc = r#""#]
            #[doc = r#"If the width or height arguments are zero, it means the client"#]
            #[doc = r#"should decide its own window dimension. This may happen when the"#]
            #[doc = r#"compositor needs to configure the state of the surface but doesn't"#]
            #[doc = r#"have any information about any previous or expected dimension."#]
            #[doc = r#""#]
            #[doc = r#"The states listed in the event specify how the width/height"#]
            #[doc = r#"arguments should be interpreted, and possibly how it should be"#]
            #[doc = r#"drawn."#]
            #[doc = r#""#]
            #[doc = r#"Clients must send an ack_configure in response to this event. See"#]
            #[doc = r#"xdg_surface.configure and xdg_surface.ack_configure for details."#]
            async fn configure(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
                states: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_toplevel#{}.configure()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(width)
                    .put_int(height)
                    .put_array(states)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The close event is sent by the compositor when the user"#]
            #[doc = r#"wants the surface to be closed. This should be equivalent to"#]
            #[doc = r#"the user clicking the close button in client-side decorations,"#]
            #[doc = r#"if your application has any."#]
            #[doc = r#""#]
            #[doc = r#"This is only a request that the user intends to close the"#]
            #[doc = r#"window. The client may choose to ignore this request, or show"#]
            #[doc = r#"a dialog to ask the user to save their data, etc."#]
            async fn close(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_toplevel#{}.close()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The configure_bounds event may be sent prior to a xdg_toplevel.configure"#]
            #[doc = r#"event to communicate the bounds a window geometry size is recommended"#]
            #[doc = r#"to constrain to."#]
            #[doc = r#""#]
            #[doc = r#"The passed width and height are in surface coordinate space. If width"#]
            #[doc = r#"and height are 0, it means bounds is unknown and equivalent to as if no"#]
            #[doc = r#"configure_bounds event was ever sent for this surface."#]
            #[doc = r#""#]
            #[doc = r#"The bounds can for example correspond to the size of a monitor excluding"#]
            #[doc = r#"any panels or other shell components, so that a surface isn't created in"#]
            #[doc = r#"a way that it cannot fit."#]
            #[doc = r#""#]
            #[doc = r#"The bounds may change at any point, and in such a case, a new"#]
            #[doc = r#"xdg_toplevel.configure_bounds will be sent, followed by"#]
            #[doc = r#"xdg_toplevel.configure and xdg_surface.configure."#]
            async fn configure_bounds(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_toplevel#{}.configure_bounds()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event advertises the capabilities supported by the compositor. If"#]
            #[doc = r#"a capability isn't supported, clients should hide or disable the UI"#]
            #[doc = r#"elements that expose this functionality. For instance, if the"#]
            #[doc = r#"compositor doesn't advertise support for minimized toplevels, a button"#]
            #[doc = r#"triggering the set_minimized request should not be displayed."#]
            #[doc = r#""#]
            #[doc = r#"The compositor will ignore requests it doesn't support. For instance,"#]
            #[doc = r#"a compositor which doesn't advertise support for minimized will ignore"#]
            #[doc = r#"set_minimized requests."#]
            #[doc = r#""#]
            #[doc = r#"Compositors must send this event once before the first"#]
            #[doc = r#"xdg_surface.configure event. When the capabilities change, compositors"#]
            #[doc = r#"must send this event again and then send an xdg_surface.configure"#]
            #[doc = r#"event."#]
            #[doc = r#""#]
            #[doc = r#"The configured state should not be applied immediately. See"#]
            #[doc = r#"xdg_surface.configure for details."#]
            #[doc = r#""#]
            #[doc = r#"The capabilities are sent as an array of 32-bit unsigned integers in"#]
            #[doc = r#"native endianness."#]
            async fn wm_capabilities(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                capabilities: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_toplevel#{}.wm_capabilities()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_array(capabilities)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod xdg_popup {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Tried to grab after being mapped"#]
            InvalidGrab = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::InvalidGrab),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"A popup surface is a short-lived, temporary surface. It can be used to"#]
        #[doc = r#"implement for example menus, popovers, tooltips and other similar user"#]
        #[doc = r#"interface concepts."#]
        #[doc = r#""#]
        #[doc = r#"A popup can be made to take an explicit grab. See xdg_popup.grab for"#]
        #[doc = r#"details."#]
        #[doc = r#""#]
        #[doc = r#"When the popup is dismissed, a popup_done event will be sent out, and at"#]
        #[doc = r#"the same time the surface will be unmapped. See the xdg_popup.popup_done"#]
        #[doc = r#"event for details."#]
        #[doc = r#""#]
        #[doc = r#"Explicitly destroying the xdg_popup object will also dismiss the popup and"#]
        #[doc = r#"unmap the surface. Clients that want to dismiss the popup when another"#]
        #[doc = r#"surface of their own is clicked should dismiss the popup using the destroy"#]
        #[doc = r#"request."#]
        #[doc = r#""#]
        #[doc = r#"A newly created xdg_popup will be stacked on top of all previously created"#]
        #[doc = r#"xdg_popup surfaces associated with the same xdg_toplevel."#]
        #[doc = r#""#]
        #[doc = r#"The parent of an xdg_popup must be mapped (see the xdg_surface"#]
        #[doc = r#"description) before the xdg_popup itself."#]
        #[doc = r#""#]
        #[doc = r#"The client must call wl_surface.commit on the corresponding wl_surface"#]
        #[doc = r#"for the xdg_popup state to take effect."#]
        pub trait XdgPopup: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_popup";
            const VERSION: u32 = 6;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("xdg_popup#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("xdg_popup#{}.grab()", object.id);
                        self.grab(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("xdg_popup#{}.reposition()", object.id);
                        self.reposition(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"This destroys the popup. Explicitly destroying the xdg_popup"#]
            #[doc = r#"object will also dismiss the popup, and unmap the surface."#]
            #[doc = r#""#]
            #[doc = r#"If this xdg_popup is not the "topmost" popup, the"#]
            #[doc = r#"xdg_wm_base.not_the_topmost_popup protocol error will be sent."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request makes the created popup take an explicit grab. An explicit"#]
            #[doc = r#"grab will be dismissed when the user dismisses the popup, or when the"#]
            #[doc = r#"client destroys the xdg_popup. This can be done by the user clicking"#]
            #[doc = r#"outside the surface, using the keyboard, or even locking the screen"#]
            #[doc = r#"through closing the lid or a timeout."#]
            #[doc = r#""#]
            #[doc = r#"If the compositor denies the grab, the popup will be immediately"#]
            #[doc = r#"dismissed."#]
            #[doc = r#""#]
            #[doc = r#"This request must be used in response to some sort of user action like a"#]
            #[doc = r#"button press, key press, or touch down event. The serial number of the"#]
            #[doc = r#"event should be passed as 'serial'."#]
            #[doc = r#""#]
            #[doc = r#"The parent of a grabbing popup must either be an xdg_toplevel surface or"#]
            #[doc = r#"another xdg_popup with an explicit grab. If the parent is another"#]
            #[doc = r#"xdg_popup it means that the popups are nested, with this popup now being"#]
            #[doc = r#"the topmost popup."#]
            #[doc = r#""#]
            #[doc = r#"Nested popups must be destroyed in the reverse order they were created"#]
            #[doc = r#"in, e.g. the only popup you are allowed to destroy at all times is the"#]
            #[doc = r#"topmost one."#]
            #[doc = r#""#]
            #[doc = r#"When compositors choose to dismiss a popup, they may dismiss every"#]
            #[doc = r#"nested grabbing popup as well. When a compositor dismisses popups, it"#]
            #[doc = r#"will follow the same dismissing order as required from the client."#]
            #[doc = r#""#]
            #[doc = r#"If the topmost grabbing popup is destroyed, the grab will be returned to"#]
            #[doc = r#"the parent of the popup, if that parent previously had an explicit grab."#]
            #[doc = r#""#]
            #[doc = r#"If the parent is a grabbing popup which has already been dismissed, this"#]
            #[doc = r#"popup will be immediately dismissed. If the parent is a popup that did"#]
            #[doc = r#"not take an explicit grab, an error will be raised."#]
            #[doc = r#""#]
            #[doc = r#"During a popup grab, the client owning the grab will receive pointer"#]
            #[doc = r#"and touch events for all their surfaces as normal (similar to an"#]
            #[doc = r#""owner-events" grab in X11 parlance), while the top most grabbing popup"#]
            #[doc = r#"will always have keyboard focus."#]
            async fn grab(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                grab: crate::wire::ObjectId,
                grab: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Reposition an already-mapped popup. The popup will be placed given the"#]
            #[doc = r#"details in the passed xdg_positioner object, and a"#]
            #[doc = r#"xdg_popup.repositioned followed by xdg_popup.configure and"#]
            #[doc = r#"xdg_surface.configure will be emitted in response. Any parameters set"#]
            #[doc = r#"by the previous positioner will be discarded."#]
            #[doc = r#""#]
            #[doc = r#"The passed token will be sent in the corresponding"#]
            #[doc = r#"xdg_popup.repositioned event. The new popup position will not take"#]
            #[doc = r#"effect until the corresponding configure event is acknowledged by the"#]
            #[doc = r#"client. See xdg_popup.repositioned for details. The token itself is"#]
            #[doc = r#"opaque, and has no other special meaning."#]
            #[doc = r#""#]
            #[doc = r#"If multiple reposition requests are sent, the compositor may skip all"#]
            #[doc = r#"but the last one."#]
            #[doc = r#""#]
            #[doc = r#"If the popup is repositioned in response to a configure event for its"#]
            #[doc = r#"parent, the client should send an xdg_positioner.set_parent_configure"#]
            #[doc = r#"and possibly an xdg_positioner.set_parent_size request to allow the"#]
            #[doc = r#"compositor to properly constrain the popup."#]
            #[doc = r#""#]
            #[doc = r#"If the popup is repositioned together with a parent that is being"#]
            #[doc = r#"resized, but not in response to a configure event, the client should"#]
            #[doc = r#"send an xdg_positioner.set_parent_size request."#]
            async fn reposition(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                reposition: crate::wire::ObjectId,
                reposition: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event asks the popup surface to configure itself given the"#]
            #[doc = r#"configuration. The configured state should not be applied immediately."#]
            #[doc = r#"See xdg_surface.configure for details."#]
            #[doc = r#""#]
            #[doc = r#"The x and y arguments represent the position the popup was placed at"#]
            #[doc = r#"given the xdg_positioner rule, relative to the upper left corner of the"#]
            #[doc = r#"window geometry of the parent surface."#]
            #[doc = r#""#]
            #[doc = r#"For version 2 or older, the configure event for an xdg_popup is only"#]
            #[doc = r#"ever sent once for the initial configuration. Starting with version 3,"#]
            #[doc = r#"it may be sent again if the popup is setup with an xdg_positioner with"#]
            #[doc = r#"set_reactive requested, or in response to xdg_popup.reposition requests."#]
            async fn configure(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_popup#{}.configure()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(x)
                    .put_int(y)
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The popup_done event is sent out when a popup is dismissed by the"#]
            #[doc = r#"compositor. The client should destroy the xdg_popup object at this"#]
            #[doc = r#"point."#]
            async fn popup_done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_popup#{}.popup_done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The repositioned event is sent as part of a popup configuration"#]
            #[doc = r#"sequence, together with xdg_popup.configure and lastly"#]
            #[doc = r#"xdg_surface.configure to notify the completion of a reposition request."#]
            #[doc = r#""#]
            #[doc = r#"The repositioned event is to notify about the completion of a"#]
            #[doc = r#"xdg_popup.reposition request. The token argument is the token passed"#]
            #[doc = r#"in the xdg_popup.reposition request."#]
            #[doc = r#""#]
            #[doc = r#"Immediately after this event is emitted, xdg_popup.configure and"#]
            #[doc = r#"xdg_surface.configure will be sent with the updated size and position,"#]
            #[doc = r#"as well as a new configure serial."#]
            #[doc = r#""#]
            #[doc = r#"The client should optionally update the content of the popup, but must"#]
            #[doc = r#"acknowledge the new popup configuration for the new position to take"#]
            #[doc = r#"effect. See xdg_surface.ack_configure for details."#]
            async fn repositioned(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                token: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_popup#{}.repositioned()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(token).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod alpha_modifier_v1 {
    pub mod wp_alpha_modifier_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Wl_surface already has a alpha modifier object"#]
            AlreadyConstructed = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::AlreadyConstructed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"This interface allows a client to set a factor for the alpha values on a"#]
        #[doc = r#"surface, which can be used to offload such operations to the compositor,"#]
        #[doc = r#"which can in turn for example offload them to KMS."#]
        #[doc = r#""#]
        #[doc = r#"Warning! The protocol described in this file is currently in the testing"#]
        #[doc = r#"phase. Backward compatible changes may be added together with the"#]
        #[doc = r#"corresponding interface version bump. Backward incompatible changes can"#]
        #[doc = r#"only be done by creating a new major version of the extension."#]
        pub trait WpAlphaModifierV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_alpha_modifier_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wp_alpha_modifier_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("wp_alpha_modifier_v1#{}.get_surface()", object.id);
                        self.get_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the alpha modifier manager. This doesn't destroy objects"#]
            #[doc = r#"created with the manager."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Create a new alpha modifier surface object associated with the"#]
            #[doc = r#"given wl_surface. If there is already such an object associated with"#]
            #[doc = r#"the wl_surface, the already_constructed error will be raised."#]
            async fn get_surface(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_surface: crate::wire::ObjectId,
                get_surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wp_alpha_modifier_surface_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Wl_surface was destroyed"#]
            NoSurface = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::NoSurface),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"This interface allows the client to set a factor for the alpha values on"#]
        #[doc = r#"a surface, which can be used to offload such operations to the compositor."#]
        #[doc = r#"The default factor is UINT32_MAX."#]
        #[doc = r#""#]
        #[doc = r#"This object has to be destroyed before the associated wl_surface. Once the"#]
        #[doc = r#"wl_surface is destroyed, all request on this object will raise the"#]
        #[doc = r#"no_surface error."#]
        pub trait WpAlphaModifierSurfaceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_alpha_modifier_surface_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wp_alpha_modifier_surface_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!(
                            "wp_alpha_modifier_surface_v1#{}.set_multiplier()",
                            object.id
                        );
                        self.set_multiplier(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"This destroys the object, and is equivalent to set_multiplier with"#]
            #[doc = r#"a value of UINT32_MAX, with the same double-buffered semantics as"#]
            #[doc = r#"set_multiplier."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Sets the alpha multiplier for the surface. The alpha multiplier is"#]
            #[doc = r#"double-buffered state, see wl_surface.commit for details."#]
            #[doc = r#""#]
            #[doc = r#"This factor is applied in the compositor's blending space, as an"#]
            #[doc = r#"additional step after the processing of per-pixel alpha values for the"#]
            #[doc = r#"wl_surface. The exact meaning of the factor is thus undefined, unless"#]
            #[doc = r#"the blending space is specified in a different extension."#]
            #[doc = r#""#]
            #[doc = r#"This multiplier is applied even if the buffer attached to the"#]
            #[doc = r#"wl_surface doesn't have an alpha channel; in that case an alpha value"#]
            #[doc = r#"of one is used instead."#]
            #[doc = r#""#]
            #[doc = r#"Zero means completely transparent, UINT32_MAX means completely opaque."#]
            async fn set_multiplier(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_multiplier: u32,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod content_type_v1 {
    pub mod wp_content_type_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Wl_surface already has a content type object"#]
            AlreadyConstructed = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::AlreadyConstructed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"This interface allows a client to describe the kind of content a surface"#]
        #[doc = r#"will display, to allow the compositor to optimize its behavior for it."#]
        #[doc = r#""#]
        #[doc = r#"Warning! The protocol described in this file is currently in the testing"#]
        #[doc = r#"phase. Backward compatible changes may be added together with the"#]
        #[doc = r#"corresponding interface version bump. Backward incompatible changes can"#]
        #[doc = r#"only be done by creating a new major version of the extension."#]
        pub trait WpContentTypeManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_content_type_manager_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wp_content_type_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!(
                            "wp_content_type_manager_v1#{}.get_surface_content_type()",
                            object.id
                        );
                        self.get_surface_content_type(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the content type manager. This doesn't destroy objects created"#]
            #[doc = r#"with the manager."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Create a new content type object associated with the given surface."#]
            #[doc = r#""#]
            #[doc = r#"Creating a wp_content_type_v1 from a wl_surface which already has one"#]
            #[doc = r#"attached is a client error: already_constructed."#]
            async fn get_surface_content_type(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_surface_content_type: crate::wire::ObjectId,
                get_surface_content_type: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wp_content_type_v1 {
        #[doc = r#"These values describe the available content types for a surface."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Type {
            None = 0,
            Photo = 1,
            Video = 2,
            Game = 3,
        }
        impl TryFrom<u32> for Type {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::None),
                    1 => Ok(Self::Photo),
                    2 => Ok(Self::Video),
                    3 => Ok(Self::Game),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"The content type object allows the compositor to optimize for the kind"#]
        #[doc = r#"of content shown on the surface. A compositor may for example use it to"#]
        #[doc = r#"set relevant drm properties like "content type"."#]
        #[doc = r#""#]
        #[doc = r#"The client may request to switch to another content type at any time."#]
        #[doc = r#"When the associated surface gets destroyed, this object becomes inert and"#]
        #[doc = r#"the client should destroy it."#]
        pub trait WpContentTypeV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_content_type_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wp_content_type_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("wp_content_type_v1#{}.set_content_type()", object.id);
                        self.set_content_type(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Switch back to not specifying the content type of this surface. This is"#]
            #[doc = r#"equivalent to setting the content type to none, including double"#]
            #[doc = r#"buffering semantics. See set_content_type for details."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set the surface content type. This informs the compositor that the"#]
            #[doc = r#"client believes it is displaying buffers matching this content type."#]
            #[doc = r#""#]
            #[doc = r#"This is purely a hint for the compositor, which can be used to adjust"#]
            #[doc = r#"its behavior or hardware settings to fit the presented content best."#]
            #[doc = r#""#]
            #[doc = r#"The content type is double-buffered state, see wl_surface.commit for"#]
            #[doc = r#"details."#]
            async fn set_content_type(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_content_type: Type,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod cursor_shape_v1 {
    pub mod wp_cursor_shape_manager_v1 {
        #[doc = r#"This global offers an alternative, optional way to set cursor images. This"#]
        #[doc = r#"new way uses enumerated cursors instead of a wl_surface like"#]
        #[doc = r#"wl_pointer.set_cursor does."#]
        #[doc = r#""#]
        #[doc = r#"Warning! The protocol described in this file is currently in the testing"#]
        #[doc = r#"phase. Backward compatible changes may be added together with the"#]
        #[doc = r#"corresponding interface version bump. Backward incompatible changes can"#]
        #[doc = r#"only be done by creating a new major version of the extension."#]
        pub trait WpCursorShapeManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_cursor_shape_manager_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wp_cursor_shape_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("wp_cursor_shape_manager_v1#{}.get_pointer()", object.id);
                        self.get_pointer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!(
                            "wp_cursor_shape_manager_v1#{}.get_tablet_tool_v2()",
                            object.id
                        );
                        self.get_tablet_tool_v2(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the cursor shape manager."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Obtain a wp_cursor_shape_device_v1 for a wl_pointer object."#]
            async fn get_pointer(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_pointer: crate::wire::ObjectId,
                get_pointer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Obtain a wp_cursor_shape_device_v1 for a zwp_tablet_tool_v2 object."#]
            async fn get_tablet_tool_v2(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_tablet_tool_v2: crate::wire::ObjectId,
                get_tablet_tool_v2: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wp_cursor_shape_device_v1 {
        #[doc = r#"This enum describes cursor shapes."#]
        #[doc = r#""#]
        #[doc = r#"The names are taken from the CSS W3C specification:"#]
        #[doc = r#"https://w3c.github.io/csswg-drafts/css-ui/#cursor"#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Shape {
            #[doc = r#"Default cursor"#]
            Default = 1,
            #[doc = r#"A context menu is available for the object under the cursor"#]
            ContextMenu = 2,
            #[doc = r#"Help is available for the object under the cursor"#]
            Help = 3,
            #[doc = r#"Pointer that indicates a link or another interactive element"#]
            Pointer = 4,
            #[doc = r#"Progress indicator"#]
            Progress = 5,
            #[doc = r#"Program is busy, user should wait"#]
            Wait = 6,
            #[doc = r#"A cell or set of cells may be selected"#]
            Cell = 7,
            #[doc = r#"Simple crosshair"#]
            Crosshair = 8,
            #[doc = r#"Text may be selected"#]
            Text = 9,
            #[doc = r#"Vertical text may be selected"#]
            VerticalText = 10,
            #[doc = r#"Drag-and-drop: alias of/shortcut to something is to be created"#]
            Alias = 11,
            #[doc = r#"Drag-and-drop: something is to be copied"#]
            Copy = 12,
            #[doc = r#"Drag-and-drop: something is to be moved"#]
            Move = 13,
            #[doc = r#"Drag-and-drop: the dragged item cannot be dropped at the current cursor location"#]
            NoDrop = 14,
            #[doc = r#"Drag-and-drop: the requested action will not be carried out"#]
            NotAllowed = 15,
            #[doc = r#"Drag-and-drop: something can be grabbed"#]
            Grab = 16,
            #[doc = r#"Drag-and-drop: something is being grabbed"#]
            Grabbing = 17,
            #[doc = r#"Resizing: the east border is to be moved"#]
            EResize = 18,
            #[doc = r#"Resizing: the north border is to be moved"#]
            NResize = 19,
            #[doc = r#"Resizing: the north-east corner is to be moved"#]
            NeResize = 20,
            #[doc = r#"Resizing: the north-west corner is to be moved"#]
            NwResize = 21,
            #[doc = r#"Resizing: the south border is to be moved"#]
            SResize = 22,
            #[doc = r#"Resizing: the south-east corner is to be moved"#]
            SeResize = 23,
            #[doc = r#"Resizing: the south-west corner is to be moved"#]
            SwResize = 24,
            #[doc = r#"Resizing: the west border is to be moved"#]
            WResize = 25,
            #[doc = r#"Resizing: the east and west borders are to be moved"#]
            EwResize = 26,
            #[doc = r#"Resizing: the north and south borders are to be moved"#]
            NsResize = 27,
            #[doc = r#"Resizing: the north-east and south-west corners are to be moved"#]
            NeswResize = 28,
            #[doc = r#"Resizing: the north-west and south-east corners are to be moved"#]
            NwseResize = 29,
            #[doc = r#"Resizing: that the item/column can be resized horizontally"#]
            ColResize = 30,
            #[doc = r#"Resizing: that the item/row can be resized vertically"#]
            RowResize = 31,
            #[doc = r#"Something can be scrolled in any direction"#]
            AllScroll = 32,
            #[doc = r#"Something can be zoomed in"#]
            ZoomIn = 33,
            #[doc = r#"Something can be zoomed out"#]
            ZoomOut = 34,
        }
        impl TryFrom<u32> for Shape {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::Default),
                    2 => Ok(Self::ContextMenu),
                    3 => Ok(Self::Help),
                    4 => Ok(Self::Pointer),
                    5 => Ok(Self::Progress),
                    6 => Ok(Self::Wait),
                    7 => Ok(Self::Cell),
                    8 => Ok(Self::Crosshair),
                    9 => Ok(Self::Text),
                    10 => Ok(Self::VerticalText),
                    11 => Ok(Self::Alias),
                    12 => Ok(Self::Copy),
                    13 => Ok(Self::Move),
                    14 => Ok(Self::NoDrop),
                    15 => Ok(Self::NotAllowed),
                    16 => Ok(Self::Grab),
                    17 => Ok(Self::Grabbing),
                    18 => Ok(Self::EResize),
                    19 => Ok(Self::NResize),
                    20 => Ok(Self::NeResize),
                    21 => Ok(Self::NwResize),
                    22 => Ok(Self::SResize),
                    23 => Ok(Self::SeResize),
                    24 => Ok(Self::SwResize),
                    25 => Ok(Self::WResize),
                    26 => Ok(Self::EwResize),
                    27 => Ok(Self::NsResize),
                    28 => Ok(Self::NeswResize),
                    29 => Ok(Self::NwseResize),
                    30 => Ok(Self::ColResize),
                    31 => Ok(Self::RowResize),
                    32 => Ok(Self::AllScroll),
                    33 => Ok(Self::ZoomIn),
                    34 => Ok(Self::ZoomOut),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"The specified shape value is invalid"#]
            InvalidShape = 1,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::InvalidShape),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"This interface allows clients to set the cursor shape."#]
        pub trait WpCursorShapeDeviceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_cursor_shape_device_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wp_cursor_shape_device_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("wp_cursor_shape_device_v1#{}.set_shape()", object.id);
                        self.set_shape(object, client, message.uint()?, message.uint()?.try_into()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the cursor shape device."#]
            #[doc = r#""#]
            #[doc = r#"The device cursor shape remains unchanged."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Sets the device cursor to the specified shape. The compositor will"#]
            #[doc = r#"change the cursor image based on the specified shape."#]
            #[doc = r#""#]
            #[doc = r#"The cursor actually changes only if the input device focus is one of"#]
            #[doc = r#"the requesting client's surfaces. If any, the previous cursor image"#]
            #[doc = r#"(surface or shape) is replaced."#]
            #[doc = r#""#]
            #[doc = r#"The "shape" argument must be a valid enum entry, otherwise the"#]
            #[doc = r#"invalid_shape protocol error is raised."#]
            #[doc = r#""#]
            #[doc = r#"This is similar to the wl_pointer.set_cursor and"#]
            #[doc = r#"zwp_tablet_tool_v2.set_cursor requests, but this request accepts a"#]
            #[doc = r#"shape instead of contents in the form of a surface. Clients can mix"#]
            #[doc = r#"set_cursor and set_shape requests."#]
            #[doc = r#""#]
            #[doc = r#"The serial parameter must match the latest wl_pointer.enter or"#]
            #[doc = r#"zwp_tablet_tool_v2.proximity_in serial number sent to the client."#]
            #[doc = r#"Otherwise the request will be ignored."#]
            async fn set_shape(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_shape: u32,
                set_shape: Shape,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod drm_lease_v1 {
    pub mod wp_drm_lease_device_v1 {
        #[doc = r#"This protocol is used by Wayland compositors which act as Direct"#]
        #[doc = r#"Rendering Manager (DRM) masters to lease DRM resources to Wayland"#]
        #[doc = r#"clients."#]
        #[doc = r#""#]
        #[doc = r#"The compositor will advertise one wp_drm_lease_device_v1 global for each"#]
        #[doc = r#"DRM node. Some time after a client binds to the wp_drm_lease_device_v1"#]
        #[doc = r#"global, the compositor will send a drm_fd event followed by zero, one or"#]
        #[doc = r#"more connector events. After all currently available connectors have been"#]
        #[doc = r#"sent, the compositor will send a wp_drm_lease_device_v1.done event."#]
        #[doc = r#""#]
        #[doc = r#"When the list of connectors available for lease changes the compositor"#]
        #[doc = r#"will send wp_drm_lease_device_v1.connector events for added connectors and"#]
        #[doc = r#"wp_drm_lease_connector_v1.withdrawn events for removed connectors,"#]
        #[doc = r#"followed by a wp_drm_lease_device_v1.done event."#]
        #[doc = r#""#]
        #[doc = r#"The compositor will indicate when a device is gone by removing the global"#]
        #[doc = r#"via a wl_registry.global_remove event. Upon receiving this event, the"#]
        #[doc = r#"client should destroy any matching wp_drm_lease_device_v1 object."#]
        #[doc = r#""#]
        #[doc = r#"To destroy a wp_drm_lease_device_v1 object, the client must first issue"#]
        #[doc = r#"a release request. Upon receiving this request, the compositor will"#]
        #[doc = r#"immediately send a released event and destroy the object. The client must"#]
        #[doc = r#"continue to process and discard drm_fd and connector events until it"#]
        #[doc = r#"receives the released event. Upon receiving the released event, the"#]
        #[doc = r#"client can safely cleanup any client-side resources."#]
        #[doc = r#""#]
        #[doc = r#"Warning! The protocol described in this file is currently in the testing"#]
        #[doc = r#"phase. Backward compatible changes may be added together with the"#]
        #[doc = r#"corresponding interface version bump. Backward incompatible changes can"#]
        #[doc = r#"only be done by creating a new major version of the extension."#]
        pub trait WpDrmLeaseDeviceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_drm_lease_device_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "wp_drm_lease_device_v1#{}.create_lease_request()",
                            object.id
                        );
                        self.create_lease_request(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("wp_drm_lease_device_v1#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Creates a lease request object."#]
            #[doc = r#""#]
            #[doc = r#"See the documentation for wp_drm_lease_request_v1 for details."#]
            async fn create_lease_request(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create_lease_request: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Indicates the client no longer wishes to use this object. In response"#]
            #[doc = r#"the compositor will immediately send the released event and destroy"#]
            #[doc = r#"this object. It can however not guarantee that the client won't receive"#]
            #[doc = r#"connector events before the released event. The client must not send any"#]
            #[doc = r#"requests after this one, doing so will raise a wl_display error."#]
            #[doc = r#"Existing connectors, lease request and leases will not be affected."#]
            async fn release(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"The compositor will send this event when the wp_drm_lease_device_v1"#]
            #[doc = r#"global is bound, although there are no guarantees as to how long this"#]
            #[doc = r#"takes - the compositor might need to wait until regaining DRM master."#]
            #[doc = r#"The included fd is a non-master DRM file descriptor opened for this"#]
            #[doc = r#"device and the compositor must not authenticate it."#]
            #[doc = r#"The purpose of this event is to give the client the ability to"#]
            #[doc = r#"query DRM and discover information which may help them pick the"#]
            #[doc = r#"appropriate DRM device or select the appropriate connectors therein."#]
            async fn drm_fd(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_drm_lease_device_v1#{}.drm_fd()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_fd(fd).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The compositor will use this event to advertise connectors available for"#]
            #[doc = r#"lease by clients. This object may be passed into a lease request to"#]
            #[doc = r#"indicate the client would like to lease that connector, see"#]
            #[doc = r#"wp_drm_lease_request_v1.request_connector for details. While the"#]
            #[doc = r#"compositor will make a best effort to not send disconnected connectors,"#]
            #[doc = r#"no guarantees can be made."#]
            #[doc = r#""#]
            #[doc = r#"The compositor must send the drm_fd event before sending connectors."#]
            #[doc = r#"After the drm_fd event it will send all available connectors but may"#]
            #[doc = r#"send additional connectors at any time."#]
            async fn connector(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_drm_lease_device_v1#{}.connector()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The compositor will send this event to indicate that it has sent all"#]
            #[doc = r#"currently available connectors after the client binds to the global or"#]
            #[doc = r#"when it updates the connector list, for example on hotplug, drm master"#]
            #[doc = r#"change or when a leased connector becomes available again. It will"#]
            #[doc = r#"similarly send this event to group wp_drm_lease_connector_v1.withdrawn"#]
            #[doc = r#"events of connectors of this device."#]
            async fn done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_drm_lease_device_v1#{}.done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent in response to the release request and indicates"#]
            #[doc = r#"that the compositor is done sending connector events."#]
            #[doc = r#"The compositor will destroy this object immediately after sending the"#]
            #[doc = r#"event and it will become invalid. The client should release any"#]
            #[doc = r#"resources associated with this device after receiving this event."#]
            async fn released(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_drm_lease_device_v1#{}.released()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod wp_drm_lease_connector_v1 {
        #[doc = r#"Represents a DRM connector which is available for lease. These objects are"#]
        #[doc = r#"created via wp_drm_lease_device_v1.connector events, and should be passed"#]
        #[doc = r#"to lease requests via wp_drm_lease_request_v1.request_connector."#]
        #[doc = r#"Immediately after the wp_drm_lease_connector_v1 object is created the"#]
        #[doc = r#"compositor will send a name, a description, a connector_id and a done"#]
        #[doc = r#"event. When the description is updated the compositor will send a"#]
        #[doc = r#"description event followed by a done event."#]
        pub trait WpDrmLeaseConnectorV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_drm_lease_connector_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wp_drm_lease_connector_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"The client may send this request to indicate that it will not use this"#]
            #[doc = r#"connector. Clients are encouraged to send this after receiving the"#]
            #[doc = r#""withdrawn" event so that the server can release the resources"#]
            #[doc = r#"associated with this connector offer. Neither existing lease requests"#]
            #[doc = r#"nor leases will be affected."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"The compositor sends this event once the connector is created to"#]
            #[doc = r#"indicate the name of this connector. This will not change for the"#]
            #[doc = r#"duration of the Wayland session, but is not guaranteed to be consistent"#]
            #[doc = r#"between sessions."#]
            #[doc = r#""#]
            #[doc = r#"If the compositor supports wl_output version 4 and this connector"#]
            #[doc = r#"corresponds to a wl_output, the compositor should use the same name as"#]
            #[doc = r#"for the wl_output."#]
            async fn name(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_drm_lease_connector_v1#{}.name()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(name))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The compositor sends this event once the connector is created to provide"#]
            #[doc = r#"a human-readable description for this connector, which may be presented"#]
            #[doc = r#"to the user. The compositor may send this event multiple times over the"#]
            #[doc = r#"lifetime of this object to reflect changes in the description."#]
            async fn description(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                description: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_drm_lease_connector_v1#{}.description()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(description))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The compositor sends this event once the connector is created to"#]
            #[doc = r#"indicate the DRM object ID which represents the underlying connector"#]
            #[doc = r#"that is being offered. Note that the final lease may include additional"#]
            #[doc = r#"object IDs, such as CRTCs and planes."#]
            async fn connector_id(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                connector_id: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_drm_lease_connector_v1#{}.connector_id()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(connector_id)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent after all properties of a connector have been sent."#]
            #[doc = r#"This allows changes to the properties to be seen as atomic even if they"#]
            #[doc = r#"happen via multiple events."#]
            async fn done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_drm_lease_connector_v1#{}.done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent to indicate that the compositor will no longer honor requests for"#]
            #[doc = r#"DRM leases which include this connector. The client may still issue a"#]
            #[doc = r#"lease request including this connector, but the compositor will send"#]
            #[doc = r#"wp_drm_lease_v1.finished without issuing a lease fd. Compositors are"#]
            #[doc = r#"encouraged to send this event when they lose access to connector, for"#]
            #[doc = r#"example when the connector is hot-unplugged, when the connector gets"#]
            #[doc = r#"leased to a client or when the compositor loses DRM master."#]
            async fn withdrawn(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_drm_lease_connector_v1#{}.withdrawn()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod wp_drm_lease_request_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Requested a connector from a different lease device"#]
            WrongDevice = 0,
            #[doc = r#"Requested a connector twice"#]
            DuplicateConnector = 1,
            #[doc = r#"Requested a lease without requesting a connector"#]
            EmptyLease = 2,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::WrongDevice),
                    1 => Ok(Self::DuplicateConnector),
                    2 => Ok(Self::EmptyLease),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"A client that wishes to lease DRM resources will attach the list of"#]
        #[doc = r#"connectors advertised with wp_drm_lease_device_v1.connector that they"#]
        #[doc = r#"wish to lease, then use wp_drm_lease_request_v1.submit to submit the"#]
        #[doc = r#"request."#]
        pub trait WpDrmLeaseRequestV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_drm_lease_request_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "wp_drm_lease_request_v1#{}.request_connector()",
                            object.id
                        );
                        self.request_connector(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("wp_drm_lease_request_v1#{}.submit()", object.id);
                        self.submit(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Indicates that the client would like to lease the given connector."#]
            #[doc = r#"This is only used as a suggestion, the compositor may choose to"#]
            #[doc = r#"include any resources in the lease it issues, or change the set of"#]
            #[doc = r#"leased resources at any time. Compositors are however encouraged to"#]
            #[doc = r#"include the requested connector and other resources necessary"#]
            #[doc = r#"to drive the connected output in the lease."#]
            #[doc = r#""#]
            #[doc = r#"Requesting a connector that was created from a different lease device"#]
            #[doc = r#"than this lease request raises the wrong_device error. Requesting a"#]
            #[doc = r#"connector twice will raise the duplicate_connector error."#]
            async fn request_connector(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                request_connector: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Submits the lease request and creates a new wp_drm_lease_v1 object."#]
            #[doc = r#"After calling submit the compositor will immediately destroy this"#]
            #[doc = r#"object, issuing any more requests will cause a wl_diplay error."#]
            #[doc = r#"The compositor doesn't make any guarantees about the events of the"#]
            #[doc = r#"lease object, clients cannot expect an immediate response."#]
            #[doc = r#"Not requesting any connectors before submitting the lease request"#]
            #[doc = r#"will raise the empty_lease error."#]
            async fn submit(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                submit: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wp_drm_lease_v1 {
        #[doc = r#"A DRM lease object is used to transfer the DRM file descriptor to the"#]
        #[doc = r#"client and manage the lifetime of the lease."#]
        #[doc = r#""#]
        #[doc = r#"Some time after the wp_drm_lease_v1 object is created, the compositor"#]
        #[doc = r#"will reply with the lease request's result. If the lease request is"#]
        #[doc = r#"granted, the compositor will send a lease_fd event. If the lease request"#]
        #[doc = r#"is denied, the compositor will send a finished event without a lease_fd"#]
        #[doc = r#"event."#]
        pub trait WpDrmLeaseV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_drm_lease_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wp_drm_lease_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"The client should send this to indicate that it no longer wishes to use"#]
            #[doc = r#"this lease. The compositor should use drmModeRevokeLease on the"#]
            #[doc = r#"appropriate file descriptor, if necessary."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event returns a file descriptor suitable for use with DRM-related"#]
            #[doc = r#"ioctls. The client should use drmModeGetLease to enumerate the DRM"#]
            #[doc = r#"objects which have been leased to them. The compositor guarantees it"#]
            #[doc = r#"will not use the leased DRM objects itself until it sends the finished"#]
            #[doc = r#"event. If the compositor cannot or will not grant a lease for the"#]
            #[doc = r#"requested connectors, it will not send this event, instead sending the"#]
            #[doc = r#"finished event."#]
            #[doc = r#""#]
            #[doc = r#"The compositor will send this event at most once during this objects"#]
            #[doc = r#"lifetime."#]
            async fn lease_fd(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                leased_fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_drm_lease_v1#{}.lease_fd()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_fd(leased_fd).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The compositor uses this event to either reject a lease request, or if"#]
            #[doc = r#"it previously sent a lease_fd, to notify the client that the lease has"#]
            #[doc = r#"been revoked. If the client requires a new lease, they should destroy"#]
            #[doc = r#"this object and submit a new lease request. The compositor will send"#]
            #[doc = r#"no further events for this object after sending the finish event."#]
            #[doc = r#"Compositors should revoke the lease when any of the leased resources"#]
            #[doc = r#"become unavailable, namely when a hot-unplug occurs or when the"#]
            #[doc = r#"compositor loses DRM master."#]
            async fn finished(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_drm_lease_v1#{}.finished()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = r#"The purpose of this protocol is to provide protocol object handles for"#]
#[doc = r#"toplevels, possibly originating from another client."#]
#[doc = r#""#]
#[doc = r#"This protocol is intentionally minimalistic and expects additional"#]
#[doc = r#"functionality (e.g. creating a screencopy source from a toplevel handle,"#]
#[doc = r#"getting information about the state of the toplevel) to be implemented"#]
#[doc = r#"in extension protocols."#]
#[doc = r#""#]
#[doc = r#"The compositor may choose to restrict this protocol to a special client"#]
#[doc = r#"launched by the compositor itself or expose it to all clients,"#]
#[doc = r#"this is compositor policy."#]
#[doc = r#""#]
#[doc = r#"The key words "must", "must not", "required", "shall", "shall not","#]
#[doc = r#""should", "should not", "recommended",  "may", and "optional" in this"#]
#[doc = r#"document are to be interpreted as described in IETF RFC 2119."#]
#[doc = r#""#]
#[doc = r#"Warning! The protocol described in this file is currently in the testing"#]
#[doc = r#"phase. Backward compatible changes may be added together with the"#]
#[doc = r#"corresponding interface version bump. Backward incompatible changes can"#]
#[doc = r#"only be done by creating a new major version of the extension."#]
pub mod ext_foreign_toplevel_list_v1 {
    pub mod ext_foreign_toplevel_list_v1 {
        #[doc = r#"A toplevel is defined as a surface with a role similar to xdg_toplevel."#]
        #[doc = r#"XWayland surfaces may be treated like toplevels in this protocol."#]
        #[doc = r#""#]
        #[doc = r#"After a client binds the ext_foreign_toplevel_list_v1, each mapped"#]
        #[doc = r#"toplevel window will be sent using the ext_foreign_toplevel_list_v1.toplevel"#]
        #[doc = r#"event."#]
        #[doc = r#""#]
        #[doc = r#"Clients which only care about the current state can perform a roundtrip after"#]
        #[doc = r#"binding this global."#]
        #[doc = r#""#]
        #[doc = r#"For each instance of ext_foreign_toplevel_list_v1, the compositor must"#]
        #[doc = r#"create a new ext_foreign_toplevel_handle_v1 object for each mapped toplevel."#]
        #[doc = r#""#]
        #[doc = r#"If a compositor implementation sends the ext_foreign_toplevel_list_v1.finished"#]
        #[doc = r#"event after the global is bound, the compositor must not send any"#]
        #[doc = r#"ext_foreign_toplevel_list_v1.toplevel events."#]
        pub trait ExtForeignToplevelListV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_foreign_toplevel_list_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("ext_foreign_toplevel_list_v1#{}.stop()", object.id);
                        self.stop(object, client).await
                    }
                    1 => {
                        tracing::debug!("ext_foreign_toplevel_list_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"This request indicates that the client no longer wishes to receive"#]
            #[doc = r#"events for new toplevels."#]
            #[doc = r#""#]
            #[doc = r#"The Wayland protocol is asynchronous, meaning the compositor may send"#]
            #[doc = r#"further toplevel events until the stop request is processed."#]
            #[doc = r#"The client should wait for a ext_foreign_toplevel_list_v1.finished"#]
            #[doc = r#"event before destroying this object."#]
            async fn stop(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request should be called either when the client will no longer"#]
            #[doc = r#"use the ext_foreign_toplevel_list_v1 or after the finished event"#]
            #[doc = r#"has been received to allow destruction of the object."#]
            #[doc = r#""#]
            #[doc = r#"If a client wishes to destroy this object it should send a"#]
            #[doc = r#"ext_foreign_toplevel_list_v1.stop request and wait for a ext_foreign_toplevel_list_v1.finished"#]
            #[doc = r#"event, then destroy the handles and then this object."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event is emitted whenever a new toplevel window is created. It is"#]
            #[doc = r#"emitted for all toplevels, regardless of the app that has created them."#]
            #[doc = r#""#]
            #[doc = r#"All initial properties of the toplevel (identifier, title, app_id) will be sent"#]
            #[doc = r#"immediately after this event using the corresponding events for"#]
            #[doc = r#"ext_foreign_toplevel_handle_v1. The compositor will use the"#]
            #[doc = r#"ext_foreign_toplevel_handle_v1.done event to indicate when all data has"#]
            #[doc = r#"been sent."#]
            async fn toplevel(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                toplevel: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_foreign_toplevel_list_v1#{}.toplevel()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(toplevel))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event indicates that the compositor is done sending events"#]
            #[doc = r#"to this object. The client should destroy the object."#]
            #[doc = r#"See ext_foreign_toplevel_list_v1.destroy for more information."#]
            #[doc = r#""#]
            #[doc = r#"The compositor must not send any more toplevel events after this event."#]
            async fn finished(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_foreign_toplevel_list_v1#{}.finished()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod ext_foreign_toplevel_handle_v1 {
        #[doc = r#"A ext_foreign_toplevel_handle_v1 object represents a mapped toplevel"#]
        #[doc = r#"window. A single app may have multiple mapped toplevels."#]
        pub trait ExtForeignToplevelHandleV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_foreign_toplevel_handle_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("ext_foreign_toplevel_handle_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"This request should be used when the client will no longer use the handle"#]
            #[doc = r#"or after the closed event has been received to allow destruction of the"#]
            #[doc = r#"object."#]
            #[doc = r#""#]
            #[doc = r#"When a handle is destroyed, a new handle may not be created by the server"#]
            #[doc = r#"until the toplevel is unmapped and then remapped. Destroying a toplevel handle"#]
            #[doc = r#"is not recommended unless the client is cleaning up child objects"#]
            #[doc = r#"before destroying the ext_foreign_toplevel_list_v1 object, the toplevel"#]
            #[doc = r#"was closed or the toplevel handle will not be used in the future."#]
            #[doc = r#""#]
            #[doc = r#"Other protocols which extend the ext_foreign_toplevel_handle_v1"#]
            #[doc = r#"interface should require destructors for extension interfaces be"#]
            #[doc = r#"called before allowing the toplevel handle to be destroyed."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"The server will emit no further events on the ext_foreign_toplevel_handle_v1"#]
            #[doc = r#"after this event. Any requests received aside from the destroy request must"#]
            #[doc = r#"be ignored. Upon receiving this event, the client should destroy the handle."#]
            #[doc = r#""#]
            #[doc = r#"Other protocols which extend the ext_foreign_toplevel_handle_v1"#]
            #[doc = r#"interface must also ignore requests other than destructors."#]
            async fn closed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_foreign_toplevel_handle_v1#{}.closed()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent after all changes in the toplevel state have"#]
            #[doc = r#"been sent."#]
            #[doc = r#""#]
            #[doc = r#"This allows changes to the ext_foreign_toplevel_handle_v1 properties"#]
            #[doc = r#"to be atomically applied. Other protocols which extend the"#]
            #[doc = r#"ext_foreign_toplevel_handle_v1 interface may use this event to also"#]
            #[doc = r#"atomically apply any pending state."#]
            #[doc = r#""#]
            #[doc = r#"This event must not be sent after the ext_foreign_toplevel_handle_v1.closed"#]
            #[doc = r#"event."#]
            async fn done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_foreign_toplevel_handle_v1#{}.done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The title of the toplevel has changed."#]
            #[doc = r#""#]
            #[doc = r#"The configured state must not be applied immediately. See"#]
            #[doc = r#"ext_foreign_toplevel_handle_v1.done for details."#]
            async fn title(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                title: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_foreign_toplevel_handle_v1#{}.title()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(title))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The app id of the toplevel has changed."#]
            #[doc = r#""#]
            #[doc = r#"The configured state must not be applied immediately. See"#]
            #[doc = r#"ext_foreign_toplevel_handle_v1.done for details."#]
            async fn app_id(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                app_id: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_foreign_toplevel_handle_v1#{}.app_id()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(app_id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This identifier is used to check if two or more toplevel handles belong"#]
            #[doc = r#"to the same toplevel."#]
            #[doc = r#""#]
            #[doc = r#"The identifier is useful for command line tools or privileged clients"#]
            #[doc = r#"which may need to reference an exact toplevel across processes or"#]
            #[doc = r#"instances of the ext_foreign_toplevel_list_v1 global."#]
            #[doc = r#""#]
            #[doc = r#"The compositor must only send this event when the handle is created."#]
            #[doc = r#""#]
            #[doc = r#"The identifier must be unique per toplevel and it's handles. Two different"#]
            #[doc = r#"toplevels must not have the same identifier. The identifier is only valid"#]
            #[doc = r#"as long as the toplevel is mapped. If the toplevel is unmapped the identifier"#]
            #[doc = r#"must not be reused. An identifier must not be reused by the compositor to"#]
            #[doc = r#"ensure there are no races when sharing identifiers between processes."#]
            #[doc = r#""#]
            #[doc = r#"An identifier is a string that contains up to 32 printable ASCII bytes."#]
            #[doc = r#"An identifier must not be an empty string. It is recommended that a"#]
            #[doc = r#"compositor includes an opaque generation value in identifiers. How the"#]
            #[doc = r#"generation value is used when generating the identifier is implementation"#]
            #[doc = r#"dependent."#]
            async fn identifier(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                identifier: String,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> ext_foreign_toplevel_handle_v1#{}.identifier()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(identifier))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod ext_idle_notify_v1 {
    pub mod ext_idle_notifier_v1 {
        #[doc = r#"This interface allows clients to monitor user idle status."#]
        #[doc = r#""#]
        #[doc = r#"After binding to this global, clients can create ext_idle_notification_v1"#]
        #[doc = r#"objects to get notified when the user is idle for a given amount of time."#]
        pub trait ExtIdleNotifierV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_idle_notifier_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("ext_idle_notifier_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!(
                            "ext_idle_notifier_v1#{}.get_idle_notification()",
                            object.id
                        );
                        self.get_idle_notification(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the manager object. All objects created via this interface"#]
            #[doc = r#"remain valid."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Create a new idle notification object."#]
            #[doc = r#""#]
            #[doc = r#"The notification object has a minimum timeout duration and is tied to a"#]
            #[doc = r#"seat. The client will be notified if the seat is inactive for at least"#]
            #[doc = r#"the provided timeout. See ext_idle_notification_v1 for more details."#]
            #[doc = r#""#]
            #[doc = r#"A zero timeout is valid and means the client wants to be notified as"#]
            #[doc = r#"soon as possible when the seat is inactive."#]
            async fn get_idle_notification(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_idle_notification: crate::wire::ObjectId,
                get_idle_notification: u32,
                get_idle_notification: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod ext_idle_notification_v1 {
        #[doc = r#"This interface is used by the compositor to send idle notification events"#]
        #[doc = r#"to clients."#]
        #[doc = r#""#]
        #[doc = r#"Initially the notification object is not idle. The notification object"#]
        #[doc = r#"becomes idle when no user activity has happened for at least the timeout"#]
        #[doc = r#"duration, starting from the creation of the notification object. User"#]
        #[doc = r#"activity may include input events or a presence sensor, but is"#]
        #[doc = r#"compositor-specific. If an idle inhibitor is active (e.g. another client"#]
        #[doc = r#"has created a zwp_idle_inhibitor_v1 on a visible surface), the compositor"#]
        #[doc = r#"must not make the notification object idle."#]
        #[doc = r#""#]
        #[doc = r#"When the notification object becomes idle, an idled event is sent. When"#]
        #[doc = r#"user activity starts again, the notification object stops being idle,"#]
        #[doc = r#"a resumed event is sent and the timeout is restarted."#]
        pub trait ExtIdleNotificationV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_idle_notification_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("ext_idle_notification_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the notification object."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event is sent when the notification object becomes idle."#]
            #[doc = r#""#]
            #[doc = r#"It's a compositor protocol error to send this event twice without a"#]
            #[doc = r#"resumed event in-between."#]
            async fn idled(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_idle_notification_v1#{}.idled()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent when the notification object stops being idle."#]
            #[doc = r#""#]
            #[doc = r#"It's a compositor protocol error to send this event twice without an"#]
            #[doc = r#"idled event in-between. It's a compositor protocol error to send this"#]
            #[doc = r#"event prior to any idled event."#]
            async fn resumed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_idle_notification_v1#{}.resumed()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = r#"This protocol allows for a privileged Wayland client to lock the session"#]
#[doc = r#"and display arbitrary graphics while the session is locked."#]
#[doc = r#""#]
#[doc = r#"The compositor may choose to restrict this protocol to a special client"#]
#[doc = r#"launched by the compositor itself or expose it to all privileged clients,"#]
#[doc = r#"this is compositor policy."#]
#[doc = r#""#]
#[doc = r#"The client is responsible for performing authentication and informing the"#]
#[doc = r#"compositor when the session should be unlocked. If the client dies while"#]
#[doc = r#"the session is locked the session remains locked, possibly permanently"#]
#[doc = r#"depending on compositor policy."#]
#[doc = r#""#]
#[doc = r#"The key words "must", "must not", "required", "shall", "shall not","#]
#[doc = r#""should", "should not", "recommended",  "may", and "optional" in this"#]
#[doc = r#"document are to be interpreted as described in IETF RFC 2119."#]
#[doc = r#""#]
#[doc = r#"Warning! The protocol described in this file is currently in the"#]
#[doc = r#"testing phase. Backward compatible changes may be added together with"#]
#[doc = r#"the corresponding interface version bump. Backward incompatible changes"#]
#[doc = r#"can only be done by creating a new major version of the extension."#]
pub mod ext_session_lock_v1 {
    pub mod ext_session_lock_manager_v1 {
        #[doc = r#"This interface is used to request that the session be locked."#]
        pub trait ExtSessionLockManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_session_lock_manager_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("ext_session_lock_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("ext_session_lock_manager_v1#{}.lock()", object.id);
                        self.lock(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"This informs the compositor that the session lock manager object will"#]
            #[doc = r#"no longer be used. Existing objects created through this interface"#]
            #[doc = r#"remain valid."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request creates a session lock and asks the compositor to lock the"#]
            #[doc = r#"session. The compositor will send either the ext_session_lock_v1.locked"#]
            #[doc = r#"or ext_session_lock_v1.finished event on the created object in"#]
            #[doc = r#"response to this request."#]
            async fn lock(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                lock: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod ext_session_lock_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Attempted to destroy session lock while locked"#]
            InvalidDestroy = 0,
            #[doc = r#"Unlock requested but locked event was never sent"#]
            InvalidUnlock = 1,
            #[doc = r#"Given wl_surface already has a role"#]
            Role = 2,
            #[doc = r#"Given output already has a lock surface"#]
            DuplicateOutput = 3,
            #[doc = r#"Given wl_surface has a buffer attached or committed"#]
            AlreadyConstructed = 4,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::InvalidDestroy),
                    1 => Ok(Self::InvalidUnlock),
                    2 => Ok(Self::Role),
                    3 => Ok(Self::DuplicateOutput),
                    4 => Ok(Self::AlreadyConstructed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"In response to the creation of this object the compositor must send"#]
        #[doc = r#"either the locked or finished event."#]
        #[doc = r#""#]
        #[doc = r#"The locked event indicates that the session is locked. This means"#]
        #[doc = r#"that the compositor must stop rendering and providing input to normal"#]
        #[doc = r#"clients. Instead the compositor must blank all outputs with an opaque"#]
        #[doc = r#"color such that their normal content is fully hidden."#]
        #[doc = r#""#]
        #[doc = r#"The only surfaces that should be rendered while the session is locked"#]
        #[doc = r#"are the lock surfaces created through this interface and optionally,"#]
        #[doc = r#"at the compositor's discretion, special privileged surfaces such as"#]
        #[doc = r#"input methods or portions of desktop shell UIs."#]
        #[doc = r#""#]
        #[doc = r#"The locked event must not be sent until a new "locked" frame (either"#]
        #[doc = r#"from a session lock surface or the compositor blanking the output) has"#]
        #[doc = r#"been presented on all outputs and no security sensitive normal/unlocked"#]
        #[doc = r#"content is possibly visible."#]
        #[doc = r#""#]
        #[doc = r#"The finished event should be sent immediately on creation of this"#]
        #[doc = r#"object if the compositor decides that the locked event will not be sent."#]
        #[doc = r#""#]
        #[doc = r#"The compositor may wait for the client to create and render session lock"#]
        #[doc = r#"surfaces before sending the locked event to avoid displaying intermediate"#]
        #[doc = r#"blank frames. However, it must impose a reasonable time limit if"#]
        #[doc = r#"waiting and send the locked event as soon as the hard requirements"#]
        #[doc = r#"described above can be met if the time limit expires. Clients should"#]
        #[doc = r#"immediately create lock surfaces for all outputs on creation of this"#]
        #[doc = r#"object to make this possible."#]
        #[doc = r#""#]
        #[doc = r#"This behavior of the locked event is required in order to prevent"#]
        #[doc = r#"possible race conditions with clients that wish to suspend the system"#]
        #[doc = r#"or similar after locking the session. Without these semantics, clients"#]
        #[doc = r#"triggering a suspend after receiving the locked event would race with"#]
        #[doc = r#"the first "locked" frame being presented and normal/unlocked frames"#]
        #[doc = r#"might be briefly visible as the system is resumed if the suspend"#]
        #[doc = r#"operation wins the race."#]
        #[doc = r#""#]
        #[doc = r#"If the client dies while the session is locked, the compositor must not"#]
        #[doc = r#"unlock the session in response. It is acceptable for the session to be"#]
        #[doc = r#"permanently locked if this happens. The compositor may choose to continue"#]
        #[doc = r#"to display the lock surfaces the client had mapped before it died or"#]
        #[doc = r#"alternatively fall back to a solid color, this is compositor policy."#]
        #[doc = r#""#]
        #[doc = r#"Compositors may also allow a secure way to recover the session, the"#]
        #[doc = r#"details of this are compositor policy. Compositors may allow a new"#]
        #[doc = r#"client to create a ext_session_lock_v1 object and take responsibility"#]
        #[doc = r#"for unlocking the session, they may even start a new lock client"#]
        #[doc = r#"instance automatically."#]
        pub trait ExtSessionLockV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_session_lock_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("ext_session_lock_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("ext_session_lock_v1#{}.get_lock_surface()", object.id);
                        self.get_lock_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("ext_session_lock_v1#{}.unlock_and_destroy()", object.id);
                        self.unlock_and_destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"This informs the compositor that the lock object will no longer be"#]
            #[doc = r#"used. Existing objects created through this interface remain valid."#]
            #[doc = r#""#]
            #[doc = r#"After this request is made, lock surfaces created through this object"#]
            #[doc = r#"should be destroyed by the client as they will no longer be used by"#]
            #[doc = r#"the compositor."#]
            #[doc = r#""#]
            #[doc = r#"It is a protocol error to make this request if the locked event was"#]
            #[doc = r#"sent, the unlock_and_destroy request must be used instead."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"The client is expected to create lock surfaces for all outputs"#]
            #[doc = r#"currently present and any new outputs as they are advertised. These"#]
            #[doc = r#"won't be displayed by the compositor unless the lock is successful"#]
            #[doc = r#"and the locked event is sent."#]
            #[doc = r#""#]
            #[doc = r#"Providing a wl_surface which already has a role or already has a buffer"#]
            #[doc = r#"attached or committed is a protocol error, as is attaching/committing"#]
            #[doc = r#"a buffer before the first ext_session_lock_surface_v1.configure event."#]
            #[doc = r#""#]
            #[doc = r#"Attempting to create more than one lock surface for a given output"#]
            #[doc = r#"is a duplicate_output protocol error."#]
            async fn get_lock_surface(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_lock_surface: crate::wire::ObjectId,
                get_lock_surface: crate::wire::ObjectId,
                get_lock_surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request indicates that the session should be unlocked, for"#]
            #[doc = r#"example because the user has entered their password and it has been"#]
            #[doc = r#"verified by the client."#]
            #[doc = r#""#]
            #[doc = r#"This request also informs the compositor that the lock object will"#]
            #[doc = r#"no longer be used and should be destroyed. Existing objects created"#]
            #[doc = r#"through this interface remain valid."#]
            #[doc = r#""#]
            #[doc = r#"After this request is made, lock surfaces created through this object"#]
            #[doc = r#"should be destroyed by the client as they will no longer be used by"#]
            #[doc = r#"the compositor."#]
            #[doc = r#""#]
            #[doc = r#"It is a protocol error to make this request if the locked event has"#]
            #[doc = r#"not been sent. In that case, the lock object must be destroyed using"#]
            #[doc = r#"the destroy request."#]
            #[doc = r#""#]
            #[doc = r#"Note that a correct client that wishes to exit directly after unlocking"#]
            #[doc = r#"the session must use the wl_display.sync request to ensure the server"#]
            #[doc = r#"receives and processes the unlock_and_destroy request. Otherwise"#]
            #[doc = r#"there is no guarantee that the server has unlocked the session due"#]
            #[doc = r#"to the asynchronous nature of the Wayland protocol. For example,"#]
            #[doc = r#"the server might terminate the client with a protocol error before"#]
            #[doc = r#"it processes the unlock_and_destroy request."#]
            async fn unlock_and_destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This client is now responsible for displaying graphics while the"#]
            #[doc = r#"session is locked and deciding when to unlock the session."#]
            #[doc = r#""#]
            #[doc = r#"The locked event must not be sent until a new "locked" frame has been"#]
            #[doc = r#"presented on all outputs and no security sensitive normal/unlocked"#]
            #[doc = r#"content is possibly visible."#]
            #[doc = r#""#]
            #[doc = r#"If this event is sent, making the destroy request is a protocol error,"#]
            #[doc = r#"the lock object must be destroyed using the unlock_and_destroy request."#]
            async fn locked(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_session_lock_v1#{}.locked()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The compositor has decided that the session lock should be destroyed"#]
            #[doc = r#"as it will no longer be used by the compositor. Exactly when this"#]
            #[doc = r#"event is sent is compositor policy, but it must never be sent more"#]
            #[doc = r#"than once for a given session lock object."#]
            #[doc = r#""#]
            #[doc = r#"This might be sent because there is already another ext_session_lock_v1"#]
            #[doc = r#"object held by a client, or the compositor has decided to deny the"#]
            #[doc = r#"request to lock the session for some other reason. This might also"#]
            #[doc = r#"be sent because the compositor implements some alternative, secure"#]
            #[doc = r#"way to authenticate and unlock the session."#]
            #[doc = r#""#]
            #[doc = r#"The finished event should be sent immediately on creation of this"#]
            #[doc = r#"object if the compositor decides that the locked event will not"#]
            #[doc = r#"be sent."#]
            #[doc = r#""#]
            #[doc = r#"If the locked event is sent on creation of this object the finished"#]
            #[doc = r#"event may still be sent at some later time in this object's"#]
            #[doc = r#"lifetime. This is compositor policy."#]
            #[doc = r#""#]
            #[doc = r#"Upon receiving this event, the client should make either the destroy"#]
            #[doc = r#"request or the unlock_and_destroy request, depending on whether or"#]
            #[doc = r#"not the locked event was received on this object."#]
            async fn finished(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_session_lock_v1#{}.finished()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod ext_session_lock_surface_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Surface committed before first ack_configure request"#]
            CommitBeforeFirstAck = 0,
            #[doc = r#"Surface committed with a null buffer"#]
            NullBuffer = 1,
            #[doc = r#"Failed to match ack'd width/height"#]
            DimensionsMismatch = 2,
            #[doc = r#"Serial provided in ack_configure is invalid"#]
            InvalidSerial = 3,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::CommitBeforeFirstAck),
                    1 => Ok(Self::NullBuffer),
                    2 => Ok(Self::DimensionsMismatch),
                    3 => Ok(Self::InvalidSerial),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"The client may use lock surfaces to display a screensaver, render a"#]
        #[doc = r#"dialog to enter a password and unlock the session, or however else it"#]
        #[doc = r#"sees fit."#]
        #[doc = r#""#]
        #[doc = r#"On binding this interface the compositor will immediately send the"#]
        #[doc = r#"first configure event. After making the ack_configure request in"#]
        #[doc = r#"response to this event the client should attach and commit the first"#]
        #[doc = r#"buffer. Committing the surface before acking the first configure is a"#]
        #[doc = r#"protocol error. Committing the surface with a null buffer at any time"#]
        #[doc = r#"is a protocol error."#]
        #[doc = r#""#]
        #[doc = r#"The compositor is free to handle keyboard/pointer focus for lock"#]
        #[doc = r#"surfaces however it chooses. A reasonable way to do this would be to"#]
        #[doc = r#"give the first lock surface created keyboard focus and change keyboard"#]
        #[doc = r#"focus if the user clicks on other surfaces."#]
        pub trait ExtSessionLockSurfaceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_session_lock_surface_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("ext_session_lock_surface_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!(
                            "ext_session_lock_surface_v1#{}.ack_configure()",
                            object.id
                        );
                        self.ack_configure(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"This informs the compositor that the lock surface object will no"#]
            #[doc = r#"longer be used."#]
            #[doc = r#""#]
            #[doc = r#"It is recommended for a lock client to destroy lock surfaces if"#]
            #[doc = r#"their corresponding wl_output global is removed."#]
            #[doc = r#""#]
            #[doc = r#"If a lock surface on an active output is destroyed before the"#]
            #[doc = r#"ext_session_lock_v1.unlock_and_destroy event is sent, the compositor"#]
            #[doc = r#"must fall back to rendering a solid color."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"When a configure event is received, if a client commits the surface"#]
            #[doc = r#"in response to the configure event, then the client must make an"#]
            #[doc = r#"ack_configure request sometime before the commit request, passing"#]
            #[doc = r#"along the serial of the configure event."#]
            #[doc = r#""#]
            #[doc = r#"If the client receives multiple configure events before it can"#]
            #[doc = r#"respond to one, it only has to ack the last configure event."#]
            #[doc = r#""#]
            #[doc = r#"A client is not required to commit immediately after sending an"#]
            #[doc = r#"ack_configure request - it may even ack_configure several times"#]
            #[doc = r#"before its next surface commit."#]
            #[doc = r#""#]
            #[doc = r#"A client may send multiple ack_configure requests before committing,"#]
            #[doc = r#"but only the last request sent before a commit indicates which"#]
            #[doc = r#"configure event the client really is responding to."#]
            #[doc = r#""#]
            #[doc = r#"Sending an ack_configure request consumes the configure event"#]
            #[doc = r#"referenced by the given serial, as well as all older configure events"#]
            #[doc = r#"sent on this object."#]
            #[doc = r#""#]
            #[doc = r#"It is a protocol error to issue multiple ack_configure requests"#]
            #[doc = r#"referencing the same configure event or to issue an ack_configure"#]
            #[doc = r#"request referencing a configure event older than the last configure"#]
            #[doc = r#"event acked for a given lock surface."#]
            async fn ack_configure(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                ack_configure: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event is sent once on binding the interface and may be sent again"#]
            #[doc = r#"at the compositor's discretion, for example if output geometry changes."#]
            #[doc = r#""#]
            #[doc = r#"The width and height are in surface-local coordinates and are exact"#]
            #[doc = r#"requirements. Failing to match these surface dimensions in the next"#]
            #[doc = r#"commit after acking a configure is a protocol error."#]
            async fn configure(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                width: u32,
                height: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_session_lock_surface_v1#{}.configure()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(width)
                    .put_uint(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = r#"The transient seat protocol can be used by privileged clients to create"#]
#[doc = r#"independent seats that will be removed from the compositor when the client"#]
#[doc = r#"destroys its transient seat."#]
#[doc = r#""#]
#[doc = r#"This protocol is intended for use with virtual input protocols such as"#]
#[doc = r#""virtual_keyboard_unstable_v1" or "wlr_virtual_pointer_unstable_v1", both"#]
#[doc = r#"of which allow the user to select a seat."#]
#[doc = r#""#]
#[doc = r#"The "wl_seat" global created by this protocol does not generate input events"#]
#[doc = r#"on its own, or have any capabilities except those assigned to it by other"#]
#[doc = r#"protocol extensions, such as the ones mentioned above."#]
#[doc = r#""#]
#[doc = r#"For example, a remote desktop server can create a seat with virtual inputs"#]
#[doc = r#"for each remote user by following these steps for each new connection:"#]
#[doc = r#"* Create a transient seat"#]
#[doc = r#"* Wait for the transient seat to be created"#]
#[doc = r#"* Locate a "wl_seat" global with a matching name"#]
#[doc = r#"* Create virtual inputs using the resulting "wl_seat" global"#]
pub mod ext_transient_seat_v1 {
    pub mod ext_transient_seat_manager_v1 {
        #[doc = r#"The transient seat manager creates short-lived seats."#]
        pub trait ExtTransientSeatManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_transient_seat_manager_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("ext_transient_seat_manager_v1#{}.create()", object.id);
                        self.create(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("ext_transient_seat_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Create a new seat that is removed when the client side transient seat"#]
            #[doc = r#"object is destroyed."#]
            #[doc = r#""#]
            #[doc = r#"The actual seat may be removed sooner, in which case the transient seat"#]
            #[doc = r#"object shall become inert."#]
            async fn create(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Destroy the manager."#]
            #[doc = r#""#]
            #[doc = r#"All objects created by the manager will remain valid until they are"#]
            #[doc = r#"destroyed themselves."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod ext_transient_seat_v1 {
        #[doc = r#"When the transient seat handle is destroyed, the seat itself will also be"#]
        #[doc = r#"destroyed."#]
        pub trait ExtTransientSeatV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "ext_transient_seat_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("ext_transient_seat_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"When the transient seat object is destroyed by the client, the"#]
            #[doc = r#"associated seat created by the compositor is also destroyed."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event advertises the global name for the wl_seat to be used with"#]
            #[doc = r#"wl_registry_bind."#]
            #[doc = r#""#]
            #[doc = r#"It is sent exactly once, immediately after the transient seat is created"#]
            #[doc = r#"and the new "wl_seat" global is advertised, if and only if the creation"#]
            #[doc = r#"of the transient seat was allowed."#]
            async fn ready(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                global_name: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_transient_seat_v1#{}.ready()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(global_name)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The event informs the client that the compositor denied its request to"#]
            #[doc = r#"create a transient seat."#]
            #[doc = r#""#]
            #[doc = r#"It is sent exactly once, immediately after the transient seat object is"#]
            #[doc = r#"created, if and only if the creation of the transient seat was denied."#]
            #[doc = r#""#]
            #[doc = r#"After receiving this event, the client should destroy the object."#]
            async fn denied(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> ext_transient_seat_v1#{}.denied()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = r#"This protocol allows a compositor to suggest for surfaces to render at"#]
#[doc = r#"fractional scales."#]
#[doc = r#""#]
#[doc = r#"A client can submit scaled content by utilizing wp_viewport. This is done by"#]
#[doc = r#"creating a wp_viewport object for the surface and setting the destination"#]
#[doc = r#"rectangle to the surface size before the scale factor is applied."#]
#[doc = r#""#]
#[doc = r#"The buffer size is calculated by multiplying the surface size by the"#]
#[doc = r#"intended scale."#]
#[doc = r#""#]
#[doc = r#"The wl_surface buffer scale should remain set to 1."#]
#[doc = r#""#]
#[doc = r#"If a surface has a surface-local size of 100 px by 50 px and wishes to"#]
#[doc = r#"submit buffers with a scale of 1.5, then a buffer of 150px by 75 px should"#]
#[doc = r#"be used and the wp_viewport destination rectangle should be 100 px by 50 px."#]
#[doc = r#""#]
#[doc = r#"For toplevel surfaces, the size is rounded halfway away from zero. The"#]
#[doc = r#"rounding algorithm for subsurface position and size is not defined."#]
pub mod fractional_scale_v1 {
    pub mod wp_fractional_scale_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"The surface already has a fractional_scale object associated"#]
            FractionalScaleExists = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::FractionalScaleExists),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"A global interface for requesting surfaces to use fractional scales."#]
        pub trait WpFractionalScaleManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_fractional_scale_manager_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wp_fractional_scale_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!(
                            "wp_fractional_scale_manager_v1#{}.get_fractional_scale()",
                            object.id
                        );
                        self.get_fractional_scale(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Informs the server that the client will not be using this protocol"#]
            #[doc = r#"object anymore. This does not affect any other objects,"#]
            #[doc = r#"wp_fractional_scale_v1 objects included."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Create an add-on object for the the wl_surface to let the compositor"#]
            #[doc = r#"request fractional scales. If the given wl_surface already has a"#]
            #[doc = r#"wp_fractional_scale_v1 object associated, the fractional_scale_exists"#]
            #[doc = r#"protocol error is raised."#]
            async fn get_fractional_scale(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_fractional_scale: crate::wire::ObjectId,
                get_fractional_scale: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wp_fractional_scale_v1 {
        #[doc = r#"An additional interface to a wl_surface object which allows the compositor"#]
        #[doc = r#"to inform the client of the preferred scale."#]
        pub trait WpFractionalScaleV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_fractional_scale_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wp_fractional_scale_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the fractional scale object. When this object is destroyed,"#]
            #[doc = r#"preferred_scale events will no longer be sent."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Notification of a new preferred scale for this surface that the"#]
            #[doc = r#"compositor suggests that the client should use."#]
            #[doc = r#""#]
            #[doc = r#"The sent scale is the numerator of a fraction with a denominator of 120."#]
            async fn preferred_scale(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                scale: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> wp_fractional_scale_v1#{}.preferred_scale()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(scale).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = r#"This protocol allows clients to request explicit synchronization for"#]
#[doc = r#"buffers. It is tied to the Linux DRM synchronization object framework."#]
#[doc = r#""#]
#[doc = r#"Synchronization refers to co-ordination of pipelined operations performed"#]
#[doc = r#"on buffers. Most GPU clients will schedule an asynchronous operation to"#]
#[doc = r#"render to the buffer, then immediately send the buffer to the compositor"#]
#[doc = r#"to be attached to a surface."#]
#[doc = r#""#]
#[doc = r#"With implicit synchronization, ensuring that the rendering operation is"#]
#[doc = r#"complete before the compositor displays the buffer is an implementation"#]
#[doc = r#"detail handled by either the kernel or userspace graphics driver."#]
#[doc = r#""#]
#[doc = r#"By contrast, with explicit synchronization, DRM synchronization object"#]
#[doc = r#"timeline points mark when the asynchronous operations are complete. When"#]
#[doc = r#"submitting a buffer, the client provides a timeline point which will be"#]
#[doc = r#"waited on before the compositor accesses the buffer, and another timeline"#]
#[doc = r#"point that the compositor will signal when it no longer needs to access the"#]
#[doc = r#"buffer contents for the purposes of the surface commit."#]
#[doc = r#""#]
#[doc = r#"Linux DRM synchronization objects are documented at:"#]
#[doc = r#"https://dri.freedesktop.org/docs/drm/gpu/drm-mm.html#drm-sync-objects"#]
#[doc = r#""#]
#[doc = r#"Warning! The protocol described in this file is currently in the testing"#]
#[doc = r#"phase. Backward compatible changes may be added together with the"#]
#[doc = r#"corresponding interface version bump. Backward incompatible changes can"#]
#[doc = r#"only be done by creating a new major version of the extension."#]
pub mod linux_drm_syncobj_v1 {
    pub mod wp_linux_drm_syncobj_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"The surface already has a synchronization object associated"#]
            SurfaceExists = 0,
            #[doc = r#"The timeline object could not be imported"#]
            InvalidTimeline = 1,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::SurfaceExists),
                    1 => Ok(Self::InvalidTimeline),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"This global is a factory interface, allowing clients to request"#]
        #[doc = r#"explicit synchronization for buffers on a per-surface basis."#]
        #[doc = r#""#]
        #[doc = r#"See wp_linux_drm_syncobj_surface_v1 for more information."#]
        pub trait WpLinuxDrmSyncobjManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_linux_drm_syncobj_manager_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wp_linux_drm_syncobj_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!(
                            "wp_linux_drm_syncobj_manager_v1#{}.get_surface()",
                            object.id
                        );
                        self.get_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!(
                            "wp_linux_drm_syncobj_manager_v1#{}.import_timeline()",
                            object.id
                        );
                        self.import_timeline(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.fd()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy this explicit synchronization factory object. Other objects"#]
            #[doc = r#"shall not be affected by this request."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Instantiate an interface extension for the given wl_surface to provide"#]
            #[doc = r#"explicit synchronization."#]
            #[doc = r#""#]
            #[doc = r#"If the given wl_surface already has an explicit synchronization object"#]
            #[doc = r#"associated, the surface_exists protocol error is raised."#]
            #[doc = r#""#]
            #[doc = r#"Graphics APIs, like EGL or Vulkan, that manage the buffer queue and"#]
            #[doc = r#"commits of a wl_surface themselves, are likely to be using this"#]
            #[doc = r#"extension internally. If a client is using such an API for a"#]
            #[doc = r#"wl_surface, it should not directly use this extension on that surface,"#]
            #[doc = r#"to avoid raising a surface_exists protocol error."#]
            async fn get_surface(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_surface: crate::wire::ObjectId,
                get_surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Import a DRM synchronization object timeline."#]
            #[doc = r#""#]
            #[doc = r#"If the FD cannot be imported, the invalid_timeline error is raised."#]
            async fn import_timeline(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                import_timeline: crate::wire::ObjectId,
                import_timeline: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wp_linux_drm_syncobj_timeline_v1 {
        #[doc = r#"This object represents an explicit synchronization object timeline"#]
        #[doc = r#"imported by the client to the compositor."#]
        pub trait WpLinuxDrmSyncobjTimelineV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_linux_drm_syncobj_timeline_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wp_linux_drm_syncobj_timeline_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the synchronization object timeline. Other objects are not"#]
            #[doc = r#"affected by this request, in particular timeline points set by"#]
            #[doc = r#"set_acquire_point and set_release_point are not unset."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wp_linux_drm_syncobj_surface_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"The associated wl_surface was destroyed"#]
            NoSurface = 1,
            #[doc = r#"The buffer does not support explicit synchronization"#]
            UnsupportedBuffer = 2,
            #[doc = r#"No buffer was attached"#]
            NoBuffer = 3,
            #[doc = r#"No acquire timeline point was set"#]
            NoAcquirePoint = 4,
            #[doc = r#"No release timeline point was set"#]
            NoReleasePoint = 5,
            #[doc = r#"Acquire and release timeline points are in conflict"#]
            ConflictingPoints = 6,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::NoSurface),
                    2 => Ok(Self::UnsupportedBuffer),
                    3 => Ok(Self::NoBuffer),
                    4 => Ok(Self::NoAcquirePoint),
                    5 => Ok(Self::NoReleasePoint),
                    6 => Ok(Self::ConflictingPoints),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"This object is an add-on interface for wl_surface to enable explicit"#]
        #[doc = r#"synchronization."#]
        #[doc = r#""#]
        #[doc = r#"Each surface can be associated with only one object of this interface at"#]
        #[doc = r#"any time."#]
        #[doc = r#""#]
        #[doc = r#"Explicit synchronization is guaranteed to be supported for buffers"#]
        #[doc = r#"created with any version of the linux-dmabuf protocol. Compositors are"#]
        #[doc = r#"free to support explicit synchronization for additional buffer types."#]
        #[doc = r#"If at surface commit time the attached buffer does not support explicit"#]
        #[doc = r#"synchronization, an unsupported_buffer error is raised."#]
        #[doc = r#""#]
        #[doc = r#"As long as the wp_linux_drm_syncobj_surface_v1 object is alive, the"#]
        #[doc = r#"compositor may ignore implicit synchronization for buffers attached and"#]
        #[doc = r#"committed to the wl_surface. The delivery of wl_buffer.release events"#]
        #[doc = r#"for buffers attached to the surface becomes undefined."#]
        #[doc = r#""#]
        #[doc = r#"Clients must set both acquire and release points if and only if a"#]
        #[doc = r#"non-null buffer is attached in the same surface commit. See the"#]
        #[doc = r#"no_buffer, no_acquire_point and no_release_point protocol errors."#]
        #[doc = r#""#]
        #[doc = r#"If at surface commit time the acquire and release DRM syncobj timelines"#]
        #[doc = r#"are identical, the acquire point value must be strictly less than the"#]
        #[doc = r#"release point value, or else the conflicting_points protocol error is"#]
        #[doc = r#"raised."#]
        pub trait WpLinuxDrmSyncobjSurfaceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_linux_drm_syncobj_surface_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wp_linux_drm_syncobj_surface_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!(
                            "wp_linux_drm_syncobj_surface_v1#{}.set_acquire_point()",
                            object.id
                        );
                        self.set_acquire_point(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!(
                            "wp_linux_drm_syncobj_surface_v1#{}.set_release_point()",
                            object.id
                        );
                        self.set_release_point(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy this surface synchronization object."#]
            #[doc = r#""#]
            #[doc = r#"Any timeline point set by this object with set_acquire_point or"#]
            #[doc = r#"set_release_point since the last commit may be discarded by the"#]
            #[doc = r#"compositor. Any timeline point set by this object before the last"#]
            #[doc = r#"commit will not be affected."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set the timeline point that must be signalled before the compositor may"#]
            #[doc = r#"sample from the buffer attached with wl_surface.attach."#]
            #[doc = r#""#]
            #[doc = r#"The 64-bit unsigned value combined from point_hi and point_lo is the"#]
            #[doc = r#"point value."#]
            #[doc = r#""#]
            #[doc = r#"The acquire point is double-buffered state, and will be applied on the"#]
            #[doc = r#"next wl_surface.commit request for the associated surface. Thus, it"#]
            #[doc = r#"applies only to the buffer that is attached to the surface at commit"#]
            #[doc = r#"time."#]
            #[doc = r#""#]
            #[doc = r#"If an acquire point has already been attached during the same commit"#]
            #[doc = r#"cycle, the new point replaces the old one."#]
            #[doc = r#""#]
            #[doc = r#"If the associated wl_surface was destroyed, a no_surface error is"#]
            #[doc = r#"raised."#]
            #[doc = r#""#]
            #[doc = r#"If at surface commit time there is a pending acquire timeline point set"#]
            #[doc = r#"but no pending buffer attached, a no_buffer error is raised. If at"#]
            #[doc = r#"surface commit time there is a pending buffer attached but no pending"#]
            #[doc = r#"acquire timeline point set, the no_acquire_point protocol error is"#]
            #[doc = r#"raised."#]
            async fn set_acquire_point(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_acquire_point: crate::wire::ObjectId,
                set_acquire_point: u32,
                set_acquire_point: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set the timeline point that must be signalled by the compositor when it"#]
            #[doc = r#"has finished its usage of the buffer attached with wl_surface.attach"#]
            #[doc = r#"for the relevant commit."#]
            #[doc = r#""#]
            #[doc = r#"Once the timeline point is signaled, and assuming the associated buffer"#]
            #[doc = r#"is not pending release from other wl_surface.commit requests, no"#]
            #[doc = r#"additional explicit or implicit synchronization with the compositor is"#]
            #[doc = r#"required to safely re-use the buffer."#]
            #[doc = r#""#]
            #[doc = r#"Note that clients cannot rely on the release point being always"#]
            #[doc = r#"signaled after the acquire point: compositors may release buffers"#]
            #[doc = r#"without ever reading from them. In addition, the compositor may use"#]
            #[doc = r#"different presentation paths for different commits, which may have"#]
            #[doc = r#"different release behavior. As a result, the compositor may signal the"#]
            #[doc = r#"release points in a different order than the client committed them."#]
            #[doc = r#""#]
            #[doc = r#"Because signaling a timeline point also signals every previous point,"#]
            #[doc = r#"it is generally not safe to use the same timeline object for the"#]
            #[doc = r#"release points of multiple buffers. The out-of-order signaling"#]
            #[doc = r#"described above may lead to a release point being signaled before the"#]
            #[doc = r#"compositor has finished reading. To avoid this, it is strongly"#]
            #[doc = r#"recommended that each buffer should use a separate timeline for its"#]
            #[doc = r#"release points."#]
            #[doc = r#""#]
            #[doc = r#"The 64-bit unsigned value combined from point_hi and point_lo is the"#]
            #[doc = r#"point value."#]
            #[doc = r#""#]
            #[doc = r#"The release point is double-buffered state, and will be applied on the"#]
            #[doc = r#"next wl_surface.commit request for the associated surface. Thus, it"#]
            #[doc = r#"applies only to the buffer that is attached to the surface at commit"#]
            #[doc = r#"time."#]
            #[doc = r#""#]
            #[doc = r#"If a release point has already been attached during the same commit"#]
            #[doc = r#"cycle, the new point replaces the old one."#]
            #[doc = r#""#]
            #[doc = r#"If the associated wl_surface was destroyed, a no_surface error is"#]
            #[doc = r#"raised."#]
            #[doc = r#""#]
            #[doc = r#"If at surface commit time there is a pending release timeline point set"#]
            #[doc = r#"but no pending buffer attached, a no_buffer error is raised. If at"#]
            #[doc = r#"surface commit time there is a pending buffer attached but no pending"#]
            #[doc = r#"release timeline point set, the no_release_point protocol error is"#]
            #[doc = r#"raised."#]
            async fn set_release_point(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_release_point: crate::wire::ObjectId,
                set_release_point: u32,
                set_release_point: u32,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod security_context_v1 {
    pub mod wp_security_context_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Listening socket FD is invalid"#]
            InvalidListenFd = 1,
            #[doc = r#"Nested security contexts are forbidden"#]
            Nested = 2,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::InvalidListenFd),
                    2 => Ok(Self::Nested),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"This interface allows a client to register a new Wayland connection to"#]
        #[doc = r#"the compositor and attach a security context to it."#]
        #[doc = r#""#]
        #[doc = r#"This is intended to be used by sandboxes. Sandbox engines attach a"#]
        #[doc = r#"security context to all connections coming from inside the sandbox. The"#]
        #[doc = r#"compositor can then restrict the features that the sandboxed connections"#]
        #[doc = r#"can use."#]
        #[doc = r#""#]
        #[doc = r#"Compositors should forbid nesting multiple security contexts by not"#]
        #[doc = r#"exposing wp_security_context_manager_v1 global to clients with a security"#]
        #[doc = r#"context attached, or by sending the nested protocol error. Nested"#]
        #[doc = r#"security contexts are dangerous because they can potentially allow"#]
        #[doc = r#"privilege escalation of a sandboxed client."#]
        #[doc = r#""#]
        #[doc = r#"Warning! The protocol described in this file is currently in the testing"#]
        #[doc = r#"phase. Backward compatible changes may be added together with the"#]
        #[doc = r#"corresponding interface version bump. Backward incompatible changes can"#]
        #[doc = r#"only be done by creating a new major version of the extension."#]
        pub trait WpSecurityContextManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_security_context_manager_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wp_security_context_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!(
                            "wp_security_context_manager_v1#{}.create_listener()",
                            object.id
                        );
                        self.create_listener(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.fd()?,
                            message.fd()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the manager. This doesn't destroy objects created with the"#]
            #[doc = r#"manager."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Creates a new security context with a socket listening FD."#]
            #[doc = r#""#]
            #[doc = r#"The compositor will accept new client connections on listen_fd."#]
            #[doc = r#"listen_fd must be ready to accept new connections when this request is"#]
            #[doc = r#"sent by the client. In other words, the client must call bind(2) and"#]
            #[doc = r#"listen(2) before sending the FD."#]
            #[doc = r#""#]
            #[doc = r#"close_fd is a FD closed by the client when the compositor should stop"#]
            #[doc = r#"accepting new connections on listen_fd."#]
            #[doc = r#""#]
            #[doc = r#"The compositor must continue to accept connections on listen_fd when"#]
            #[doc = r#"the Wayland client which created the security context disconnects."#]
            #[doc = r#""#]
            #[doc = r#"After sending this request, closing listen_fd and close_fd remains the"#]
            #[doc = r#"only valid operation on them."#]
            async fn create_listener(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create_listener: crate::wire::ObjectId,
                create_listener: rustix::fd::OwnedFd,
                create_listener: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wp_security_context_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Security context has already been committed"#]
            AlreadyUsed = 1,
            #[doc = r#"Metadata has already been set"#]
            AlreadySet = 2,
            #[doc = r#"Metadata is invalid"#]
            InvalidMetadata = 3,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::AlreadyUsed),
                    2 => Ok(Self::AlreadySet),
                    3 => Ok(Self::InvalidMetadata),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"The security context allows a client to register a new client and attach"#]
        #[doc = r#"security context metadata to the connections."#]
        #[doc = r#""#]
        #[doc = r#"When both are set, the combination of the application ID and the sandbox"#]
        #[doc = r#"engine must uniquely identify an application. The same application ID"#]
        #[doc = r#"will be used across instances (e.g. if the application is restarted, or"#]
        #[doc = r#"if the application is started multiple times)."#]
        #[doc = r#""#]
        #[doc = r#"When both are set, the combination of the instance ID and the sandbox"#]
        #[doc = r#"engine must uniquely identify a running instance of an application."#]
        pub trait WpSecurityContextV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_security_context_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wp_security_context_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!(
                            "wp_security_context_v1#{}.set_sandbox_engine()",
                            object.id
                        );
                        self.set_sandbox_engine(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("wp_security_context_v1#{}.set_app_id()", object.id);
                        self.set_app_id(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3 => {
                        tracing::debug!("wp_security_context_v1#{}.set_instance_id()", object.id);
                        self.set_instance_id(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    4 => {
                        tracing::debug!("wp_security_context_v1#{}.commit()", object.id);
                        self.commit(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the security context object."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Attach a unique sandbox engine name to the security context. The name"#]
            #[doc = r#"should follow the reverse-DNS style (e.g. "org.flatpak")."#]
            #[doc = r#""#]
            #[doc = r#"A list of well-known engines is maintained at:"#]
            #[doc = r#"https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/security-context/engines.md"#]
            #[doc = r#""#]
            #[doc = r#"It is a protocol error to call this request twice. The already_set"#]
            #[doc = r#"error is sent in this case."#]
            async fn set_sandbox_engine(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_sandbox_engine: String,
            ) -> crate::server::Result<()>;
            #[doc = r#"Attach an application ID to the security context."#]
            #[doc = r#""#]
            #[doc = r#"The application ID is an opaque, sandbox-specific identifier for an"#]
            #[doc = r#"application. See the well-known engines document for more details:"#]
            #[doc = r#"https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/security-context/engines.md"#]
            #[doc = r#""#]
            #[doc = r#"The compositor may use the application ID to group clients belonging to"#]
            #[doc = r#"the same security context application."#]
            #[doc = r#""#]
            #[doc = r#"Whether this request is optional or not depends on the sandbox engine used."#]
            #[doc = r#""#]
            #[doc = r#"It is a protocol error to call this request twice. The already_set"#]
            #[doc = r#"error is sent in this case."#]
            async fn set_app_id(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_app_id: String,
            ) -> crate::server::Result<()>;
            #[doc = r#"Attach an instance ID to the security context."#]
            #[doc = r#""#]
            #[doc = r#"The instance ID is an opaque, sandbox-specific identifier for a running"#]
            #[doc = r#"instance of an application. See the well-known engines document for"#]
            #[doc = r#"more details:"#]
            #[doc = r#"https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/security-context/engines.md"#]
            #[doc = r#""#]
            #[doc = r#"Whether this request is optional or not depends on the sandbox engine used."#]
            #[doc = r#""#]
            #[doc = r#"It is a protocol error to call this request twice. The already_set"#]
            #[doc = r#"error is sent in this case."#]
            async fn set_instance_id(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_instance_id: String,
            ) -> crate::server::Result<()>;
            #[doc = r#"Atomically register the new client and attach the security context"#]
            #[doc = r#"metadata."#]
            #[doc = r#""#]
            #[doc = r#"If the provided metadata is inconsistent or does not match with out of"#]
            #[doc = r#"band metadata (see"#]
            #[doc = r#"https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/security-context/engines.md),"#]
            #[doc = r#"the invalid_metadata error may be sent eventually."#]
            #[doc = r#""#]
            #[doc = r#"It's a protocol error to send any request other than "destroy" after"#]
            #[doc = r#"this request. In this case, the already_used error is sent."#]
            async fn commit(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
#[doc = r#"This protocol extension allows clients to create single-pixel buffers."#]
#[doc = r#""#]
#[doc = r#"Compositors supporting this protocol extension should also support the"#]
#[doc = r#"viewporter protocol extension. Clients may use viewporter to scale a"#]
#[doc = r#"single-pixel buffer to a desired size."#]
#[doc = r#""#]
#[doc = r#"Warning! The protocol described in this file is currently in the testing"#]
#[doc = r#"phase. Backward compatible changes may be added together with the"#]
#[doc = r#"corresponding interface version bump. Backward incompatible changes can"#]
#[doc = r#"only be done by creating a new major version of the extension."#]
pub mod single_pixel_buffer_v1 {
    pub mod wp_single_pixel_buffer_manager_v1 {
        #[doc = r#"The wp_single_pixel_buffer_manager_v1 interface is a factory for"#]
        #[doc = r#"single-pixel buffers."#]
        pub trait WpSinglePixelBufferManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_single_pixel_buffer_manager_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "wp_single_pixel_buffer_manager_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!(
                            "wp_single_pixel_buffer_manager_v1#{}.create_u32_rgba_buffer()",
                            object.id
                        );
                        self.create_u32_rgba_buffer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the wp_single_pixel_buffer_manager_v1 object."#]
            #[doc = r#""#]
            #[doc = r#"The child objects created via this interface are unaffected."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Create a single-pixel buffer from four 32-bit RGBA values."#]
            #[doc = r#""#]
            #[doc = r#"Unless specified in another protocol extension, the RGBA values use"#]
            #[doc = r#"pre-multiplied alpha."#]
            #[doc = r#""#]
            #[doc = r#"The width and height of the buffer are 1."#]
            async fn create_u32_rgba_buffer(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create_u32_rgba_buffer: crate::wire::ObjectId,
                create_u32_rgba_buffer: u32,
                create_u32_rgba_buffer: u32,
                create_u32_rgba_buffer: u32,
                create_u32_rgba_buffer: u32,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod tearing_control_v1 {
    pub mod wp_tearing_control_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"The surface already has a tearing object associated"#]
            TearingControlExists = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::TearingControlExists),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"For some use cases like games or drawing tablets it can make sense to"#]
        #[doc = r#"reduce latency by accepting tearing with the use of asynchronous page"#]
        #[doc = r#"flips. This global is a factory interface, allowing clients to inform"#]
        #[doc = r#"which type of presentation the content of their surfaces is suitable for."#]
        #[doc = r#""#]
        #[doc = r#"Graphics APIs like EGL or Vulkan, that manage the buffer queue and commits"#]
        #[doc = r#"of a wl_surface themselves, are likely to be using this extension"#]
        #[doc = r#"internally. If a client is using such an API for a wl_surface, it should"#]
        #[doc = r#"not directly use this extension on that surface, to avoid raising a"#]
        #[doc = r#"tearing_control_exists protocol error."#]
        #[doc = r#""#]
        #[doc = r#"Warning! The protocol described in this file is currently in the testing"#]
        #[doc = r#"phase. Backward compatible changes may be added together with the"#]
        #[doc = r#"corresponding interface version bump. Backward incompatible changes can"#]
        #[doc = r#"only be done by creating a new major version of the extension."#]
        pub trait WpTearingControlManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_tearing_control_manager_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("wp_tearing_control_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!(
                            "wp_tearing_control_manager_v1#{}.get_tearing_control()",
                            object.id
                        );
                        self.get_tearing_control(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy this tearing control factory object. Other objects, including"#]
            #[doc = r#"wp_tearing_control_v1 objects created by this factory, are not affected"#]
            #[doc = r#"by this request."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Instantiate an interface extension for the given wl_surface to request"#]
            #[doc = r#"asynchronous page flips for presentation."#]
            #[doc = r#""#]
            #[doc = r#"If the given wl_surface already has a wp_tearing_control_v1 object"#]
            #[doc = r#"associated, the tearing_control_exists protocol error is raised."#]
            async fn get_tearing_control(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_tearing_control: crate::wire::ObjectId,
                get_tearing_control: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod wp_tearing_control_v1 {
        #[doc = r#"This enum provides information for if submitted frames from the client"#]
        #[doc = r#"may be presented with tearing."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum PresentationHint {
            Vsync = 0,
            Async = 1,
        }
        impl TryFrom<u32> for PresentationHint {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Vsync),
                    1 => Ok(Self::Async),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"An additional interface to a wl_surface object, which allows the client"#]
        #[doc = r#"to hint to the compositor if the content on the surface is suitable for"#]
        #[doc = r#"presentation with tearing."#]
        #[doc = r#"The default presentation hint is vsync. See presentation_hint for more"#]
        #[doc = r#"details."#]
        pub trait WpTearingControlV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "wp_tearing_control_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "wp_tearing_control_v1#{}.set_presentation_hint()",
                            object.id
                        );
                        self.set_presentation_hint(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    1 => {
                        tracing::debug!("wp_tearing_control_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Set the presentation hint for the associated wl_surface. This state is"#]
            #[doc = r#"double-buffered and is applied on the next wl_surface.commit."#]
            #[doc = r#""#]
            #[doc = r#"The compositor is free to dynamically respect or ignore this hint based"#]
            #[doc = r#"on various conditions like hardware capabilities, surface state and"#]
            #[doc = r#"user preferences."#]
            async fn set_presentation_hint(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_presentation_hint: PresentationHint,
            ) -> crate::server::Result<()>;
            #[doc = r#"Destroy this surface tearing object and revert the presentation hint to"#]
            #[doc = r#"vsync. The change will be applied on the next wl_surface.commit."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
#[doc = r#"The way for a client to pass focus to another toplevel is as follows."#]
#[doc = r#""#]
#[doc = r#"The client that intends to activate another toplevel uses the"#]
#[doc = r#"xdg_activation_v1.get_activation_token request to get an activation token."#]
#[doc = r#"This token is then forwarded to the client, which is supposed to activate"#]
#[doc = r#"one of its surfaces, through a separate band of communication."#]
#[doc = r#""#]
#[doc = r#"One established way of doing this is through the XDG_ACTIVATION_TOKEN"#]
#[doc = r#"environment variable of a newly launched child process. The child process"#]
#[doc = r#"should unset the environment variable again right after reading it out in"#]
#[doc = r#"order to avoid propagating it to other child processes."#]
#[doc = r#""#]
#[doc = r#"Another established way exists for Applications implementing the D-Bus"#]
#[doc = r#"interface org.freedesktop.Application, which should get their token under"#]
#[doc = r#"activation-token on their platform_data."#]
#[doc = r#""#]
#[doc = r#"In general activation tokens may be transferred across clients through"#]
#[doc = r#"means not described in this protocol."#]
#[doc = r#""#]
#[doc = r#"The client to be activated will then pass the token"#]
#[doc = r#"it received to the xdg_activation_v1.activate request. The compositor can"#]
#[doc = r#"then use this token to decide how to react to the activation request."#]
#[doc = r#""#]
#[doc = r#"The token the activating client gets may be ineffective either already at"#]
#[doc = r#"the time it receives it, for example if it was not focused, for focus"#]
#[doc = r#"stealing prevention. The activating client will have no way to discover"#]
#[doc = r#"the validity of the token, and may still forward it to the to be activated"#]
#[doc = r#"client."#]
#[doc = r#""#]
#[doc = r#"The created activation token may optionally get information attached to it"#]
#[doc = r#"that can be used by the compositor to identify the application that we"#]
#[doc = r#"intend to activate. This can for example be used to display a visual hint"#]
#[doc = r#"about what application is being started."#]
#[doc = r#""#]
#[doc = r#"Warning! The protocol described in this file is currently in the testing"#]
#[doc = r#"phase. Backward compatible changes may be added together with the"#]
#[doc = r#"corresponding interface version bump. Backward incompatible changes can"#]
#[doc = r#"only be done by creating a new major version of the extension."#]
pub mod xdg_activation_v1 {
    pub mod xdg_activation_v1 {
        #[doc = r#"A global interface used for informing the compositor about applications"#]
        #[doc = r#"being activated or started, or for applications to request to be"#]
        #[doc = r#"activated."#]
        pub trait XdgActivationV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_activation_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("xdg_activation_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("xdg_activation_v1#{}.get_activation_token()", object.id);
                        self.get_activation_token(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("xdg_activation_v1#{}.activate()", object.id);
                        self.activate(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Notify the compositor that the xdg_activation object will no longer be"#]
            #[doc = r#"used."#]
            #[doc = r#""#]
            #[doc = r#"The child objects created via this interface are unaffected and should"#]
            #[doc = r#"be destroyed separately."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Creates an xdg_activation_token_v1 object that will provide"#]
            #[doc = r#"the initiating client with a unique token for this activation. This"#]
            #[doc = r#"token should be offered to the clients to be activated."#]
            async fn get_activation_token(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_activation_token: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Requests surface activation. It's up to the compositor to display"#]
            #[doc = r#"this information as desired, for example by placing the surface above"#]
            #[doc = r#"the rest."#]
            #[doc = r#""#]
            #[doc = r#"The compositor may know who requested this by checking the activation"#]
            #[doc = r#"token and might decide not to follow through with the activation if it's"#]
            #[doc = r#"considered unwanted."#]
            #[doc = r#""#]
            #[doc = r#"Compositors can ignore unknown activation tokens when an invalid"#]
            #[doc = r#"token is passed."#]
            async fn activate(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                activate: String,
                activate: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod xdg_activation_token_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"The token has already been used previously"#]
            AlreadyUsed = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::AlreadyUsed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"An object for setting up a token and receiving a token handle that can"#]
        #[doc = r#"be passed as an activation token to another client."#]
        #[doc = r#""#]
        #[doc = r#"The object is created using the xdg_activation_v1.get_activation_token"#]
        #[doc = r#"request. This object should then be populated with the app_id, surface"#]
        #[doc = r#"and serial information and committed. The compositor shall then issue a"#]
        #[doc = r#"done event with the token. In case the request's parameters are invalid,"#]
        #[doc = r#"the compositor will provide an invalid token."#]
        pub trait XdgActivationTokenV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_activation_token_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("xdg_activation_token_v1#{}.set_serial()", object.id);
                        self.set_serial(
                            object,
                            client,
                            message.uint()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("xdg_activation_token_v1#{}.set_app_id()", object.id);
                        self.set_app_id(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("xdg_activation_token_v1#{}.set_surface()", object.id);
                        self.set_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3 => {
                        tracing::debug!("xdg_activation_token_v1#{}.commit()", object.id);
                        self.commit(object, client).await
                    }
                    4 => {
                        tracing::debug!("xdg_activation_token_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Provides information about the seat and serial event that requested the"#]
            #[doc = r#"token."#]
            #[doc = r#""#]
            #[doc = r#"The serial can come from an input or focus event. For instance, if a"#]
            #[doc = r#"click triggers the launch of a third-party client, the launcher client"#]
            #[doc = r#"should send a set_serial request with the serial and seat from the"#]
            #[doc = r#"wl_pointer.button event."#]
            #[doc = r#""#]
            #[doc = r#"Some compositors might refuse to activate toplevels when the token"#]
            #[doc = r#"doesn't have a valid and recent enough event serial."#]
            #[doc = r#""#]
            #[doc = r#"Must be sent before commit. This information is optional."#]
            async fn set_serial(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_serial: u32,
                set_serial: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"The requesting client can specify an app_id to associate the token"#]
            #[doc = r#"being created with it."#]
            #[doc = r#""#]
            #[doc = r#"Must be sent before commit. This information is optional."#]
            async fn set_app_id(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_app_id: String,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request sets the surface requesting the activation. Note, this is"#]
            #[doc = r#"different from the surface that will be activated."#]
            #[doc = r#""#]
            #[doc = r#"Some compositors might refuse to activate toplevels when the token"#]
            #[doc = r#"doesn't have a requesting surface."#]
            #[doc = r#""#]
            #[doc = r#"Must be sent before commit. This information is optional."#]
            async fn set_surface(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Requests an activation token based on the different parameters that"#]
            #[doc = r#"have been offered through set_serial, set_surface and set_app_id."#]
            async fn commit(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Notify the compositor that the xdg_activation_token_v1 object will no"#]
            #[doc = r#"longer be used. The received token stays valid."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"The 'done' event contains the unique token of this activation request"#]
            #[doc = r#"and notifies that the provider is done."#]
            async fn done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                token: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_activation_token_v1#{}.done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(token))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod xdg_dialog_v1 {
    pub mod xdg_wm_dialog_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"The xdg_toplevel object has already been used to create a xdg_dialog_v1"#]
            AlreadyUsed = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::AlreadyUsed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"The xdg_wm_dialog_v1 interface is exposed as a global object allowing"#]
        #[doc = r#"to register surfaces with a xdg_toplevel role as "dialogs" relative to"#]
        #[doc = r#"another toplevel."#]
        #[doc = r#""#]
        #[doc = r#"The compositor may let this relation influence how the surface is"#]
        #[doc = r#"placed, displayed or interacted with."#]
        #[doc = r#""#]
        #[doc = r#"Warning! The protocol described in this file is currently in the testing"#]
        #[doc = r#"phase. Backward compatible changes may be added together with the"#]
        #[doc = r#"corresponding interface version bump. Backward incompatible changes can"#]
        #[doc = r#"only be done by creating a new major version of the extension."#]
        pub trait XdgWmDialogV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_wm_dialog_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("xdg_wm_dialog_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("xdg_wm_dialog_v1#{}.get_xdg_dialog()", object.id);
                        self.get_xdg_dialog(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroys the xdg_wm_dialog_v1 object. This does not affect"#]
            #[doc = r#"the xdg_dialog_v1 objects generated through it."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Creates a xdg_dialog_v1 object for the given toplevel. See the interface"#]
            #[doc = r#"description for more details."#]
            #[doc = r#""#]
            #[doc = r#"Compositors must raise an already_used error if clients attempt to"#]
            #[doc = r#"create multiple xdg_dialog_v1 objects for the same xdg_toplevel."#]
            async fn get_xdg_dialog(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_xdg_dialog: crate::wire::ObjectId,
                get_xdg_dialog: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod xdg_dialog_v1 {
        #[doc = r#"A xdg_dialog_v1 object is an ancillary object tied to a xdg_toplevel. Its"#]
        #[doc = r#"purpose is hinting the compositor that the toplevel is a "dialog" (e.g. a"#]
        #[doc = r#"temporary window) relative to another toplevel (see"#]
        #[doc = r#"xdg_toplevel.set_parent). If the xdg_toplevel is destroyed, the xdg_dialog_v1"#]
        #[doc = r#"becomes inert."#]
        #[doc = r#""#]
        #[doc = r#"Through this object, the client may provide additional hints about"#]
        #[doc = r#"the purpose of the secondary toplevel. This interface has no effect"#]
        #[doc = r#"on toplevels that are not attached to a parent toplevel."#]
        pub trait XdgDialogV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_dialog_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("xdg_dialog_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("xdg_dialog_v1#{}.set_modal()", object.id);
                        self.set_modal(object, client).await
                    }
                    2 => {
                        tracing::debug!("xdg_dialog_v1#{}.unset_modal()", object.id);
                        self.unset_modal(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroys the xdg_dialog_v1 object. If this object is destroyed"#]
            #[doc = r#"before the related xdg_toplevel, the compositor should unapply its"#]
            #[doc = r#"effects."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Hints that the dialog has "modal" behavior. Modal dialogs typically"#]
            #[doc = r#"require to be fully addressed by the user (i.e. closed) before resuming"#]
            #[doc = r#"interaction with the parent toplevel, and may require a distinct"#]
            #[doc = r#"presentation."#]
            #[doc = r#""#]
            #[doc = r#"Clients must implement the logic to filter events in the parent"#]
            #[doc = r#"toplevel on their own."#]
            #[doc = r#""#]
            #[doc = r#"Compositors may choose any policy in event delivery to the parent"#]
            #[doc = r#"toplevel, from delivering all events unfiltered to using them for"#]
            #[doc = r#"internal consumption."#]
            async fn set_modal(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Drops the hint that this dialog has "modal" behavior. See"#]
            #[doc = r#"xdg_dialog_v1.set_modal for more details."#]
            async fn unset_modal(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod xdg_toplevel_drag_v1 {
    pub mod xdg_toplevel_drag_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Data_source already used for toplevel drag"#]
            InvalidSource = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::InvalidSource),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"This protocol enhances normal drag and drop with the ability to move a"#]
        #[doc = r#"window at the same time. This allows having detachable parts of a window"#]
        #[doc = r#"that when dragged out of it become a new window and can be dragged over"#]
        #[doc = r#"an existing window to be reattached."#]
        #[doc = r#""#]
        #[doc = r#"A typical workflow would be when the user starts dragging on top of a"#]
        #[doc = r#"detachable part of a window, the client would create a wl_data_source and"#]
        #[doc = r#"a xdg_toplevel_drag_v1 object and start the drag as normal via"#]
        #[doc = r#"wl_data_device.start_drag. Once the client determines that the detachable"#]
        #[doc = r#"window contents should be detached from the originating window, it creates"#]
        #[doc = r#"a new xdg_toplevel with these contents and issues a"#]
        #[doc = r#"xdg_toplevel_drag_v1.attach request before mapping it. From now on the new"#]
        #[doc = r#"window is moved by the compositor during the drag as if the client called"#]
        #[doc = r#"xdg_toplevel.move."#]
        #[doc = r#""#]
        #[doc = r#"Dragging an existing window is similar. The client creates a"#]
        #[doc = r#"xdg_toplevel_drag_v1 object and attaches the existing toplevel before"#]
        #[doc = r#"starting the drag."#]
        #[doc = r#""#]
        #[doc = r#"Clients use the existing drag and drop mechanism to detect when a window"#]
        #[doc = r#"can be docked or undocked. If the client wants to snap a window into a"#]
        #[doc = r#"parent window it should delete or unmap the dragged top-level. If the"#]
        #[doc = r#"contents should be detached again it attaches a new toplevel as described"#]
        #[doc = r#"above. If a drag operation is cancelled without being dropped, clients"#]
        #[doc = r#"should revert to the previous state, deleting any newly created windows"#]
        #[doc = r#"as appropriate. When a drag operation ends as indicated by"#]
        #[doc = r#"wl_data_source.dnd_drop_performed the dragged toplevel window's final"#]
        #[doc = r#"position is determined as if a xdg_toplevel_move operation ended."#]
        #[doc = r#""#]
        #[doc = r#"Warning! The protocol described in this file is currently in the testing"#]
        #[doc = r#"phase. Backward compatible changes may be added together with the"#]
        #[doc = r#"corresponding interface version bump. Backward incompatible changes can"#]
        #[doc = r#"only be done by creating a new major version of the extension."#]
        pub trait XdgToplevelDragManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_toplevel_drag_manager_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("xdg_toplevel_drag_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!(
                            "xdg_toplevel_drag_manager_v1#{}.get_xdg_toplevel_drag()",
                            object.id
                        );
                        self.get_xdg_toplevel_drag(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy this xdg_toplevel_drag_manager_v1 object. Other objects,"#]
            #[doc = r#"including xdg_toplevel_drag_v1 objects created by this factory, are not"#]
            #[doc = r#"affected by this request."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Create an xdg_toplevel_drag for a drag and drop operation that is going"#]
            #[doc = r#"to be started with data_source."#]
            #[doc = r#""#]
            #[doc = r#"This request can only be made on sources used in drag-and-drop, so it"#]
            #[doc = r#"must be performed before wl_data_device.start_drag. Attempting to use"#]
            #[doc = r#"the source other than for drag-and-drop such as in"#]
            #[doc = r#"wl_data_device.set_selection will raise an invalid_source error."#]
            #[doc = r#""#]
            #[doc = r#"Destroying data_source while a toplevel is attached to the"#]
            #[doc = r#"xdg_toplevel_drag is undefined."#]
            async fn get_xdg_toplevel_drag(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_xdg_toplevel_drag: crate::wire::ObjectId,
                get_xdg_toplevel_drag: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod xdg_toplevel_drag_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Valid toplevel already attached"#]
            ToplevelAttached = 0,
            #[doc = r#"Drag has not ended"#]
            OngoingDrag = 1,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::ToplevelAttached),
                    1 => Ok(Self::OngoingDrag),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        pub trait XdgToplevelDragV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_toplevel_drag_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("xdg_toplevel_drag_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("xdg_toplevel_drag_v1#{}.attach()", object.id);
                        self.attach(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy this xdg_toplevel_drag_v1 object. This request must only be"#]
            #[doc = r#"called after the underlying wl_data_source drag has ended, as indicated"#]
            #[doc = r#"by the dnd_drop_performed or cancelled events. In any other case an"#]
            #[doc = r#"ongoing_drag error is raised."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Request that the window will be moved with the cursor during the drag"#]
            #[doc = r#"operation. The offset is a hint to the compositor how the toplevel"#]
            #[doc = r#"should be positioned relative to the cursor hotspot in surface local"#]
            #[doc = r#"coordinates. For example it might only be used when an unmapped window"#]
            #[doc = r#"is attached. The attached window does not participate in the selection"#]
            #[doc = r#"of the drag target."#]
            #[doc = r#""#]
            #[doc = r#"If the toplevel is unmapped while it is attached, it is automatically"#]
            #[doc = r#"detached from the drag. In this case this request has to be called again"#]
            #[doc = r#"if the window should be attached after it is remapped."#]
            #[doc = r#""#]
            #[doc = r#"This request can be called multiple times but issuing it while a"#]
            #[doc = r#"toplevel with an active role is attached raises a toplevel_attached"#]
            #[doc = r#"error."#]
            async fn attach(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                attach: crate::wire::ObjectId,
                attach: i32,
                attach: i32,
            ) -> crate::server::Result<()>;
        }
    }
}
#[doc = r#"This protocol adds a xwayland_surface role which allows an Xwayland"#]
#[doc = r#"server to associate an X11 window to a wl_surface."#]
#[doc = r#""#]
#[doc = r#"Before this protocol, this would be done via the Xwayland server"#]
#[doc = r#"providing the wl_surface's resource id via the a client message with"#]
#[doc = r#"the WL_SURFACE_ID atom on the X window."#]
#[doc = r#"This was problematic as a race could occur if the wl_surface"#]
#[doc = r#"associated with a WL_SURFACE_ID for a window was destroyed before the"#]
#[doc = r#"client message was processed by the compositor and another surface"#]
#[doc = r#"(or other object) had taken its id due to recycling."#]
#[doc = r#""#]
#[doc = r#"This protocol solves the problem by moving the X11 window to wl_surface"#]
#[doc = r#"association step to the Wayland side, which means that the association"#]
#[doc = r#"cannot happen out-of-sync with the resource lifetime of the wl_surface."#]
#[doc = r#""#]
#[doc = r#"This protocol avoids duplicating the race on the other side by adding a"#]
#[doc = r#"non-zero monotonic serial number which is entirely unique that is set on"#]
#[doc = r#"both the wl_surface (via. xwayland_surface_v1's set_serial method) and"#]
#[doc = r#"the X11 window (via. the `WL_SURFACE_SERIAL` client message) that can be"#]
#[doc = r#"used to associate them, and synchronize the two timelines."#]
#[doc = r#""#]
#[doc = r#"The key words "must", "must not", "required", "shall", "shall not","#]
#[doc = r#""should", "should not", "recommended",  "may", and "optional" in this"#]
#[doc = r#"document are to be interpreted as described in IETF RFC 2119."#]
#[doc = r#""#]
#[doc = r#"Warning! The protocol described in this file is currently in the testing"#]
#[doc = r#"phase. Backward compatible changes may be added together with the"#]
#[doc = r#"corresponding interface version bump. Backward incompatible changes can"#]
#[doc = r#"only be done by creating a new major version of the extension."#]
pub mod xwayland_shell_v1 {
    pub mod xwayland_shell_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Given wl_surface has another role"#]
            Role = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Role),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"xwayland_shell_v1 is a singleton global object that"#]
        #[doc = r#"provides the ability to create a xwayland_surface_v1 object"#]
        #[doc = r#"for a given wl_surface."#]
        #[doc = r#""#]
        #[doc = r#"This interface is intended to be bound by the Xwayland server."#]
        #[doc = r#""#]
        #[doc = r#"A compositor must not allow clients other than Xwayland to"#]
        #[doc = r#"bind to this interface. A compositor should hide this global"#]
        #[doc = r#"from other clients' wl_registry."#]
        #[doc = r#"A client the compositor does not consider to be an Xwayland"#]
        #[doc = r#"server attempting to bind this interface will result in"#]
        #[doc = r#"an implementation-defined error."#]
        #[doc = r#""#]
        #[doc = r#"An Xwayland server that has bound this interface must not"#]
        #[doc = r#"set the `WL_SURFACE_ID` atom on a window."#]
        pub trait XwaylandShellV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xwayland_shell_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("xwayland_shell_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("xwayland_shell_v1#{}.get_xwayland_surface()", object.id);
                        self.get_xwayland_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the xwayland_shell_v1 object."#]
            #[doc = r#""#]
            #[doc = r#"The child objects created via this interface are unaffected."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Create an xwayland_surface_v1 interface for a given wl_surface"#]
            #[doc = r#"object and gives it the xwayland_surface role."#]
            #[doc = r#""#]
            #[doc = r#"It is illegal to create an xwayland_surface_v1 for a wl_surface"#]
            #[doc = r#"which already has an assigned role and this will result in the"#]
            #[doc = r#"`role` protocol error."#]
            #[doc = r#""#]
            #[doc = r#"See the documentation of xwayland_surface_v1 for more details"#]
            #[doc = r#"about what an xwayland_surface_v1 is and how it is used."#]
            async fn get_xwayland_surface(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_xwayland_surface: crate::wire::ObjectId,
                get_xwayland_surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod xwayland_surface_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Given wl_surface is already associated with an X11 window"#]
            AlreadyAssociated = 0,
            #[doc = r#"Serial was not valid"#]
            InvalidSerial = 1,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::AlreadyAssociated),
                    1 => Ok(Self::InvalidSerial),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"An Xwayland surface is a surface managed by an Xwayland server."#]
        #[doc = r#"It is used for associating surfaces to Xwayland windows."#]
        #[doc = r#""#]
        #[doc = r#"The Xwayland server associated with actions in this interface is"#]
        #[doc = r#"determined by the Wayland client making the request."#]
        #[doc = r#""#]
        #[doc = r#"The client must call wl_surface.commit on the corresponding wl_surface"#]
        #[doc = r#"for the xwayland_surface_v1 state to take effect."#]
        pub trait XwaylandSurfaceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xwayland_surface_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("xwayland_surface_v1#{}.set_serial()", object.id);
                        self.set_serial(object, client, message.uint()?, message.uint()?)
                            .await
                    }
                    1 => {
                        tracing::debug!("xwayland_surface_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Associates an Xwayland window to a wl_surface."#]
            #[doc = r#"The association state is double-buffered and will be applied at"#]
            #[doc = r#"the time wl_surface.commit of the corresponding wl_surface is called."#]
            #[doc = r#""#]
            #[doc = r#"The `serial_lo` and `serial_hi` parameters specify a non-zero"#]
            #[doc = r#"monotonic serial number which is entirely unique and provided by the"#]
            #[doc = r#"Xwayland server equal to the serial value provided by a client message"#]
            #[doc = r#"with a message type of the `WL_SURFACE_SERIAL` atom on the X11 window"#]
            #[doc = r#"for this surface to be associated to."#]
            #[doc = r#""#]
            #[doc = r#"The serial value in the `WL_SURFACE_SERIAL` client message is specified"#]
            #[doc = r#"as having the lo-bits specified in `l[0]` and the hi-bits specified"#]
            #[doc = r#"in `l[1]`."#]
            #[doc = r#""#]
            #[doc = r#"If the serial value provided by `serial_lo` and `serial_hi` is not"#]
            #[doc = r#"valid, the `invalid_serial` protocol error will be raised."#]
            #[doc = r#""#]
            #[doc = r#"An X11 window may be associated with multiple surfaces throughout its"#]
            #[doc = r#"lifespan. (eg. unmapping and remapping a window)."#]
            #[doc = r#""#]
            #[doc = r#"For each wl_surface, this state must not be committed more than once,"#]
            #[doc = r#"otherwise the `already_associated` protocol error will be raised."#]
            async fn set_serial(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_serial: u32,
                set_serial: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Destroy the xwayland_surface_v1 object."#]
            #[doc = r#""#]
            #[doc = r#"Any already existing associations are unaffected by this action."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod fullscreen_shell_unstable_v1 {
    pub mod zwp_fullscreen_shell_v1 {
        #[doc = r#"Various capabilities that can be advertised by the compositor.  They"#]
        #[doc = r#"are advertised one-at-a-time when the wl_fullscreen_shell interface is"#]
        #[doc = r#"bound.  See the wl_fullscreen_shell.capability event for more details."#]
        #[doc = r#""#]
        #[doc = r#"ARBITRARY_MODES:"#]
        #[doc = r#"This is a hint to the client that indicates that the compositor is"#]
        #[doc = r#"capable of setting practically any mode on its outputs.  If this"#]
        #[doc = r#"capability is provided, wl_fullscreen_shell.present_surface_for_mode"#]
        #[doc = r#"will almost never fail and clients should feel free to set whatever"#]
        #[doc = r#"mode they like.  If the compositor does not advertise this, it may"#]
        #[doc = r#"still support some modes that are not advertised through wl_global.mode"#]
        #[doc = r#"but it is less likely."#]
        #[doc = r#""#]
        #[doc = r#"CURSOR_PLANE:"#]
        #[doc = r#"This is a hint to the client that indicates that the compositor can"#]
        #[doc = r#"handle a cursor surface from the client without actually compositing."#]
        #[doc = r#"This may be because of a hardware cursor plane or some other mechanism."#]
        #[doc = r#"If the compositor does not advertise this capability then setting"#]
        #[doc = r#"wl_pointer.cursor may degrade performance or be ignored entirely.  If"#]
        #[doc = r#"CURSOR_PLANE is not advertised, it is recommended that the client draw"#]
        #[doc = r#"its own cursor and set wl_pointer.cursor(NULL)."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Capability {
            #[doc = r#"Compositor is capable of almost any output mode"#]
            ArbitraryModes = 1,
            #[doc = r#"Compositor has a separate cursor plane"#]
            CursorPlane = 2,
        }
        impl TryFrom<u32> for Capability {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::ArbitraryModes),
                    2 => Ok(Self::CursorPlane),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"Hints to indicate to the compositor how to deal with a conflict"#]
        #[doc = r#"between the dimensions of the surface and the dimensions of the"#]
        #[doc = r#"output. The compositor is free to ignore this parameter."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum PresentMethod {
            #[doc = r#"No preference, apply default policy"#]
            Default = 0,
            #[doc = r#"Center the surface on the output"#]
            Center = 1,
            #[doc = r#"Scale the surface, preserving aspect ratio, to the largest size that will fit on the output"#]
            Zoom = 2,
            #[doc = r#"Scale the surface, preserving aspect ratio, to fully fill the output cropping if needed"#]
            ZoomCrop = 3,
            #[doc = r#"Scale the surface to the size of the output ignoring aspect ratio"#]
            Stretch = 4,
        }
        impl TryFrom<u32> for PresentMethod {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Default),
                    1 => Ok(Self::Center),
                    2 => Ok(Self::Zoom),
                    3 => Ok(Self::ZoomCrop),
                    4 => Ok(Self::Stretch),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"These errors can be emitted in response to wl_fullscreen_shell requests."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Present_method is not known"#]
            InvalidMethod = 0,
            #[doc = r#"Given wl_surface has another role"#]
            Role = 1,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::InvalidMethod),
                    1 => Ok(Self::Role),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"Displays a single surface per output."#]
        #[doc = r#""#]
        #[doc = r#"This interface provides a mechanism for a single client to display"#]
        #[doc = r#"simple full-screen surfaces.  While there technically may be multiple"#]
        #[doc = r#"clients bound to this interface, only one of those clients should be"#]
        #[doc = r#"shown at a time."#]
        #[doc = r#""#]
        #[doc = r#"To present a surface, the client uses either the present_surface or"#]
        #[doc = r#"present_surface_for_mode requests.  Presenting a surface takes effect"#]
        #[doc = r#"on the next wl_surface.commit.  See the individual requests for"#]
        #[doc = r#"details about scaling and mode switches."#]
        #[doc = r#""#]
        #[doc = r#"The client can have at most one surface per output at any time."#]
        #[doc = r#"Requesting a surface to be presented on an output that already has a"#]
        #[doc = r#"surface replaces the previously presented surface.  Presenting a null"#]
        #[doc = r#"surface removes its content and effectively disables the output."#]
        #[doc = r#"Exactly what happens when an output is "disabled" is"#]
        #[doc = r#"compositor-specific.  The same surface may be presented on multiple"#]
        #[doc = r#"outputs simultaneously."#]
        #[doc = r#""#]
        #[doc = r#"Once a surface is presented on an output, it stays on that output"#]
        #[doc = r#"until either the client removes it or the compositor destroys the"#]
        #[doc = r#"output.  This way, the client can update the output's contents by"#]
        #[doc = r#"simply attaching a new buffer."#]
        #[doc = r#""#]
        #[doc = r#"Warning! The protocol described in this file is experimental and"#]
        #[doc = r#"backward incompatible changes may be made. Backward compatible changes"#]
        #[doc = r#"may be added together with the corresponding interface version bump."#]
        #[doc = r#"Backward incompatible changes are done by bumping the version number in"#]
        #[doc = r#"the protocol and interface names and resetting the interface version."#]
        #[doc = r#"Once the protocol is to be declared stable, the 'z' prefix and the"#]
        #[doc = r#"version number in the protocol and interface names are removed and the"#]
        #[doc = r#"interface version number is reset."#]
        pub trait ZwpFullscreenShellV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_fullscreen_shell_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_fullscreen_shell_v1#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    1 => {
                        tracing::debug!("zwp_fullscreen_shell_v1#{}.present_surface()", object.id);
                        self.present_surface(
                            object,
                            client,
                            message.object()?,
                            message.uint()?.try_into()?,
                            message.object()?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!(
                            "zwp_fullscreen_shell_v1#{}.present_surface_for_mode()",
                            object.id
                        );
                        self.present_surface_for_mode(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Release the binding from the wl_fullscreen_shell interface."#]
            #[doc = r#""#]
            #[doc = r#"This destroys the server-side object and frees this binding.  If"#]
            #[doc = r#"the client binds to wl_fullscreen_shell multiple times, it may wish"#]
            #[doc = r#"to free some of those bindings."#]
            async fn release(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Present a surface on the given output."#]
            #[doc = r#""#]
            #[doc = r#"If the output is null, the compositor will present the surface on"#]
            #[doc = r#"whatever display (or displays) it thinks best.  In particular, this"#]
            #[doc = r#"may replace any or all surfaces currently presented so it should"#]
            #[doc = r#"not be used in combination with placing surfaces on specific"#]
            #[doc = r#"outputs."#]
            #[doc = r#""#]
            #[doc = r#"The method parameter is a hint to the compositor for how the surface"#]
            #[doc = r#"is to be presented.  In particular, it tells the compositor how to"#]
            #[doc = r#"handle a size mismatch between the presented surface and the"#]
            #[doc = r#"output.  The compositor is free to ignore this parameter."#]
            #[doc = r#""#]
            #[doc = r#"The "zoom", "zoom_crop", and "stretch" methods imply a scaling"#]
            #[doc = r#"operation on the surface.  This will override any kind of output"#]
            #[doc = r#"scaling, so the buffer_scale property of the surface is effectively"#]
            #[doc = r#"ignored."#]
            #[doc = r#""#]
            #[doc = r#"This request gives the surface the role of a fullscreen shell surface."#]
            #[doc = r#"If the surface already has another role, it raises a role protocol"#]
            #[doc = r#"error."#]
            async fn present_surface(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                present_surface: Option<crate::wire::ObjectId>,
                present_surface: PresentMethod,
                present_surface: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = r#"Presents a surface on the given output for a particular mode."#]
            #[doc = r#""#]
            #[doc = r#"If the current size of the output differs from that of the surface,"#]
            #[doc = r#"the compositor will attempt to change the size of the output to"#]
            #[doc = r#"match the surface.  The result of the mode-switch operation will be"#]
            #[doc = r#"returned via the provided wl_fullscreen_shell_mode_feedback object."#]
            #[doc = r#""#]
            #[doc = r#"If the current output mode matches the one requested or if the"#]
            #[doc = r#"compositor successfully switches the mode to match the surface,"#]
            #[doc = r#"then the mode_successful event will be sent and the output will"#]
            #[doc = r#"contain the contents of the given surface.  If the compositor"#]
            #[doc = r#"cannot match the output size to the surface size, the mode_failed"#]
            #[doc = r#"will be sent and the output will contain the contents of the"#]
            #[doc = r#"previously presented surface (if any).  If another surface is"#]
            #[doc = r#"presented on the given output before either of these has a chance"#]
            #[doc = r#"to happen, the present_cancelled event will be sent."#]
            #[doc = r#""#]
            #[doc = r#"Due to race conditions and other issues unknown to the client, no"#]
            #[doc = r#"mode-switch operation is guaranteed to succeed.  However, if the"#]
            #[doc = r#"mode is one advertised by wl_output.mode or if the compositor"#]
            #[doc = r#"advertises the ARBITRARY_MODES capability, then the client should"#]
            #[doc = r#"expect that the mode-switch operation will usually succeed."#]
            #[doc = r#""#]
            #[doc = r#"If the size of the presented surface changes, the resulting output"#]
            #[doc = r#"is undefined.  The compositor may attempt to change the output mode"#]
            #[doc = r#"to compensate.  However, there is no guarantee that a suitable mode"#]
            #[doc = r#"will be found and the client has no way to be notified of success"#]
            #[doc = r#"or failure."#]
            #[doc = r#""#]
            #[doc = r#"The framerate parameter specifies the desired framerate for the"#]
            #[doc = r#"output in mHz.  The compositor is free to ignore this parameter.  A"#]
            #[doc = r#"value of 0 indicates that the client has no preference."#]
            #[doc = r#""#]
            #[doc = r#"If the value of wl_output.scale differs from wl_surface.buffer_scale,"#]
            #[doc = r#"then the compositor may choose a mode that matches either the buffer"#]
            #[doc = r#"size or the surface size.  In either case, the surface will fill the"#]
            #[doc = r#"output."#]
            #[doc = r#""#]
            #[doc = r#"This request gives the surface the role of a fullscreen shell surface."#]
            #[doc = r#"If the surface already has another role, it raises a role protocol"#]
            #[doc = r#"error."#]
            async fn present_surface_for_mode(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                present_surface_for_mode: crate::wire::ObjectId,
                present_surface_for_mode: crate::wire::ObjectId,
                present_surface_for_mode: i32,
                present_surface_for_mode: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Advertises a single capability of the compositor."#]
            #[doc = r#""#]
            #[doc = r#"When the wl_fullscreen_shell interface is bound, this event is emitted"#]
            #[doc = r#"once for each capability advertised.  Valid capabilities are given by"#]
            #[doc = r#"the wl_fullscreen_shell.capability enum.  If clients want to take"#]
            #[doc = r#"advantage of any of these capabilities, they should use a"#]
            #[doc = r#"wl_display.sync request immediately after binding to ensure that they"#]
            #[doc = r#"receive all the capability events."#]
            async fn capability(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                capability: Capability,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_fullscreen_shell_v1#{}.capability()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(capability as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_fullscreen_shell_mode_feedback_v1 {
        pub trait ZwpFullscreenShellModeFeedbackV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_fullscreen_shell_mode_feedback_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"This event indicates that the attempted mode switch operation was"#]
            #[doc = r#"successful.  A surface of the size requested in the mode switch"#]
            #[doc = r#"will fill the output without scaling."#]
            #[doc = r#""#]
            #[doc = r#"Upon receiving this event, the client should destroy the"#]
            #[doc = r#"wl_fullscreen_shell_mode_feedback object."#]
            async fn mode_successful(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_fullscreen_shell_mode_feedback_v1#{}.mode_successful()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event indicates that the attempted mode switch operation"#]
            #[doc = r#"failed.  This may be because the requested output mode is not"#]
            #[doc = r#"possible or it may mean that the compositor does not want to allow it."#]
            #[doc = r#""#]
            #[doc = r#"Upon receiving this event, the client should destroy the"#]
            #[doc = r#"wl_fullscreen_shell_mode_feedback object."#]
            async fn mode_failed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_fullscreen_shell_mode_feedback_v1#{}.mode_failed()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event indicates that the attempted mode switch operation was"#]
            #[doc = r#"cancelled.  Most likely this is because the client requested a"#]
            #[doc = r#"second mode switch before the first one completed."#]
            #[doc = r#""#]
            #[doc = r#"Upon receiving this event, the client should destroy the"#]
            #[doc = r#"wl_fullscreen_shell_mode_feedback object."#]
            async fn present_cancelled(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_fullscreen_shell_mode_feedback_v1#{}.present_cancelled()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod idle_inhibit_unstable_v1 {
    pub mod zwp_idle_inhibit_manager_v1 {
        #[doc = r#"This interface permits inhibiting the idle behavior such as screen"#]
        #[doc = r#"blanking, locking, and screensaving.  The client binds the idle manager"#]
        #[doc = r#"globally, then creates idle-inhibitor objects for each surface."#]
        #[doc = r#""#]
        #[doc = r#"Warning! The protocol described in this file is experimental and"#]
        #[doc = r#"backward incompatible changes may be made. Backward compatible changes"#]
        #[doc = r#"may be added together with the corresponding interface version bump."#]
        #[doc = r#"Backward incompatible changes are done by bumping the version number in"#]
        #[doc = r#"the protocol and interface names and resetting the interface version."#]
        #[doc = r#"Once the protocol is to be declared stable, the 'z' prefix and the"#]
        #[doc = r#"version number in the protocol and interface names are removed and the"#]
        #[doc = r#"interface version number is reset."#]
        pub trait ZwpIdleInhibitManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_idle_inhibit_manager_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_idle_inhibit_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!(
                            "zwp_idle_inhibit_manager_v1#{}.create_inhibitor()",
                            object.id
                        );
                        self.create_inhibitor(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the inhibit manager."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Create a new inhibitor object associated with the given surface."#]
            async fn create_inhibitor(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create_inhibitor: crate::wire::ObjectId,
                create_inhibitor: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_idle_inhibitor_v1 {
        #[doc = r#"An idle inhibitor prevents the output that the associated surface is"#]
        #[doc = r#"visible on from being set to a state where it is not visually usable due"#]
        #[doc = r#"to lack of user interaction (e.g. blanked, dimmed, locked, set to power"#]
        #[doc = r#"save, etc.)  Any screensaver processes are also blocked from displaying."#]
        #[doc = r#""#]
        #[doc = r#"If the surface is destroyed, unmapped, becomes occluded, loses"#]
        #[doc = r#"visibility, or otherwise becomes not visually relevant for the user, the"#]
        #[doc = r#"idle inhibitor will not be honored by the compositor; if the surface"#]
        #[doc = r#"subsequently regains visibility the inhibitor takes effect once again."#]
        #[doc = r#"Likewise, the inhibitor isn't honored if the system was already idled at"#]
        #[doc = r#"the time the inhibitor was established, although if the system later"#]
        #[doc = r#"de-idles and re-idles the inhibitor will take effect."#]
        pub trait ZwpIdleInhibitorV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_idle_inhibitor_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_idle_inhibitor_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Remove the inhibitor effect from the associated wl_surface."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod input_method_unstable_v1 {
    pub mod zwp_input_method_context_v1 {
        #[doc = r#"Corresponds to a text input on the input method side. An input method context"#]
        #[doc = r#"is created on text input activation on the input method side. It allows"#]
        #[doc = r#"receiving information about the text input from the application via events."#]
        #[doc = r#"Input method contexts do not keep state after deactivation and should be"#]
        #[doc = r#"destroyed after deactivation is handled."#]
        #[doc = r#""#]
        #[doc = r#"Text is generally UTF-8 encoded, indices and lengths are in bytes."#]
        #[doc = r#""#]
        #[doc = r#"Serials are used to synchronize the state between the text input and"#]
        #[doc = r#"an input method. New serials are sent by the text input in the"#]
        #[doc = r#"commit_state request and are used by the input method to indicate"#]
        #[doc = r#"the known text input state in events like preedit_string, commit_string,"#]
        #[doc = r#"and keysym. The text input can then ignore events from the input method"#]
        #[doc = r#"which are based on an outdated state (for example after a reset)."#]
        #[doc = r#""#]
        #[doc = r#"Warning! The protocol described in this file is experimental and"#]
        #[doc = r#"backward incompatible changes may be made. Backward compatible changes"#]
        #[doc = r#"may be added together with the corresponding interface version bump."#]
        #[doc = r#"Backward incompatible changes are done by bumping the version number in"#]
        #[doc = r#"the protocol and interface names and resetting the interface version."#]
        #[doc = r#"Once the protocol is to be declared stable, the 'z' prefix and the"#]
        #[doc = r#"version number in the protocol and interface names are removed and the"#]
        #[doc = r#"interface version number is reset."#]
        pub trait ZwpInputMethodContextV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_input_method_context_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_input_method_context_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.commit_string()",
                            object.id
                        );
                        self.commit_string(
                            object,
                            client,
                            message.uint()?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.preedit_string()",
                            object.id
                        );
                        self.preedit_string(
                            object,
                            client,
                            message.uint()?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.preedit_styling()",
                            object.id
                        );
                        self.preedit_styling(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    4 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.preedit_cursor()",
                            object.id
                        );
                        self.preedit_cursor(object, client, message.int()?).await
                    }
                    5 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.delete_surrounding_text()",
                            object.id
                        );
                        self.delete_surrounding_text(
                            object,
                            client,
                            message.int()?,
                            message.uint()?,
                        )
                        .await
                    }
                    6 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.cursor_position()",
                            object.id
                        );
                        self.cursor_position(object, client, message.int()?, message.int()?)
                            .await
                    }
                    7 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.modifiers_map()",
                            object.id
                        );
                        self.modifiers_map(object, client, message.array()?).await
                    }
                    8 => {
                        tracing::debug!("zwp_input_method_context_v1#{}.keysym()", object.id);
                        self.keysym(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    9 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.grab_keyboard()",
                            object.id
                        );
                        self.grab_keyboard(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    10 => {
                        tracing::debug!("zwp_input_method_context_v1#{}.key()", object.id);
                        self.key(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    11 => {
                        tracing::debug!("zwp_input_method_context_v1#{}.modifiers()", object.id);
                        self.modifiers(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    12 => {
                        tracing::debug!("zwp_input_method_context_v1#{}.language()", object.id);
                        self.language(
                            object,
                            client,
                            message.uint()?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    13 => {
                        tracing::debug!(
                            "zwp_input_method_context_v1#{}.text_direction()",
                            object.id
                        );
                        self.text_direction(object, client, message.uint()?, message.uint()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Send the commit string text for insertion to the application."#]
            #[doc = r#""#]
            #[doc = r#"The text to commit could be either just a single character after a key"#]
            #[doc = r#"press or the result of some composing (pre-edit). It could be also an"#]
            #[doc = r#"empty text when some text should be removed (see"#]
            #[doc = r#"delete_surrounding_text) or when the input cursor should be moved (see"#]
            #[doc = r#"cursor_position)."#]
            #[doc = r#""#]
            #[doc = r#"Any previously set composing text will be removed."#]
            async fn commit_string(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                commit_string: u32,
                commit_string: String,
            ) -> crate::server::Result<()>;
            #[doc = r#"Send the pre-edit string text to the application text input."#]
            #[doc = r#""#]
            #[doc = r#"The commit text can be used to replace the pre-edit text on reset (for"#]
            #[doc = r#"example on unfocus)."#]
            #[doc = r#""#]
            #[doc = r#"Previously sent preedit_style and preedit_cursor requests are also"#]
            #[doc = r#"processed by the text_input."#]
            async fn preedit_string(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                preedit_string: u32,
                preedit_string: String,
                preedit_string: String,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set the styling information on composing text. The style is applied for"#]
            #[doc = r#"length in bytes from index relative to the beginning of"#]
            #[doc = r#"the composing text (as byte offset). Multiple styles can"#]
            #[doc = r#"be applied to a composing text."#]
            #[doc = r#""#]
            #[doc = r#"This request should be sent before sending a preedit_string request."#]
            async fn preedit_styling(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                preedit_styling: u32,
                preedit_styling: u32,
                preedit_styling: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set the cursor position inside the composing text (as byte offset)"#]
            #[doc = r#"relative to the start of the composing text."#]
            #[doc = r#""#]
            #[doc = r#"When index is negative no cursor should be displayed."#]
            #[doc = r#""#]
            #[doc = r#"This request should be sent before sending a preedit_string request."#]
            async fn preedit_cursor(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                preedit_cursor: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Remove the surrounding text."#]
            #[doc = r#""#]
            #[doc = r#"This request will be handled on the text_input side directly following"#]
            #[doc = r#"a commit_string request."#]
            async fn delete_surrounding_text(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                delete_surrounding_text: i32,
                delete_surrounding_text: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set the cursor and anchor to a new position. Index is the new cursor"#]
            #[doc = r#"position in bytes (when >= 0 this is relative to the end of the inserted text,"#]
            #[doc = r#"otherwise it is relative to the beginning of the inserted text). Anchor is"#]
            #[doc = r#"the new anchor position in bytes (when >= 0 this is relative to the end of the"#]
            #[doc = r#"inserted text, otherwise it is relative to the beginning of the inserted"#]
            #[doc = r#"text). When there should be no selected text, anchor should be the same"#]
            #[doc = r#"as index."#]
            #[doc = r#""#]
            #[doc = r#"This request will be handled on the text_input side directly following"#]
            #[doc = r#"a commit_string request."#]
            async fn cursor_position(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                cursor_position: i32,
                cursor_position: i32,
            ) -> crate::server::Result<()>;
            async fn modifiers_map(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                modifiers_map: Vec<u8>,
            ) -> crate::server::Result<()>;
            #[doc = r#"Notify when a key event was sent. Key events should not be used for"#]
            #[doc = r#"normal text input operations, which should be done with commit_string,"#]
            #[doc = r#"delete_surrounding_text, etc. The key event follows the wl_keyboard key"#]
            #[doc = r#"event convention. Sym is an XKB keysym, state is a wl_keyboard key_state."#]
            async fn keysym(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                keysym: u32,
                keysym: u32,
                keysym: u32,
                keysym: u32,
                keysym: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Allow an input method to receive hardware keyboard input and process"#]
            #[doc = r#"key events to generate text events (with pre-edit) over the wire. This"#]
            #[doc = r#"allows input methods which compose multiple key events for inputting"#]
            #[doc = r#"text like it is done for CJK languages."#]
            async fn grab_keyboard(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                grab_keyboard: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Forward a wl_keyboard::key event to the client that was not processed"#]
            #[doc = r#"by the input method itself. Should be used when filtering key events"#]
            #[doc = r#"with grab_keyboard.  The arguments should be the ones from the"#]
            #[doc = r#"wl_keyboard::key event."#]
            #[doc = r#""#]
            #[doc = r#"For generating custom key events use the keysym request instead."#]
            async fn key(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                key: u32,
                key: u32,
                key: u32,
                key: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Forward a wl_keyboard::modifiers event to the client that was not"#]
            #[doc = r#"processed by the input method itself.  Should be used when filtering"#]
            #[doc = r#"key events with grab_keyboard. The arguments should be the ones"#]
            #[doc = r#"from the wl_keyboard::modifiers event."#]
            async fn modifiers(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                modifiers: u32,
                modifiers: u32,
                modifiers: u32,
                modifiers: u32,
                modifiers: u32,
            ) -> crate::server::Result<()>;
            async fn language(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                language: u32,
                language: String,
            ) -> crate::server::Result<()>;
            async fn text_direction(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                text_direction: u32,
                text_direction: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"The plain surrounding text around the input position. Cursor is the"#]
            #[doc = r#"position in bytes within the surrounding text relative to the beginning"#]
            #[doc = r#"of the text. Anchor is the position in bytes of the selection anchor"#]
            #[doc = r#"within the surrounding text relative to the beginning of the text. If"#]
            #[doc = r#"there is no selected text then anchor is the same as cursor."#]
            async fn surrounding_text(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                text: String,
                cursor: u32,
                anchor: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_input_method_context_v1#{}.surrounding_text()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(text))
                    .put_uint(cursor)
                    .put_uint(anchor)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn reset(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_input_method_context_v1#{}.reset()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn content_type(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                hint: u32,
                purpose: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_input_method_context_v1#{}.content_type()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(hint)
                    .put_uint(purpose)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn invoke_action(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                button: u32,
                index: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_input_method_context_v1#{}.invoke_action()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(button)
                    .put_uint(index)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn commit_state(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_input_method_context_v1#{}.commit_state()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            async fn preferred_language(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                language: String,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_input_method_context_v1#{}.preferred_language()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(language))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 5, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_input_method_v1 {
        #[doc = r#"An input method object is responsible for composing text in response to"#]
        #[doc = r#"input from hardware or virtual keyboards. There is one input method"#]
        #[doc = r#"object per seat. On activate there is a new input method context object"#]
        #[doc = r#"created which allows the input method to communicate with the text input."#]
        pub trait ZwpInputMethodV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_input_method_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"A text input was activated. Creates an input method context object"#]
            #[doc = r#"which allows communication with the text input."#]
            async fn activate(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_input_method_v1#{}.activate()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The text input corresponding to the context argument was deactivated."#]
            #[doc = r#"The input method context should be destroyed after deactivation is"#]
            #[doc = r#"handled."#]
            async fn deactivate(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                context: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_input_method_v1#{}.deactivate()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(context))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_input_panel_v1 {
        #[doc = r#"Only one client can bind this interface at a time."#]
        pub trait ZwpInputPanelV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_input_panel_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "zwp_input_panel_v1#{}.get_input_panel_surface()",
                            object.id
                        );
                        self.get_input_panel_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn get_input_panel_surface(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_input_panel_surface: crate::wire::ObjectId,
                get_input_panel_surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_input_panel_surface_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Position {
            CenterBottom = 0,
        }
        impl TryFrom<u32> for Position {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::CenterBottom),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        pub trait ZwpInputPanelSurfaceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_input_panel_surface_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_input_panel_surface_v1#{}.set_toplevel()", object.id);
                        self.set_toplevel(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!(
                            "zwp_input_panel_surface_v1#{}.set_overlay_panel()",
                            object.id
                        );
                        self.set_overlay_panel(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Set the input_panel_surface type to keyboard."#]
            #[doc = r#""#]
            #[doc = r#"A keyboard surface is only shown when a text input is active."#]
            async fn set_toplevel(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_toplevel: crate::wire::ObjectId,
                set_toplevel: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set the input_panel_surface to be an overlay panel."#]
            #[doc = r#""#]
            #[doc = r#"This is shown near the input cursor above the application window when"#]
            #[doc = r#"a text input is active."#]
            async fn set_overlay_panel(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
#[doc = r#"This protocol specifies a way for a client to request and receive"#]
#[doc = r#"high-resolution timestamps for input events."#]
#[doc = r#""#]
#[doc = r#"Warning! The protocol described in this file is experimental and"#]
#[doc = r#"backward incompatible changes may be made. Backward compatible changes"#]
#[doc = r#"may be added together with the corresponding interface version bump."#]
#[doc = r#"Backward incompatible changes are done by bumping the version number in"#]
#[doc = r#"the protocol and interface names and resetting the interface version."#]
#[doc = r#"Once the protocol is to be declared stable, the 'z' prefix and the"#]
#[doc = r#"version number in the protocol and interface names are removed and the"#]
#[doc = r#"interface version number is reset."#]
pub mod input_timestamps_unstable_v1 {
    pub mod zwp_input_timestamps_manager_v1 {
        #[doc = r#"A global interface used for requesting high-resolution timestamps"#]
        #[doc = r#"for input events."#]
        pub trait ZwpInputTimestampsManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_input_timestamps_manager_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_input_timestamps_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!(
                            "zwp_input_timestamps_manager_v1#{}.get_keyboard_timestamps()",
                            object.id
                        );
                        self.get_keyboard_timestamps(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!(
                            "zwp_input_timestamps_manager_v1#{}.get_pointer_timestamps()",
                            object.id
                        );
                        self.get_pointer_timestamps(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3 => {
                        tracing::debug!(
                            "zwp_input_timestamps_manager_v1#{}.get_touch_timestamps()",
                            object.id
                        );
                        self.get_touch_timestamps(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Informs the server that the client will no longer be using this"#]
            #[doc = r#"protocol object. Existing objects created by this object are not"#]
            #[doc = r#"affected."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Creates a new input timestamps object that represents a subscription"#]
            #[doc = r#"to high-resolution timestamp events for all wl_keyboard events that"#]
            #[doc = r#"carry a timestamp."#]
            #[doc = r#""#]
            #[doc = r#"If the associated wl_keyboard object is invalidated, either through"#]
            #[doc = r#"client action (e.g. release) or server-side changes, the input"#]
            #[doc = r#"timestamps object becomes inert and the client should destroy it"#]
            #[doc = r#"by calling zwp_input_timestamps_v1.destroy."#]
            async fn get_keyboard_timestamps(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_keyboard_timestamps: crate::wire::ObjectId,
                get_keyboard_timestamps: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Creates a new input timestamps object that represents a subscription"#]
            #[doc = r#"to high-resolution timestamp events for all wl_pointer events that"#]
            #[doc = r#"carry a timestamp."#]
            #[doc = r#""#]
            #[doc = r#"If the associated wl_pointer object is invalidated, either through"#]
            #[doc = r#"client action (e.g. release) or server-side changes, the input"#]
            #[doc = r#"timestamps object becomes inert and the client should destroy it"#]
            #[doc = r#"by calling zwp_input_timestamps_v1.destroy."#]
            async fn get_pointer_timestamps(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_pointer_timestamps: crate::wire::ObjectId,
                get_pointer_timestamps: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Creates a new input timestamps object that represents a subscription"#]
            #[doc = r#"to high-resolution timestamp events for all wl_touch events that"#]
            #[doc = r#"carry a timestamp."#]
            #[doc = r#""#]
            #[doc = r#"If the associated wl_touch object becomes invalid, either through"#]
            #[doc = r#"client action (e.g. release) or server-side changes, the input"#]
            #[doc = r#"timestamps object becomes inert and the client should destroy it"#]
            #[doc = r#"by calling zwp_input_timestamps_v1.destroy."#]
            async fn get_touch_timestamps(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_touch_timestamps: crate::wire::ObjectId,
                get_touch_timestamps: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_input_timestamps_v1 {
        #[doc = r#"Provides high-resolution timestamp events for a set of subscribed input"#]
        #[doc = r#"events. The set of subscribed input events is determined by the"#]
        #[doc = r#"zwp_input_timestamps_manager_v1 request used to create this object."#]
        pub trait ZwpInputTimestampsV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_input_timestamps_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_input_timestamps_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Informs the server that the client will no longer be using this"#]
            #[doc = r#"protocol object. After the server processes the request, no more"#]
            #[doc = r#"timestamp events will be emitted."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"The timestamp event is associated with the first subsequent input event"#]
            #[doc = r#"carrying a timestamp which belongs to the set of input events this"#]
            #[doc = r#"object is subscribed to."#]
            #[doc = r#""#]
            #[doc = r#"The timestamp provided by this event is a high-resolution version of"#]
            #[doc = r#"the timestamp argument of the associated input event. The provided"#]
            #[doc = r#"timestamp is in the same clock domain and is at least as accurate as"#]
            #[doc = r#"the associated input event timestamp."#]
            #[doc = r#""#]
            #[doc = r#"The timestamp is expressed as tv_sec_hi, tv_sec_lo, tv_nsec triples,"#]
            #[doc = r#"each component being an unsigned 32-bit value. Whole seconds are in"#]
            #[doc = r#"tv_sec which is a 64-bit value combined from tv_sec_hi and tv_sec_lo,"#]
            #[doc = r#"and the additional fractional part in tv_nsec as nanoseconds. Hence,"#]
            #[doc = r#"for valid timestamps tv_nsec must be in [0, 999999999]."#]
            async fn timestamp(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                tv_sec_hi: u32,
                tv_sec_lo: u32,
                tv_nsec: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_input_timestamps_v1#{}.timestamp()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(tv_sec_hi)
                    .put_uint(tv_sec_lo)
                    .put_uint(tv_nsec)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = r#"This protocol specifies a way for a client to request the compositor"#]
#[doc = r#"to ignore its own keyboard shortcuts for a given seat, so that all"#]
#[doc = r#"key events from that seat get forwarded to a surface."#]
#[doc = r#""#]
#[doc = r#"Warning! The protocol described in this file is experimental and"#]
#[doc = r#"backward incompatible changes may be made. Backward compatible"#]
#[doc = r#"changes may be added together with the corresponding interface"#]
#[doc = r#"version bump."#]
#[doc = r#"Backward incompatible changes are done by bumping the version"#]
#[doc = r#"number in the protocol and interface names and resetting the"#]
#[doc = r#"interface version. Once the protocol is to be declared stable,"#]
#[doc = r#"the 'z' prefix and the version number in the protocol and"#]
#[doc = r#"interface names are removed and the interface version number is"#]
#[doc = r#"reset."#]
pub mod keyboard_shortcuts_inhibit_unstable_v1 {
    pub mod zwp_keyboard_shortcuts_inhibit_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"The shortcuts are already inhibited for this surface"#]
            AlreadyInhibited = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::AlreadyInhibited),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"A global interface used for inhibiting the compositor keyboard shortcuts."#]
        pub trait ZwpKeyboardShortcutsInhibitManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_keyboard_shortcuts_inhibit_manager_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "zwp_keyboard_shortcuts_inhibit_manager_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!(
                            "zwp_keyboard_shortcuts_inhibit_manager_v1#{}.inhibit_shortcuts()",
                            object.id
                        );
                        self.inhibit_shortcuts(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the keyboard shortcuts inhibitor manager."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Create a new keyboard shortcuts inhibitor object associated with"#]
            #[doc = r#"the given surface for the given seat."#]
            #[doc = r#""#]
            #[doc = r#"If shortcuts are already inhibited for the specified seat and surface,"#]
            #[doc = r#"a protocol error "already_inhibited" is raised by the compositor."#]
            async fn inhibit_shortcuts(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                inhibit_shortcuts: crate::wire::ObjectId,
                inhibit_shortcuts: crate::wire::ObjectId,
                inhibit_shortcuts: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_keyboard_shortcuts_inhibitor_v1 {
        #[doc = r#"A keyboard shortcuts inhibitor instructs the compositor to ignore"#]
        #[doc = r#"its own keyboard shortcuts when the associated surface has keyboard"#]
        #[doc = r#"focus. As a result, when the surface has keyboard focus on the given"#]
        #[doc = r#"seat, it will receive all key events originating from the specified"#]
        #[doc = r#"seat, even those which would normally be caught by the compositor for"#]
        #[doc = r#"its own shortcuts."#]
        #[doc = r#""#]
        #[doc = r#"The Wayland compositor is however under no obligation to disable"#]
        #[doc = r#"all of its shortcuts, and may keep some special key combo for its own"#]
        #[doc = r#"use, including but not limited to one allowing the user to forcibly"#]
        #[doc = r#"restore normal keyboard events routing in the case of an unwilling"#]
        #[doc = r#"client. The compositor may also use the same key combo to reactivate"#]
        #[doc = r#"an existing shortcut inhibitor that was previously deactivated on"#]
        #[doc = r#"user request."#]
        #[doc = r#""#]
        #[doc = r#"When the compositor restores its own keyboard shortcuts, an"#]
        #[doc = r#""inactive" event is emitted to notify the client that the keyboard"#]
        #[doc = r#"shortcuts inhibitor is not effectively active for the surface and"#]
        #[doc = r#"seat any more, and the client should not expect to receive all"#]
        #[doc = r#"keyboard events."#]
        #[doc = r#""#]
        #[doc = r#"When the keyboard shortcuts inhibitor is inactive, the client has"#]
        #[doc = r#"no way to forcibly reactivate the keyboard shortcuts inhibitor."#]
        #[doc = r#""#]
        #[doc = r#"The user can chose to re-enable a previously deactivated keyboard"#]
        #[doc = r#"shortcuts inhibitor using any mechanism the compositor may offer,"#]
        #[doc = r#"in which case the compositor will send an "active" event to notify"#]
        #[doc = r#"the client."#]
        #[doc = r#""#]
        #[doc = r#"If the surface is destroyed, unmapped, or loses the seat's keyboard"#]
        #[doc = r#"focus, the keyboard shortcuts inhibitor becomes irrelevant and the"#]
        #[doc = r#"compositor will restore its own keyboard shortcuts but no "inactive""#]
        #[doc = r#"event is emitted in this case."#]
        pub trait ZwpKeyboardShortcutsInhibitorV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_keyboard_shortcuts_inhibitor_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "zwp_keyboard_shortcuts_inhibitor_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Remove the keyboard shortcuts inhibitor from the associated wl_surface."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event indicates that the shortcut inhibitor is active."#]
            #[doc = r#""#]
            #[doc = r#"The compositor sends this event every time compositor shortcuts"#]
            #[doc = r#"are inhibited on behalf of the surface. When active, the client"#]
            #[doc = r#"may receive input events normally reserved by the compositor"#]
            #[doc = r#"(see zwp_keyboard_shortcuts_inhibitor_v1)."#]
            #[doc = r#""#]
            #[doc = r#"This occurs typically when the initial request "inhibit_shortcuts""#]
            #[doc = r#"first becomes active or when the user instructs the compositor to"#]
            #[doc = r#"re-enable and existing shortcuts inhibitor using any mechanism"#]
            #[doc = r#"offered by the compositor."#]
            async fn active(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_keyboard_shortcuts_inhibitor_v1#{}.active()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event indicates that the shortcuts inhibitor is inactive,"#]
            #[doc = r#"normal shortcuts processing is restored by the compositor."#]
            async fn inactive(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_keyboard_shortcuts_inhibitor_v1#{}.inactive()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod linux_dmabuf_unstable_v1 {
    pub mod zwp_linux_dmabuf_v1 {
        #[doc = r#"Following the interfaces from:"#]
        #[doc = r#"https://www.khronos.org/registry/egl/extensions/EXT/EGL_EXT_image_dma_buf_import.txt"#]
        #[doc = r#"https://www.khronos.org/registry/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import_modifiers.txt"#]
        #[doc = r#"and the Linux DRM sub-system's AddFb2 ioctl."#]
        #[doc = r#""#]
        #[doc = r#"This interface offers ways to create generic dmabuf-based wl_buffers."#]
        #[doc = r#""#]
        #[doc = r#"Clients can use the get_surface_feedback request to get dmabuf feedback"#]
        #[doc = r#"for a particular surface. If the client wants to retrieve feedback not"#]
        #[doc = r#"tied to a surface, they can use the get_default_feedback request."#]
        #[doc = r#""#]
        #[doc = r#"The following are required from clients:"#]
        #[doc = r#""#]
        #[doc = r#"- Clients must ensure that either all data in the dma-buf is"#]
        #[doc = r#"coherent for all subsequent read access or that coherency is"#]
        #[doc = r#"correctly handled by the underlying kernel-side dma-buf"#]
        #[doc = r#"implementation."#]
        #[doc = r#""#]
        #[doc = r#"- Don't make any more attachments after sending the buffer to the"#]
        #[doc = r#"compositor. Making more attachments later increases the risk of"#]
        #[doc = r#"the compositor not being able to use (re-import) an existing"#]
        #[doc = r#"dmabuf-based wl_buffer."#]
        #[doc = r#""#]
        #[doc = r#"The underlying graphics stack must ensure the following:"#]
        #[doc = r#""#]
        #[doc = r#"- The dmabuf file descriptors relayed to the server will stay valid"#]
        #[doc = r#"for the whole lifetime of the wl_buffer. This means the server may"#]
        #[doc = r#"at any time use those fds to import the dmabuf into any kernel"#]
        #[doc = r#"sub-system that might accept it."#]
        #[doc = r#""#]
        #[doc = r#"However, when the underlying graphics stack fails to deliver the"#]
        #[doc = r#"promise, because of e.g. a device hot-unplug which raises internal"#]
        #[doc = r#"errors, after the wl_buffer has been successfully created the"#]
        #[doc = r#"compositor must not raise protocol errors to the client when dmabuf"#]
        #[doc = r#"import later fails."#]
        #[doc = r#""#]
        #[doc = r#"To create a wl_buffer from one or more dmabufs, a client creates a"#]
        #[doc = r#"zwp_linux_dmabuf_params_v1 object with a zwp_linux_dmabuf_v1.create_params"#]
        #[doc = r#"request. All planes required by the intended format are added with"#]
        #[doc = r#"the 'add' request. Finally, a 'create' or 'create_immed' request is"#]
        #[doc = r#"issued, which has the following outcome depending on the import success."#]
        #[doc = r#""#]
        #[doc = r#"The 'create' request,"#]
        #[doc = r#"- on success, triggers a 'created' event which provides the final"#]
        #[doc = r#"wl_buffer to the client."#]
        #[doc = r#"- on failure, triggers a 'failed' event to convey that the server"#]
        #[doc = r#"cannot use the dmabufs received from the client."#]
        #[doc = r#""#]
        #[doc = r#"For the 'create_immed' request,"#]
        #[doc = r#"- on success, the server immediately imports the added dmabufs to"#]
        #[doc = r#"create a wl_buffer. No event is sent from the server in this case."#]
        #[doc = r#"- on failure, the server can choose to either:"#]
        #[doc = r#"- terminate the client by raising a fatal error."#]
        #[doc = r#"- mark the wl_buffer as failed, and send a 'failed' event to the"#]
        #[doc = r#"client. If the client uses a failed wl_buffer as an argument to any"#]
        #[doc = r#"request, the behaviour is compositor implementation-defined."#]
        #[doc = r#""#]
        #[doc = r#"For all DRM formats and unless specified in another protocol extension,"#]
        #[doc = r#"pre-multiplied alpha is used for pixel values."#]
        #[doc = r#""#]
        #[doc = r#"Unless specified otherwise in another protocol extension, implicit"#]
        #[doc = r#"synchronization is used. In other words, compositors and clients must"#]
        #[doc = r#"wait and signal fences implicitly passed via the DMA-BUF's reservation"#]
        #[doc = r#"mechanism."#]
        #[doc = r#""#]
        #[doc = r#"Disclaimer: This protocol extension has been marked stable. This copy is"#]
        #[doc = r#"no longer used and only retained for backwards compatibility. The"#]
        #[doc = r#"canonical version can be found in the stable/ directory."#]
        pub trait ZwpLinuxDmabufV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_dmabuf_v1";
            const VERSION: u32 = 5;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.create_params()", object.id);
                        self.create_params(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.get_default_feedback()", object.id);
                        self.get_default_feedback(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3 => {
                        tracing::debug!("zwp_linux_dmabuf_v1#{}.get_surface_feedback()", object.id);
                        self.get_surface_feedback(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Objects created through this interface, especially wl_buffers, will"#]
            #[doc = r#"remain valid."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This temporary object is used to collect multiple dmabuf handles into"#]
            #[doc = r#"a single batch to create a wl_buffer. It can only be used once and"#]
            #[doc = r#"should be destroyed after a 'created' or 'failed' event has been"#]
            #[doc = r#"received."#]
            async fn create_params(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create_params: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request creates a new wp_linux_dmabuf_feedback object not bound"#]
            #[doc = r#"to a particular surface. This object will deliver feedback about dmabuf"#]
            #[doc = r#"parameters to use if the client doesn't support per-surface feedback"#]
            #[doc = r#"(see get_surface_feedback)."#]
            async fn get_default_feedback(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_default_feedback: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request creates a new wp_linux_dmabuf_feedback object for the"#]
            #[doc = r#"specified wl_surface. This object will deliver feedback about dmabuf"#]
            #[doc = r#"parameters to use for buffers attached to this surface."#]
            #[doc = r#""#]
            #[doc = r#"If the surface is destroyed before the wp_linux_dmabuf_feedback object,"#]
            #[doc = r#"the feedback object becomes inert."#]
            async fn get_surface_feedback(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_surface_feedback: crate::wire::ObjectId,
                get_surface_feedback: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event advertises one buffer format that the server supports."#]
            #[doc = r#"All the supported formats are advertised once when the client"#]
            #[doc = r#"binds to this interface. A roundtrip after binding guarantees"#]
            #[doc = r#"that the client has received all supported formats."#]
            #[doc = r#""#]
            #[doc = r#"For the definition of the format codes, see the"#]
            #[doc = r#"zwp_linux_buffer_params_v1::create request."#]
            #[doc = r#""#]
            #[doc = r#"Starting version 4, the format event is deprecated and must not be"#]
            #[doc = r#"sent by compositors. Instead, use get_default_feedback or"#]
            #[doc = r#"get_surface_feedback."#]
            async fn format(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                format: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_linux_dmabuf_v1#{}.format()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(format).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event advertises the formats that the server supports, along with"#]
            #[doc = r#"the modifiers supported for each format. All the supported modifiers"#]
            #[doc = r#"for all the supported formats are advertised once when the client"#]
            #[doc = r#"binds to this interface. A roundtrip after binding guarantees that"#]
            #[doc = r#"the client has received all supported format-modifier pairs."#]
            #[doc = r#""#]
            #[doc = r#"For legacy support, DRM_FORMAT_MOD_INVALID (that is, modifier_hi =="#]
            #[doc = r#"0x00ffffff and modifier_lo == 0xffffffff) is allowed in this event."#]
            #[doc = r#"It indicates that the server can support the format with an implicit"#]
            #[doc = r#"modifier. When a plane has DRM_FORMAT_MOD_INVALID as its modifier, it"#]
            #[doc = r#"is as if no explicit modifier is specified. The effective modifier"#]
            #[doc = r#"will be derived from the dmabuf."#]
            #[doc = r#""#]
            #[doc = r#"A compositor that sends valid modifiers and DRM_FORMAT_MOD_INVALID for"#]
            #[doc = r#"a given format supports both explicit modifiers and implicit modifiers."#]
            #[doc = r#""#]
            #[doc = r#"For the definition of the format and modifier codes, see the"#]
            #[doc = r#"zwp_linux_buffer_params_v1::create and zwp_linux_buffer_params_v1::add"#]
            #[doc = r#"requests."#]
            #[doc = r#""#]
            #[doc = r#"Starting version 4, the modifier event is deprecated and must not be"#]
            #[doc = r#"sent by compositors. Instead, use get_default_feedback or"#]
            #[doc = r#"get_surface_feedback."#]
            async fn modifier(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                format: u32,
                modifier_hi: u32,
                modifier_lo: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_linux_dmabuf_v1#{}.modifier()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(format)
                    .put_uint(modifier_hi)
                    .put_uint(modifier_lo)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_linux_buffer_params_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"The dmabuf_batch object has already been used to create a wl_buffer"#]
            AlreadyUsed = 0,
            #[doc = r#"Plane index out of bounds"#]
            PlaneIdx = 1,
            #[doc = r#"The plane index was already set"#]
            PlaneSet = 2,
            #[doc = r#"Missing or too many planes to create a buffer"#]
            Incomplete = 3,
            #[doc = r#"Format not supported"#]
            InvalidFormat = 4,
            #[doc = r#"Invalid width or height"#]
            InvalidDimensions = 5,
            #[doc = r#"Offset + stride * height goes out of dmabuf bounds"#]
            OutOfBounds = 6,
            #[doc = r#"Invalid wl_buffer resulted from importing dmabufs via"#]
            #[doc = r#"The create_immed request on given buffer_params"#]
            InvalidWlBuffer = 7,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::AlreadyUsed),
                    1 => Ok(Self::PlaneIdx),
                    2 => Ok(Self::PlaneSet),
                    3 => Ok(Self::Incomplete),
                    4 => Ok(Self::InvalidFormat),
                    5 => Ok(Self::InvalidDimensions),
                    6 => Ok(Self::OutOfBounds),
                    7 => Ok(Self::InvalidWlBuffer),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! {
                                    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
                                    pub struct Flags: u32 {#[doc = r#"Contents are y-inverted"#]
        const YInvert = 1;#[doc = r#"Content is interlaced"#]
        const Interlaced = 2;#[doc = r#"Bottom field first"#]
        const BottomFirst = 4;}
                                }
        impl TryFrom<u32> for Flags {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = r#"This temporary object is a collection of dmabufs and other"#]
        #[doc = r#"parameters that together form a single logical buffer. The temporary"#]
        #[doc = r#"object may eventually create one wl_buffer unless cancelled by"#]
        #[doc = r#"destroying it before requesting 'create'."#]
        #[doc = r#""#]
        #[doc = r#"Single-planar formats only require one dmabuf, however"#]
        #[doc = r#"multi-planar formats may require more than one dmabuf. For all"#]
        #[doc = r#"formats, an 'add' request must be called once per plane (even if the"#]
        #[doc = r#"underlying dmabuf fd is identical)."#]
        #[doc = r#""#]
        #[doc = r#"You must use consecutive plane indices ('plane_idx' argument for 'add')"#]
        #[doc = r#"from zero to the number of planes used by the drm_fourcc format code."#]
        #[doc = r#"All planes required by the format must be given exactly once, but can"#]
        #[doc = r#"be given in any order. Each plane index can be set only once."#]
        pub trait ZwpLinuxBufferParamsV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_buffer_params_v1";
            const VERSION: u32 = 5;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.add()", object.id);
                        self.add(
                            object,
                            client,
                            message.fd()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.create()", object.id);
                        self.create(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.uint()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    3 => {
                        tracing::debug!("zwp_linux_buffer_params_v1#{}.create_immed()", object.id);
                        self.create_immed(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.uint()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Cleans up the temporary data sent to the server for dmabuf-based"#]
            #[doc = r#"wl_buffer creation."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request adds one dmabuf to the set in this"#]
            #[doc = r#"zwp_linux_buffer_params_v1."#]
            #[doc = r#""#]
            #[doc = r#"The 64-bit unsigned value combined from modifier_hi and modifier_lo"#]
            #[doc = r#"is the dmabuf layout modifier. DRM AddFB2 ioctl calls this the"#]
            #[doc = r#"fb modifier, which is defined in drm_mode.h of Linux UAPI."#]
            #[doc = r#"This is an opaque token. Drivers use this token to express tiling,"#]
            #[doc = r#"compression, etc. driver-specific modifications to the base format"#]
            #[doc = r#"defined by the DRM fourcc code."#]
            #[doc = r#""#]
            #[doc = r#"Starting from version 4, the invalid_format protocol error is sent if"#]
            #[doc = r#"the format + modifier pair was not advertised as supported."#]
            #[doc = r#""#]
            #[doc = r#"Starting from version 5, the invalid_format protocol error is sent if"#]
            #[doc = r#"all planes don't use the same modifier."#]
            #[doc = r#""#]
            #[doc = r#"This request raises the PLANE_IDX error if plane_idx is too large."#]
            #[doc = r#"The error PLANE_SET is raised if attempting to set a plane that"#]
            #[doc = r#"was already set."#]
            async fn add(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                add: rustix::fd::OwnedFd,
                add: u32,
                add: u32,
                add: u32,
                add: u32,
                add: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"This asks for creation of a wl_buffer from the added dmabuf"#]
            #[doc = r#"buffers. The wl_buffer is not created immediately but returned via"#]
            #[doc = r#"the 'created' event if the dmabuf sharing succeeds. The sharing"#]
            #[doc = r#"may fail at runtime for reasons a client cannot predict, in"#]
            #[doc = r#"which case the 'failed' event is triggered."#]
            #[doc = r#""#]
            #[doc = r#"The 'format' argument is a DRM_FORMAT code, as defined by the"#]
            #[doc = r#"libdrm's drm_fourcc.h. The Linux kernel's DRM sub-system is the"#]
            #[doc = r#"authoritative source on how the format codes should work."#]
            #[doc = r#""#]
            #[doc = r#"The 'flags' is a bitfield of the flags defined in enum "flags"."#]
            #[doc = r#"'y_invert' means the that the image needs to be y-flipped."#]
            #[doc = r#""#]
            #[doc = r#"Flag 'interlaced' means that the frame in the buffer is not"#]
            #[doc = r#"progressive as usual, but interlaced. An interlaced buffer as"#]
            #[doc = r#"supported here must always contain both top and bottom fields."#]
            #[doc = r#"The top field always begins on the first pixel row. The temporal"#]
            #[doc = r#"ordering between the two fields is top field first, unless"#]
            #[doc = r#"'bottom_first' is specified. It is undefined whether 'bottom_first'"#]
            #[doc = r#"is ignored if 'interlaced' is not set."#]
            #[doc = r#""#]
            #[doc = r#"This protocol does not convey any information about field rate,"#]
            #[doc = r#"duration, or timing, other than the relative ordering between the"#]
            #[doc = r#"two fields in one buffer. A compositor may have to estimate the"#]
            #[doc = r#"intended field rate from the incoming buffer rate. It is undefined"#]
            #[doc = r#"whether the time of receiving wl_surface.commit with a new buffer"#]
            #[doc = r#"attached, applying the wl_surface state, wl_surface.frame callback"#]
            #[doc = r#"trigger, presentation, or any other point in the compositor cycle"#]
            #[doc = r#"is used to measure the frame or field times. There is no support"#]
            #[doc = r#"for detecting missed or late frames/fields/buffers either, and"#]
            #[doc = r#"there is no support whatsoever for cooperating with interlaced"#]
            #[doc = r#"compositor output."#]
            #[doc = r#""#]
            #[doc = r#"The composited image quality resulting from the use of interlaced"#]
            #[doc = r#"buffers is explicitly undefined. A compositor may use elaborate"#]
            #[doc = r#"hardware features or software to deinterlace and create progressive"#]
            #[doc = r#"output frames from a sequence of interlaced input buffers, or it"#]
            #[doc = r#"may produce substandard image quality. However, compositors that"#]
            #[doc = r#"cannot guarantee reasonable image quality in all cases are recommended"#]
            #[doc = r#"to just reject all interlaced buffers."#]
            #[doc = r#""#]
            #[doc = r#"Any argument errors, including non-positive width or height,"#]
            #[doc = r#"mismatch between the number of planes and the format, bad"#]
            #[doc = r#"format, bad offset or stride, may be indicated by fatal protocol"#]
            #[doc = r#"errors: INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS,"#]
            #[doc = r#"OUT_OF_BOUNDS."#]
            #[doc = r#""#]
            #[doc = r#"Dmabuf import errors in the server that are not obvious client"#]
            #[doc = r#"bugs are returned via the 'failed' event as non-fatal. This"#]
            #[doc = r#"allows attempting dmabuf sharing and falling back in the client"#]
            #[doc = r#"if it fails."#]
            #[doc = r#""#]
            #[doc = r#"This request can be sent only once in the object's lifetime, after"#]
            #[doc = r#"which the only legal request is destroy. This object should be"#]
            #[doc = r#"destroyed after issuing a 'create' request. Attempting to use this"#]
            #[doc = r#"object after issuing 'create' raises ALREADY_USED protocol error."#]
            #[doc = r#""#]
            #[doc = r#"It is not mandatory to issue 'create'. If a client wants to"#]
            #[doc = r#"cancel the buffer creation, it can just destroy this object."#]
            async fn create(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create: i32,
                create: i32,
                create: u32,
                create: Flags,
            ) -> crate::server::Result<()>;
            #[doc = r#"This asks for immediate creation of a wl_buffer by importing the"#]
            #[doc = r#"added dmabufs."#]
            #[doc = r#""#]
            #[doc = r#"In case of import success, no event is sent from the server, and the"#]
            #[doc = r#"wl_buffer is ready to be used by the client."#]
            #[doc = r#""#]
            #[doc = r#"Upon import failure, either of the following may happen, as seen fit"#]
            #[doc = r#"by the implementation:"#]
            #[doc = r#"- the client is terminated with one of the following fatal protocol"#]
            #[doc = r#"errors:"#]
            #[doc = r#"- INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS, OUT_OF_BOUNDS,"#]
            #[doc = r#"in case of argument errors such as mismatch between the number"#]
            #[doc = r#"of planes and the format, bad format, non-positive width or"#]
            #[doc = r#"height, or bad offset or stride."#]
            #[doc = r#"- INVALID_WL_BUFFER, in case the cause for failure is unknown or"#]
            #[doc = r#"plaform specific."#]
            #[doc = r#"- the server creates an invalid wl_buffer, marks it as failed and"#]
            #[doc = r#"sends a 'failed' event to the client. The result of using this"#]
            #[doc = r#"invalid wl_buffer as an argument in any request by the client is"#]
            #[doc = r#"defined by the compositor implementation."#]
            #[doc = r#""#]
            #[doc = r#"This takes the same arguments as a 'create' request, and obeys the"#]
            #[doc = r#"same restrictions."#]
            async fn create_immed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create_immed: crate::wire::ObjectId,
                create_immed: i32,
                create_immed: i32,
                create_immed: u32,
                create_immed: Flags,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event indicates that the attempted buffer creation was"#]
            #[doc = r#"successful. It provides the new wl_buffer referencing the dmabuf(s)."#]
            #[doc = r#""#]
            #[doc = r#"Upon receiving this event, the client should destroy the"#]
            #[doc = r#"zwp_linux_buffer_params_v1 object."#]
            async fn created(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                buffer: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_linux_buffer_params_v1#{}.created()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(buffer))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event indicates that the attempted buffer creation has"#]
            #[doc = r#"failed. It usually means that one of the dmabuf constraints"#]
            #[doc = r#"has not been fulfilled."#]
            #[doc = r#""#]
            #[doc = r#"Upon receiving this event, the client should destroy the"#]
            #[doc = r#"zwp_linux_buffer_params_v1 object."#]
            async fn failed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_linux_buffer_params_v1#{}.failed()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_linux_dmabuf_feedback_v1 {
        bitflags::bitflags! {
                                    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
                                    pub struct TrancheFlags: u32 {#[doc = r#"Direct scan-out tranche"#]
        const Scanout = 1;}
                                }
        impl TryFrom<u32> for TrancheFlags {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = r#"This object advertises dmabuf parameters feedback. This includes the"#]
        #[doc = r#"preferred devices and the supported formats/modifiers."#]
        #[doc = r#""#]
        #[doc = r#"The parameters are sent once when this object is created and whenever they"#]
        #[doc = r#"change. The done event is always sent once after all parameters have been"#]
        #[doc = r#"sent. When a single parameter changes, all parameters are re-sent by the"#]
        #[doc = r#"compositor."#]
        #[doc = r#""#]
        #[doc = r#"Compositors can re-send the parameters when the current client buffer"#]
        #[doc = r#"allocations are sub-optimal. Compositors should not re-send the"#]
        #[doc = r#"parameters if re-allocating the buffers would not result in a more optimal"#]
        #[doc = r#"configuration. In particular, compositors should avoid sending the exact"#]
        #[doc = r#"same parameters multiple times in a row."#]
        #[doc = r#""#]
        #[doc = r#"The tranche_target_device and tranche_formats events are grouped by"#]
        #[doc = r#"tranches of preference. For each tranche, a tranche_target_device, one"#]
        #[doc = r#"tranche_flags and one or more tranche_formats events are sent, followed"#]
        #[doc = r#"by a tranche_done event finishing the list. The tranches are sent in"#]
        #[doc = r#"descending order of preference. All formats and modifiers in the same"#]
        #[doc = r#"tranche have the same preference."#]
        #[doc = r#""#]
        #[doc = r#"To send parameters, the compositor sends one main_device event, tranches"#]
        #[doc = r#"(each consisting of one tranche_target_device event, one tranche_flags"#]
        #[doc = r#"event, tranche_formats events and then a tranche_done event), then one"#]
        #[doc = r#"done event."#]
        pub trait ZwpLinuxDmabufFeedbackV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_dmabuf_feedback_v1";
            const VERSION: u32 = 5;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_linux_dmabuf_feedback_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Using this request a client can tell the server that it is not going to"#]
            #[doc = r#"use the wp_linux_dmabuf_feedback object anymore."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event is sent after all parameters of a wp_linux_dmabuf_feedback"#]
            #[doc = r#"object have been sent."#]
            #[doc = r#""#]
            #[doc = r#"This allows changes to the wp_linux_dmabuf_feedback parameters to be"#]
            #[doc = r#"seen as atomic, even if they happen via multiple events."#]
            async fn done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_linux_dmabuf_feedback_v1#{}.done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event provides a file descriptor which can be memory-mapped to"#]
            #[doc = r#"access the format and modifier table."#]
            #[doc = r#""#]
            #[doc = r#"The table contains a tightly packed array of consecutive format +"#]
            #[doc = r#"modifier pairs. Each pair is 16 bytes wide. It contains a format as a"#]
            #[doc = r#"32-bit unsigned integer, followed by 4 bytes of unused padding, and a"#]
            #[doc = r#"modifier as a 64-bit unsigned integer. The native endianness is used."#]
            #[doc = r#""#]
            #[doc = r#"The client must map the file descriptor in read-only private mode."#]
            #[doc = r#""#]
            #[doc = r#"Compositors are not allowed to mutate the table file contents once this"#]
            #[doc = r#"event has been sent. Instead, compositors must create a new, separate"#]
            #[doc = r#"table file and re-send feedback parameters. Compositors are allowed to"#]
            #[doc = r#"store duplicate format + modifier pairs in the table."#]
            async fn format_table(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                fd: rustix::fd::OwnedFd,
                size: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.format_table()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fd(fd)
                    .put_uint(size)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event advertises the main device that the server prefers to use"#]
            #[doc = r#"when direct scan-out to the target device isn't possible. The"#]
            #[doc = r#"advertised main device may be different for each"#]
            #[doc = r#"wp_linux_dmabuf_feedback object, and may change over time."#]
            #[doc = r#""#]
            #[doc = r#"There is exactly one main device. The compositor must send at least"#]
            #[doc = r#"one preference tranche with tranche_target_device equal to main_device."#]
            #[doc = r#""#]
            #[doc = r#"Clients need to create buffers that the main device can import and"#]
            #[doc = r#"read from, otherwise creating the dmabuf wl_buffer will fail (see the"#]
            #[doc = r#"wp_linux_buffer_params.create and create_immed requests for details)."#]
            #[doc = r#"The main device will also likely be kept active by the compositor,"#]
            #[doc = r#"so clients can use it instead of waking up another device for power"#]
            #[doc = r#"savings."#]
            #[doc = r#""#]
            #[doc = r#"In general the device is a DRM node. The DRM node type (primary vs."#]
            #[doc = r#"render) is unspecified. Clients must not rely on the compositor sending"#]
            #[doc = r#"a particular node type. Clients cannot check two devices for equality"#]
            #[doc = r#"by comparing the dev_t value."#]
            #[doc = r#""#]
            #[doc = r#"If explicit modifiers are not supported and the client performs buffer"#]
            #[doc = r#"allocations on a different device than the main device, then the client"#]
            #[doc = r#"must force the buffer to have a linear layout."#]
            async fn main_device(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                device: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.main_device()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_array(device).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event splits tranche_target_device and tranche_formats events in"#]
            #[doc = r#"preference tranches. It is sent after a set of tranche_target_device"#]
            #[doc = r#"and tranche_formats events; it represents the end of a tranche. The"#]
            #[doc = r#"next tranche will have a lower preference."#]
            async fn tranche_done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.tranche_done()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event advertises the target device that the server prefers to use"#]
            #[doc = r#"for a buffer created given this tranche. The advertised target device"#]
            #[doc = r#"may be different for each preference tranche, and may change over time."#]
            #[doc = r#""#]
            #[doc = r#"There is exactly one target device per tranche."#]
            #[doc = r#""#]
            #[doc = r#"The target device may be a scan-out device, for example if the"#]
            #[doc = r#"compositor prefers to directly scan-out a buffer created given this"#]
            #[doc = r#"tranche. The target device may be a rendering device, for example if"#]
            #[doc = r#"the compositor prefers to texture from said buffer."#]
            #[doc = r#""#]
            #[doc = r#"The client can use this hint to allocate the buffer in a way that makes"#]
            #[doc = r#"it accessible from the target device, ideally directly. The buffer must"#]
            #[doc = r#"still be accessible from the main device, either through direct import"#]
            #[doc = r#"or through a potentially more expensive fallback path. If the buffer"#]
            #[doc = r#"can't be directly imported from the main device then clients must be"#]
            #[doc = r#"prepared for the compositor changing the tranche priority or making"#]
            #[doc = r#"wl_buffer creation fail (see the wp_linux_buffer_params.create and"#]
            #[doc = r#"create_immed requests for details)."#]
            #[doc = r#""#]
            #[doc = r#"If the device is a DRM node, the DRM node type (primary vs. render) is"#]
            #[doc = r#"unspecified. Clients must not rely on the compositor sending a"#]
            #[doc = r#"particular node type. Clients cannot check two devices for equality by"#]
            #[doc = r#"comparing the dev_t value."#]
            #[doc = r#""#]
            #[doc = r#"This event is tied to a preference tranche, see the tranche_done event."#]
            async fn tranche_target_device(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                device: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.tranche_target_device()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_array(device).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event advertises the format + modifier combinations that the"#]
            #[doc = r#"compositor supports."#]
            #[doc = r#""#]
            #[doc = r#"It carries an array of indices, each referring to a format + modifier"#]
            #[doc = r#"pair in the last received format table (see the format_table event)."#]
            #[doc = r#"Each index is a 16-bit unsigned integer in native endianness."#]
            #[doc = r#""#]
            #[doc = r#"For legacy support, DRM_FORMAT_MOD_INVALID is an allowed modifier."#]
            #[doc = r#"It indicates that the server can support the format with an implicit"#]
            #[doc = r#"modifier. When a buffer has DRM_FORMAT_MOD_INVALID as its modifier, it"#]
            #[doc = r#"is as if no explicit modifier is specified. The effective modifier"#]
            #[doc = r#"will be derived from the dmabuf."#]
            #[doc = r#""#]
            #[doc = r#"A compositor that sends valid modifiers and DRM_FORMAT_MOD_INVALID for"#]
            #[doc = r#"a given format supports both explicit modifiers and implicit modifiers."#]
            #[doc = r#""#]
            #[doc = r#"Compositors must not send duplicate format + modifier pairs within the"#]
            #[doc = r#"same tranche or across two different tranches with the same target"#]
            #[doc = r#"device and flags."#]
            #[doc = r#""#]
            #[doc = r#"This event is tied to a preference tranche, see the tranche_done event."#]
            #[doc = r#""#]
            #[doc = r#"For the definition of the format and modifier codes, see the"#]
            #[doc = r#"wp_linux_buffer_params.create request."#]
            async fn tranche_formats(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                indices: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.tranche_formats()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_array(indices)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 5, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event sets tranche-specific flags."#]
            #[doc = r#""#]
            #[doc = r#"The scanout flag is a hint that direct scan-out may be attempted by the"#]
            #[doc = r#"compositor on the target device if the client appropriately allocates a"#]
            #[doc = r#"buffer. How to allocate a buffer that can be scanned out on the target"#]
            #[doc = r#"device is implementation-defined."#]
            #[doc = r#""#]
            #[doc = r#"This event is tied to a preference tranche, see the tranche_done event."#]
            async fn tranche_flags(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                flags: TrancheFlags,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_dmabuf_feedback_v1#{}.tranche_flags()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(flags.bits())
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 6, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod zwp_linux_explicit_synchronization_unstable_v1 {
    pub mod zwp_linux_explicit_synchronization_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"The surface already has a synchronization object associated"#]
            SynchronizationExists = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::SynchronizationExists),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"This global is a factory interface, allowing clients to request"#]
        #[doc = r#"explicit synchronization for buffers on a per-surface basis."#]
        #[doc = r#""#]
        #[doc = r#"See zwp_linux_surface_synchronization_v1 for more information."#]
        #[doc = r#""#]
        #[doc = r#"This interface is derived from Chromium's"#]
        #[doc = r#"zcr_linux_explicit_synchronization_v1."#]
        #[doc = r#""#]
        #[doc = r#"Note: this protocol is superseded by linux-drm-syncobj."#]
        #[doc = r#""#]
        #[doc = r#"Warning! The protocol described in this file is experimental and"#]
        #[doc = r#"backward incompatible changes may be made. Backward compatible changes"#]
        #[doc = r#"may be added together with the corresponding interface version bump."#]
        #[doc = r#"Backward incompatible changes are done by bumping the version number in"#]
        #[doc = r#"the protocol and interface names and resetting the interface version."#]
        #[doc = r#"Once the protocol is to be declared stable, the 'z' prefix and the"#]
        #[doc = r#"version number in the protocol and interface names are removed and the"#]
        #[doc = r#"interface version number is reset."#]
        pub trait ZwpLinuxExplicitSynchronizationV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_explicit_synchronization_v1";
            const VERSION: u32 = 2;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "zwp_linux_explicit_synchronization_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!(
                            "zwp_linux_explicit_synchronization_v1#{}.get_synchronization()",
                            object.id
                        );
                        self.get_synchronization(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy this explicit synchronization factory object. Other objects,"#]
            #[doc = r#"including zwp_linux_surface_synchronization_v1 objects created by this"#]
            #[doc = r#"factory, shall not be affected by this request."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Instantiate an interface extension for the given wl_surface to provide"#]
            #[doc = r#"explicit synchronization."#]
            #[doc = r#""#]
            #[doc = r#"If the given wl_surface already has an explicit synchronization object"#]
            #[doc = r#"associated, the synchronization_exists protocol error is raised."#]
            #[doc = r#""#]
            #[doc = r#"Graphics APIs, like EGL or Vulkan, that manage the buffer queue and"#]
            #[doc = r#"commits of a wl_surface themselves, are likely to be using this"#]
            #[doc = r#"extension internally. If a client is using such an API for a"#]
            #[doc = r#"wl_surface, it should not directly use this extension on that surface,"#]
            #[doc = r#"to avoid raising a synchronization_exists protocol error."#]
            async fn get_synchronization(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_synchronization: crate::wire::ObjectId,
                get_synchronization: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_linux_surface_synchronization_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"The fence specified by the client could not be imported"#]
            InvalidFence = 0,
            #[doc = r#"Multiple fences added for a single surface commit"#]
            DuplicateFence = 1,
            #[doc = r#"Multiple releases added for a single surface commit"#]
            DuplicateRelease = 2,
            #[doc = r#"The associated wl_surface was destroyed"#]
            NoSurface = 3,
            #[doc = r#"The buffer does not support explicit synchronization"#]
            UnsupportedBuffer = 4,
            #[doc = r#"No buffer was attached"#]
            NoBuffer = 5,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::InvalidFence),
                    1 => Ok(Self::DuplicateFence),
                    2 => Ok(Self::DuplicateRelease),
                    3 => Ok(Self::NoSurface),
                    4 => Ok(Self::UnsupportedBuffer),
                    5 => Ok(Self::NoBuffer),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"This object implements per-surface explicit synchronization."#]
        #[doc = r#""#]
        #[doc = r#"Synchronization refers to co-ordination of pipelined operations performed"#]
        #[doc = r#"on buffers. Most GPU clients will schedule an asynchronous operation to"#]
        #[doc = r#"render to the buffer, then immediately send the buffer to the compositor"#]
        #[doc = r#"to be attached to a surface."#]
        #[doc = r#""#]
        #[doc = r#"In implicit synchronization, ensuring that the rendering operation is"#]
        #[doc = r#"complete before the compositor displays the buffer is an implementation"#]
        #[doc = r#"detail handled by either the kernel or userspace graphics driver."#]
        #[doc = r#""#]
        #[doc = r#"By contrast, in explicit synchronization, dma_fence objects mark when the"#]
        #[doc = r#"asynchronous operations are complete. When submitting a buffer, the"#]
        #[doc = r#"client provides an acquire fence which will be waited on before the"#]
        #[doc = r#"compositor accesses the buffer. The Wayland server, through a"#]
        #[doc = r#"zwp_linux_buffer_release_v1 object, will inform the client with an event"#]
        #[doc = r#"which may be accompanied by a release fence, when the compositor will no"#]
        #[doc = r#"longer access the buffer contents due to the specific commit that"#]
        #[doc = r#"requested the release event."#]
        #[doc = r#""#]
        #[doc = r#"Each surface can be associated with only one object of this interface at"#]
        #[doc = r#"any time."#]
        #[doc = r#""#]
        #[doc = r#"In version 1 of this interface, explicit synchronization is only"#]
        #[doc = r#"guaranteed to be supported for buffers created with any version of the"#]
        #[doc = r#"wp_linux_dmabuf buffer factory. Version 2 additionally guarantees"#]
        #[doc = r#"explicit synchronization support for opaque EGL buffers, which is a type"#]
        #[doc = r#"of platform specific buffers described in the EGL_WL_bind_wayland_display"#]
        #[doc = r#"extension. Compositors are free to support explicit synchronization for"#]
        #[doc = r#"additional buffer types."#]
        pub trait ZwpLinuxSurfaceSynchronizationV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_surface_synchronization_v1";
            const VERSION: u32 = 2;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "zwp_linux_surface_synchronization_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!(
                            "zwp_linux_surface_synchronization_v1#{}.set_acquire_fence()",
                            object.id
                        );
                        self.set_acquire_fence(object, client, message.fd()?).await
                    }
                    2 => {
                        tracing::debug!(
                            "zwp_linux_surface_synchronization_v1#{}.get_release()",
                            object.id
                        );
                        self.get_release(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy this explicit synchronization object."#]
            #[doc = r#""#]
            #[doc = r#"Any fence set by this object with set_acquire_fence since the last"#]
            #[doc = r#"commit will be discarded by the server. Any fences set by this object"#]
            #[doc = r#"before the last commit are not affected."#]
            #[doc = r#""#]
            #[doc = r#"zwp_linux_buffer_release_v1 objects created by this object are not"#]
            #[doc = r#"affected by this request."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set the acquire fence that must be signaled before the compositor"#]
            #[doc = r#"may sample from the buffer attached with wl_surface.attach. The fence"#]
            #[doc = r#"is a dma_fence kernel object."#]
            #[doc = r#""#]
            #[doc = r#"The acquire fence is double-buffered state, and will be applied on the"#]
            #[doc = r#"next wl_surface.commit request for the associated surface. Thus, it"#]
            #[doc = r#"applies only to the buffer that is attached to the surface at commit"#]
            #[doc = r#"time."#]
            #[doc = r#""#]
            #[doc = r#"If the provided fd is not a valid dma_fence fd, then an INVALID_FENCE"#]
            #[doc = r#"error is raised."#]
            #[doc = r#""#]
            #[doc = r#"If a fence has already been attached during the same commit cycle, a"#]
            #[doc = r#"DUPLICATE_FENCE error is raised."#]
            #[doc = r#""#]
            #[doc = r#"If the associated wl_surface was destroyed, a NO_SURFACE error is"#]
            #[doc = r#"raised."#]
            #[doc = r#""#]
            #[doc = r#"If at surface commit time the attached buffer does not support explicit"#]
            #[doc = r#"synchronization, an UNSUPPORTED_BUFFER error is raised."#]
            #[doc = r#""#]
            #[doc = r#"If at surface commit time there is no buffer attached, a NO_BUFFER"#]
            #[doc = r#"error is raised."#]
            async fn set_acquire_fence(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_acquire_fence: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()>;
            #[doc = r#"Create a listener for the release of the buffer attached by the"#]
            #[doc = r#"client with wl_surface.attach. See zwp_linux_buffer_release_v1"#]
            #[doc = r#"documentation for more information."#]
            #[doc = r#""#]
            #[doc = r#"The release object is double-buffered state, and will be associated"#]
            #[doc = r#"with the buffer that is attached to the surface at wl_surface.commit"#]
            #[doc = r#"time."#]
            #[doc = r#""#]
            #[doc = r#"If a zwp_linux_buffer_release_v1 object has already been requested for"#]
            #[doc = r#"the surface in the same commit cycle, a DUPLICATE_RELEASE error is"#]
            #[doc = r#"raised."#]
            #[doc = r#""#]
            #[doc = r#"If the associated wl_surface was destroyed, a NO_SURFACE error"#]
            #[doc = r#"is raised."#]
            #[doc = r#""#]
            #[doc = r#"If at surface commit time there is no buffer attached, a NO_BUFFER"#]
            #[doc = r#"error is raised."#]
            async fn get_release(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_release: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_linux_buffer_release_v1 {
        #[doc = r#"This object is instantiated in response to a"#]
        #[doc = r#"zwp_linux_surface_synchronization_v1.get_release request."#]
        #[doc = r#""#]
        #[doc = r#"It provides an alternative to wl_buffer.release events, providing a"#]
        #[doc = r#"unique release from a single wl_surface.commit request. The release event"#]
        #[doc = r#"also supports explicit synchronization, providing a fence FD for the"#]
        #[doc = r#"client to synchronize against."#]
        #[doc = r#""#]
        #[doc = r#"Exactly one event, either a fenced_release or an immediate_release, will"#]
        #[doc = r#"be emitted for the wl_surface.commit request. The compositor can choose"#]
        #[doc = r#"release by release which event it uses."#]
        #[doc = r#""#]
        #[doc = r#"This event does not replace wl_buffer.release events; servers are still"#]
        #[doc = r#"required to send those events."#]
        #[doc = r#""#]
        #[doc = r#"Once a buffer release object has delivered a 'fenced_release' or an"#]
        #[doc = r#"'immediate_release' event it is automatically destroyed."#]
        pub trait ZwpLinuxBufferReleaseV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_linux_buffer_release_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Sent when the compositor has finalised its usage of the associated"#]
            #[doc = r#"buffer for the relevant commit, providing a dma_fence which will be"#]
            #[doc = r#"signaled when all operations by the compositor on that buffer for that"#]
            #[doc = r#"commit have finished."#]
            #[doc = r#""#]
            #[doc = r#"Once the fence has signaled, and assuming the associated buffer is not"#]
            #[doc = r#"pending release from other wl_surface.commit requests, no additional"#]
            #[doc = r#"explicit or implicit synchronization is required to safely reuse or"#]
            #[doc = r#"destroy the buffer."#]
            #[doc = r#""#]
            #[doc = r#"This event destroys the zwp_linux_buffer_release_v1 object."#]
            async fn fenced_release(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                fence: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_buffer_release_v1#{}.fenced_release()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_fd(fence).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent when the compositor has finalised its usage of the associated"#]
            #[doc = r#"buffer for the relevant commit, and either performed no operations"#]
            #[doc = r#"using it, or has a guarantee that all its operations on that buffer for"#]
            #[doc = r#"that commit have finished."#]
            #[doc = r#""#]
            #[doc = r#"Once this event is received, and assuming the associated buffer is not"#]
            #[doc = r#"pending release from other wl_surface.commit requests, no additional"#]
            #[doc = r#"explicit or implicit synchronization is required to safely reuse or"#]
            #[doc = r#"destroy the buffer."#]
            #[doc = r#""#]
            #[doc = r#"This event destroys the zwp_linux_buffer_release_v1 object."#]
            async fn immediate_release(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_linux_buffer_release_v1#{}.immediate_release()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = r#"This protocol specifies a set of interfaces used for adding constraints to"#]
#[doc = r#"the motion of a pointer. Possible constraints include confining pointer"#]
#[doc = r#"motions to a given region, or locking it to its current position."#]
#[doc = r#""#]
#[doc = r#"In order to constrain the pointer, a client must first bind the global"#]
#[doc = r#"interface "wp_pointer_constraints" which, if a compositor supports pointer"#]
#[doc = r#"constraints, is exposed by the registry. Using the bound global object, the"#]
#[doc = r#"client uses the request that corresponds to the type of constraint it wants"#]
#[doc = r#"to make. See wp_pointer_constraints for more details."#]
#[doc = r#""#]
#[doc = r#"Warning! The protocol described in this file is experimental and backward"#]
#[doc = r#"incompatible changes may be made. Backward compatible changes may be added"#]
#[doc = r#"together with the corresponding interface version bump. Backward"#]
#[doc = r#"incompatible changes are done by bumping the version number in the protocol"#]
#[doc = r#"and interface names and resetting the interface version. Once the protocol"#]
#[doc = r#"is to be declared stable, the 'z' prefix and the version number in the"#]
#[doc = r#"protocol and interface names are removed and the interface version number is"#]
#[doc = r#"reset."#]
pub mod pointer_constraints_unstable_v1 {
    pub mod zwp_pointer_constraints_v1 {
        #[doc = r#"These errors can be emitted in response to wp_pointer_constraints"#]
        #[doc = r#"requests."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Pointer constraint already requested on that surface"#]
            AlreadyConstrained = 1,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::AlreadyConstrained),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"These values represent different lifetime semantics. They are passed"#]
        #[doc = r#"as arguments to the factory requests to specify how the constraint"#]
        #[doc = r#"lifetimes should be managed."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Lifetime {
            Oneshot = 1,
            Persistent = 2,
        }
        impl TryFrom<u32> for Lifetime {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::Oneshot),
                    2 => Ok(Self::Persistent),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"The global interface exposing pointer constraining functionality. It"#]
        #[doc = r#"exposes two requests: lock_pointer for locking the pointer to its"#]
        #[doc = r#"position, and confine_pointer for locking the pointer to a region."#]
        #[doc = r#""#]
        #[doc = r#"The lock_pointer and confine_pointer requests create the objects"#]
        #[doc = r#"wp_locked_pointer and wp_confined_pointer respectively, and the client can"#]
        #[doc = r#"use these objects to interact with the lock."#]
        #[doc = r#""#]
        #[doc = r#"For any surface, only one lock or confinement may be active across all"#]
        #[doc = r#"wl_pointer objects of the same seat. If a lock or confinement is requested"#]
        #[doc = r#"when another lock or confinement is active or requested on the same surface"#]
        #[doc = r#"and with any of the wl_pointer objects of the same seat, an"#]
        #[doc = r#"'already_constrained' error will be raised."#]
        pub trait ZwpPointerConstraintsV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_pointer_constraints_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_pointer_constraints_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("zwp_pointer_constraints_v1#{}.lock_pointer()", object.id);
                        self.lock_pointer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.object()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!(
                            "zwp_pointer_constraints_v1#{}.confine_pointer()",
                            object.id
                        );
                        self.confine_pointer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.object()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Used by the client to notify the server that it will no longer use this"#]
            #[doc = r#"pointer constraints object."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"The lock_pointer request lets the client request to disable movements of"#]
            #[doc = r#"the virtual pointer (i.e. the cursor), effectively locking the pointer"#]
            #[doc = r#"to a position. This request may not take effect immediately; in the"#]
            #[doc = r#"future, when the compositor deems implementation-specific constraints"#]
            #[doc = r#"are satisfied, the pointer lock will be activated and the compositor"#]
            #[doc = r#"sends a locked event."#]
            #[doc = r#""#]
            #[doc = r#"The protocol provides no guarantee that the constraints are ever"#]
            #[doc = r#"satisfied, and does not require the compositor to send an error if the"#]
            #[doc = r#"constraints cannot ever be satisfied. It is thus possible to request a"#]
            #[doc = r#"lock that will never activate."#]
            #[doc = r#""#]
            #[doc = r#"There may not be another pointer constraint of any kind requested or"#]
            #[doc = r#"active on the surface for any of the wl_pointer objects of the seat of"#]
            #[doc = r#"the passed pointer when requesting a lock. If there is, an error will be"#]
            #[doc = r#"raised. See general pointer lock documentation for more details."#]
            #[doc = r#""#]
            #[doc = r#"The intersection of the region passed with this request and the input"#]
            #[doc = r#"region of the surface is used to determine where the pointer must be"#]
            #[doc = r#"in order for the lock to activate. It is up to the compositor whether to"#]
            #[doc = r#"warp the pointer or require some kind of user interaction for the lock"#]
            #[doc = r#"to activate. If the region is null the surface input region is used."#]
            #[doc = r#""#]
            #[doc = r#"A surface may receive pointer focus without the lock being activated."#]
            #[doc = r#""#]
            #[doc = r#"The request creates a new object wp_locked_pointer which is used to"#]
            #[doc = r#"interact with the lock as well as receive updates about its state. See"#]
            #[doc = r#"the the description of wp_locked_pointer for further information."#]
            #[doc = r#""#]
            #[doc = r#"Note that while a pointer is locked, the wl_pointer objects of the"#]
            #[doc = r#"corresponding seat will not emit any wl_pointer.motion events, but"#]
            #[doc = r#"relative motion events will still be emitted via wp_relative_pointer"#]
            #[doc = r#"objects of the same seat. wl_pointer.axis and wl_pointer.button events"#]
            #[doc = r#"are unaffected."#]
            async fn lock_pointer(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                lock_pointer: crate::wire::ObjectId,
                lock_pointer: crate::wire::ObjectId,
                lock_pointer: crate::wire::ObjectId,
                lock_pointer: Option<crate::wire::ObjectId>,
                lock_pointer: Lifetime,
            ) -> crate::server::Result<()>;
            #[doc = r#"The confine_pointer request lets the client request to confine the"#]
            #[doc = r#"pointer cursor to a given region. This request may not take effect"#]
            #[doc = r#"immediately; in the future, when the compositor deems implementation-"#]
            #[doc = r#"specific constraints are satisfied, the pointer confinement will be"#]
            #[doc = r#"activated and the compositor sends a confined event."#]
            #[doc = r#""#]
            #[doc = r#"The intersection of the region passed with this request and the input"#]
            #[doc = r#"region of the surface is used to determine where the pointer must be"#]
            #[doc = r#"in order for the confinement to activate. It is up to the compositor"#]
            #[doc = r#"whether to warp the pointer or require some kind of user interaction for"#]
            #[doc = r#"the confinement to activate. If the region is null the surface input"#]
            #[doc = r#"region is used."#]
            #[doc = r#""#]
            #[doc = r#"The request will create a new object wp_confined_pointer which is used"#]
            #[doc = r#"to interact with the confinement as well as receive updates about its"#]
            #[doc = r#"state. See the the description of wp_confined_pointer for further"#]
            #[doc = r#"information."#]
            async fn confine_pointer(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                confine_pointer: crate::wire::ObjectId,
                confine_pointer: crate::wire::ObjectId,
                confine_pointer: crate::wire::ObjectId,
                confine_pointer: Option<crate::wire::ObjectId>,
                confine_pointer: Lifetime,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_locked_pointer_v1 {
        #[doc = r#"The wp_locked_pointer interface represents a locked pointer state."#]
        #[doc = r#""#]
        #[doc = r#"While the lock of this object is active, the wl_pointer objects of the"#]
        #[doc = r#"associated seat will not emit any wl_pointer.motion events."#]
        #[doc = r#""#]
        #[doc = r#"This object will send the event 'locked' when the lock is activated."#]
        #[doc = r#"Whenever the lock is activated, it is guaranteed that the locked surface"#]
        #[doc = r#"will already have received pointer focus and that the pointer will be"#]
        #[doc = r#"within the region passed to the request creating this object."#]
        #[doc = r#""#]
        #[doc = r#"To unlock the pointer, send the destroy request. This will also destroy"#]
        #[doc = r#"the wp_locked_pointer object."#]
        #[doc = r#""#]
        #[doc = r#"If the compositor decides to unlock the pointer the unlocked event is"#]
        #[doc = r#"sent. See wp_locked_pointer.unlock for details."#]
        #[doc = r#""#]
        #[doc = r#"When unlocking, the compositor may warp the cursor position to the set"#]
        #[doc = r#"cursor position hint. If it does, it will not result in any relative"#]
        #[doc = r#"motion events emitted via wp_relative_pointer."#]
        #[doc = r#""#]
        #[doc = r#"If the surface the lock was requested on is destroyed and the lock is not"#]
        #[doc = r#"yet activated, the wp_locked_pointer object is now defunct and must be"#]
        #[doc = r#"destroyed."#]
        pub trait ZwpLockedPointerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_locked_pointer_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_locked_pointer_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!(
                            "zwp_locked_pointer_v1#{}.set_cursor_position_hint()",
                            object.id
                        );
                        self.set_cursor_position_hint(
                            object,
                            client,
                            message.fixed()?,
                            message.fixed()?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("zwp_locked_pointer_v1#{}.set_region()", object.id);
                        self.set_region(object, client, message.object()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the locked pointer object. If applicable, the compositor will"#]
            #[doc = r#"unlock the pointer."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set the cursor position hint relative to the top left corner of the"#]
            #[doc = r#"surface."#]
            #[doc = r#""#]
            #[doc = r#"If the client is drawing its own cursor, it should update the position"#]
            #[doc = r#"hint to the position of its own cursor. A compositor may use this"#]
            #[doc = r#"information to warp the pointer upon unlock in order to avoid pointer"#]
            #[doc = r#"jumps."#]
            #[doc = r#""#]
            #[doc = r#"The cursor position hint is double buffered. The new hint will only take"#]
            #[doc = r#"effect when the associated surface gets it pending state applied. See"#]
            #[doc = r#"wl_surface.commit for details."#]
            async fn set_cursor_position_hint(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_cursor_position_hint: crate::wire::Fixed,
                set_cursor_position_hint: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set a new region used to lock the pointer."#]
            #[doc = r#""#]
            #[doc = r#"The new lock region is double-buffered. The new lock region will"#]
            #[doc = r#"only take effect when the associated surface gets its pending state"#]
            #[doc = r#"applied. See wl_surface.commit for details."#]
            #[doc = r#""#]
            #[doc = r#"For details about the lock region, see wp_locked_pointer."#]
            async fn set_region(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_region: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = r#"Notification that the pointer lock of the seat's pointer is activated."#]
            async fn locked(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_locked_pointer_v1#{}.locked()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notification that the pointer lock of the seat's pointer is no longer"#]
            #[doc = r#"active. If this is a oneshot pointer lock (see"#]
            #[doc = r#"wp_pointer_constraints.lifetime) this object is now defunct and should"#]
            #[doc = r#"be destroyed. If this is a persistent pointer lock (see"#]
            #[doc = r#"wp_pointer_constraints.lifetime) this pointer lock may again"#]
            #[doc = r#"reactivate in the future."#]
            async fn unlocked(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_locked_pointer_v1#{}.unlocked()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_confined_pointer_v1 {
        #[doc = r#"The wp_confined_pointer interface represents a confined pointer state."#]
        #[doc = r#""#]
        #[doc = r#"This object will send the event 'confined' when the confinement is"#]
        #[doc = r#"activated. Whenever the confinement is activated, it is guaranteed that"#]
        #[doc = r#"the surface the pointer is confined to will already have received pointer"#]
        #[doc = r#"focus and that the pointer will be within the region passed to the request"#]
        #[doc = r#"creating this object. It is up to the compositor to decide whether this"#]
        #[doc = r#"requires some user interaction and if the pointer will warp to within the"#]
        #[doc = r#"passed region if outside."#]
        #[doc = r#""#]
        #[doc = r#"To unconfine the pointer, send the destroy request. This will also destroy"#]
        #[doc = r#"the wp_confined_pointer object."#]
        #[doc = r#""#]
        #[doc = r#"If the compositor decides to unconfine the pointer the unconfined event is"#]
        #[doc = r#"sent. The wp_confined_pointer object is at this point defunct and should"#]
        #[doc = r#"be destroyed."#]
        pub trait ZwpConfinedPointerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_confined_pointer_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_confined_pointer_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("zwp_confined_pointer_v1#{}.set_region()", object.id);
                        self.set_region(object, client, message.object()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the confined pointer object. If applicable, the compositor will"#]
            #[doc = r#"unconfine the pointer."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set a new region used to confine the pointer."#]
            #[doc = r#""#]
            #[doc = r#"The new confine region is double-buffered. The new confine region will"#]
            #[doc = r#"only take effect when the associated surface gets its pending state"#]
            #[doc = r#"applied. See wl_surface.commit for details."#]
            #[doc = r#""#]
            #[doc = r#"If the confinement is active when the new confinement region is applied"#]
            #[doc = r#"and the pointer ends up outside of newly applied region, the pointer may"#]
            #[doc = r#"warped to a position within the new confinement region. If warped, a"#]
            #[doc = r#"wl_pointer.motion event will be emitted, but no"#]
            #[doc = r#"wp_relative_pointer.relative_motion event."#]
            #[doc = r#""#]
            #[doc = r#"The compositor may also, instead of using the new region, unconfine the"#]
            #[doc = r#"pointer."#]
            #[doc = r#""#]
            #[doc = r#"For details about the confine region, see wp_confined_pointer."#]
            async fn set_region(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_region: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = r#"Notification that the pointer confinement of the seat's pointer is"#]
            #[doc = r#"activated."#]
            async fn confined(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_confined_pointer_v1#{}.confined()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notification that the pointer confinement of the seat's pointer is no"#]
            #[doc = r#"longer active. If this is a oneshot pointer confinement (see"#]
            #[doc = r#"wp_pointer_constraints.lifetime) this object is now defunct and should"#]
            #[doc = r#"be destroyed. If this is a persistent pointer confinement (see"#]
            #[doc = r#"wp_pointer_constraints.lifetime) this pointer confinement may again"#]
            #[doc = r#"reactivate in the future."#]
            async fn unconfined(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_confined_pointer_v1#{}.unconfined()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod pointer_gestures_unstable_v1 {
    pub mod zwp_pointer_gestures_v1 {
        #[doc = r#"A global interface to provide semantic touchpad gestures for a given"#]
        #[doc = r#"pointer."#]
        #[doc = r#""#]
        #[doc = r#"Three gestures are currently supported: swipe, pinch, and hold."#]
        #[doc = r#"Pinch and swipe gestures follow a three-stage cycle: begin, update,"#]
        #[doc = r#"end, hold gestures follow a two-stage cycle: begin and end. All"#]
        #[doc = r#"gestures are identified by a unique id."#]
        #[doc = r#""#]
        #[doc = r#"Warning! The protocol described in this file is experimental and"#]
        #[doc = r#"backward incompatible changes may be made. Backward compatible changes"#]
        #[doc = r#"may be added together with the corresponding interface version bump."#]
        #[doc = r#"Backward incompatible changes are done by bumping the version number in"#]
        #[doc = r#"the protocol and interface names and resetting the interface version."#]
        #[doc = r#"Once the protocol is to be declared stable, the 'z' prefix and the"#]
        #[doc = r#"version number in the protocol and interface names are removed and the"#]
        #[doc = r#"interface version number is reset."#]
        pub trait ZwpPointerGesturesV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_pointer_gestures_v1";
            const VERSION: u32 = 3;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "zwp_pointer_gestures_v1#{}.get_swipe_gesture()",
                            object.id
                        );
                        self.get_swipe_gesture(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!(
                            "zwp_pointer_gestures_v1#{}.get_pinch_gesture()",
                            object.id
                        );
                        self.get_pinch_gesture(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("zwp_pointer_gestures_v1#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    3 => {
                        tracing::debug!("zwp_pointer_gestures_v1#{}.get_hold_gesture()", object.id);
                        self.get_hold_gesture(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Create a swipe gesture object. See the"#]
            #[doc = r#"wl_pointer_gesture_swipe interface for details."#]
            async fn get_swipe_gesture(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_swipe_gesture: crate::wire::ObjectId,
                get_swipe_gesture: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Create a pinch gesture object. See the"#]
            #[doc = r#"wl_pointer_gesture_pinch interface for details."#]
            async fn get_pinch_gesture(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_pinch_gesture: crate::wire::ObjectId,
                get_pinch_gesture: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Destroy the pointer gesture object. Swipe, pinch and hold objects"#]
            #[doc = r#"created via this gesture object remain valid."#]
            async fn release(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Create a hold gesture object. See the"#]
            #[doc = r#"wl_pointer_gesture_hold interface for details."#]
            async fn get_hold_gesture(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_hold_gesture: crate::wire::ObjectId,
                get_hold_gesture: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_pointer_gesture_swipe_v1 {
        #[doc = r#"A swipe gesture object notifies a client about a multi-finger swipe"#]
        #[doc = r#"gesture detected on an indirect input device such as a touchpad."#]
        #[doc = r#"The gesture is usually initiated by multiple fingers moving in the"#]
        #[doc = r#"same direction but once initiated the direction may change."#]
        #[doc = r#"The precise conditions of when such a gesture is detected are"#]
        #[doc = r#"implementation-dependent."#]
        #[doc = r#""#]
        #[doc = r#"A gesture consists of three stages: begin, update (optional) and end."#]
        #[doc = r#"There cannot be multiple simultaneous hold, pinch or swipe gestures on a"#]
        #[doc = r#"same pointer/seat, how compositors prevent these situations is"#]
        #[doc = r#"implementation-dependent."#]
        #[doc = r#""#]
        #[doc = r#"A gesture may be cancelled by the compositor or the hardware."#]
        #[doc = r#"Clients should not consider performing permanent or irreversible"#]
        #[doc = r#"actions until the end of a gesture has been received."#]
        pub trait ZwpPointerGestureSwipeV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_pointer_gesture_swipe_v1";
            const VERSION: u32 = 2;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_pointer_gesture_swipe_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event is sent when a multi-finger swipe gesture is detected"#]
            #[doc = r#"on the device."#]
            async fn begin(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                surface: crate::wire::ObjectId,
                fingers: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_pointer_gesture_swipe_v1#{}.begin()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(time)
                    .put_object(Some(surface))
                    .put_uint(fingers)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent when a multi-finger swipe gesture changes the"#]
            #[doc = r#"position of the logical center."#]
            #[doc = r#""#]
            #[doc = r#"The dx and dy coordinates are relative coordinates of the logical"#]
            #[doc = r#"center of the gesture compared to the previous event."#]
            async fn update(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                dx: crate::wire::Fixed,
                dy: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_pointer_gesture_swipe_v1#{}.update()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_fixed(dx)
                    .put_fixed(dy)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent when a multi-finger swipe gesture ceases to"#]
            #[doc = r#"be valid. This may happen when one or more fingers are lifted or"#]
            #[doc = r#"the gesture is cancelled."#]
            #[doc = r#""#]
            #[doc = r#"When a gesture is cancelled, the client should undo state changes"#]
            #[doc = r#"caused by this gesture. What causes a gesture to be cancelled is"#]
            #[doc = r#"implementation-dependent."#]
            async fn end(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                cancelled: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_pointer_gesture_swipe_v1#{}.end()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(time)
                    .put_int(cancelled)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_pointer_gesture_pinch_v1 {
        #[doc = r#"A pinch gesture object notifies a client about a multi-finger pinch"#]
        #[doc = r#"gesture detected on an indirect input device such as a touchpad."#]
        #[doc = r#"The gesture is usually initiated by multiple fingers moving towards"#]
        #[doc = r#"each other or away from each other, or by two or more fingers rotating"#]
        #[doc = r#"around a logical center of gravity. The precise conditions of when"#]
        #[doc = r#"such a gesture is detected are implementation-dependent."#]
        #[doc = r#""#]
        #[doc = r#"A gesture consists of three stages: begin, update (optional) and end."#]
        #[doc = r#"There cannot be multiple simultaneous hold, pinch or swipe gestures on a"#]
        #[doc = r#"same pointer/seat, how compositors prevent these situations is"#]
        #[doc = r#"implementation-dependent."#]
        #[doc = r#""#]
        #[doc = r#"A gesture may be cancelled by the compositor or the hardware."#]
        #[doc = r#"Clients should not consider performing permanent or irreversible"#]
        #[doc = r#"actions until the end of a gesture has been received."#]
        pub trait ZwpPointerGesturePinchV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_pointer_gesture_pinch_v1";
            const VERSION: u32 = 2;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_pointer_gesture_pinch_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event is sent when a multi-finger pinch gesture is detected"#]
            #[doc = r#"on the device."#]
            async fn begin(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                surface: crate::wire::ObjectId,
                fingers: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_pointer_gesture_pinch_v1#{}.begin()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(time)
                    .put_object(Some(surface))
                    .put_uint(fingers)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent when a multi-finger pinch gesture changes the"#]
            #[doc = r#"position of the logical center, the rotation or the relative scale."#]
            #[doc = r#""#]
            #[doc = r#"The dx and dy coordinates are relative coordinates in the"#]
            #[doc = r#"surface coordinate space of the logical center of the gesture."#]
            #[doc = r#""#]
            #[doc = r#"The scale factor is an absolute scale compared to the"#]
            #[doc = r#"pointer_gesture_pinch.begin event, e.g. a scale of 2 means the fingers"#]
            #[doc = r#"are now twice as far apart as on pointer_gesture_pinch.begin."#]
            #[doc = r#""#]
            #[doc = r#"The rotation is the relative angle in degrees clockwise compared to the previous"#]
            #[doc = r#"pointer_gesture_pinch.begin or pointer_gesture_pinch.update event."#]
            async fn update(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                dx: crate::wire::Fixed,
                dy: crate::wire::Fixed,
                scale: crate::wire::Fixed,
                rotation: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_pointer_gesture_pinch_v1#{}.update()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_fixed(dx)
                    .put_fixed(dy)
                    .put_fixed(scale)
                    .put_fixed(rotation)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent when a multi-finger pinch gesture ceases to"#]
            #[doc = r#"be valid. This may happen when one or more fingers are lifted or"#]
            #[doc = r#"the gesture is cancelled."#]
            #[doc = r#""#]
            #[doc = r#"When a gesture is cancelled, the client should undo state changes"#]
            #[doc = r#"caused by this gesture. What causes a gesture to be cancelled is"#]
            #[doc = r#"implementation-dependent."#]
            async fn end(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                cancelled: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_pointer_gesture_pinch_v1#{}.end()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(time)
                    .put_int(cancelled)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_pointer_gesture_hold_v1 {
        #[doc = r#"A hold gesture object notifies a client about a single- or"#]
        #[doc = r#"multi-finger hold gesture detected on an indirect input device such as"#]
        #[doc = r#"a touchpad. The gesture is usually initiated by one or more fingers"#]
        #[doc = r#"being held down without significant movement. The precise conditions"#]
        #[doc = r#"of when such a gesture is detected are implementation-dependent."#]
        #[doc = r#""#]
        #[doc = r#"In particular, this gesture may be used to cancel kinetic scrolling."#]
        #[doc = r#""#]
        #[doc = r#"A hold gesture consists of two stages: begin and end. Unlike pinch and"#]
        #[doc = r#"swipe there is no update stage."#]
        #[doc = r#"There cannot be multiple simultaneous hold, pinch or swipe gestures on a"#]
        #[doc = r#"same pointer/seat, how compositors prevent these situations is"#]
        #[doc = r#"implementation-dependent."#]
        #[doc = r#""#]
        #[doc = r#"A gesture may be cancelled by the compositor or the hardware."#]
        #[doc = r#"Clients should not consider performing permanent or irreversible"#]
        #[doc = r#"actions until the end of a gesture has been received."#]
        pub trait ZwpPointerGestureHoldV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_pointer_gesture_hold_v1";
            const VERSION: u32 = 3;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_pointer_gesture_hold_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event is sent when a hold gesture is detected on the device."#]
            async fn begin(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                surface: crate::wire::ObjectId,
                fingers: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_pointer_gesture_hold_v1#{}.begin()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(time)
                    .put_object(Some(surface))
                    .put_uint(fingers)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent when a hold gesture ceases to"#]
            #[doc = r#"be valid. This may happen when the holding fingers are lifted or"#]
            #[doc = r#"the gesture is cancelled, for example if the fingers move past an"#]
            #[doc = r#"implementation-defined threshold, the finger count changes or the hold"#]
            #[doc = r#"gesture changes into a different type of gesture."#]
            #[doc = r#""#]
            #[doc = r#"When a gesture is cancelled, the client may need to undo state changes"#]
            #[doc = r#"caused by this gesture. What causes a gesture to be cancelled is"#]
            #[doc = r#"implementation-dependent."#]
            async fn end(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                cancelled: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_pointer_gesture_hold_v1#{}.end()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(time)
                    .put_int(cancelled)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = r#"This protocol provides the ability to have a primary selection device to"#]
#[doc = r#"match that of the X server. This primary selection is a shortcut to the"#]
#[doc = r#"common clipboard selection, where text just needs to be selected in order"#]
#[doc = r#"to allow copying it elsewhere. The de facto way to perform this action"#]
#[doc = r#"is the middle mouse button, although it is not limited to this one."#]
#[doc = r#""#]
#[doc = r#"Clients wishing to honor primary selection should create a primary"#]
#[doc = r#"selection source and set it as the selection through"#]
#[doc = r#"wp_primary_selection_device.set_selection whenever the text selection"#]
#[doc = r#"changes. In order to minimize calls in pointer-driven text selection,"#]
#[doc = r#"it should happen only once after the operation finished. Similarly,"#]
#[doc = r#"a NULL source should be set when text is unselected."#]
#[doc = r#""#]
#[doc = r#"wp_primary_selection_offer objects are first announced through the"#]
#[doc = r#"wp_primary_selection_device.data_offer event. Immediately after this event,"#]
#[doc = r#"the primary data offer will emit wp_primary_selection_offer.offer events"#]
#[doc = r#"to let know of the mime types being offered."#]
#[doc = r#""#]
#[doc = r#"When the primary selection changes, the client with the keyboard focus"#]
#[doc = r#"will receive wp_primary_selection_device.selection events. Only the client"#]
#[doc = r#"with the keyboard focus will receive such events with a non-NULL"#]
#[doc = r#"wp_primary_selection_offer. Across keyboard focus changes, previously"#]
#[doc = r#"focused clients will receive wp_primary_selection_device.events with a"#]
#[doc = r#"NULL wp_primary_selection_offer."#]
#[doc = r#""#]
#[doc = r#"In order to request the primary selection data, the client must pass"#]
#[doc = r#"a recent serial pertaining to the press event that is triggering the"#]
#[doc = r#"operation, if the compositor deems the serial valid and recent, the"#]
#[doc = r#"wp_primary_selection_source.send event will happen in the other end"#]
#[doc = r#"to let the transfer begin. The client owning the primary selection"#]
#[doc = r#"should write the requested data, and close the file descriptor"#]
#[doc = r#"immediately."#]
#[doc = r#""#]
#[doc = r#"If the primary selection owner client disappeared during the transfer,"#]
#[doc = r#"the client reading the data will receive a"#]
#[doc = r#"wp_primary_selection_device.selection event with a NULL"#]
#[doc = r#"wp_primary_selection_offer, the client should take this as a hint"#]
#[doc = r#"to finish the reads related to the no longer existing offer."#]
#[doc = r#""#]
#[doc = r#"The primary selection owner should be checking for errors during"#]
#[doc = r#"writes, merely cancelling the ongoing transfer if any happened."#]
pub mod wp_primary_selection_unstable_v1 {
    pub mod zwp_primary_selection_device_manager_v1 {
        #[doc = r#"The primary selection device manager is a singleton global object that"#]
        #[doc = r#"provides access to the primary selection. It allows to create"#]
        #[doc = r#"wp_primary_selection_source objects, as well as retrieving the per-seat"#]
        #[doc = r#"wp_primary_selection_device objects."#]
        pub trait ZwpPrimarySelectionDeviceManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_primary_selection_device_manager_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "zwp_primary_selection_device_manager_v1#{}.create_source()",
                            object.id
                        );
                        self.create_source(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!(
                            "zwp_primary_selection_device_manager_v1#{}.get_device()",
                            object.id
                        );
                        self.get_device(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!(
                            "zwp_primary_selection_device_manager_v1#{}.destroy()",
                            object.id
                        );
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Create a new primary selection source."#]
            async fn create_source(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create_source: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Create a new data device for a given seat."#]
            async fn get_device(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_device: crate::wire::ObjectId,
                get_device: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Destroy the primary selection device manager."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_primary_selection_device_v1 {
        pub trait ZwpPrimarySelectionDeviceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_primary_selection_device_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "zwp_primary_selection_device_v1#{}.set_selection()",
                            object.id
                        );
                        self.set_selection(object, client, message.object()?, message.uint()?)
                            .await
                    }
                    1 => {
                        tracing::debug!("zwp_primary_selection_device_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Replaces the current selection. The previous owner of the primary"#]
            #[doc = r#"selection will receive a wp_primary_selection_source.cancelled event."#]
            #[doc = r#""#]
            #[doc = r#"To unset the selection, set the source to NULL."#]
            async fn set_selection(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_selection: Option<crate::wire::ObjectId>,
                set_selection: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Destroy the primary selection device."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Introduces a new wp_primary_selection_offer object that may be used"#]
            #[doc = r#"to receive the current primary selection. Immediately following this"#]
            #[doc = r#"event, the new wp_primary_selection_offer object will send"#]
            #[doc = r#"wp_primary_selection_offer.offer events to describe the offered mime"#]
            #[doc = r#"types."#]
            async fn data_offer(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                offer: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_primary_selection_device_v1#{}.data_offer()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(offer))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The wp_primary_selection_device.selection event is sent to notify the"#]
            #[doc = r#"client of a new primary selection. This event is sent after the"#]
            #[doc = r#"wp_primary_selection.data_offer event introducing this object, and after"#]
            #[doc = r#"the offer has announced its mimetypes through"#]
            #[doc = r#"wp_primary_selection_offer.offer."#]
            #[doc = r#""#]
            #[doc = r#"The data_offer is valid until a new offer or NULL is received"#]
            #[doc = r#"or until the client loses keyboard focus. The client must destroy the"#]
            #[doc = r#"previous selection data_offer, if any, upon receiving this event."#]
            async fn selection(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_primary_selection_device_v1#{}.selection()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_object(id).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_primary_selection_offer_v1 {
        #[doc = r#"A wp_primary_selection_offer represents an offer to transfer the contents"#]
        #[doc = r#"of the primary selection clipboard to the client. Similar to"#]
        #[doc = r#"wl_data_offer, the offer also describes the mime types that the data can"#]
        #[doc = r#"be converted to and provides the mechanisms for transferring the data"#]
        #[doc = r#"directly to the client."#]
        pub trait ZwpPrimarySelectionOfferV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_primary_selection_offer_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_primary_selection_offer_v1#{}.receive()", object.id);
                        self.receive(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.fd()?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwp_primary_selection_offer_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"To transfer the contents of the primary selection clipboard, the client"#]
            #[doc = r#"issues this request and indicates the mime type that it wants to"#]
            #[doc = r#"receive. The transfer happens through the passed file descriptor"#]
            #[doc = r#"(typically created with the pipe system call). The source client writes"#]
            #[doc = r#"the data in the mime type representation requested and then closes the"#]
            #[doc = r#"file descriptor."#]
            #[doc = r#""#]
            #[doc = r#"The receiving client reads from the read end of the pipe until EOF and"#]
            #[doc = r#"closes its end, at which point the transfer is complete."#]
            async fn receive(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                receive: String,
                receive: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()>;
            #[doc = r#"Destroy the primary selection offer."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Sent immediately after creating announcing the"#]
            #[doc = r#"wp_primary_selection_offer through"#]
            #[doc = r#"wp_primary_selection_device.data_offer. One event is sent per offered"#]
            #[doc = r#"mime type."#]
            async fn offer(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_primary_selection_offer_v1#{}.offer()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(mime_type))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_primary_selection_source_v1 {
        #[doc = r#"The source side of a wp_primary_selection_offer, it provides a way to"#]
        #[doc = r#"describe the offered data and respond to requests to transfer the"#]
        #[doc = r#"requested contents of the primary selection clipboard."#]
        pub trait ZwpPrimarySelectionSourceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_primary_selection_source_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_primary_selection_source_v1#{}.offer()", object.id);
                        self.offer(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwp_primary_selection_source_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"This request adds a mime type to the set of mime types advertised to"#]
            #[doc = r#"targets. Can be called several times to offer multiple types."#]
            async fn offer(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                offer: String,
            ) -> crate::server::Result<()>;
            #[doc = r#"Destroy the primary selection source."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Request for the current primary selection contents from the client."#]
            #[doc = r#"Send the specified mime type over the passed file descriptor, then"#]
            #[doc = r#"close it."#]
            async fn send(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
                fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_primary_selection_source_v1#{}.send()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(mime_type))
                    .put_fd(fd)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This primary selection source is no longer valid. The client should"#]
            #[doc = r#"clean up and destroy this primary selection source."#]
            async fn cancelled(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_primary_selection_source_v1#{}.cancelled()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = r#"This protocol specifies a set of interfaces used for making clients able to"#]
#[doc = r#"receive relative pointer events not obstructed by barriers (such as the"#]
#[doc = r#"monitor edge or other pointer barriers)."#]
#[doc = r#""#]
#[doc = r#"To start receiving relative pointer events, a client must first bind the"#]
#[doc = r#"global interface "wp_relative_pointer_manager" which, if a compositor"#]
#[doc = r#"supports relative pointer motion events, is exposed by the registry. After"#]
#[doc = r#"having created the relative pointer manager proxy object, the client uses"#]
#[doc = r#"it to create the actual relative pointer object using the"#]
#[doc = r#""get_relative_pointer" request given a wl_pointer. The relative pointer"#]
#[doc = r#"motion events will then, when applicable, be transmitted via the proxy of"#]
#[doc = r#"the newly created relative pointer object. See the documentation of the"#]
#[doc = r#"relative pointer interface for more details."#]
#[doc = r#""#]
#[doc = r#"Warning! The protocol described in this file is experimental and backward"#]
#[doc = r#"incompatible changes may be made. Backward compatible changes may be added"#]
#[doc = r#"together with the corresponding interface version bump. Backward"#]
#[doc = r#"incompatible changes are done by bumping the version number in the protocol"#]
#[doc = r#"and interface names and resetting the interface version. Once the protocol"#]
#[doc = r#"is to be declared stable, the 'z' prefix and the version number in the"#]
#[doc = r#"protocol and interface names are removed and the interface version number is"#]
#[doc = r#"reset."#]
pub mod relative_pointer_unstable_v1 {
    pub mod zwp_relative_pointer_manager_v1 {
        #[doc = r#"A global interface used for getting the relative pointer object for a"#]
        #[doc = r#"given pointer."#]
        pub trait ZwpRelativePointerManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_relative_pointer_manager_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_relative_pointer_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!(
                            "zwp_relative_pointer_manager_v1#{}.get_relative_pointer()",
                            object.id
                        );
                        self.get_relative_pointer(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Used by the client to notify the server that it will no longer use this"#]
            #[doc = r#"relative pointer manager object."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Create a relative pointer interface given a wl_pointer object. See the"#]
            #[doc = r#"wp_relative_pointer interface for more details."#]
            async fn get_relative_pointer(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_relative_pointer: crate::wire::ObjectId,
                get_relative_pointer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_relative_pointer_v1 {
        #[doc = r#"A wp_relative_pointer object is an extension to the wl_pointer interface"#]
        #[doc = r#"used for emitting relative pointer events. It shares the same focus as"#]
        #[doc = r#"wl_pointer objects of the same seat and will only emit events when it has"#]
        #[doc = r#"focus."#]
        pub trait ZwpRelativePointerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_relative_pointer_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_relative_pointer_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Relative x/y pointer motion from the pointer of the seat associated with"#]
            #[doc = r#"this object."#]
            #[doc = r#""#]
            #[doc = r#"A relative motion is in the same dimension as regular wl_pointer motion"#]
            #[doc = r#"events, except they do not represent an absolute position. For example,"#]
            #[doc = r#"moving a pointer from (x, y) to (x', y') would have the equivalent"#]
            #[doc = r#"relative motion (x' - x, y' - y). If a pointer motion caused the"#]
            #[doc = r#"absolute pointer position to be clipped by for example the edge of the"#]
            #[doc = r#"monitor, the relative motion is unaffected by the clipping and will"#]
            #[doc = r#"represent the unclipped motion."#]
            #[doc = r#""#]
            #[doc = r#"This event also contains non-accelerated motion deltas. The"#]
            #[doc = r#"non-accelerated delta is, when applicable, the regular pointer motion"#]
            #[doc = r#"delta as it was before having applied motion acceleration and other"#]
            #[doc = r#"transformations such as normalization."#]
            #[doc = r#""#]
            #[doc = r#"Note that the non-accelerated delta does not represent 'raw' events as"#]
            #[doc = r#"they were read from some device. Pointer motion acceleration is device-"#]
            #[doc = r#"and configuration-specific and non-accelerated deltas and accelerated"#]
            #[doc = r#"deltas may have the same value on some devices."#]
            #[doc = r#""#]
            #[doc = r#"Relative motions are not coupled to wl_pointer.motion events, and can be"#]
            #[doc = r#"sent in combination with such events, but also independently. There may"#]
            #[doc = r#"also be scenarios where wl_pointer.motion is sent, but there is no"#]
            #[doc = r#"relative motion. The order of an absolute and relative motion event"#]
            #[doc = r#"originating from the same physical motion is not guaranteed."#]
            #[doc = r#""#]
            #[doc = r#"If the client needs button events or focus state, it can receive them"#]
            #[doc = r#"from a wl_pointer object of the same seat that the wp_relative_pointer"#]
            #[doc = r#"object is associated with."#]
            async fn relative_motion(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                utime_hi: u32,
                utime_lo: u32,
                dx: crate::wire::Fixed,
                dy: crate::wire::Fixed,
                dx_unaccel: crate::wire::Fixed,
                dy_unaccel: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_relative_pointer_v1#{}.relative_motion()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(utime_hi)
                    .put_uint(utime_lo)
                    .put_fixed(dx)
                    .put_fixed(dy)
                    .put_fixed(dx_unaccel)
                    .put_fixed(dy_unaccel)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = r#"This description provides a high-level overview of the interplay between"#]
#[doc = r#"the interfaces defined this protocol. For details, see the protocol"#]
#[doc = r#"specification."#]
#[doc = r#""#]
#[doc = r#"More than one tablet may exist, and device-specifics matter. Tablets are"#]
#[doc = r#"not represented by a single virtual device like wl_pointer. A client"#]
#[doc = r#"binds to the tablet manager object which is just a proxy object. From"#]
#[doc = r#"that, the client requests wp_tablet_manager.get_tablet_seat(wl_seat)"#]
#[doc = r#"and that returns the actual interface that has all the tablets. With"#]
#[doc = r#"this indirection, we can avoid merging wp_tablet into the actual Wayland"#]
#[doc = r#"protocol, a long-term benefit."#]
#[doc = r#""#]
#[doc = r#"The wp_tablet_seat sends a "tablet added" event for each tablet"#]
#[doc = r#"connected. That event is followed by descriptive events about the"#]
#[doc = r#"hardware; currently that includes events for name, vid/pid and"#]
#[doc = r#"a wp_tablet.path event that describes a local path. This path can be"#]
#[doc = r#"used to uniquely identify a tablet or get more information through"#]
#[doc = r#"libwacom. Emulated or nested tablets can skip any of those, e.g. a"#]
#[doc = r#"virtual tablet may not have a vid/pid. The sequence of descriptive"#]
#[doc = r#"events is terminated by a wp_tablet.done event to signal that a client"#]
#[doc = r#"may now finalize any initialization for that tablet."#]
#[doc = r#""#]
#[doc = r#"Events from tablets require a tool in proximity. Tools are also managed"#]
#[doc = r#"by the tablet seat; a "tool added" event is sent whenever a tool is new"#]
#[doc = r#"to the compositor. That event is followed by a number of descriptive"#]
#[doc = r#"events about the hardware; currently that includes capabilities,"#]
#[doc = r#"hardware id and serial number, and tool type. Similar to the tablet"#]
#[doc = r#"interface, a wp_tablet_tool.done event is sent to terminate that initial"#]
#[doc = r#"sequence."#]
#[doc = r#""#]
#[doc = r#"Any event from a tool happens on the wp_tablet_tool interface. When the"#]
#[doc = r#"tool gets into proximity of the tablet, a proximity_in event is sent on"#]
#[doc = r#"the wp_tablet_tool interface, listing the tablet and the surface. That"#]
#[doc = r#"event is followed by a motion event with the coordinates. After that,"#]
#[doc = r#"it's the usual motion, axis, button, etc. events. The protocol's"#]
#[doc = r#"serialisation means events are grouped by wp_tablet_tool.frame events."#]
#[doc = r#""#]
#[doc = r#"Two special events (that don't exist in X) are down and up. They signal"#]
#[doc = r#""tip touching the surface". For tablets without real proximity"#]
#[doc = r#"detection, the sequence is: proximity_in, motion, down, frame."#]
#[doc = r#""#]
#[doc = r#"When the tool leaves proximity, a proximity_out event is sent. If any"#]
#[doc = r#"button is still down, a button release event is sent before this"#]
#[doc = r#"proximity event. These button events are sent in the same frame as the"#]
#[doc = r#"proximity event to signal to the client that the buttons were held when"#]
#[doc = r#"the tool left proximity."#]
#[doc = r#""#]
#[doc = r#"If the tool moves out of the surface but stays in proximity (i.e."#]
#[doc = r#"between windows), compositor-specific grab policies apply. This usually"#]
#[doc = r#"means that the proximity-out is delayed until all buttons are released."#]
#[doc = r#""#]
#[doc = r#"Moving a tool physically from one tablet to the other has no real effect"#]
#[doc = r#"on the protocol, since we already have the tool object from the "tool"#]
#[doc = r#"added" event. All the information is already there and the proximity"#]
#[doc = r#"events on both tablets are all a client needs to reconstruct what"#]
#[doc = r#"happened."#]
#[doc = r#""#]
#[doc = r#"Some extra axes are normalized, i.e. the client knows the range as"#]
#[doc = r#"specified in the protocol (e.g. [0, 65535]), the granularity however is"#]
#[doc = r#"unknown. The current normalized axes are pressure, distance, and slider."#]
#[doc = r#""#]
#[doc = r#"Other extra axes are in physical units as specified in the protocol."#]
#[doc = r#"The current extra axes with physical units are tilt, rotation and"#]
#[doc = r#"wheel rotation."#]
#[doc = r#""#]
#[doc = r#"Since tablets work independently of the pointer controlled by the mouse,"#]
#[doc = r#"the focus handling is independent too and controlled by proximity."#]
#[doc = r#"The wp_tablet_tool.set_cursor request sets a tool-specific cursor."#]
#[doc = r#"This cursor surface may be the same as the mouse cursor, and it may be"#]
#[doc = r#"the same across tools but it is possible to be more fine-grained. For"#]
#[doc = r#"example, a client may set different cursors for the pen and eraser."#]
#[doc = r#""#]
#[doc = r#"Tools are generally independent of tablets and it is"#]
#[doc = r#"compositor-specific policy when a tool can be removed. Common approaches"#]
#[doc = r#"will likely include some form of removing a tool when all tablets the"#]
#[doc = r#"tool was used on are removed."#]
#[doc = r#""#]
#[doc = r#"Warning! The protocol described in this file is experimental and"#]
#[doc = r#"backward incompatible changes may be made. Backward compatible changes"#]
#[doc = r#"may be added together with the corresponding interface version bump."#]
#[doc = r#"Backward incompatible changes are done by bumping the version number in"#]
#[doc = r#"the protocol and interface names and resetting the interface version."#]
#[doc = r#"Once the protocol is to be declared stable, the 'z' prefix and the"#]
#[doc = r#"version number in the protocol and interface names are removed and the"#]
#[doc = r#"interface version number is reset."#]
pub mod tablet_unstable_v1 {
    pub mod zwp_tablet_manager_v1 {
        #[doc = r#"An object that provides access to the graphics tablets available on this"#]
        #[doc = r#"system. All tablets are associated with a seat, to get access to the"#]
        #[doc = r#"actual tablets, use wp_tablet_manager.get_tablet_seat."#]
        pub trait ZwpTabletManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_manager_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_tablet_manager_v1#{}.get_tablet_seat()", object.id);
                        self.get_tablet_seat(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwp_tablet_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Get the wp_tablet_seat object for the given seat. This object"#]
            #[doc = r#"provides access to all graphics tablets in this seat."#]
            async fn get_tablet_seat(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_tablet_seat: crate::wire::ObjectId,
                get_tablet_seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Destroy the wp_tablet_manager object. Objects created from this"#]
            #[doc = r#"object are unaffected and should be destroyed separately."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_tablet_seat_v1 {
        #[doc = r#"An object that provides access to the graphics tablets available on this"#]
        #[doc = r#"seat. After binding to this interface, the compositor sends a set of"#]
        #[doc = r#"wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events."#]
        pub trait ZwpTabletSeatV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_seat_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_tablet_seat_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the wp_tablet_seat object. Objects created from this"#]
            #[doc = r#"object are unaffected and should be destroyed separately."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event is sent whenever a new tablet becomes available on this"#]
            #[doc = r#"seat. This event only provides the object id of the tablet, any"#]
            #[doc = r#"static information about the tablet (device name, vid/pid, etc.) is"#]
            #[doc = r#"sent through the wp_tablet interface."#]
            async fn tablet_added(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_seat_v1#{}.tablet_added()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent whenever a tool that has not previously been used"#]
            #[doc = r#"with a tablet comes into use. This event only provides the object id"#]
            #[doc = r#"of the tool; any static information about the tool (capabilities,"#]
            #[doc = r#"type, etc.) is sent through the wp_tablet_tool interface."#]
            async fn tool_added(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_seat_v1#{}.tool_added()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_tablet_tool_v1 {
        #[doc = r#"Describes the physical type of a tool. The physical type of a tool"#]
        #[doc = r#"generally defines its base usage."#]
        #[doc = r#""#]
        #[doc = r#"The mouse tool represents a mouse-shaped tool that is not a relative"#]
        #[doc = r#"device but bound to the tablet's surface, providing absolute"#]
        #[doc = r#"coordinates."#]
        #[doc = r#""#]
        #[doc = r#"The lens tool is a mouse-shaped tool with an attached lens to"#]
        #[doc = r#"provide precision focus."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Type {
            #[doc = r#"Pen"#]
            Pen = 0x140,
            #[doc = r#"Eraser"#]
            Eraser = 0x141,
            #[doc = r#"Brush"#]
            Brush = 0x142,
            #[doc = r#"Pencil"#]
            Pencil = 0x143,
            #[doc = r#"Airbrush"#]
            Airbrush = 0x144,
            #[doc = r#"Finger"#]
            Finger = 0x145,
            #[doc = r#"Mouse"#]
            Mouse = 0x146,
            #[doc = r#"Lens"#]
            Lens = 0x147,
        }
        impl TryFrom<u32> for Type {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0x140 => Ok(Self::Pen),
                    0x141 => Ok(Self::Eraser),
                    0x142 => Ok(Self::Brush),
                    0x143 => Ok(Self::Pencil),
                    0x144 => Ok(Self::Airbrush),
                    0x145 => Ok(Self::Finger),
                    0x146 => Ok(Self::Mouse),
                    0x147 => Ok(Self::Lens),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"Describes extra capabilities on a tablet."#]
        #[doc = r#""#]
        #[doc = r#"Any tool must provide x and y values, extra axes are"#]
        #[doc = r#"device-specific."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Capability {
            #[doc = r#"Tilt axes"#]
            Tilt = 1,
            #[doc = r#"Pressure axis"#]
            Pressure = 2,
            #[doc = r#"Distance axis"#]
            Distance = 3,
            #[doc = r#"Z-rotation axis"#]
            Rotation = 4,
            #[doc = r#"Slider axis"#]
            Slider = 5,
            #[doc = r#"Wheel axis"#]
            Wheel = 6,
        }
        impl TryFrom<u32> for Capability {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::Tilt),
                    2 => Ok(Self::Pressure),
                    3 => Ok(Self::Distance),
                    4 => Ok(Self::Rotation),
                    5 => Ok(Self::Slider),
                    6 => Ok(Self::Wheel),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"Describes the physical state of a button that produced the button event."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ButtonState {
            #[doc = r#"Button is not pressed"#]
            Released = 0,
            #[doc = r#"Button is pressed"#]
            Pressed = 1,
        }
        impl TryFrom<u32> for ButtonState {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Released),
                    1 => Ok(Self::Pressed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Given wl_surface has another role"#]
            Role = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Role),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"An object that represents a physical tool that has been, or is"#]
        #[doc = r#"currently in use with a tablet in this seat. Each wp_tablet_tool"#]
        #[doc = r#"object stays valid until the client destroys it; the compositor"#]
        #[doc = r#"reuses the wp_tablet_tool object to indicate that the object's"#]
        #[doc = r#"respective physical tool has come into proximity of a tablet again."#]
        #[doc = r#""#]
        #[doc = r#"A wp_tablet_tool object's relation to a physical tool depends on the"#]
        #[doc = r#"tablet's ability to report serial numbers. If the tablet supports"#]
        #[doc = r#"this capability, then the object represents a specific physical tool"#]
        #[doc = r#"and can be identified even when used on multiple tablets."#]
        #[doc = r#""#]
        #[doc = r#"A tablet tool has a number of static characteristics, e.g. tool type,"#]
        #[doc = r#"hardware_serial and capabilities. These capabilities are sent in an"#]
        #[doc = r#"event sequence after the wp_tablet_seat.tool_added event before any"#]
        #[doc = r#"actual events from this tool. This initial event sequence is"#]
        #[doc = r#"terminated by a wp_tablet_tool.done event."#]
        #[doc = r#""#]
        #[doc = r#"Tablet tool events are grouped by wp_tablet_tool.frame events."#]
        #[doc = r#"Any events received before a wp_tablet_tool.frame event should be"#]
        #[doc = r#"considered part of the same hardware state change."#]
        pub trait ZwpTabletToolV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_tool_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_tablet_tool_v1#{}.set_cursor()", object.id);
                        self.set_cursor(
                            object,
                            client,
                            message.uint()?,
                            message.object()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwp_tablet_tool_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Sets the surface of the cursor used for this tool on the given"#]
            #[doc = r#"tablet. This request only takes effect if the tool is in proximity"#]
            #[doc = r#"of one of the requesting client's surfaces or the surface parameter"#]
            #[doc = r#"is the current pointer surface. If there was a previous surface set"#]
            #[doc = r#"with this request it is replaced. If surface is NULL, the cursor"#]
            #[doc = r#"image is hidden."#]
            #[doc = r#""#]
            #[doc = r#"The parameters hotspot_x and hotspot_y define the position of the"#]
            #[doc = r#"pointer surface relative to the pointer location. Its top-left corner"#]
            #[doc = r#"is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the"#]
            #[doc = r#"coordinates of the pointer location, in surface-local coordinates."#]
            #[doc = r#""#]
            #[doc = r#"On surface.attach requests to the pointer surface, hotspot_x and"#]
            #[doc = r#"hotspot_y are decremented by the x and y parameters passed to the"#]
            #[doc = r#"request. Attach must be confirmed by wl_surface.commit as usual."#]
            #[doc = r#""#]
            #[doc = r#"The hotspot can also be updated by passing the currently set pointer"#]
            #[doc = r#"surface to this request with new values for hotspot_x and hotspot_y."#]
            #[doc = r#""#]
            #[doc = r#"The current and pending input regions of the wl_surface are cleared,"#]
            #[doc = r#"and wl_surface.set_input_region is ignored until the wl_surface is no"#]
            #[doc = r#"longer used as the cursor. When the use as a cursor ends, the current"#]
            #[doc = r#"and pending input regions become undefined, and the wl_surface is"#]
            #[doc = r#"unmapped."#]
            #[doc = r#""#]
            #[doc = r#"This request gives the surface the role of a cursor. The role"#]
            #[doc = r#"assigned by this request is the same as assigned by"#]
            #[doc = r#"wl_pointer.set_cursor meaning the same surface can be"#]
            #[doc = r#"used both as a wl_pointer cursor and a wp_tablet cursor. If the"#]
            #[doc = r#"surface already has another role, it raises a protocol error."#]
            #[doc = r#"The surface may be used on multiple tablets and across multiple"#]
            #[doc = r#"seats."#]
            async fn set_cursor(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_cursor: u32,
                set_cursor: Option<crate::wire::ObjectId>,
                set_cursor: i32,
                set_cursor: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"This destroys the client's resource for this tool object."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"The tool type is the high-level type of the tool and usually decides"#]
            #[doc = r#"the interaction expected from this tool."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_tool.done event."#]
            async fn r#type(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                tool_type: Type,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.type()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(tool_type as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"If the physical tool can be identified by a unique 64-bit serial"#]
            #[doc = r#"number, this event notifies the client of this serial number."#]
            #[doc = r#""#]
            #[doc = r#"If multiple tablets are available in the same seat and the tool is"#]
            #[doc = r#"uniquely identifiable by the serial number, that tool may move"#]
            #[doc = r#"between tablets."#]
            #[doc = r#""#]
            #[doc = r#"Otherwise, if the tool has no serial number and this event is"#]
            #[doc = r#"missing, the tool is tied to the tablet it first comes into"#]
            #[doc = r#"proximity with. Even if the physical tool is used on multiple"#]
            #[doc = r#"tablets, separate wp_tablet_tool objects will be created, one per"#]
            #[doc = r#"tablet."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_tool.done event."#]
            async fn hardware_serial(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                hardware_serial_hi: u32,
                hardware_serial_lo: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.hardware_serial()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(hardware_serial_hi)
                    .put_uint(hardware_serial_lo)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event notifies the client of a hardware id available on this tool."#]
            #[doc = r#""#]
            #[doc = r#"The hardware id is a device-specific 64-bit id that provides extra"#]
            #[doc = r#"information about the tool in use, beyond the wl_tool.type"#]
            #[doc = r#"enumeration. The format of the id is specific to tablets made by"#]
            #[doc = r#"Wacom Inc. For example, the hardware id of a Wacom Grip"#]
            #[doc = r#"Pen (a stylus) is 0x802."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_tool.done event."#]
            async fn hardware_id_wacom(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                hardware_id_hi: u32,
                hardware_id_lo: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.hardware_id_wacom()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(hardware_id_hi)
                    .put_uint(hardware_id_lo)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event notifies the client of any capabilities of this tool,"#]
            #[doc = r#"beyond the main set of x/y axes and tip up/down detection."#]
            #[doc = r#""#]
            #[doc = r#"One event is sent for each extra capability available on this tool."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_tool.done event."#]
            async fn capability(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                capability: Capability,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.capability()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(capability as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event signals the end of the initial burst of descriptive"#]
            #[doc = r#"events. A client may consider the static description of the tool to"#]
            #[doc = r#"be complete and finalize initialization of the tool."#]
            async fn done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent when the tool is removed from the system and will"#]
            #[doc = r#"send no further events. Should the physical tool come back into"#]
            #[doc = r#"proximity later, a new wp_tablet_tool object will be created."#]
            #[doc = r#""#]
            #[doc = r#"It is compositor-dependent when a tool is removed. A compositor may"#]
            #[doc = r#"remove a tool on proximity out, tablet removal or any other reason."#]
            #[doc = r#"A compositor may also keep a tool alive until shutdown."#]
            #[doc = r#""#]
            #[doc = r#"If the tool is currently in proximity, a proximity_out event will be"#]
            #[doc = r#"sent before the removed event. See wp_tablet_tool.proximity_out for"#]
            #[doc = r#"the handling of any buttons logically down."#]
            #[doc = r#""#]
            #[doc = r#"When this event is received, the client must wp_tablet_tool.destroy"#]
            #[doc = r#"the object."#]
            async fn removed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.removed()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 5, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notification that this tool is focused on a certain surface."#]
            #[doc = r#""#]
            #[doc = r#"This event can be received when the tool has moved from one surface to"#]
            #[doc = r#"another, or when the tool has come back into proximity above the"#]
            #[doc = r#"surface."#]
            #[doc = r#""#]
            #[doc = r#"If any button is logically down when the tool comes into proximity,"#]
            #[doc = r#"the respective button event is sent after the proximity_in event but"#]
            #[doc = r#"within the same frame as the proximity_in event."#]
            async fn proximity_in(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                tablet: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.proximity_in()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(tablet))
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 6, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notification that this tool has either left proximity, or is no"#]
            #[doc = r#"longer focused on a certain surface."#]
            #[doc = r#""#]
            #[doc = r#"When the tablet tool leaves proximity of the tablet, button release"#]
            #[doc = r#"events are sent for each button that was held down at the time of"#]
            #[doc = r#"leaving proximity. These events are sent before the proximity_out"#]
            #[doc = r#"event but within the same wp_tablet.frame."#]
            #[doc = r#""#]
            #[doc = r#"If the tool stays within proximity of the tablet, but the focus"#]
            #[doc = r#"changes from one surface to another, a button release event may not"#]
            #[doc = r#"be sent until the button is actually released or the tool leaves the"#]
            #[doc = r#"proximity of the tablet."#]
            async fn proximity_out(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.proximity_out()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 7, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the tablet tool comes in contact with the surface of the"#]
            #[doc = r#"tablet."#]
            #[doc = r#""#]
            #[doc = r#"If the tool is already in contact with the tablet when entering the"#]
            #[doc = r#"input region, the client owning said region will receive a"#]
            #[doc = r#"wp_tablet.proximity_in event, followed by a wp_tablet.down"#]
            #[doc = r#"event and a wp_tablet.frame event."#]
            #[doc = r#""#]
            #[doc = r#"Note that this event describes logical contact, not physical"#]
            #[doc = r#"contact. On some devices, a compositor may not consider a tool in"#]
            #[doc = r#"logical contact until a minimum physical pressure threshold is"#]
            #[doc = r#"exceeded."#]
            async fn down(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.down()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 8, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the tablet tool stops making contact with the surface of"#]
            #[doc = r#"the tablet, or when the tablet tool moves out of the input region"#]
            #[doc = r#"and the compositor grab (if any) is dismissed."#]
            #[doc = r#""#]
            #[doc = r#"If the tablet tool moves out of the input region while in contact"#]
            #[doc = r#"with the surface of the tablet and the compositor does not have an"#]
            #[doc = r#"ongoing grab on the surface, the client owning said region will"#]
            #[doc = r#"receive a wp_tablet.up event, followed by a wp_tablet.proximity_out"#]
            #[doc = r#"event and a wp_tablet.frame event. If the compositor has an ongoing"#]
            #[doc = r#"grab on this device, this event sequence is sent whenever the grab"#]
            #[doc = r#"is dismissed in the future."#]
            #[doc = r#""#]
            #[doc = r#"Note that this event describes logical contact, not physical"#]
            #[doc = r#"contact. On some devices, a compositor may not consider a tool out"#]
            #[doc = r#"of logical contact until physical pressure falls below a specific"#]
            #[doc = r#"threshold."#]
            async fn up(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.up()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 9, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever a tablet tool moves."#]
            async fn motion(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: crate::wire::Fixed,
                y: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.motion()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fixed(x)
                    .put_fixed(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 10, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the pressure axis on a tool changes. The value of this"#]
            #[doc = r#"event is normalized to a value between 0 and 65535."#]
            #[doc = r#""#]
            #[doc = r#"Note that pressure may be nonzero even when a tool is not in logical"#]
            #[doc = r#"contact. See the down and up events for more details."#]
            async fn pressure(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                pressure: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.pressure()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(pressure)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 11, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the distance axis on a tool changes. The value of this"#]
            #[doc = r#"event is normalized to a value between 0 and 65535."#]
            #[doc = r#""#]
            #[doc = r#"Note that distance may be nonzero even when a tool is not in logical"#]
            #[doc = r#"contact. See the down and up events for more details."#]
            async fn distance(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                distance: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.distance()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(distance)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 12, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever one or both of the tilt axes on a tool change. Each tilt"#]
            #[doc = r#"value is in 0.01 of a degree, relative to the z-axis of the tablet."#]
            #[doc = r#"The angle is positive when the top of a tool tilts along the"#]
            #[doc = r#"positive x or y axis."#]
            async fn tilt(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                tilt_x: i32,
                tilt_y: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.tilt()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(tilt_x)
                    .put_int(tilt_y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 13, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the z-rotation axis on the tool changes. The"#]
            #[doc = r#"rotation value is in 0.01 of a degree clockwise from the tool's"#]
            #[doc = r#"logical neutral position."#]
            async fn rotation(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                degrees: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.rotation()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(degrees).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 14, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the slider position on the tool changes. The"#]
            #[doc = r#"value is normalized between -65535 and 65535, with 0 as the logical"#]
            #[doc = r#"neutral position of the slider."#]
            #[doc = r#""#]
            #[doc = r#"The slider is available on e.g. the Wacom Airbrush tool."#]
            async fn slider(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                position: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.slider()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(position).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 15, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the wheel on the tool emits an event. This event"#]
            #[doc = r#"contains two values for the same axis change. The degrees value is"#]
            #[doc = r#"in 0.01 of a degree in the same orientation as the"#]
            #[doc = r#"wl_pointer.vertical_scroll axis. The clicks value is in discrete"#]
            #[doc = r#"logical clicks of the mouse wheel. This value may be zero if the"#]
            #[doc = r#"movement of the wheel was less than one logical click."#]
            #[doc = r#""#]
            #[doc = r#"Clients should choose either value and avoid mixing degrees and"#]
            #[doc = r#"clicks. The compositor may accumulate values smaller than a logical"#]
            #[doc = r#"click and emulate click events when a certain threshold is met."#]
            #[doc = r#"Thus, wl_tablet_tool.wheel events with non-zero clicks values may"#]
            #[doc = r#"have different degrees values."#]
            async fn wheel(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                degrees: i32,
                clicks: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.wheel()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(degrees)
                    .put_int(clicks)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever a button on the tool is pressed or released."#]
            #[doc = r#""#]
            #[doc = r#"If a button is held down when the tool moves in or out of proximity,"#]
            #[doc = r#"button events are generated by the compositor. See"#]
            #[doc = r#"wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for"#]
            #[doc = r#"details."#]
            async fn button(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                button: u32,
                state: ButtonState,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.button()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(button)
                    .put_uint(state as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 17, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Marks the end of a series of axis and/or button updates from the"#]
            #[doc = r#"tablet. The Wayland protocol requires axis updates to be sent"#]
            #[doc = r#"sequentially, however all events within a frame should be considered"#]
            #[doc = r#"one hardware event."#]
            async fn frame(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v1#{}.frame()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(time).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 18, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_tablet_v1 {
        #[doc = r#"The wp_tablet interface represents one graphics tablet device. The"#]
        #[doc = r#"tablet interface itself does not generate events; all events are"#]
        #[doc = r#"generated by wp_tablet_tool objects when in proximity above a tablet."#]
        #[doc = r#""#]
        #[doc = r#"A tablet has a number of static characteristics, e.g. device name and"#]
        #[doc = r#"pid/vid. These capabilities are sent in an event sequence after the"#]
        #[doc = r#"wp_tablet_seat.tablet_added event. This initial event sequence is"#]
        #[doc = r#"terminated by a wp_tablet.done event."#]
        pub trait ZwpTabletV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_tablet_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"This destroys the client's resource for this tablet object."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet.done event."#]
            async fn name(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v1#{}.name()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(name))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet.done event."#]
            async fn id(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                vid: u32,
                pid: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v1#{}.id()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(vid)
                    .put_uint(pid)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"A system-specific device path that indicates which device is behind"#]
            #[doc = r#"this wp_tablet. This information may be used to gather additional"#]
            #[doc = r#"information about the device, e.g. through libwacom."#]
            #[doc = r#""#]
            #[doc = r#"A device may have more than one device path. If so, multiple"#]
            #[doc = r#"wp_tablet.path events are sent. A device may be emulated and not"#]
            #[doc = r#"have a device path, and in that case this event will not be sent."#]
            #[doc = r#""#]
            #[doc = r#"The format of the path is unspecified, it may be a device node, a"#]
            #[doc = r#"sysfs path, or some other identifier. It is up to the client to"#]
            #[doc = r#"identify the string provided."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet.done event."#]
            async fn path(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                path: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v1#{}.path()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(path))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent immediately to signal the end of the initial"#]
            #[doc = r#"burst of descriptive events. A client may consider the static"#]
            #[doc = r#"description of the tablet to be complete and finalize initialization"#]
            #[doc = r#"of the tablet."#]
            async fn done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v1#{}.done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent when the tablet has been removed from the system. When a tablet"#]
            #[doc = r#"is removed, some tools may be removed."#]
            #[doc = r#""#]
            #[doc = r#"When this event is received, the client must wp_tablet.destroy"#]
            #[doc = r#"the object."#]
            async fn removed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v1#{}.removed()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = r#"This description provides a high-level overview of the interplay between"#]
#[doc = r#"the interfaces defined this protocol. For details, see the protocol"#]
#[doc = r#"specification."#]
#[doc = r#""#]
#[doc = r#"More than one tablet may exist, and device-specifics matter. Tablets are"#]
#[doc = r#"not represented by a single virtual device like wl_pointer. A client"#]
#[doc = r#"binds to the tablet manager object which is just a proxy object. From"#]
#[doc = r#"that, the client requests wp_tablet_manager.get_tablet_seat(wl_seat)"#]
#[doc = r#"and that returns the actual interface that has all the tablets. With"#]
#[doc = r#"this indirection, we can avoid merging wp_tablet into the actual Wayland"#]
#[doc = r#"protocol, a long-term benefit."#]
#[doc = r#""#]
#[doc = r#"The wp_tablet_seat sends a "tablet added" event for each tablet"#]
#[doc = r#"connected. That event is followed by descriptive events about the"#]
#[doc = r#"hardware; currently that includes events for name, vid/pid and"#]
#[doc = r#"a wp_tablet.path event that describes a local path. This path can be"#]
#[doc = r#"used to uniquely identify a tablet or get more information through"#]
#[doc = r#"libwacom. Emulated or nested tablets can skip any of those, e.g. a"#]
#[doc = r#"virtual tablet may not have a vid/pid. The sequence of descriptive"#]
#[doc = r#"events is terminated by a wp_tablet.done event to signal that a client"#]
#[doc = r#"may now finalize any initialization for that tablet."#]
#[doc = r#""#]
#[doc = r#"Events from tablets require a tool in proximity. Tools are also managed"#]
#[doc = r#"by the tablet seat; a "tool added" event is sent whenever a tool is new"#]
#[doc = r#"to the compositor. That event is followed by a number of descriptive"#]
#[doc = r#"events about the hardware; currently that includes capabilities,"#]
#[doc = r#"hardware id and serial number, and tool type. Similar to the tablet"#]
#[doc = r#"interface, a wp_tablet_tool.done event is sent to terminate that initial"#]
#[doc = r#"sequence."#]
#[doc = r#""#]
#[doc = r#"Any event from a tool happens on the wp_tablet_tool interface. When the"#]
#[doc = r#"tool gets into proximity of the tablet, a proximity_in event is sent on"#]
#[doc = r#"the wp_tablet_tool interface, listing the tablet and the surface. That"#]
#[doc = r#"event is followed by a motion event with the coordinates. After that,"#]
#[doc = r#"it's the usual motion, axis, button, etc. events. The protocol's"#]
#[doc = r#"serialisation means events are grouped by wp_tablet_tool.frame events."#]
#[doc = r#""#]
#[doc = r#"Two special events (that don't exist in X) are down and up. They signal"#]
#[doc = r#""tip touching the surface". For tablets without real proximity"#]
#[doc = r#"detection, the sequence is: proximity_in, motion, down, frame."#]
#[doc = r#""#]
#[doc = r#"When the tool leaves proximity, a proximity_out event is sent. If any"#]
#[doc = r#"button is still down, a button release event is sent before this"#]
#[doc = r#"proximity event. These button events are sent in the same frame as the"#]
#[doc = r#"proximity event to signal to the client that the buttons were held when"#]
#[doc = r#"the tool left proximity."#]
#[doc = r#""#]
#[doc = r#"If the tool moves out of the surface but stays in proximity (i.e."#]
#[doc = r#"between windows), compositor-specific grab policies apply. This usually"#]
#[doc = r#"means that the proximity-out is delayed until all buttons are released."#]
#[doc = r#""#]
#[doc = r#"Moving a tool physically from one tablet to the other has no real effect"#]
#[doc = r#"on the protocol, since we already have the tool object from the "tool"#]
#[doc = r#"added" event. All the information is already there and the proximity"#]
#[doc = r#"events on both tablets are all a client needs to reconstruct what"#]
#[doc = r#"happened."#]
#[doc = r#""#]
#[doc = r#"Some extra axes are normalized, i.e. the client knows the range as"#]
#[doc = r#"specified in the protocol (e.g. [0, 65535]), the granularity however is"#]
#[doc = r#"unknown. The current normalized axes are pressure, distance, and slider."#]
#[doc = r#""#]
#[doc = r#"Other extra axes are in physical units as specified in the protocol."#]
#[doc = r#"The current extra axes with physical units are tilt, rotation and"#]
#[doc = r#"wheel rotation."#]
#[doc = r#""#]
#[doc = r#"Since tablets work independently of the pointer controlled by the mouse,"#]
#[doc = r#"the focus handling is independent too and controlled by proximity."#]
#[doc = r#"The wp_tablet_tool.set_cursor request sets a tool-specific cursor."#]
#[doc = r#"This cursor surface may be the same as the mouse cursor, and it may be"#]
#[doc = r#"the same across tools but it is possible to be more fine-grained. For"#]
#[doc = r#"example, a client may set different cursors for the pen and eraser."#]
#[doc = r#""#]
#[doc = r#"Tools are generally independent of tablets and it is"#]
#[doc = r#"compositor-specific policy when a tool can be removed. Common approaches"#]
#[doc = r#"will likely include some form of removing a tool when all tablets the"#]
#[doc = r#"tool was used on are removed."#]
#[doc = r#""#]
#[doc = r#"Disclaimer: This protocol extension has been marked stable. This copy is"#]
#[doc = r#"no longer used and only retained for backwards compatibility. The"#]
#[doc = r#"canonical version can be found in the stable/ directory."#]
pub mod tablet_unstable_v2 {
    pub mod zwp_tablet_manager_v2 {
        #[doc = r#"An object that provides access to the graphics tablets available on this"#]
        #[doc = r#"system. All tablets are associated with a seat, to get access to the"#]
        #[doc = r#"actual tablets, use wp_tablet_manager.get_tablet_seat."#]
        pub trait ZwpTabletManagerV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_manager_v2";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_tablet_manager_v2#{}.get_tablet_seat()", object.id);
                        self.get_tablet_seat(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwp_tablet_manager_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Get the wp_tablet_seat object for the given seat. This object"#]
            #[doc = r#"provides access to all graphics tablets in this seat."#]
            async fn get_tablet_seat(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_tablet_seat: crate::wire::ObjectId,
                get_tablet_seat: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Destroy the wp_tablet_manager object. Objects created from this"#]
            #[doc = r#"object are unaffected and should be destroyed separately."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwp_tablet_seat_v2 {
        #[doc = r#"An object that provides access to the graphics tablets available on this"#]
        #[doc = r#"seat. After binding to this interface, the compositor sends a set of"#]
        #[doc = r#"wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events."#]
        pub trait ZwpTabletSeatV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_seat_v2";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_tablet_seat_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the wp_tablet_seat object. Objects created from this"#]
            #[doc = r#"object are unaffected and should be destroyed separately."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event is sent whenever a new tablet becomes available on this"#]
            #[doc = r#"seat. This event only provides the object id of the tablet, any"#]
            #[doc = r#"static information about the tablet (device name, vid/pid, etc.) is"#]
            #[doc = r#"sent through the wp_tablet interface."#]
            async fn tablet_added(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_seat_v2#{}.tablet_added()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent whenever a tool that has not previously been used"#]
            #[doc = r#"with a tablet comes into use. This event only provides the object id"#]
            #[doc = r#"of the tool; any static information about the tool (capabilities,"#]
            #[doc = r#"type, etc.) is sent through the wp_tablet_tool interface."#]
            async fn tool_added(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_seat_v2#{}.tool_added()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent whenever a new pad is known to the system. Typically,"#]
            #[doc = r#"pads are physically attached to tablets and a pad_added event is"#]
            #[doc = r#"sent immediately after the wp_tablet_seat.tablet_added."#]
            #[doc = r#"However, some standalone pad devices logically attach to tablets at"#]
            #[doc = r#"runtime, and the client must wait for wp_tablet_pad.enter to know"#]
            #[doc = r#"the tablet a pad is attached to."#]
            #[doc = r#""#]
            #[doc = r#"This event only provides the object id of the pad. All further"#]
            #[doc = r#"features (buttons, strips, rings) are sent through the wp_tablet_pad"#]
            #[doc = r#"interface."#]
            async fn pad_added(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_seat_v2#{}.pad_added()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_tablet_tool_v2 {
        #[doc = r#"Describes the physical type of a tool. The physical type of a tool"#]
        #[doc = r#"generally defines its base usage."#]
        #[doc = r#""#]
        #[doc = r#"The mouse tool represents a mouse-shaped tool that is not a relative"#]
        #[doc = r#"device but bound to the tablet's surface, providing absolute"#]
        #[doc = r#"coordinates."#]
        #[doc = r#""#]
        #[doc = r#"The lens tool is a mouse-shaped tool with an attached lens to"#]
        #[doc = r#"provide precision focus."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Type {
            #[doc = r#"Pen"#]
            Pen = 0x140,
            #[doc = r#"Eraser"#]
            Eraser = 0x141,
            #[doc = r#"Brush"#]
            Brush = 0x142,
            #[doc = r#"Pencil"#]
            Pencil = 0x143,
            #[doc = r#"Airbrush"#]
            Airbrush = 0x144,
            #[doc = r#"Finger"#]
            Finger = 0x145,
            #[doc = r#"Mouse"#]
            Mouse = 0x146,
            #[doc = r#"Lens"#]
            Lens = 0x147,
        }
        impl TryFrom<u32> for Type {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0x140 => Ok(Self::Pen),
                    0x141 => Ok(Self::Eraser),
                    0x142 => Ok(Self::Brush),
                    0x143 => Ok(Self::Pencil),
                    0x144 => Ok(Self::Airbrush),
                    0x145 => Ok(Self::Finger),
                    0x146 => Ok(Self::Mouse),
                    0x147 => Ok(Self::Lens),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"Describes extra capabilities on a tablet."#]
        #[doc = r#""#]
        #[doc = r#"Any tool must provide x and y values, extra axes are"#]
        #[doc = r#"device-specific."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Capability {
            #[doc = r#"Tilt axes"#]
            Tilt = 1,
            #[doc = r#"Pressure axis"#]
            Pressure = 2,
            #[doc = r#"Distance axis"#]
            Distance = 3,
            #[doc = r#"Z-rotation axis"#]
            Rotation = 4,
            #[doc = r#"Slider axis"#]
            Slider = 5,
            #[doc = r#"Wheel axis"#]
            Wheel = 6,
        }
        impl TryFrom<u32> for Capability {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::Tilt),
                    2 => Ok(Self::Pressure),
                    3 => Ok(Self::Distance),
                    4 => Ok(Self::Rotation),
                    5 => Ok(Self::Slider),
                    6 => Ok(Self::Wheel),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"Describes the physical state of a button that produced the button event."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ButtonState {
            #[doc = r#"Button is not pressed"#]
            Released = 0,
            #[doc = r#"Button is pressed"#]
            Pressed = 1,
        }
        impl TryFrom<u32> for ButtonState {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Released),
                    1 => Ok(Self::Pressed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Given wl_surface has another role"#]
            Role = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Role),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"An object that represents a physical tool that has been, or is"#]
        #[doc = r#"currently in use with a tablet in this seat. Each wp_tablet_tool"#]
        #[doc = r#"object stays valid until the client destroys it; the compositor"#]
        #[doc = r#"reuses the wp_tablet_tool object to indicate that the object's"#]
        #[doc = r#"respective physical tool has come into proximity of a tablet again."#]
        #[doc = r#""#]
        #[doc = r#"A wp_tablet_tool object's relation to a physical tool depends on the"#]
        #[doc = r#"tablet's ability to report serial numbers. If the tablet supports"#]
        #[doc = r#"this capability, then the object represents a specific physical tool"#]
        #[doc = r#"and can be identified even when used on multiple tablets."#]
        #[doc = r#""#]
        #[doc = r#"A tablet tool has a number of static characteristics, e.g. tool type,"#]
        #[doc = r#"hardware_serial and capabilities. These capabilities are sent in an"#]
        #[doc = r#"event sequence after the wp_tablet_seat.tool_added event before any"#]
        #[doc = r#"actual events from this tool. This initial event sequence is"#]
        #[doc = r#"terminated by a wp_tablet_tool.done event."#]
        #[doc = r#""#]
        #[doc = r#"Tablet tool events are grouped by wp_tablet_tool.frame events."#]
        #[doc = r#"Any events received before a wp_tablet_tool.frame event should be"#]
        #[doc = r#"considered part of the same hardware state change."#]
        pub trait ZwpTabletToolV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_tool_v2";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_tablet_tool_v2#{}.set_cursor()", object.id);
                        self.set_cursor(
                            object,
                            client,
                            message.uint()?,
                            message.object()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwp_tablet_tool_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Sets the surface of the cursor used for this tool on the given"#]
            #[doc = r#"tablet. This request only takes effect if the tool is in proximity"#]
            #[doc = r#"of one of the requesting client's surfaces or the surface parameter"#]
            #[doc = r#"is the current pointer surface. If there was a previous surface set"#]
            #[doc = r#"with this request it is replaced. If surface is NULL, the cursor"#]
            #[doc = r#"image is hidden."#]
            #[doc = r#""#]
            #[doc = r#"The parameters hotspot_x and hotspot_y define the position of the"#]
            #[doc = r#"pointer surface relative to the pointer location. Its top-left corner"#]
            #[doc = r#"is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the"#]
            #[doc = r#"coordinates of the pointer location, in surface-local coordinates."#]
            #[doc = r#""#]
            #[doc = r#"On surface.attach requests to the pointer surface, hotspot_x and"#]
            #[doc = r#"hotspot_y are decremented by the x and y parameters passed to the"#]
            #[doc = r#"request. Attach must be confirmed by wl_surface.commit as usual."#]
            #[doc = r#""#]
            #[doc = r#"The hotspot can also be updated by passing the currently set pointer"#]
            #[doc = r#"surface to this request with new values for hotspot_x and hotspot_y."#]
            #[doc = r#""#]
            #[doc = r#"The current and pending input regions of the wl_surface are cleared,"#]
            #[doc = r#"and wl_surface.set_input_region is ignored until the wl_surface is no"#]
            #[doc = r#"longer used as the cursor. When the use as a cursor ends, the current"#]
            #[doc = r#"and pending input regions become undefined, and the wl_surface is"#]
            #[doc = r#"unmapped."#]
            #[doc = r#""#]
            #[doc = r#"This request gives the surface the role of a wp_tablet_tool cursor. A"#]
            #[doc = r#"surface may only ever be used as the cursor surface for one"#]
            #[doc = r#"wp_tablet_tool. If the surface already has another role or has"#]
            #[doc = r#"previously been used as cursor surface for a different tool, a"#]
            #[doc = r#"protocol error is raised."#]
            async fn set_cursor(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_cursor: u32,
                set_cursor: Option<crate::wire::ObjectId>,
                set_cursor: i32,
                set_cursor: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"This destroys the client's resource for this tool object."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"The tool type is the high-level type of the tool and usually decides"#]
            #[doc = r#"the interaction expected from this tool."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_tool.done event."#]
            async fn r#type(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                tool_type: Type,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.type()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(tool_type as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"If the physical tool can be identified by a unique 64-bit serial"#]
            #[doc = r#"number, this event notifies the client of this serial number."#]
            #[doc = r#""#]
            #[doc = r#"If multiple tablets are available in the same seat and the tool is"#]
            #[doc = r#"uniquely identifiable by the serial number, that tool may move"#]
            #[doc = r#"between tablets."#]
            #[doc = r#""#]
            #[doc = r#"Otherwise, if the tool has no serial number and this event is"#]
            #[doc = r#"missing, the tool is tied to the tablet it first comes into"#]
            #[doc = r#"proximity with. Even if the physical tool is used on multiple"#]
            #[doc = r#"tablets, separate wp_tablet_tool objects will be created, one per"#]
            #[doc = r#"tablet."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_tool.done event."#]
            async fn hardware_serial(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                hardware_serial_hi: u32,
                hardware_serial_lo: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.hardware_serial()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(hardware_serial_hi)
                    .put_uint(hardware_serial_lo)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event notifies the client of a hardware id available on this tool."#]
            #[doc = r#""#]
            #[doc = r#"The hardware id is a device-specific 64-bit id that provides extra"#]
            #[doc = r#"information about the tool in use, beyond the wl_tool.type"#]
            #[doc = r#"enumeration. The format of the id is specific to tablets made by"#]
            #[doc = r#"Wacom Inc. For example, the hardware id of a Wacom Grip"#]
            #[doc = r#"Pen (a stylus) is 0x802."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_tool.done event."#]
            async fn hardware_id_wacom(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                hardware_id_hi: u32,
                hardware_id_lo: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.hardware_id_wacom()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(hardware_id_hi)
                    .put_uint(hardware_id_lo)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event notifies the client of any capabilities of this tool,"#]
            #[doc = r#"beyond the main set of x/y axes and tip up/down detection."#]
            #[doc = r#""#]
            #[doc = r#"One event is sent for each extra capability available on this tool."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_tool.done event."#]
            async fn capability(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                capability: Capability,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.capability()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(capability as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event signals the end of the initial burst of descriptive"#]
            #[doc = r#"events. A client may consider the static description of the tool to"#]
            #[doc = r#"be complete and finalize initialization of the tool."#]
            async fn done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent when the tool is removed from the system and will"#]
            #[doc = r#"send no further events. Should the physical tool come back into"#]
            #[doc = r#"proximity later, a new wp_tablet_tool object will be created."#]
            #[doc = r#""#]
            #[doc = r#"It is compositor-dependent when a tool is removed. A compositor may"#]
            #[doc = r#"remove a tool on proximity out, tablet removal or any other reason."#]
            #[doc = r#"A compositor may also keep a tool alive until shutdown."#]
            #[doc = r#""#]
            #[doc = r#"If the tool is currently in proximity, a proximity_out event will be"#]
            #[doc = r#"sent before the removed event. See wp_tablet_tool.proximity_out for"#]
            #[doc = r#"the handling of any buttons logically down."#]
            #[doc = r#""#]
            #[doc = r#"When this event is received, the client must wp_tablet_tool.destroy"#]
            #[doc = r#"the object."#]
            async fn removed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.removed()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 5, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notification that this tool is focused on a certain surface."#]
            #[doc = r#""#]
            #[doc = r#"This event can be received when the tool has moved from one surface to"#]
            #[doc = r#"another, or when the tool has come back into proximity above the"#]
            #[doc = r#"surface."#]
            #[doc = r#""#]
            #[doc = r#"If any button is logically down when the tool comes into proximity,"#]
            #[doc = r#"the respective button event is sent after the proximity_in event but"#]
            #[doc = r#"within the same frame as the proximity_in event."#]
            async fn proximity_in(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                tablet: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.proximity_in()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(tablet))
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 6, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notification that this tool has either left proximity, or is no"#]
            #[doc = r#"longer focused on a certain surface."#]
            #[doc = r#""#]
            #[doc = r#"When the tablet tool leaves proximity of the tablet, button release"#]
            #[doc = r#"events are sent for each button that was held down at the time of"#]
            #[doc = r#"leaving proximity. These events are sent before the proximity_out"#]
            #[doc = r#"event but within the same wp_tablet.frame."#]
            #[doc = r#""#]
            #[doc = r#"If the tool stays within proximity of the tablet, but the focus"#]
            #[doc = r#"changes from one surface to another, a button release event may not"#]
            #[doc = r#"be sent until the button is actually released or the tool leaves the"#]
            #[doc = r#"proximity of the tablet."#]
            async fn proximity_out(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.proximity_out()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 7, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the tablet tool comes in contact with the surface of the"#]
            #[doc = r#"tablet."#]
            #[doc = r#""#]
            #[doc = r#"If the tool is already in contact with the tablet when entering the"#]
            #[doc = r#"input region, the client owning said region will receive a"#]
            #[doc = r#"wp_tablet.proximity_in event, followed by a wp_tablet.down"#]
            #[doc = r#"event and a wp_tablet.frame event."#]
            #[doc = r#""#]
            #[doc = r#"Note that this event describes logical contact, not physical"#]
            #[doc = r#"contact. On some devices, a compositor may not consider a tool in"#]
            #[doc = r#"logical contact until a minimum physical pressure threshold is"#]
            #[doc = r#"exceeded."#]
            async fn down(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.down()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 8, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the tablet tool stops making contact with the surface of"#]
            #[doc = r#"the tablet, or when the tablet tool moves out of the input region"#]
            #[doc = r#"and the compositor grab (if any) is dismissed."#]
            #[doc = r#""#]
            #[doc = r#"If the tablet tool moves out of the input region while in contact"#]
            #[doc = r#"with the surface of the tablet and the compositor does not have an"#]
            #[doc = r#"ongoing grab on the surface, the client owning said region will"#]
            #[doc = r#"receive a wp_tablet.up event, followed by a wp_tablet.proximity_out"#]
            #[doc = r#"event and a wp_tablet.frame event. If the compositor has an ongoing"#]
            #[doc = r#"grab on this device, this event sequence is sent whenever the grab"#]
            #[doc = r#"is dismissed in the future."#]
            #[doc = r#""#]
            #[doc = r#"Note that this event describes logical contact, not physical"#]
            #[doc = r#"contact. On some devices, a compositor may not consider a tool out"#]
            #[doc = r#"of logical contact until physical pressure falls below a specific"#]
            #[doc = r#"threshold."#]
            async fn up(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.up()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 9, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever a tablet tool moves."#]
            async fn motion(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: crate::wire::Fixed,
                y: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.motion()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fixed(x)
                    .put_fixed(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 10, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the pressure axis on a tool changes. The value of this"#]
            #[doc = r#"event is normalized to a value between 0 and 65535."#]
            #[doc = r#""#]
            #[doc = r#"Note that pressure may be nonzero even when a tool is not in logical"#]
            #[doc = r#"contact. See the down and up events for more details."#]
            async fn pressure(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                pressure: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.pressure()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(pressure)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 11, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the distance axis on a tool changes. The value of this"#]
            #[doc = r#"event is normalized to a value between 0 and 65535."#]
            #[doc = r#""#]
            #[doc = r#"Note that distance may be nonzero even when a tool is not in logical"#]
            #[doc = r#"contact. See the down and up events for more details."#]
            async fn distance(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                distance: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.distance()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(distance)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 12, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever one or both of the tilt axes on a tool change. Each tilt"#]
            #[doc = r#"value is in degrees, relative to the z-axis of the tablet."#]
            #[doc = r#"The angle is positive when the top of a tool tilts along the"#]
            #[doc = r#"positive x or y axis."#]
            async fn tilt(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                tilt_x: crate::wire::Fixed,
                tilt_y: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.tilt()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fixed(tilt_x)
                    .put_fixed(tilt_y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 13, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the z-rotation axis on the tool changes. The"#]
            #[doc = r#"rotation value is in degrees clockwise from the tool's"#]
            #[doc = r#"logical neutral position."#]
            async fn rotation(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                degrees: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.rotation()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fixed(degrees)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 14, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the slider position on the tool changes. The"#]
            #[doc = r#"value is normalized between -65535 and 65535, with 0 as the logical"#]
            #[doc = r#"neutral position of the slider."#]
            #[doc = r#""#]
            #[doc = r#"The slider is available on e.g. the Wacom Airbrush tool."#]
            async fn slider(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                position: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.slider()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(position).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 15, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the wheel on the tool emits an event. This event"#]
            #[doc = r#"contains two values for the same axis change. The degrees value is"#]
            #[doc = r#"in the same orientation as the wl_pointer.vertical_scroll axis. The"#]
            #[doc = r#"clicks value is in discrete logical clicks of the mouse wheel. This"#]
            #[doc = r#"value may be zero if the movement of the wheel was less"#]
            #[doc = r#"than one logical click."#]
            #[doc = r#""#]
            #[doc = r#"Clients should choose either value and avoid mixing degrees and"#]
            #[doc = r#"clicks. The compositor may accumulate values smaller than a logical"#]
            #[doc = r#"click and emulate click events when a certain threshold is met."#]
            #[doc = r#"Thus, wl_tablet_tool.wheel events with non-zero clicks values may"#]
            #[doc = r#"have different degrees values."#]
            async fn wheel(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                degrees: crate::wire::Fixed,
                clicks: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.wheel()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fixed(degrees)
                    .put_int(clicks)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 16, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever a button on the tool is pressed or released."#]
            #[doc = r#""#]
            #[doc = r#"If a button is held down when the tool moves in or out of proximity,"#]
            #[doc = r#"button events are generated by the compositor. See"#]
            #[doc = r#"wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for"#]
            #[doc = r#"details."#]
            async fn button(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                button: u32,
                state: ButtonState,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.button()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(button)
                    .put_uint(state as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 17, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Marks the end of a series of axis and/or button updates from the"#]
            #[doc = r#"tablet. The Wayland protocol requires axis updates to be sent"#]
            #[doc = r#"sequentially, however all events within a frame should be considered"#]
            #[doc = r#"one hardware event."#]
            async fn frame(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_tool_v2#{}.frame()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(time).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 18, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_tablet_v2 {
        #[doc = r#"The wp_tablet interface represents one graphics tablet device. The"#]
        #[doc = r#"tablet interface itself does not generate events; all events are"#]
        #[doc = r#"generated by wp_tablet_tool objects when in proximity above a tablet."#]
        #[doc = r#""#]
        #[doc = r#"A tablet has a number of static characteristics, e.g. device name and"#]
        #[doc = r#"pid/vid. These capabilities are sent in an event sequence after the"#]
        #[doc = r#"wp_tablet_seat.tablet_added event. This initial event sequence is"#]
        #[doc = r#"terminated by a wp_tablet.done event."#]
        pub trait ZwpTabletV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_v2";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_tablet_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"This destroys the client's resource for this tablet object."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"A descriptive name for the tablet device."#]
            #[doc = r#""#]
            #[doc = r#"If the device has no descriptive name, this event is not sent."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet.done event."#]
            async fn name(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v2#{}.name()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(name))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The USB vendor and product IDs for the tablet device."#]
            #[doc = r#""#]
            #[doc = r#"If the device has no USB vendor/product ID, this event is not sent."#]
            #[doc = r#"This can happen for virtual devices or non-USB devices, for instance."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet.done event."#]
            async fn id(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                vid: u32,
                pid: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v2#{}.id()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(vid)
                    .put_uint(pid)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"A system-specific device path that indicates which device is behind"#]
            #[doc = r#"this wp_tablet. This information may be used to gather additional"#]
            #[doc = r#"information about the device, e.g. through libwacom."#]
            #[doc = r#""#]
            #[doc = r#"A device may have more than one device path. If so, multiple"#]
            #[doc = r#"wp_tablet.path events are sent. A device may be emulated and not"#]
            #[doc = r#"have a device path, and in that case this event will not be sent."#]
            #[doc = r#""#]
            #[doc = r#"The format of the path is unspecified, it may be a device node, a"#]
            #[doc = r#"sysfs path, or some other identifier. It is up to the client to"#]
            #[doc = r#"identify the string provided."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet.done event."#]
            async fn path(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                path: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v2#{}.path()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(path))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent immediately to signal the end of the initial"#]
            #[doc = r#"burst of descriptive events. A client may consider the static"#]
            #[doc = r#"description of the tablet to be complete and finalize initialization"#]
            #[doc = r#"of the tablet."#]
            async fn done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v2#{}.done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent when the tablet has been removed from the system. When a tablet"#]
            #[doc = r#"is removed, some tools may be removed."#]
            #[doc = r#""#]
            #[doc = r#"When this event is received, the client must wp_tablet.destroy"#]
            #[doc = r#"the object."#]
            async fn removed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_v2#{}.removed()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_tablet_pad_ring_v2 {
        #[doc = r#"Describes the source types for ring events. This indicates to the"#]
        #[doc = r#"client how a ring event was physically generated; a client may"#]
        #[doc = r#"adjust the user interface accordingly. For example, events"#]
        #[doc = r#"from a "finger" source may trigger kinetic scrolling."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Source {
            #[doc = r#"Finger"#]
            Finger = 1,
        }
        impl TryFrom<u32> for Source {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::Finger),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"A circular interaction area, such as the touch ring on the Wacom Intuos"#]
        #[doc = r#"Pro series tablets."#]
        #[doc = r#""#]
        #[doc = r#"Events on a ring are logically grouped by the wl_tablet_pad_ring.frame"#]
        #[doc = r#"event."#]
        pub trait ZwpTabletPadRingV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_ring_v2";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_tablet_pad_ring_v2#{}.set_feedback()", object.id);
                        self.set_feedback(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwp_tablet_pad_ring_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Request that the compositor use the provided feedback string"#]
            #[doc = r#"associated with this ring. This request should be issued immediately"#]
            #[doc = r#"after a wp_tablet_pad_group.mode_switch event from the corresponding"#]
            #[doc = r#"group is received, or whenever the ring is mapped to a different"#]
            #[doc = r#"action. See wp_tablet_pad_group.mode_switch for more details."#]
            #[doc = r#""#]
            #[doc = r#"Clients are encouraged to provide context-aware descriptions for"#]
            #[doc = r#"the actions associated with the ring; compositors may use this"#]
            #[doc = r#"information to offer visual feedback about the button layout"#]
            #[doc = r#"(eg. on-screen displays)."#]
            #[doc = r#""#]
            #[doc = r#"The provided string 'description' is a UTF-8 encoded string to be"#]
            #[doc = r#"associated with this ring, and is considered user-visible; general"#]
            #[doc = r#"internationalization rules apply."#]
            #[doc = r#""#]
            #[doc = r#"The serial argument will be that of the last"#]
            #[doc = r#"wp_tablet_pad_group.mode_switch event received for the group of this"#]
            #[doc = r#"ring. Requests providing other serials than the most recent one will be"#]
            #[doc = r#"ignored."#]
            async fn set_feedback(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_feedback: String,
                set_feedback: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"This destroys the client's resource for this ring object."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Source information for ring events."#]
            #[doc = r#""#]
            #[doc = r#"This event does not occur on its own. It is sent before a"#]
            #[doc = r#"wp_tablet_pad_ring.frame event and carries the source information"#]
            #[doc = r#"for all events within that frame."#]
            #[doc = r#""#]
            #[doc = r#"The source specifies how this event was generated. If the source is"#]
            #[doc = r#"wp_tablet_pad_ring.source.finger, a wp_tablet_pad_ring.stop event"#]
            #[doc = r#"will be sent when the user lifts the finger off the device."#]
            #[doc = r#""#]
            #[doc = r#"This event is optional. If the source is unknown for an interaction,"#]
            #[doc = r#"no event is sent."#]
            async fn source(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: Source,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_ring_v2#{}.source()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(source as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the angle on a ring changes."#]
            #[doc = r#""#]
            #[doc = r#"The angle is provided in degrees clockwise from the logical"#]
            #[doc = r#"north of the ring in the pad's current rotation."#]
            async fn angle(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                degrees: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_ring_v2#{}.angle()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_fixed(degrees)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Stop notification for ring events."#]
            #[doc = r#""#]
            #[doc = r#"For some wp_tablet_pad_ring.source types, a wp_tablet_pad_ring.stop"#]
            #[doc = r#"event is sent to notify a client that the interaction with the ring"#]
            #[doc = r#"has terminated. This enables the client to implement kinetic scrolling."#]
            #[doc = r#"See the wp_tablet_pad_ring.source documentation for information on"#]
            #[doc = r#"when this event may be generated."#]
            #[doc = r#""#]
            #[doc = r#"Any wp_tablet_pad_ring.angle events with the same source after this"#]
            #[doc = r#"event should be considered as the start of a new interaction."#]
            async fn stop(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_ring_v2#{}.stop()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Indicates the end of a set of ring events that logically belong"#]
            #[doc = r#"together. A client is expected to accumulate the data in all events"#]
            #[doc = r#"within the frame before proceeding."#]
            #[doc = r#""#]
            #[doc = r#"All wp_tablet_pad_ring events before a wp_tablet_pad_ring.frame event belong"#]
            #[doc = r#"logically together. For example, on termination of a finger interaction"#]
            #[doc = r#"on a ring the compositor will send a wp_tablet_pad_ring.source event,"#]
            #[doc = r#"a wp_tablet_pad_ring.stop event and a wp_tablet_pad_ring.frame event."#]
            #[doc = r#""#]
            #[doc = r#"A wp_tablet_pad_ring.frame event is sent for every logical event"#]
            #[doc = r#"group, even if the group only contains a single wp_tablet_pad_ring"#]
            #[doc = r#"event. Specifically, a client may get a sequence: angle, frame,"#]
            #[doc = r#"angle, frame, etc."#]
            async fn frame(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_ring_v2#{}.frame()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(time).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_tablet_pad_strip_v2 {
        #[doc = r#"Describes the source types for strip events. This indicates to the"#]
        #[doc = r#"client how a strip event was physically generated; a client may"#]
        #[doc = r#"adjust the user interface accordingly. For example, events"#]
        #[doc = r#"from a "finger" source may trigger kinetic scrolling."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Source {
            #[doc = r#"Finger"#]
            Finger = 1,
        }
        impl TryFrom<u32> for Source {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::Finger),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"A linear interaction area, such as the strips found in Wacom Cintiq"#]
        #[doc = r#"models."#]
        #[doc = r#""#]
        #[doc = r#"Events on a strip are logically grouped by the wl_tablet_pad_strip.frame"#]
        #[doc = r#"event."#]
        pub trait ZwpTabletPadStripV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_strip_v2";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_tablet_pad_strip_v2#{}.set_feedback()", object.id);
                        self.set_feedback(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwp_tablet_pad_strip_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Requests the compositor to use the provided feedback string"#]
            #[doc = r#"associated with this strip. This request should be issued immediately"#]
            #[doc = r#"after a wp_tablet_pad_group.mode_switch event from the corresponding"#]
            #[doc = r#"group is received, or whenever the strip is mapped to a different"#]
            #[doc = r#"action. See wp_tablet_pad_group.mode_switch for more details."#]
            #[doc = r#""#]
            #[doc = r#"Clients are encouraged to provide context-aware descriptions for"#]
            #[doc = r#"the actions associated with the strip, and compositors may use this"#]
            #[doc = r#"information to offer visual feedback about the button layout"#]
            #[doc = r#"(eg. on-screen displays)."#]
            #[doc = r#""#]
            #[doc = r#"The provided string 'description' is a UTF-8 encoded string to be"#]
            #[doc = r#"associated with this ring, and is considered user-visible; general"#]
            #[doc = r#"internationalization rules apply."#]
            #[doc = r#""#]
            #[doc = r#"The serial argument will be that of the last"#]
            #[doc = r#"wp_tablet_pad_group.mode_switch event received for the group of this"#]
            #[doc = r#"strip. Requests providing other serials than the most recent one will be"#]
            #[doc = r#"ignored."#]
            async fn set_feedback(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_feedback: String,
                set_feedback: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"This destroys the client's resource for this strip object."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Source information for strip events."#]
            #[doc = r#""#]
            #[doc = r#"This event does not occur on its own. It is sent before a"#]
            #[doc = r#"wp_tablet_pad_strip.frame event and carries the source information"#]
            #[doc = r#"for all events within that frame."#]
            #[doc = r#""#]
            #[doc = r#"The source specifies how this event was generated. If the source is"#]
            #[doc = r#"wp_tablet_pad_strip.source.finger, a wp_tablet_pad_strip.stop event"#]
            #[doc = r#"will be sent when the user lifts their finger off the device."#]
            #[doc = r#""#]
            #[doc = r#"This event is optional. If the source is unknown for an interaction,"#]
            #[doc = r#"no event is sent."#]
            async fn source(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                source: Source,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_strip_v2#{}.source()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(source as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the position on a strip changes."#]
            #[doc = r#""#]
            #[doc = r#"The position is normalized to a range of [0, 65535], the 0-value"#]
            #[doc = r#"represents the top-most and/or left-most position of the strip in"#]
            #[doc = r#"the pad's current rotation."#]
            async fn position(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                position: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_strip_v2#{}.position()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(position)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Stop notification for strip events."#]
            #[doc = r#""#]
            #[doc = r#"For some wp_tablet_pad_strip.source types, a wp_tablet_pad_strip.stop"#]
            #[doc = r#"event is sent to notify a client that the interaction with the strip"#]
            #[doc = r#"has terminated. This enables the client to implement kinetic"#]
            #[doc = r#"scrolling. See the wp_tablet_pad_strip.source documentation for"#]
            #[doc = r#"information on when this event may be generated."#]
            #[doc = r#""#]
            #[doc = r#"Any wp_tablet_pad_strip.position events with the same source after this"#]
            #[doc = r#"event should be considered as the start of a new interaction."#]
            async fn stop(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_strip_v2#{}.stop()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Indicates the end of a set of events that represent one logical"#]
            #[doc = r#"hardware strip event. A client is expected to accumulate the data"#]
            #[doc = r#"in all events within the frame before proceeding."#]
            #[doc = r#""#]
            #[doc = r#"All wp_tablet_pad_strip events before a wp_tablet_pad_strip.frame event belong"#]
            #[doc = r#"logically together. For example, on termination of a finger interaction"#]
            #[doc = r#"on a strip the compositor will send a wp_tablet_pad_strip.source event,"#]
            #[doc = r#"a wp_tablet_pad_strip.stop event and a wp_tablet_pad_strip.frame"#]
            #[doc = r#"event."#]
            #[doc = r#""#]
            #[doc = r#"A wp_tablet_pad_strip.frame event is sent for every logical event"#]
            #[doc = r#"group, even if the group only contains a single wp_tablet_pad_strip"#]
            #[doc = r#"event. Specifically, a client may get a sequence: position, frame,"#]
            #[doc = r#"position, frame, etc."#]
            async fn frame(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_strip_v2#{}.frame()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(time).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_tablet_pad_group_v2 {
        #[doc = r#"A pad group describes a distinct (sub)set of buttons, rings and strips"#]
        #[doc = r#"present in the tablet. The criteria of this grouping is usually positional,"#]
        #[doc = r#"eg. if a tablet has buttons on the left and right side, 2 groups will be"#]
        #[doc = r#"presented. The physical arrangement of groups is undisclosed and may"#]
        #[doc = r#"change on the fly."#]
        #[doc = r#""#]
        #[doc = r#"Pad groups will announce their features during pad initialization. Between"#]
        #[doc = r#"the corresponding wp_tablet_pad.group event and wp_tablet_pad_group.done, the"#]
        #[doc = r#"pad group will announce the buttons, rings and strips contained in it,"#]
        #[doc = r#"plus the number of supported modes."#]
        #[doc = r#""#]
        #[doc = r#"Modes are a mechanism to allow multiple groups of actions for every element"#]
        #[doc = r#"in the pad group. The number of groups and available modes in each is"#]
        #[doc = r#"persistent across device plugs. The current mode is user-switchable, it"#]
        #[doc = r#"will be announced through the wp_tablet_pad_group.mode_switch event both"#]
        #[doc = r#"whenever it is switched, and after wp_tablet_pad.enter."#]
        #[doc = r#""#]
        #[doc = r#"The current mode logically applies to all elements in the pad group,"#]
        #[doc = r#"although it is at clients' discretion whether to actually perform different"#]
        #[doc = r#"actions, and/or issue the respective .set_feedback requests to notify the"#]
        #[doc = r#"compositor. See the wp_tablet_pad_group.mode_switch event for more details."#]
        pub trait ZwpTabletPadGroupV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_group_v2";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_tablet_pad_group_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the wp_tablet_pad_group object. Objects created from this object"#]
            #[doc = r#"are unaffected and should be destroyed separately."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Sent on wp_tablet_pad_group initialization to announce the available"#]
            #[doc = r#"buttons in the group. Button indices start at 0, a button may only be"#]
            #[doc = r#"in one group at a time."#]
            #[doc = r#""#]
            #[doc = r#"This event is first sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_pad_group.done event."#]
            #[doc = r#""#]
            #[doc = r#"Some buttons are reserved by the compositor. These buttons may not be"#]
            #[doc = r#"assigned to any wp_tablet_pad_group. Compositors may broadcast this"#]
            #[doc = r#"event in the case of changes to the mapping of these reserved buttons."#]
            #[doc = r#"If the compositor happens to reserve all buttons in a group, this event"#]
            #[doc = r#"will be sent with an empty array."#]
            async fn buttons(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                buttons: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.buttons()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_array(buttons)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent on wp_tablet_pad_group initialization to announce available rings."#]
            #[doc = r#"One event is sent for each ring available on this pad group."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_pad_group.done event."#]
            async fn ring(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                ring: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.ring()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(ring))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent on wp_tablet_pad initialization to announce available strips."#]
            #[doc = r#"One event is sent for each strip available on this pad group."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_pad_group.done event."#]
            async fn strip(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                strip: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.strip()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(strip))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent on wp_tablet_pad_group initialization to announce that the pad"#]
            #[doc = r#"group may switch between modes. A client may use a mode to store a"#]
            #[doc = r#"specific configuration for buttons, rings and strips and use the"#]
            #[doc = r#"wl_tablet_pad_group.mode_switch event to toggle between these"#]
            #[doc = r#"configurations. Mode indices start at 0."#]
            #[doc = r#""#]
            #[doc = r#"Switching modes is compositor-dependent. See the"#]
            #[doc = r#"wp_tablet_pad_group.mode_switch event for more details."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_pad_group.done event. This event is only sent when more than"#]
            #[doc = r#"more than one mode is available."#]
            async fn modes(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                modes: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.modes()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(modes).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent immediately to signal the end of the initial"#]
            #[doc = r#"burst of descriptive events. A client may consider the static"#]
            #[doc = r#"description of the tablet to be complete and finalize initialization"#]
            #[doc = r#"of the tablet group."#]
            async fn done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notification that the mode was switched."#]
            #[doc = r#""#]
            #[doc = r#"A mode applies to all buttons, rings and strips in a group"#]
            #[doc = r#"simultaneously, but a client is not required to assign different actions"#]
            #[doc = r#"for each mode. For example, a client may have mode-specific button"#]
            #[doc = r#"mappings but map the ring to vertical scrolling in all modes. Mode"#]
            #[doc = r#"indices start at 0."#]
            #[doc = r#""#]
            #[doc = r#"Switching modes is compositor-dependent. The compositor may provide"#]
            #[doc = r#"visual cues to the client about the mode, e.g. by toggling LEDs on"#]
            #[doc = r#"the tablet device. Mode-switching may be software-controlled or"#]
            #[doc = r#"controlled by one or more physical buttons. For example, on a Wacom"#]
            #[doc = r#"Intuos Pro, the button inside the ring may be assigned to switch"#]
            #[doc = r#"between modes."#]
            #[doc = r#""#]
            #[doc = r#"The compositor will also send this event after wp_tablet_pad.enter on"#]
            #[doc = r#"each group in order to notify of the current mode. Groups that only"#]
            #[doc = r#"feature one mode will use mode=0 when emitting this event."#]
            #[doc = r#""#]
            #[doc = r#"If a button action in the new mode differs from the action in the"#]
            #[doc = r#"previous mode, the client should immediately issue a"#]
            #[doc = r#"wp_tablet_pad.set_feedback request for each changed button."#]
            #[doc = r#""#]
            #[doc = r#"If a ring or strip action in the new mode differs from the action"#]
            #[doc = r#"in the previous mode, the client should immediately issue a"#]
            #[doc = r#"wp_tablet_ring.set_feedback or wp_tablet_strip.set_feedback request"#]
            #[doc = r#"for each changed ring or strip."#]
            async fn mode_switch(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                serial: u32,
                mode: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_group_v2#{}.mode_switch()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_uint(serial)
                    .put_uint(mode)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 5, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_tablet_pad_v2 {
        #[doc = r#"Describes the physical state of a button that caused the button"#]
        #[doc = r#"event."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ButtonState {
            #[doc = r#"The button is not pressed"#]
            Released = 0,
            #[doc = r#"The button is pressed"#]
            Pressed = 1,
        }
        impl TryFrom<u32> for ButtonState {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Released),
                    1 => Ok(Self::Pressed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"A pad device is a set of buttons, rings and strips"#]
        #[doc = r#"usually physically present on the tablet device itself. Some"#]
        #[doc = r#"exceptions exist where the pad device is physically detached, e.g. the"#]
        #[doc = r#"Wacom ExpressKey Remote."#]
        #[doc = r#""#]
        #[doc = r#"Pad devices have no axes that control the cursor and are generally"#]
        #[doc = r#"auxiliary devices to the tool devices used on the tablet surface."#]
        #[doc = r#""#]
        #[doc = r#"A pad device has a number of static characteristics, e.g. the number"#]
        #[doc = r#"of rings. These capabilities are sent in an event sequence after the"#]
        #[doc = r#"wp_tablet_seat.pad_added event before any actual events from this pad."#]
        #[doc = r#"This initial event sequence is terminated by a wp_tablet_pad.done"#]
        #[doc = r#"event."#]
        #[doc = r#""#]
        #[doc = r#"All pad features (buttons, rings and strips) are logically divided into"#]
        #[doc = r#"groups and all pads have at least one group. The available groups are"#]
        #[doc = r#"notified through the wp_tablet_pad.group event; the compositor will"#]
        #[doc = r#"emit one event per group before emitting wp_tablet_pad.done."#]
        #[doc = r#""#]
        #[doc = r#"Groups may have multiple modes. Modes allow clients to map multiple"#]
        #[doc = r#"actions to a single pad feature. Only one mode can be active per group,"#]
        #[doc = r#"although different groups may have different active modes."#]
        pub trait ZwpTabletPadV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_tablet_pad_v2";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_tablet_pad_v2#{}.set_feedback()", object.id);
                        self.set_feedback(
                            object,
                            client,
                            message.uint()?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwp_tablet_pad_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Requests the compositor to use the provided feedback string"#]
            #[doc = r#"associated with this button. This request should be issued immediately"#]
            #[doc = r#"after a wp_tablet_pad_group.mode_switch event from the corresponding"#]
            #[doc = r#"group is received, or whenever a button is mapped to a different"#]
            #[doc = r#"action. See wp_tablet_pad_group.mode_switch for more details."#]
            #[doc = r#""#]
            #[doc = r#"Clients are encouraged to provide context-aware descriptions for"#]
            #[doc = r#"the actions associated with each button, and compositors may use"#]
            #[doc = r#"this information to offer visual feedback on the button layout"#]
            #[doc = r#"(e.g. on-screen displays)."#]
            #[doc = r#""#]
            #[doc = r#"Button indices start at 0. Setting the feedback string on a button"#]
            #[doc = r#"that is reserved by the compositor (i.e. not belonging to any"#]
            #[doc = r#"wp_tablet_pad_group) does not generate an error but the compositor"#]
            #[doc = r#"is free to ignore the request."#]
            #[doc = r#""#]
            #[doc = r#"The provided string 'description' is a UTF-8 encoded string to be"#]
            #[doc = r#"associated with this ring, and is considered user-visible; general"#]
            #[doc = r#"internationalization rules apply."#]
            #[doc = r#""#]
            #[doc = r#"The serial argument will be that of the last"#]
            #[doc = r#"wp_tablet_pad_group.mode_switch event received for the group of this"#]
            #[doc = r#"button. Requests providing other serials than the most recent one will"#]
            #[doc = r#"be ignored."#]
            async fn set_feedback(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_feedback: u32,
                set_feedback: String,
                set_feedback: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Destroy the wp_tablet_pad object. Objects created from this object"#]
            #[doc = r#"are unaffected and should be destroyed separately."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Sent on wp_tablet_pad initialization to announce available groups."#]
            #[doc = r#"One event is sent for each pad group available."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_pad.done event. At least one group will be announced."#]
            async fn group(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                pad_group: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.group()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(pad_group))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"A system-specific device path that indicates which device is behind"#]
            #[doc = r#"this wp_tablet_pad. This information may be used to gather additional"#]
            #[doc = r#"information about the device, e.g. through libwacom."#]
            #[doc = r#""#]
            #[doc = r#"The format of the path is unspecified, it may be a device node, a"#]
            #[doc = r#"sysfs path, or some other identifier. It is up to the client to"#]
            #[doc = r#"identify the string provided."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_pad.done event."#]
            async fn path(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                path: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.path()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(path))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent on wp_tablet_pad initialization to announce the available"#]
            #[doc = r#"buttons."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent in the initial burst of events before the"#]
            #[doc = r#"wp_tablet_pad.done event. This event is only sent when at least one"#]
            #[doc = r#"button is available."#]
            async fn buttons(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                buttons: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.buttons()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(buttons).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event signals the end of the initial burst of descriptive"#]
            #[doc = r#"events. A client may consider the static description of the pad to"#]
            #[doc = r#"be complete and finalize initialization of the pad."#]
            async fn done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent whenever the physical state of a button changes."#]
            async fn button(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                time: u32,
                button: u32,
                state: ButtonState,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.button()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(time)
                    .put_uint(button)
                    .put_uint(state as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notification that this pad is focused on the specified surface."#]
            async fn enter(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                tablet: crate::wire::ObjectId,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.enter()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(tablet))
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 5, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notification that this pad is no longer focused on the specified"#]
            #[doc = r#"surface."#]
            async fn leave(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.leave()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 6, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent when the pad has been removed from the system. When a tablet"#]
            #[doc = r#"is removed its pad(s) will be removed too."#]
            #[doc = r#""#]
            #[doc = r#"When this event is received, the client must destroy all rings, strips"#]
            #[doc = r#"and groups that were offered by this pad, and issue wp_tablet_pad.destroy"#]
            #[doc = r#"the pad itself."#]
            async fn removed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_tablet_pad_v2#{}.removed()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 7, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod text_input_unstable_v1 {
    pub mod zwp_text_input_v1 {
        #[doc = r#"Content hint is a bitmask to allow to modify the behavior of the text"#]
        #[doc = r#"input."#]
        bitflags::bitflags! {
                                    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
                                    pub struct ContentHint: u32 {#[doc = r#"No special behaviour"#]
        const None = 0x0;#[doc = r#"Auto completion, correction and capitalization"#]
        const Default = 0x7;#[doc = r#"Hidden and sensitive text"#]
        const Password = 0xc0;#[doc = r#"Suggest word completions"#]
        const AutoCompletion = 0x1;#[doc = r#"Suggest word corrections"#]
        const AutoCorrection = 0x2;#[doc = r#"Switch to uppercase letters at the start of a sentence"#]
        const AutoCapitalization = 0x4;#[doc = r#"Prefer lowercase letters"#]
        const Lowercase = 0x8;#[doc = r#"Prefer uppercase letters"#]
        const Uppercase = 0x10;#[doc = r#"Prefer casing for titles and headings (can be language dependent)"#]
        const Titlecase = 0x20;#[doc = r#"Characters should be hidden"#]
        const HiddenText = 0x40;#[doc = r#"Typed text should not be stored"#]
        const SensitiveData = 0x80;#[doc = r#"Just latin characters should be entered"#]
        const Latin = 0x100;#[doc = r#"The text input is multiline"#]
        const Multiline = 0x200;}
                                }
        impl TryFrom<u32> for ContentHint {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = r#"The content purpose allows to specify the primary purpose of a text"#]
        #[doc = r#"input."#]
        #[doc = r#""#]
        #[doc = r#"This allows an input method to show special purpose input panels with"#]
        #[doc = r#"extra characters or to disallow some characters."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ContentPurpose {
            #[doc = r#"Default input, allowing all characters"#]
            Normal = 0,
            #[doc = r#"Allow only alphabetic characters"#]
            Alpha = 1,
            #[doc = r#"Allow only digits"#]
            Digits = 2,
            #[doc = r#"Input a number (including decimal separator and sign)"#]
            Number = 3,
            #[doc = r#"Input a phone number"#]
            Phone = 4,
            #[doc = r#"Input an URL"#]
            Url = 5,
            #[doc = r#"Input an email address"#]
            Email = 6,
            #[doc = r#"Input a name of a person"#]
            Name = 7,
            #[doc = r#"Input a password (combine with password or sensitive_data hint)"#]
            Password = 8,
            #[doc = r#"Input a date"#]
            Date = 9,
            #[doc = r#"Input a time"#]
            Time = 10,
            #[doc = r#"Input a date and time"#]
            Datetime = 11,
            #[doc = r#"Input for a terminal"#]
            Terminal = 12,
        }
        impl TryFrom<u32> for ContentPurpose {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Normal),
                    1 => Ok(Self::Alpha),
                    2 => Ok(Self::Digits),
                    3 => Ok(Self::Number),
                    4 => Ok(Self::Phone),
                    5 => Ok(Self::Url),
                    6 => Ok(Self::Email),
                    7 => Ok(Self::Name),
                    8 => Ok(Self::Password),
                    9 => Ok(Self::Date),
                    10 => Ok(Self::Time),
                    11 => Ok(Self::Datetime),
                    12 => Ok(Self::Terminal),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum PreeditStyle {
            #[doc = r#"Default style for composing text"#]
            Default = 0,
            #[doc = r#"Style should be the same as in non-composing text"#]
            None = 1,
            Active = 2,
            Inactive = 3,
            Highlight = 4,
            Underline = 5,
            Selection = 6,
            Incorrect = 7,
        }
        impl TryFrom<u32> for PreeditStyle {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Default),
                    1 => Ok(Self::None),
                    2 => Ok(Self::Active),
                    3 => Ok(Self::Inactive),
                    4 => Ok(Self::Highlight),
                    5 => Ok(Self::Underline),
                    6 => Ok(Self::Selection),
                    7 => Ok(Self::Incorrect),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum TextDirection {
            #[doc = r#"Automatic text direction based on text and language"#]
            Auto = 0,
            #[doc = r#"Left-to-right"#]
            Ltr = 1,
            #[doc = r#"Right-to-left"#]
            Rtl = 2,
        }
        impl TryFrom<u32> for TextDirection {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Auto),
                    1 => Ok(Self::Ltr),
                    2 => Ok(Self::Rtl),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"An object used for text input. Adds support for text input and input"#]
        #[doc = r#"methods to applications. A text_input object is created from a"#]
        #[doc = r#"wl_text_input_manager and corresponds typically to a text entry in an"#]
        #[doc = r#"application."#]
        #[doc = r#""#]
        #[doc = r#"Requests are used to activate/deactivate the text_input object and set"#]
        #[doc = r#"state information like surrounding and selected text or the content type."#]
        #[doc = r#"The information about entered text is sent to the text_input object via"#]
        #[doc = r#"the pre-edit and commit events. Using this interface removes the need"#]
        #[doc = r#"for applications to directly process hardware key events and compose text"#]
        #[doc = r#"out of them."#]
        #[doc = r#""#]
        #[doc = r#"Text is generally UTF-8 encoded, indices and lengths are in bytes."#]
        #[doc = r#""#]
        #[doc = r#"Serials are used to synchronize the state between the text input and"#]
        #[doc = r#"an input method. New serials are sent by the text input in the"#]
        #[doc = r#"commit_state request and are used by the input method to indicate"#]
        #[doc = r#"the known text input state in events like preedit_string, commit_string,"#]
        #[doc = r#"and keysym. The text input can then ignore events from the input method"#]
        #[doc = r#"which are based on an outdated state (for example after a reset)."#]
        #[doc = r#""#]
        #[doc = r#"Warning! The protocol described in this file is experimental and"#]
        #[doc = r#"backward incompatible changes may be made. Backward compatible changes"#]
        #[doc = r#"may be added together with the corresponding interface version bump."#]
        #[doc = r#"Backward incompatible changes are done by bumping the version number in"#]
        #[doc = r#"the protocol and interface names and resetting the interface version."#]
        #[doc = r#"Once the protocol is to be declared stable, the 'z' prefix and the"#]
        #[doc = r#"version number in the protocol and interface names are removed and the"#]
        #[doc = r#"interface version number is reset."#]
        pub trait ZwpTextInputV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_text_input_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_text_input_v1#{}.activate()", object.id);
                        self.activate(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwp_text_input_v1#{}.deactivate()", object.id);
                        self.deactivate(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("zwp_text_input_v1#{}.show_input_panel()", object.id);
                        self.show_input_panel(object, client).await
                    }
                    3 => {
                        tracing::debug!("zwp_text_input_v1#{}.hide_input_panel()", object.id);
                        self.hide_input_panel(object, client).await
                    }
                    4 => {
                        tracing::debug!("zwp_text_input_v1#{}.reset()", object.id);
                        self.reset(object, client).await
                    }
                    5 => {
                        tracing::debug!("zwp_text_input_v1#{}.set_surrounding_text()", object.id);
                        self.set_surrounding_text(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    6 => {
                        tracing::debug!("zwp_text_input_v1#{}.set_content_type()", object.id);
                        self.set_content_type(
                            object,
                            client,
                            message.uint()?.try_into()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    7 => {
                        tracing::debug!("zwp_text_input_v1#{}.set_cursor_rectangle()", object.id);
                        self.set_cursor_rectangle(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    8 => {
                        tracing::debug!("zwp_text_input_v1#{}.set_preferred_language()", object.id);
                        self.set_preferred_language(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    9 => {
                        tracing::debug!("zwp_text_input_v1#{}.commit_state()", object.id);
                        self.commit_state(object, client, message.uint()?).await
                    }
                    10 => {
                        tracing::debug!("zwp_text_input_v1#{}.invoke_action()", object.id);
                        self.invoke_action(object, client, message.uint()?, message.uint()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Requests the text_input object to be activated (typically when the"#]
            #[doc = r#"text entry gets focus)."#]
            #[doc = r#""#]
            #[doc = r#"The seat argument is a wl_seat which maintains the focus for this"#]
            #[doc = r#"activation. The surface argument is a wl_surface assigned to the"#]
            #[doc = r#"text_input object and tracked for focus lost. The enter event"#]
            #[doc = r#"is emitted on successful activation."#]
            async fn activate(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                activate: crate::wire::ObjectId,
                activate: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Requests the text_input object to be deactivated (typically when the"#]
            #[doc = r#"text entry lost focus). The seat argument is a wl_seat which was used"#]
            #[doc = r#"for activation."#]
            async fn deactivate(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                deactivate: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Requests input panels (virtual keyboard) to show."#]
            async fn show_input_panel(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Requests input panels (virtual keyboard) to hide."#]
            async fn hide_input_panel(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Should be called by an editor widget when the input state should be"#]
            #[doc = r#"reset, for example after the text was changed outside of the normal"#]
            #[doc = r#"input method flow."#]
            async fn reset(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Sets the plain surrounding text around the input position. Text is"#]
            #[doc = r#"UTF-8 encoded. Cursor is the byte offset within the"#]
            #[doc = r#"surrounding text. Anchor is the byte offset of the"#]
            #[doc = r#"selection anchor within the surrounding text. If there is no selected"#]
            #[doc = r#"text anchor, then it is the same as cursor."#]
            async fn set_surrounding_text(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_surrounding_text: String,
                set_surrounding_text: u32,
                set_surrounding_text: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Sets the content purpose and content hint. While the purpose is the"#]
            #[doc = r#"basic purpose of an input field, the hint flags allow to modify some"#]
            #[doc = r#"of the behavior."#]
            #[doc = r#""#]
            #[doc = r#"When no content type is explicitly set, a normal content purpose with"#]
            #[doc = r#"default hints (auto completion, auto correction, auto capitalization)"#]
            #[doc = r#"should be assumed."#]
            async fn set_content_type(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_content_type: ContentHint,
                set_content_type: ContentPurpose,
            ) -> crate::server::Result<()>;
            async fn set_cursor_rectangle(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_cursor_rectangle: i32,
                set_cursor_rectangle: i32,
                set_cursor_rectangle: i32,
                set_cursor_rectangle: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Sets a specific language. This allows for example a virtual keyboard to"#]
            #[doc = r#"show a language specific layout. The "language" argument is an RFC-3066"#]
            #[doc = r#"format language tag."#]
            #[doc = r#""#]
            #[doc = r#"It could be used for example in a word processor to indicate the"#]
            #[doc = r#"language of the currently edited document or in an instant message"#]
            #[doc = r#"application which tracks languages of contacts."#]
            async fn set_preferred_language(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_preferred_language: String,
            ) -> crate::server::Result<()>;
            async fn commit_state(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                commit_state: u32,
            ) -> crate::server::Result<()>;
            async fn invoke_action(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                invoke_action: u32,
                invoke_action: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Notify the text_input object when it received focus. Typically in"#]
            #[doc = r#"response to an activate request."#]
            async fn enter(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.enter()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notify the text_input object when it lost focus. Either in response"#]
            #[doc = r#"to a deactivate request or when the assigned surface lost focus or was"#]
            #[doc = r#"destroyed."#]
            async fn leave(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.leave()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Transfer an array of 0-terminated modifier names. The position in"#]
            #[doc = r#"the array is the index of the modifier as used in the modifiers"#]
            #[doc = r#"bitmask in the keysym event."#]
            async fn modifiers_map(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                map: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.modifiers_map()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_array(map).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notify when the visibility state of the input panel changed."#]
            async fn input_panel_state(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                state: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.input_panel_state()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(state).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notify when a new composing text (pre-edit) should be set around the"#]
            #[doc = r#"current cursor position. Any previously set composing text should"#]
            #[doc = r#"be removed."#]
            #[doc = r#""#]
            #[doc = r#"The commit text can be used to replace the preedit text on reset"#]
            #[doc = r#"(for example on unfocus)."#]
            #[doc = r#""#]
            #[doc = r#"The text input should also handle all preedit_style and preedit_cursor"#]
            #[doc = r#"events occurring directly before preedit_string."#]
            async fn preedit_string(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                text: String,
                commit: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.preedit_string()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_string(Some(text))
                    .put_string(Some(commit))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sets styling information on composing text. The style is applied for"#]
            #[doc = r#"length bytes from index relative to the beginning of the composing"#]
            #[doc = r#"text (as byte offset). Multiple styles can"#]
            #[doc = r#"be applied to a composing text by sending multiple preedit_styling"#]
            #[doc = r#"events."#]
            #[doc = r#""#]
            #[doc = r#"This event is handled as part of a following preedit_string event."#]
            async fn preedit_styling(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: u32,
                length: u32,
                style: PreeditStyle,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.preedit_styling()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(index)
                    .put_uint(length)
                    .put_uint(style as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 5, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sets the cursor position inside the composing text (as byte"#]
            #[doc = r#"offset) relative to the start of the composing text. When index is a"#]
            #[doc = r#"negative number no cursor is shown."#]
            #[doc = r#""#]
            #[doc = r#"This event is handled as part of a following preedit_string event."#]
            async fn preedit_cursor(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.preedit_cursor()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(index).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 6, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notify when text should be inserted into the editor widget. The text to"#]
            #[doc = r#"commit could be either just a single character after a key press or the"#]
            #[doc = r#"result of some composing (pre-edit). It could also be an empty text"#]
            #[doc = r#"when some text should be removed (see delete_surrounding_text) or when"#]
            #[doc = r#"the input cursor should be moved (see cursor_position)."#]
            #[doc = r#""#]
            #[doc = r#"Any previously set composing text should be removed."#]
            async fn commit_string(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                text: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.commit_string()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_string(Some(text))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 7, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notify when the cursor or anchor position should be modified."#]
            #[doc = r#""#]
            #[doc = r#"This event should be handled as part of a following commit_string"#]
            #[doc = r#"event."#]
            async fn cursor_position(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: i32,
                anchor: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.cursor_position()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(index)
                    .put_int(anchor)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 8, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notify when the text around the current cursor position should be"#]
            #[doc = r#"deleted."#]
            #[doc = r#""#]
            #[doc = r#"Index is relative to the current cursor (in bytes)."#]
            #[doc = r#"Length is the length of deleted text (in bytes)."#]
            #[doc = r#""#]
            #[doc = r#"This event should be handled as part of a following commit_string"#]
            #[doc = r#"event."#]
            async fn delete_surrounding_text(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: i32,
                length: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_text_input_v1#{}.delete_surrounding_text()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(index)
                    .put_uint(length)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 9, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notify when a key event was sent. Key events should not be used"#]
            #[doc = r#"for normal text input operations, which should be done with"#]
            #[doc = r#"commit_string, delete_surrounding_text, etc. The key event follows"#]
            #[doc = r#"the wl_keyboard key event convention. Sym is an XKB keysym, state a"#]
            #[doc = r#"wl_keyboard key_state. Modifiers are a mask for effective modifiers"#]
            #[doc = r#"(where the modifier indices are set by the modifiers_map event)"#]
            async fn keysym(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                time: u32,
                sym: u32,
                state: u32,
                modifiers: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.keysym()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(time)
                    .put_uint(sym)
                    .put_uint(state)
                    .put_uint(modifiers)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 10, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sets the language of the input text. The "language" argument is an"#]
            #[doc = r#"RFC-3066 format language tag."#]
            async fn language(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                language: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.language()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_string(Some(language))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 11, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sets the text direction of input text."#]
            #[doc = r#""#]
            #[doc = r#"It is mainly needed for showing an input cursor on the correct side of"#]
            #[doc = r#"the editor when there is no input done yet and making sure neutral"#]
            #[doc = r#"direction text is laid out properly."#]
            async fn text_direction(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                direction: TextDirection,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v1#{}.text_direction()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(direction as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 12, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_text_input_manager_v1 {
        #[doc = r#"A factory for text_input objects. This object is a global singleton."#]
        pub trait ZwpTextInputManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_text_input_manager_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "zwp_text_input_manager_v1#{}.create_text_input()",
                            object.id
                        );
                        self.create_text_input(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Creates a new text_input object."#]
            async fn create_text_input(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create_text_input: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
}
#[doc = r#"This protocol allows compositors to act as input methods and to send text"#]
#[doc = r#"to applications. A text input object is used to manage state of what are"#]
#[doc = r#"typically text entry fields in the application."#]
#[doc = r#""#]
#[doc = r#"This document adheres to the RFC 2119 when using words like "must","#]
#[doc = r#""should", "may", etc."#]
#[doc = r#""#]
#[doc = r#"Warning! The protocol described in this file is experimental and"#]
#[doc = r#"backward incompatible changes may be made. Backward compatible changes"#]
#[doc = r#"may be added together with the corresponding interface version bump."#]
#[doc = r#"Backward incompatible changes are done by bumping the version number in"#]
#[doc = r#"the protocol and interface names and resetting the interface version."#]
#[doc = r#"Once the protocol is to be declared stable, the 'z' prefix and the"#]
#[doc = r#"version number in the protocol and interface names are removed and the"#]
#[doc = r#"interface version number is reset."#]
pub mod text_input_unstable_v3 {
    pub mod zwp_text_input_v3 {
        #[doc = r#"Reason for the change of surrounding text or cursor posision."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ChangeCause {
            #[doc = r#"Input method caused the change"#]
            InputMethod = 0,
            #[doc = r#"Something else than the input method caused the change"#]
            Other = 1,
        }
        impl TryFrom<u32> for ChangeCause {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::InputMethod),
                    1 => Ok(Self::Other),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"Content hint is a bitmask to allow to modify the behavior of the text"#]
        #[doc = r#"input."#]
        bitflags::bitflags! {
                                    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
                                    pub struct ContentHint: u32 {#[doc = r#"No special behavior"#]
        const None = 0x0;#[doc = r#"Suggest word completions"#]
        const Completion = 0x1;#[doc = r#"Suggest word corrections"#]
        const Spellcheck = 0x2;#[doc = r#"Switch to uppercase letters at the start of a sentence"#]
        const AutoCapitalization = 0x4;#[doc = r#"Prefer lowercase letters"#]
        const Lowercase = 0x8;#[doc = r#"Prefer uppercase letters"#]
        const Uppercase = 0x10;#[doc = r#"Prefer casing for titles and headings (can be language dependent)"#]
        const Titlecase = 0x20;#[doc = r#"Characters should be hidden"#]
        const HiddenText = 0x40;#[doc = r#"Typed text should not be stored"#]
        const SensitiveData = 0x80;#[doc = r#"Just Latin characters should be entered"#]
        const Latin = 0x100;#[doc = r#"The text input is multiline"#]
        const Multiline = 0x200;}
                                }
        impl TryFrom<u32> for ContentHint {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = r#"The content purpose allows to specify the primary purpose of a text"#]
        #[doc = r#"input."#]
        #[doc = r#""#]
        #[doc = r#"This allows an input method to show special purpose input panels with"#]
        #[doc = r#"extra characters or to disallow some characters."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ContentPurpose {
            #[doc = r#"Default input, allowing all characters"#]
            Normal = 0,
            #[doc = r#"Allow only alphabetic characters"#]
            Alpha = 1,
            #[doc = r#"Allow only digits"#]
            Digits = 2,
            #[doc = r#"Input a number (including decimal separator and sign)"#]
            Number = 3,
            #[doc = r#"Input a phone number"#]
            Phone = 4,
            #[doc = r#"Input an URL"#]
            Url = 5,
            #[doc = r#"Input an email address"#]
            Email = 6,
            #[doc = r#"Input a name of a person"#]
            Name = 7,
            #[doc = r#"Input a password (combine with sensitive_data hint)"#]
            Password = 8,
            #[doc = r#"Input is a numeric password (combine with sensitive_data hint)"#]
            Pin = 9,
            #[doc = r#"Input a date"#]
            Date = 10,
            #[doc = r#"Input a time"#]
            Time = 11,
            #[doc = r#"Input a date and time"#]
            Datetime = 12,
            #[doc = r#"Input for a terminal"#]
            Terminal = 13,
        }
        impl TryFrom<u32> for ContentPurpose {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Normal),
                    1 => Ok(Self::Alpha),
                    2 => Ok(Self::Digits),
                    3 => Ok(Self::Number),
                    4 => Ok(Self::Phone),
                    5 => Ok(Self::Url),
                    6 => Ok(Self::Email),
                    7 => Ok(Self::Name),
                    8 => Ok(Self::Password),
                    9 => Ok(Self::Pin),
                    10 => Ok(Self::Date),
                    11 => Ok(Self::Time),
                    12 => Ok(Self::Datetime),
                    13 => Ok(Self::Terminal),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"The zwp_text_input_v3 interface represents text input and input methods"#]
        #[doc = r#"associated with a seat. It provides enter/leave events to follow the"#]
        #[doc = r#"text input focus for a seat."#]
        #[doc = r#""#]
        #[doc = r#"Requests are used to enable/disable the text-input object and set"#]
        #[doc = r#"state information like surrounding and selected text or the content type."#]
        #[doc = r#"The information about the entered text is sent to the text-input object"#]
        #[doc = r#"via the preedit_string and commit_string events."#]
        #[doc = r#""#]
        #[doc = r#"Text is valid UTF-8 encoded, indices and lengths are in bytes. Indices"#]
        #[doc = r#"must not point to middle bytes inside a code point: they must either"#]
        #[doc = r#"point to the first byte of a code point or to the end of the buffer."#]
        #[doc = r#"Lengths must be measured between two valid indices."#]
        #[doc = r#""#]
        #[doc = r#"Focus moving throughout surfaces will result in the emission of"#]
        #[doc = r#"zwp_text_input_v3.enter and zwp_text_input_v3.leave events. The focused"#]
        #[doc = r#"surface must commit zwp_text_input_v3.enable and"#]
        #[doc = r#"zwp_text_input_v3.disable requests as the keyboard focus moves across"#]
        #[doc = r#"editable and non-editable elements of the UI. Those two requests are not"#]
        #[doc = r#"expected to be paired with each other, the compositor must be able to"#]
        #[doc = r#"handle consecutive series of the same request."#]
        #[doc = r#""#]
        #[doc = r#"State is sent by the state requests (set_surrounding_text,"#]
        #[doc = r#"set_content_type and set_cursor_rectangle) and a commit request. After an"#]
        #[doc = r#"enter event or disable request all state information is invalidated and"#]
        #[doc = r#"needs to be resent by the client."#]
        pub trait ZwpTextInputV3: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_text_input_v3";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_text_input_v3#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("zwp_text_input_v3#{}.enable()", object.id);
                        self.enable(object, client).await
                    }
                    2 => {
                        tracing::debug!("zwp_text_input_v3#{}.disable()", object.id);
                        self.disable(object, client).await
                    }
                    3 => {
                        tracing::debug!("zwp_text_input_v3#{}.set_surrounding_text()", object.id);
                        self.set_surrounding_text(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    4 => {
                        tracing::debug!("zwp_text_input_v3#{}.set_text_change_cause()", object.id);
                        self.set_text_change_cause(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    5 => {
                        tracing::debug!("zwp_text_input_v3#{}.set_content_type()", object.id);
                        self.set_content_type(
                            object,
                            client,
                            message.uint()?.try_into()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    6 => {
                        tracing::debug!("zwp_text_input_v3#{}.set_cursor_rectangle()", object.id);
                        self.set_cursor_rectangle(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    7 => {
                        tracing::debug!("zwp_text_input_v3#{}.commit()", object.id);
                        self.commit(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the wp_text_input object. Also disables all surfaces enabled"#]
            #[doc = r#"through this wp_text_input object."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Requests text input on the surface previously obtained from the enter"#]
            #[doc = r#"event."#]
            #[doc = r#""#]
            #[doc = r#"This request must be issued every time the active text input changes"#]
            #[doc = r#"to a new one, including within the current surface. Use"#]
            #[doc = r#"zwp_text_input_v3.disable when there is no longer any input focus on"#]
            #[doc = r#"the current surface."#]
            #[doc = r#""#]
            #[doc = r#"Clients must not enable more than one text input on the single seat"#]
            #[doc = r#"and should disable the current text input before enabling the new one."#]
            #[doc = r#"At most one instance of text input may be in enabled state per instance,"#]
            #[doc = r#"Requests to enable the another text input when some text input is active"#]
            #[doc = r#"must be ignored by compositor."#]
            #[doc = r#""#]
            #[doc = r#"This request resets all state associated with previous enable, disable,"#]
            #[doc = r#"set_surrounding_text, set_text_change_cause, set_content_type, and"#]
            #[doc = r#"set_cursor_rectangle requests, as well as the state associated with"#]
            #[doc = r#"preedit_string, commit_string, and delete_surrounding_text events."#]
            #[doc = r#""#]
            #[doc = r#"The set_surrounding_text, set_content_type and set_cursor_rectangle"#]
            #[doc = r#"requests must follow if the text input supports the necessary"#]
            #[doc = r#"functionality."#]
            #[doc = r#""#]
            #[doc = r#"State set with this request is double-buffered. It will get applied on"#]
            #[doc = r#"the next zwp_text_input_v3.commit request, and stay valid until the"#]
            #[doc = r#"next committed enable or disable request."#]
            #[doc = r#""#]
            #[doc = r#"The changes must be applied by the compositor after issuing a"#]
            #[doc = r#"zwp_text_input_v3.commit request."#]
            async fn enable(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Explicitly disable text input on the current surface (typically when"#]
            #[doc = r#"there is no focus on any text entry inside the surface)."#]
            #[doc = r#""#]
            #[doc = r#"State set with this request is double-buffered. It will get applied on"#]
            #[doc = r#"the next zwp_text_input_v3.commit request."#]
            async fn disable(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Sets the surrounding plain text around the input, excluding the preedit"#]
            #[doc = r#"text."#]
            #[doc = r#""#]
            #[doc = r#"The client should notify the compositor of any changes in any of the"#]
            #[doc = r#"values carried with this request, including changes caused by handling"#]
            #[doc = r#"incoming text-input events as well as changes caused by other"#]
            #[doc = r#"mechanisms like keyboard typing."#]
            #[doc = r#""#]
            #[doc = r#"If the client is unaware of the text around the cursor, it should not"#]
            #[doc = r#"issue this request, to signify lack of support to the compositor."#]
            #[doc = r#""#]
            #[doc = r#"Text is UTF-8 encoded, and should include the cursor position, the"#]
            #[doc = r#"complete selection and additional characters before and after them."#]
            #[doc = r#"There is a maximum length of wayland messages, so text can not be"#]
            #[doc = r#"longer than 4000 bytes."#]
            #[doc = r#""#]
            #[doc = r#"Cursor is the byte offset of the cursor within text buffer."#]
            #[doc = r#""#]
            #[doc = r#"Anchor is the byte offset of the selection anchor within text buffer."#]
            #[doc = r#"If there is no selected text, anchor is the same as cursor."#]
            #[doc = r#""#]
            #[doc = r#"If any preedit text is present, it is replaced with a cursor for the"#]
            #[doc = r#"purpose of this event."#]
            #[doc = r#""#]
            #[doc = r#"Values set with this request are double-buffered. They will get applied"#]
            #[doc = r#"on the next zwp_text_input_v3.commit request, and stay valid until the"#]
            #[doc = r#"next committed enable or disable request."#]
            #[doc = r#""#]
            #[doc = r#"The initial state for affected fields is empty, meaning that the text"#]
            #[doc = r#"input does not support sending surrounding text. If the empty values"#]
            #[doc = r#"get applied, subsequent attempts to change them may have no effect."#]
            async fn set_surrounding_text(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_surrounding_text: String,
                set_surrounding_text: i32,
                set_surrounding_text: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Tells the compositor why the text surrounding the cursor changed."#]
            #[doc = r#""#]
            #[doc = r#"Whenever the client detects an external change in text, cursor, or"#]
            #[doc = r#"anchor posision, it must issue this request to the compositor. This"#]
            #[doc = r#"request is intended to give the input method a chance to update the"#]
            #[doc = r#"preedit text in an appropriate way, e.g. by removing it when the user"#]
            #[doc = r#"starts typing with a keyboard."#]
            #[doc = r#""#]
            #[doc = r#"cause describes the source of the change."#]
            #[doc = r#""#]
            #[doc = r#"The value set with this request is double-buffered. It must be applied"#]
            #[doc = r#"and reset to initial at the next zwp_text_input_v3.commit request."#]
            #[doc = r#""#]
            #[doc = r#"The initial value of cause is input_method."#]
            async fn set_text_change_cause(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_text_change_cause: ChangeCause,
            ) -> crate::server::Result<()>;
            #[doc = r#"Sets the content purpose and content hint. While the purpose is the"#]
            #[doc = r#"basic purpose of an input field, the hint flags allow to modify some of"#]
            #[doc = r#"the behavior."#]
            #[doc = r#""#]
            #[doc = r#"Values set with this request are double-buffered. They will get applied"#]
            #[doc = r#"on the next zwp_text_input_v3.commit request."#]
            #[doc = r#"Subsequent attempts to update them may have no effect. The values"#]
            #[doc = r#"remain valid until the next committed enable or disable request."#]
            #[doc = r#""#]
            #[doc = r#"The initial value for hint is none, and the initial value for purpose"#]
            #[doc = r#"is normal."#]
            async fn set_content_type(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_content_type: ContentHint,
                set_content_type: ContentPurpose,
            ) -> crate::server::Result<()>;
            #[doc = r#"Marks an area around the cursor as a x, y, width, height rectangle in"#]
            #[doc = r#"surface local coordinates."#]
            #[doc = r#""#]
            #[doc = r#"Allows the compositor to put a window with word suggestions near the"#]
            #[doc = r#"cursor, without obstructing the text being input."#]
            #[doc = r#""#]
            #[doc = r#"If the client is unaware of the position of edited text, it should not"#]
            #[doc = r#"issue this request, to signify lack of support to the compositor."#]
            #[doc = r#""#]
            #[doc = r#"Values set with this request are double-buffered. They will get applied"#]
            #[doc = r#"on the next zwp_text_input_v3.commit request, and stay valid until the"#]
            #[doc = r#"next committed enable or disable request."#]
            #[doc = r#""#]
            #[doc = r#"The initial values describing a cursor rectangle are empty. That means"#]
            #[doc = r#"the text input does not support describing the cursor area. If the"#]
            #[doc = r#"empty values get applied, subsequent attempts to change them may have"#]
            #[doc = r#"no effect."#]
            async fn set_cursor_rectangle(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_cursor_rectangle: i32,
                set_cursor_rectangle: i32,
                set_cursor_rectangle: i32,
                set_cursor_rectangle: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Atomically applies state changes recently sent to the compositor."#]
            #[doc = r#""#]
            #[doc = r#"The commit request establishes and updates the state of the client, and"#]
            #[doc = r#"must be issued after any changes to apply them."#]
            #[doc = r#""#]
            #[doc = r#"Text input state (enabled status, content purpose, content hint,"#]
            #[doc = r#"surrounding text and change cause, cursor rectangle) is conceptually"#]
            #[doc = r#"double-buffered within the context of a text input, i.e. between a"#]
            #[doc = r#"committed enable request and the following committed enable or disable"#]
            #[doc = r#"request."#]
            #[doc = r#""#]
            #[doc = r#"Protocol requests modify the pending state, as opposed to the current"#]
            #[doc = r#"state in use by the input method. A commit request atomically applies"#]
            #[doc = r#"all pending state, replacing the current state. After commit, the new"#]
            #[doc = r#"pending state is as documented for each related request."#]
            #[doc = r#""#]
            #[doc = r#"Requests are applied in the order of arrival."#]
            #[doc = r#""#]
            #[doc = r#"Neither current nor pending state are modified unless noted otherwise."#]
            #[doc = r#""#]
            #[doc = r#"The compositor must count the number of commit requests coming from"#]
            #[doc = r#"each zwp_text_input_v3 object and use the count as the serial in done"#]
            #[doc = r#"events."#]
            async fn commit(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Notification that this seat's text-input focus is on a certain surface."#]
            #[doc = r#""#]
            #[doc = r#"If client has created multiple text input objects, compositor must send"#]
            #[doc = r#"this event to all of them."#]
            #[doc = r#""#]
            #[doc = r#"When the seat has the keyboard capability the text-input focus follows"#]
            #[doc = r#"the keyboard focus. This event sets the current surface for the"#]
            #[doc = r#"text-input object."#]
            async fn enter(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v3#{}.enter()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notification that this seat's text-input focus is no longer on a"#]
            #[doc = r#"certain surface. The client should reset any preedit string previously"#]
            #[doc = r#"set."#]
            #[doc = r#""#]
            #[doc = r#"The leave notification clears the current surface. It is sent before"#]
            #[doc = r#"the enter notification for the new focus. After leave event, compositor"#]
            #[doc = r#"must ignore requests from any text input instances until next enter"#]
            #[doc = r#"event."#]
            #[doc = r#""#]
            #[doc = r#"When the seat has the keyboard capability the text-input focus follows"#]
            #[doc = r#"the keyboard focus."#]
            async fn leave(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v3#{}.leave()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(surface))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notify when a new composing text (pre-edit) should be set at the"#]
            #[doc = r#"current cursor position. Any previously set composing text must be"#]
            #[doc = r#"removed. Any previously existing selected text must be removed."#]
            #[doc = r#""#]
            #[doc = r#"The argument text contains the pre-edit string buffer."#]
            #[doc = r#""#]
            #[doc = r#"The parameters cursor_begin and cursor_end are counted in bytes"#]
            #[doc = r#"relative to the beginning of the submitted text buffer. Cursor should"#]
            #[doc = r#"be hidden when both are equal to -1."#]
            #[doc = r#""#]
            #[doc = r#"They could be represented by the client as a line if both values are"#]
            #[doc = r#"the same, or as a text highlight otherwise."#]
            #[doc = r#""#]
            #[doc = r#"Values set with this event are double-buffered. They must be applied"#]
            #[doc = r#"and reset to initial on the next zwp_text_input_v3.done event."#]
            #[doc = r#""#]
            #[doc = r#"The initial value of text is an empty string, and cursor_begin,"#]
            #[doc = r#"cursor_end and cursor_hidden are all 0."#]
            async fn preedit_string(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                text: Option<String>,
                cursor_begin: i32,
                cursor_end: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v3#{}.preedit_string()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(text)
                    .put_int(cursor_begin)
                    .put_int(cursor_end)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notify when text should be inserted into the editor widget. The text to"#]
            #[doc = r#"commit could be either just a single character after a key press or the"#]
            #[doc = r#"result of some composing (pre-edit)."#]
            #[doc = r#""#]
            #[doc = r#"Values set with this event are double-buffered. They must be applied"#]
            #[doc = r#"and reset to initial on the next zwp_text_input_v3.done event."#]
            #[doc = r#""#]
            #[doc = r#"The initial value of text is an empty string."#]
            async fn commit_string(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                text: Option<String>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v3#{}.commit_string()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_string(text).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Notify when the text around the current cursor position should be"#]
            #[doc = r#"deleted."#]
            #[doc = r#""#]
            #[doc = r#"Before_length and after_length are the number of bytes before and after"#]
            #[doc = r#"the current cursor index (excluding the selection) to delete."#]
            #[doc = r#""#]
            #[doc = r#"If a preedit text is present, in effect before_length is counted from"#]
            #[doc = r#"the beginning of it, and after_length from its end (see done event"#]
            #[doc = r#"sequence)."#]
            #[doc = r#""#]
            #[doc = r#"Values set with this event are double-buffered. They must be applied"#]
            #[doc = r#"and reset to initial on the next zwp_text_input_v3.done event."#]
            #[doc = r#""#]
            #[doc = r#"The initial values of both before_length and after_length are 0."#]
            async fn delete_surrounding_text(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                before_length: u32,
                after_length: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwp_text_input_v3#{}.delete_surrounding_text()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(before_length)
                    .put_uint(after_length)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Instruct the application to apply changes to state requested by the"#]
            #[doc = r#"preedit_string, commit_string and delete_surrounding_text events. The"#]
            #[doc = r#"state relating to these events is double-buffered, and each one"#]
            #[doc = r#"modifies the pending state. This event replaces the current state with"#]
            #[doc = r#"the pending state."#]
            #[doc = r#""#]
            #[doc = r#"The application must proceed by evaluating the changes in the following"#]
            #[doc = r#"order:"#]
            #[doc = r#""#]
            #[doc = r#"1. Replace existing preedit string with the cursor."#]
            #[doc = r#"2. Delete requested surrounding text."#]
            #[doc = r#"3. Insert commit string with the cursor at its end."#]
            #[doc = r#"4. Calculate surrounding text to send."#]
            #[doc = r#"5. Insert new preedit text in cursor position."#]
            #[doc = r#"6. Place cursor inside preedit text."#]
            #[doc = r#""#]
            #[doc = r#"The serial number reflects the last state of the zwp_text_input_v3"#]
            #[doc = r#"object known to the compositor. The value of the serial argument must"#]
            #[doc = r#"be equal to the number of commit requests already issued on that object."#]
            #[doc = r#""#]
            #[doc = r#"When the client receives a done event with a serial different than the"#]
            #[doc = r#"number of past commit requests, it must proceed with evaluating and"#]
            #[doc = r#"applying the changes as normal, except it should not change the current"#]
            #[doc = r#"state of the zwp_text_input_v3 object. All pending state requests"#]
            #[doc = r#"(set_surrounding_text, set_content_type and set_cursor_rectangle) on"#]
            #[doc = r#"the zwp_text_input_v3 object should be sent and committed after"#]
            #[doc = r#"receiving a zwp_text_input_v3.done event with a matching serial."#]
            async fn done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwp_text_input_v3#{}.done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 5, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwp_text_input_manager_v3 {
        #[doc = r#"A factory for text-input objects. This object is a global singleton."#]
        pub trait ZwpTextInputManagerV3: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwp_text_input_manager_v3";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwp_text_input_manager_v3#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("zwp_text_input_manager_v3#{}.get_text_input()", object.id);
                        self.get_text_input(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the wp_text_input_manager object."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Creates a new text-input object for a given seat."#]
            async fn get_text_input(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_text_input: crate::wire::ObjectId,
                get_text_input: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod xdg_decoration_unstable_v1 {
    pub mod zxdg_decoration_manager_v1 {
        #[doc = r#"This interface allows a compositor to announce support for server-side"#]
        #[doc = r#"decorations."#]
        #[doc = r#""#]
        #[doc = r#"A window decoration is a set of window controls as deemed appropriate by"#]
        #[doc = r#"the party managing them, such as user interface components used to move,"#]
        #[doc = r#"resize and change a window's state."#]
        #[doc = r#""#]
        #[doc = r#"A client can use this protocol to request being decorated by a supporting"#]
        #[doc = r#"compositor."#]
        #[doc = r#""#]
        #[doc = r#"If compositor and client do not negotiate the use of a server-side"#]
        #[doc = r#"decoration using this protocol, clients continue to self-decorate as they"#]
        #[doc = r#"see fit."#]
        #[doc = r#""#]
        #[doc = r#"Warning! The protocol described in this file is experimental and"#]
        #[doc = r#"backward incompatible changes may be made. Backward compatible changes"#]
        #[doc = r#"may be added together with the corresponding interface version bump."#]
        #[doc = r#"Backward incompatible changes are done by bumping the version number in"#]
        #[doc = r#"the protocol and interface names and resetting the interface version."#]
        #[doc = r#"Once the protocol is to be declared stable, the 'z' prefix and the"#]
        #[doc = r#"version number in the protocol and interface names are removed and the"#]
        #[doc = r#"interface version number is reset."#]
        pub trait ZxdgDecorationManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_decoration_manager_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zxdg_decoration_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!(
                            "zxdg_decoration_manager_v1#{}.get_toplevel_decoration()",
                            object.id
                        );
                        self.get_toplevel_decoration(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the decoration manager. This doesn't destroy objects created"#]
            #[doc = r#"with the manager."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Create a new decoration object associated with the given toplevel."#]
            #[doc = r#""#]
            #[doc = r#"Creating an xdg_toplevel_decoration from an xdg_toplevel which has a"#]
            #[doc = r#"buffer attached or committed is a client error, and any attempts by a"#]
            #[doc = r#"client to attach or manipulate a buffer prior to the first"#]
            #[doc = r#"xdg_toplevel_decoration.configure event must also be treated as"#]
            #[doc = r#"errors."#]
            async fn get_toplevel_decoration(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_toplevel_decoration: crate::wire::ObjectId,
                get_toplevel_decoration: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zxdg_toplevel_decoration_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Xdg_toplevel has a buffer attached before configure"#]
            UnconfiguredBuffer = 0,
            #[doc = r#"Xdg_toplevel already has a decoration object"#]
            AlreadyConstructed = 1,
            #[doc = r#"Xdg_toplevel destroyed before the decoration object"#]
            Orphaned = 2,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::UnconfiguredBuffer),
                    1 => Ok(Self::AlreadyConstructed),
                    2 => Ok(Self::Orphaned),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"These values describe window decoration modes."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Mode {
            #[doc = r#"No server-side window decoration"#]
            ClientSide = 1,
            #[doc = r#"Server-side window decoration"#]
            ServerSide = 2,
        }
        impl TryFrom<u32> for Mode {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::ClientSide),
                    2 => Ok(Self::ServerSide),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"The decoration object allows the compositor to toggle server-side window"#]
        #[doc = r#"decorations for a toplevel surface. The client can request to switch to"#]
        #[doc = r#"another mode."#]
        #[doc = r#""#]
        #[doc = r#"The xdg_toplevel_decoration object must be destroyed before its"#]
        #[doc = r#"xdg_toplevel."#]
        pub trait ZxdgToplevelDecorationV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_toplevel_decoration_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zxdg_toplevel_decoration_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("zxdg_toplevel_decoration_v1#{}.set_mode()", object.id);
                        self.set_mode(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    2 => {
                        tracing::debug!("zxdg_toplevel_decoration_v1#{}.unset_mode()", object.id);
                        self.unset_mode(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Switch back to a mode without any server-side decorations at the next"#]
            #[doc = r#"commit."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set the toplevel surface decoration mode. This informs the compositor"#]
            #[doc = r#"that the client prefers the provided decoration mode."#]
            #[doc = r#""#]
            #[doc = r#"After requesting a decoration mode, the compositor will respond by"#]
            #[doc = r#"emitting an xdg_surface.configure event. The client should then update"#]
            #[doc = r#"its content, drawing it without decorations if the received mode is"#]
            #[doc = r#"server-side decorations. The client must also acknowledge the configure"#]
            #[doc = r#"when committing the new content (see xdg_surface.ack_configure)."#]
            #[doc = r#""#]
            #[doc = r#"The compositor can decide not to use the client's mode and enforce a"#]
            #[doc = r#"different mode instead."#]
            #[doc = r#""#]
            #[doc = r#"Clients whose decoration mode depend on the xdg_toplevel state may send"#]
            #[doc = r#"a set_mode request in response to an xdg_surface.configure event and wait"#]
            #[doc = r#"for the next xdg_surface.configure event to prevent unwanted state."#]
            #[doc = r#"Such clients are responsible for preventing configure loops and must"#]
            #[doc = r#"make sure not to send multiple successive set_mode requests with the"#]
            #[doc = r#"same decoration mode."#]
            async fn set_mode(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_mode: Mode,
            ) -> crate::server::Result<()>;
            #[doc = r#"Unset the toplevel surface decoration mode. This informs the compositor"#]
            #[doc = r#"that the client doesn't prefer a particular decoration mode."#]
            #[doc = r#""#]
            #[doc = r#"This request has the same semantics as set_mode."#]
            async fn unset_mode(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"The configure event configures the effective decoration mode. The"#]
            #[doc = r#"configured state should not be applied immediately. Clients must send an"#]
            #[doc = r#"ack_configure in response to this event. See xdg_surface.configure and"#]
            #[doc = r#"xdg_surface.ack_configure for details."#]
            #[doc = r#""#]
            #[doc = r#"A configure event can be sent at any time. The specified mode must be"#]
            #[doc = r#"obeyed by the client."#]
            async fn configure(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                mode: Mode,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_toplevel_decoration_v1#{}.configure()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(mode as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = r#"This protocol specifies a way for making it possible to reference a surface"#]
#[doc = r#"of a different client. With such a reference, a client can, by using the"#]
#[doc = r#"interfaces provided by this protocol, manipulate the relationship between"#]
#[doc = r#"its own surfaces and the surface of some other client. For example, stack"#]
#[doc = r#"some of its own surface above the other clients surface."#]
#[doc = r#""#]
#[doc = r#"In order for a client A to get a reference of a surface of client B, client"#]
#[doc = r#"B must first export its surface using xdg_exporter.export. Upon doing this,"#]
#[doc = r#"client B will receive a handle (a unique string) that it may share with"#]
#[doc = r#"client A in some way (for example D-Bus). After client A has received the"#]
#[doc = r#"handle from client B, it may use xdg_importer.import to create a reference"#]
#[doc = r#"to the surface client B just exported. See the corresponding requests for"#]
#[doc = r#"details."#]
#[doc = r#""#]
#[doc = r#"A possible use case for this is out-of-process dialogs. For example when a"#]
#[doc = r#"sandboxed client without file system access needs the user to select a file"#]
#[doc = r#"on the file system, given sandbox environment support, it can export its"#]
#[doc = r#"surface, passing the exported surface handle to an unsandboxed process that"#]
#[doc = r#"can show a file browser dialog and stack it above the sandboxed client's"#]
#[doc = r#"surface."#]
#[doc = r#""#]
#[doc = r#"Warning! The protocol described in this file is experimental and backward"#]
#[doc = r#"incompatible changes may be made. Backward compatible changes may be added"#]
#[doc = r#"together with the corresponding interface version bump. Backward"#]
#[doc = r#"incompatible changes are done by bumping the version number in the protocol"#]
#[doc = r#"and interface names and resetting the interface version. Once the protocol"#]
#[doc = r#"is to be declared stable, the 'z' prefix and the version number in the"#]
#[doc = r#"protocol and interface names are removed and the interface version number is"#]
#[doc = r#"reset."#]
pub mod xdg_foreign_unstable_v1 {
    pub mod zxdg_exporter_v1 {
        #[doc = r#"A global interface used for exporting surfaces that can later be imported"#]
        #[doc = r#"using xdg_importer."#]
        pub trait ZxdgExporterV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_exporter_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zxdg_exporter_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("zxdg_exporter_v1#{}.export()", object.id);
                        self.export(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Notify the compositor that the xdg_exporter object will no longer be"#]
            #[doc = r#"used."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"The export request exports the passed surface so that it can later be"#]
            #[doc = r#"imported via xdg_importer. When called, a new xdg_exported object will"#]
            #[doc = r#"be created and xdg_exported.handle will be sent immediately. See the"#]
            #[doc = r#"corresponding interface and event for details."#]
            #[doc = r#""#]
            #[doc = r#"A surface may be exported multiple times, and each exported handle may"#]
            #[doc = r#"be used to create an xdg_imported multiple times. Only xdg_surface"#]
            #[doc = r#"surfaces may be exported."#]
            async fn export(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                export: crate::wire::ObjectId,
                export: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zxdg_importer_v1 {
        #[doc = r#"A global interface used for importing surfaces exported by xdg_exporter."#]
        #[doc = r#"With this interface, a client can create a reference to a surface of"#]
        #[doc = r#"another client."#]
        pub trait ZxdgImporterV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_importer_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zxdg_importer_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("zxdg_importer_v1#{}.import()", object.id);
                        self.import(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Notify the compositor that the xdg_importer object will no longer be"#]
            #[doc = r#"used."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"The import request imports a surface from any client given a handle"#]
            #[doc = r#"retrieved by exporting said surface using xdg_exporter.export. When"#]
            #[doc = r#"called, a new xdg_imported object will be created. This new object"#]
            #[doc = r#"represents the imported surface, and the importing client can"#]
            #[doc = r#"manipulate its relationship using it. See xdg_imported for details."#]
            async fn import(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                import: crate::wire::ObjectId,
                import: String,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zxdg_exported_v1 {
        #[doc = r#"An xdg_exported object represents an exported reference to a surface. The"#]
        #[doc = r#"exported surface may be referenced as long as the xdg_exported object not"#]
        #[doc = r#"destroyed. Destroying the xdg_exported invalidates any relationship the"#]
        #[doc = r#"importer may have established using xdg_imported."#]
        pub trait ZxdgExportedV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_exported_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zxdg_exported_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Revoke the previously exported surface. This invalidates any"#]
            #[doc = r#"relationship the importer may have set up using the xdg_imported created"#]
            #[doc = r#"given the handle sent via xdg_exported.handle."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"The handle event contains the unique handle of this exported surface"#]
            #[doc = r#"reference. It may be shared with any client, which then can use it to"#]
            #[doc = r#"import the surface by calling xdg_importer.import. A handle may be"#]
            #[doc = r#"used to import the surface multiple times."#]
            async fn handle(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                handle: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_exported_v1#{}.handle()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(handle))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zxdg_imported_v1 {
        #[doc = r#"An xdg_imported object represents an imported reference to surface exported"#]
        #[doc = r#"by some client. A client can use this interface to manipulate"#]
        #[doc = r#"relationships between its own surfaces and the imported surface."#]
        pub trait ZxdgImportedV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_imported_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zxdg_imported_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("zxdg_imported_v1#{}.set_parent_of()", object.id);
                        self.set_parent_of(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Notify the compositor that it will no longer use the xdg_imported"#]
            #[doc = r#"object. Any relationship that may have been set up will at this point"#]
            #[doc = r#"be invalidated."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set the imported surface as the parent of some surface of the client."#]
            #[doc = r#"The passed surface must be a toplevel xdg_surface. Calling this function"#]
            #[doc = r#"sets up a surface to surface relation with the same stacking and positioning"#]
            #[doc = r#"semantics as xdg_surface.set_parent."#]
            async fn set_parent_of(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_parent_of: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"The imported surface handle has been destroyed and any relationship set"#]
            #[doc = r#"up has been invalidated. This may happen for various reasons, for"#]
            #[doc = r#"example if the exported surface or the exported surface handle has been"#]
            #[doc = r#"destroyed, if the handle used for importing was invalid."#]
            async fn destroyed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_imported_v1#{}.destroyed()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = r#"This protocol specifies a way for making it possible to reference a surface"#]
#[doc = r#"of a different client. With such a reference, a client can, by using the"#]
#[doc = r#"interfaces provided by this protocol, manipulate the relationship between"#]
#[doc = r#"its own surfaces and the surface of some other client. For example, stack"#]
#[doc = r#"some of its own surface above the other clients surface."#]
#[doc = r#""#]
#[doc = r#"In order for a client A to get a reference of a surface of client B, client"#]
#[doc = r#"B must first export its surface using xdg_exporter.export_toplevel. Upon"#]
#[doc = r#"doing this, client B will receive a handle (a unique string) that it may"#]
#[doc = r#"share with client A in some way (for example D-Bus). After client A has"#]
#[doc = r#"received the handle from client B, it may use xdg_importer.import_toplevel"#]
#[doc = r#"to create a reference to the surface client B just exported. See the"#]
#[doc = r#"corresponding requests for details."#]
#[doc = r#""#]
#[doc = r#"A possible use case for this is out-of-process dialogs. For example when a"#]
#[doc = r#"sandboxed client without file system access needs the user to select a file"#]
#[doc = r#"on the file system, given sandbox environment support, it can export its"#]
#[doc = r#"surface, passing the exported surface handle to an unsandboxed process that"#]
#[doc = r#"can show a file browser dialog and stack it above the sandboxed client's"#]
#[doc = r#"surface."#]
#[doc = r#""#]
#[doc = r#"Warning! The protocol described in this file is experimental and backward"#]
#[doc = r#"incompatible changes may be made. Backward compatible changes may be added"#]
#[doc = r#"together with the corresponding interface version bump. Backward"#]
#[doc = r#"incompatible changes are done by bumping the version number in the protocol"#]
#[doc = r#"and interface names and resetting the interface version. Once the protocol"#]
#[doc = r#"is to be declared stable, the 'z' prefix and the version number in the"#]
#[doc = r#"protocol and interface names are removed and the interface version number is"#]
#[doc = r#"reset."#]
pub mod xdg_foreign_unstable_v2 {
    pub mod zxdg_exporter_v2 {
        #[doc = r#"These errors can be emitted in response to invalid xdg_exporter"#]
        #[doc = r#"requests."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Surface is not an xdg_toplevel"#]
            InvalidSurface = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::InvalidSurface),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"A global interface used for exporting surfaces that can later be imported"#]
        #[doc = r#"using xdg_importer."#]
        pub trait ZxdgExporterV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_exporter_v2";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zxdg_exporter_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("zxdg_exporter_v2#{}.export_toplevel()", object.id);
                        self.export_toplevel(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Notify the compositor that the xdg_exporter object will no longer be"#]
            #[doc = r#"used."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"The export_toplevel request exports the passed surface so that it can later be"#]
            #[doc = r#"imported via xdg_importer. When called, a new xdg_exported object will"#]
            #[doc = r#"be created and xdg_exported.handle will be sent immediately. See the"#]
            #[doc = r#"corresponding interface and event for details."#]
            #[doc = r#""#]
            #[doc = r#"A surface may be exported multiple times, and each exported handle may"#]
            #[doc = r#"be used to create an xdg_imported multiple times. Only xdg_toplevel"#]
            #[doc = r#"equivalent surfaces may be exported, otherwise an invalid_surface"#]
            #[doc = r#"protocol error is sent."#]
            async fn export_toplevel(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                export_toplevel: crate::wire::ObjectId,
                export_toplevel: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zxdg_importer_v2 {
        #[doc = r#"A global interface used for importing surfaces exported by xdg_exporter."#]
        #[doc = r#"With this interface, a client can create a reference to a surface of"#]
        #[doc = r#"another client."#]
        pub trait ZxdgImporterV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_importer_v2";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zxdg_importer_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("zxdg_importer_v2#{}.import_toplevel()", object.id);
                        self.import_toplevel(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Notify the compositor that the xdg_importer object will no longer be"#]
            #[doc = r#"used."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"The import_toplevel request imports a surface from any client given a handle"#]
            #[doc = r#"retrieved by exporting said surface using xdg_exporter.export_toplevel."#]
            #[doc = r#"When called, a new xdg_imported object will be created. This new object"#]
            #[doc = r#"represents the imported surface, and the importing client can"#]
            #[doc = r#"manipulate its relationship using it. See xdg_imported for details."#]
            async fn import_toplevel(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                import_toplevel: crate::wire::ObjectId,
                import_toplevel: String,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zxdg_exported_v2 {
        #[doc = r#"An xdg_exported object represents an exported reference to a surface. The"#]
        #[doc = r#"exported surface may be referenced as long as the xdg_exported object not"#]
        #[doc = r#"destroyed. Destroying the xdg_exported invalidates any relationship the"#]
        #[doc = r#"importer may have established using xdg_imported."#]
        pub trait ZxdgExportedV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_exported_v2";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zxdg_exported_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Revoke the previously exported surface. This invalidates any"#]
            #[doc = r#"relationship the importer may have set up using the xdg_imported created"#]
            #[doc = r#"given the handle sent via xdg_exported.handle."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"The handle event contains the unique handle of this exported surface"#]
            #[doc = r#"reference. It may be shared with any client, which then can use it to"#]
            #[doc = r#"import the surface by calling xdg_importer.import_toplevel. A handle"#]
            #[doc = r#"may be used to import the surface multiple times."#]
            async fn handle(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                handle: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_exported_v2#{}.handle()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(handle))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zxdg_imported_v2 {
        #[doc = r#"These errors can be emitted in response to invalid xdg_imported"#]
        #[doc = r#"requests."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Surface is not an xdg_toplevel"#]
            InvalidSurface = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::InvalidSurface),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"An xdg_imported object represents an imported reference to surface exported"#]
        #[doc = r#"by some client. A client can use this interface to manipulate"#]
        #[doc = r#"relationships between its own surfaces and the imported surface."#]
        pub trait ZxdgImportedV2: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_imported_v2";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zxdg_imported_v2#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("zxdg_imported_v2#{}.set_parent_of()", object.id);
                        self.set_parent_of(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Notify the compositor that it will no longer use the xdg_imported"#]
            #[doc = r#"object. Any relationship that may have been set up will at this point"#]
            #[doc = r#"be invalidated."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set the imported surface as the parent of some surface of the client."#]
            #[doc = r#"The passed surface must be an xdg_toplevel equivalent, otherwise an"#]
            #[doc = r#"invalid_surface protocol error is sent. Calling this function sets up"#]
            #[doc = r#"a surface to surface relation with the same stacking and positioning"#]
            #[doc = r#"semantics as xdg_toplevel.set_parent."#]
            async fn set_parent_of(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_parent_of: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"The imported surface handle has been destroyed and any relationship set"#]
            #[doc = r#"up has been invalidated. This may happen for various reasons, for"#]
            #[doc = r#"example if the exported surface or the exported surface handle has been"#]
            #[doc = r#"destroyed, if the handle used for importing was invalid."#]
            async fn destroyed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_imported_v2#{}.destroyed()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = r#"This protocol aims at describing outputs in a way which is more in line"#]
#[doc = r#"with the concept of an output on desktop oriented systems."#]
#[doc = r#""#]
#[doc = r#"Some information are more specific to the concept of an output for"#]
#[doc = r#"a desktop oriented system and may not make sense in other applications,"#]
#[doc = r#"such as IVI systems for example."#]
#[doc = r#""#]
#[doc = r#"Typically, the global compositor space on a desktop system is made of"#]
#[doc = r#"a contiguous or overlapping set of rectangular regions."#]
#[doc = r#""#]
#[doc = r#"The logical_position and logical_size events defined in this protocol"#]
#[doc = r#"might provide information identical to their counterparts already"#]
#[doc = r#"available from wl_output, in which case the information provided by this"#]
#[doc = r#"protocol should be preferred to their equivalent in wl_output. The goal is"#]
#[doc = r#"to move the desktop specific concepts (such as output location within the"#]
#[doc = r#"global compositor space, etc.) out of the core wl_output protocol."#]
#[doc = r#""#]
#[doc = r#"Warning! The protocol described in this file is experimental and"#]
#[doc = r#"backward incompatible changes may be made. Backward compatible"#]
#[doc = r#"changes may be added together with the corresponding interface"#]
#[doc = r#"version bump."#]
#[doc = r#"Backward incompatible changes are done by bumping the version"#]
#[doc = r#"number in the protocol and interface names and resetting the"#]
#[doc = r#"interface version. Once the protocol is to be declared stable,"#]
#[doc = r#"the 'z' prefix and the version number in the protocol and"#]
#[doc = r#"interface names are removed and the interface version number is"#]
#[doc = r#"reset."#]
pub mod xdg_output_unstable_v1 {
    pub mod zxdg_output_manager_v1 {
        #[doc = r#"A global factory interface for xdg_output objects."#]
        pub trait ZxdgOutputManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_output_manager_v1";
            const VERSION: u32 = 3;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zxdg_output_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("zxdg_output_manager_v1#{}.get_xdg_output()", object.id);
                        self.get_xdg_output(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Using this request a client can tell the server that it is not"#]
            #[doc = r#"going to use the xdg_output_manager object anymore."#]
            #[doc = r#""#]
            #[doc = r#"Any objects already created through this instance are not affected."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This creates a new xdg_output object for the given wl_output."#]
            async fn get_xdg_output(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_xdg_output: crate::wire::ObjectId,
                get_xdg_output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zxdg_output_v1 {
        #[doc = r#"An xdg_output describes part of the compositor geometry."#]
        #[doc = r#""#]
        #[doc = r#"This typically corresponds to a monitor that displays part of the"#]
        #[doc = r#"compositor space."#]
        #[doc = r#""#]
        #[doc = r#"For objects version 3 onwards, after all xdg_output properties have been"#]
        #[doc = r#"sent (when the object is created and when properties are updated), a"#]
        #[doc = r#"wl_output.done event is sent. This allows changes to the output"#]
        #[doc = r#"properties to be seen as atomic, even if they happen via multiple events."#]
        pub trait ZxdgOutputV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_output_v1";
            const VERSION: u32 = 3;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zxdg_output_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Using this request a client can tell the server that it is not"#]
            #[doc = r#"going to use the xdg_output object anymore."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"The position event describes the location of the wl_output within"#]
            #[doc = r#"the global compositor space."#]
            #[doc = r#""#]
            #[doc = r#"The logical_position event is sent after creating an xdg_output"#]
            #[doc = r#"(see xdg_output_manager.get_xdg_output) and whenever the location"#]
            #[doc = r#"of the output changes within the global compositor space."#]
            async fn logical_position(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_output_v1#{}.logical_position()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(x)
                    .put_int(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The logical_size event describes the size of the output in the"#]
            #[doc = r#"global compositor space."#]
            #[doc = r#""#]
            #[doc = r#"Most regular Wayland clients should not pay attention to the"#]
            #[doc = r#"logical size and would rather rely on xdg_shell interfaces."#]
            #[doc = r#""#]
            #[doc = r#"Some clients such as Xwayland, however, need this to configure"#]
            #[doc = r#"their surfaces in the global compositor space as the compositor"#]
            #[doc = r#"may apply a different scale from what is advertised by the output"#]
            #[doc = r#"scaling property (to achieve fractional scaling, for example)."#]
            #[doc = r#""#]
            #[doc = r#"For example, for a wl_output mode 38402160 and a scale factor 2:"#]
            #[doc = r#""#]
            #[doc = r#"- A compositor not scaling the monitor viewport in its compositing space"#]
            #[doc = r#"will advertise a logical size of 38402160,"#]
            #[doc = r#""#]
            #[doc = r#"- A compositor scaling the monitor viewport with scale factor 2 will"#]
            #[doc = r#"advertise a logical size of 19201080,"#]
            #[doc = r#""#]
            #[doc = r#"- A compositor scaling the monitor viewport using a fractional scale of"#]
            #[doc = r#"1.5 will advertise a logical size of 25601440."#]
            #[doc = r#""#]
            #[doc = r#"For example, for a wl_output mode 19201080 and a 90 degree rotation,"#]
            #[doc = r#"the compositor will advertise a logical size of 1080x1920."#]
            #[doc = r#""#]
            #[doc = r#"The logical_size event is sent after creating an xdg_output"#]
            #[doc = r#"(see xdg_output_manager.get_xdg_output) and whenever the logical"#]
            #[doc = r#"size of the output changes, either as a result of a change in the"#]
            #[doc = r#"applied scale or because of a change in the corresponding output"#]
            #[doc = r#"mode(see wl_output.mode) or transform (see wl_output.transform)."#]
            async fn logical_size(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_output_v1#{}.logical_size()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent after all other properties of an xdg_output"#]
            #[doc = r#"have been sent."#]
            #[doc = r#""#]
            #[doc = r#"This allows changes to the xdg_output properties to be seen as"#]
            #[doc = r#"atomic, even if they happen via multiple events."#]
            #[doc = r#""#]
            #[doc = r#"For objects version 3 onwards, this event is deprecated. Compositors"#]
            #[doc = r#"are not required to send it anymore and must send wl_output.done"#]
            #[doc = r#"instead."#]
            async fn done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_output_v1#{}.done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Many compositors will assign names to their outputs, show them to the"#]
            #[doc = r#"user, allow them to be configured by name, etc. The client may wish to"#]
            #[doc = r#"know this name as well to offer the user similar behaviors."#]
            #[doc = r#""#]
            #[doc = r#"The naming convention is compositor defined, but limited to"#]
            #[doc = r#"alphanumeric characters and dashes (-). Each name is unique among all"#]
            #[doc = r#"wl_output globals, but if a wl_output global is destroyed the same name"#]
            #[doc = r#"may be reused later. The names will also remain consistent across"#]
            #[doc = r#"sessions with the same hardware and software configuration."#]
            #[doc = r#""#]
            #[doc = r#"Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do"#]
            #[doc = r#"not assume that the name is a reflection of an underlying DRM"#]
            #[doc = r#"connector, X11 connection, etc."#]
            #[doc = r#""#]
            #[doc = r#"The name event is sent after creating an xdg_output (see"#]
            #[doc = r#"xdg_output_manager.get_xdg_output). This event is only sent once per"#]
            #[doc = r#"xdg_output, and the name does not change over the lifetime of the"#]
            #[doc = r#"wl_output global."#]
            #[doc = r#""#]
            #[doc = r#"This event is deprecated, instead clients should use wl_output.name."#]
            #[doc = r#"Compositors must still support this event."#]
            async fn name(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_output_v1#{}.name()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(name))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Many compositors can produce human-readable descriptions of their"#]
            #[doc = r#"outputs.  The client may wish to know this description as well, to"#]
            #[doc = r#"communicate the user for various purposes."#]
            #[doc = r#""#]
            #[doc = r#"The description is a UTF-8 string with no convention defined for its"#]
            #[doc = r#"contents. Examples might include 'Foocorp 11" Display' or 'Virtual X11"#]
            #[doc = r#"output via :1'."#]
            #[doc = r#""#]
            #[doc = r#"The description event is sent after creating an xdg_output (see"#]
            #[doc = r#"xdg_output_manager.get_xdg_output) and whenever the description"#]
            #[doc = r#"changes. The description is optional, and may not be sent at all."#]
            #[doc = r#""#]
            #[doc = r#"For objects of version 2 and lower, this event is only sent once per"#]
            #[doc = r#"xdg_output, and the description does not change over the lifetime of"#]
            #[doc = r#"the wl_output global."#]
            #[doc = r#""#]
            #[doc = r#"This event is deprecated, instead clients should use"#]
            #[doc = r#"wl_output.description. Compositors must still support this event."#]
            async fn description(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                description: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_output_v1#{}.description()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(description))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod xdg_shell_unstable_v5 {
    pub mod xdg_shell {
        #[doc = r#"The 'current' member of this enum gives the version of the"#]
        #[doc = r#"protocol.  Implementations can compare this to the version"#]
        #[doc = r#"they implement using static_assert to ensure the protocol and"#]
        #[doc = r#"implementation versions match."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Version {
            #[doc = r#"Always the latest version"#]
            Current = 5,
        }
        impl TryFrom<u32> for Version {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    5 => Ok(Self::Current),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Given wl_surface has another role"#]
            Role = 0,
            #[doc = r#"Xdg_shell was destroyed before children"#]
            DefunctSurfaces = 1,
            #[doc = r#"The client tried to map or destroy a non-topmost popup"#]
            NotTheTopmostPopup = 2,
            #[doc = r#"The client specified an invalid popup parent surface"#]
            InvalidPopupParent = 3,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Role),
                    1 => Ok(Self::DefunctSurfaces),
                    2 => Ok(Self::NotTheTopmostPopup),
                    3 => Ok(Self::InvalidPopupParent),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"xdg_shell allows clients to turn a wl_surface into a "real window""#]
        #[doc = r#"which can be dragged, resized, stacked, and moved around by the"#]
        #[doc = r#"user. Everything about this interface is suited towards traditional"#]
        #[doc = r#"desktop environments."#]
        pub trait XdgShell: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_shell";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("xdg_shell#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("xdg_shell#{}.use_unstable_version()", object.id);
                        self.use_unstable_version(object, client, message.int()?)
                            .await
                    }
                    2 => {
                        tracing::debug!("xdg_shell#{}.get_xdg_surface()", object.id);
                        self.get_xdg_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3 => {
                        tracing::debug!("xdg_shell#{}.get_xdg_popup()", object.id);
                        self.get_xdg_popup(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    4 => {
                        tracing::debug!("xdg_shell#{}.pong()", object.id);
                        self.pong(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy this xdg_shell object."#]
            #[doc = r#""#]
            #[doc = r#"Destroying a bound xdg_shell object while there are surfaces"#]
            #[doc = r#"still alive created by this xdg_shell object instance is illegal"#]
            #[doc = r#"and will result in a protocol error."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Negotiate the unstable version of the interface.  This"#]
            #[doc = r#"mechanism is in place to ensure client and server agree on the"#]
            #[doc = r#"unstable versions of the protocol that they speak or exit"#]
            #[doc = r#"cleanly if they don't agree.  This request will go away once"#]
            #[doc = r#"the xdg-shell protocol is stable."#]
            async fn use_unstable_version(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                use_unstable_version: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"This creates an xdg_surface for the given surface and gives it the"#]
            #[doc = r#"xdg_surface role. A wl_surface can only be given an xdg_surface role"#]
            #[doc = r#"once. If get_xdg_surface is called with a wl_surface that already has"#]
            #[doc = r#"an active xdg_surface associated with it, or if it had any other role,"#]
            #[doc = r#"an error is raised."#]
            #[doc = r#""#]
            #[doc = r#"See the documentation of xdg_surface for more details about what an"#]
            #[doc = r#"xdg_surface is and how it is used."#]
            async fn get_xdg_surface(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_xdg_surface: crate::wire::ObjectId,
                get_xdg_surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"This creates an xdg_popup for the given surface and gives it the"#]
            #[doc = r#"xdg_popup role. A wl_surface can only be given an xdg_popup role"#]
            #[doc = r#"once. If get_xdg_popup is called with a wl_surface that already has"#]
            #[doc = r#"an active xdg_popup associated with it, or if it had any other role,"#]
            #[doc = r#"an error is raised."#]
            #[doc = r#""#]
            #[doc = r#"This request must be used in response to some sort of user action"#]
            #[doc = r#"like a button press, key press, or touch down event."#]
            #[doc = r#""#]
            #[doc = r#"See the documentation of xdg_popup for more details about what an"#]
            #[doc = r#"xdg_popup is and how it is used."#]
            async fn get_xdg_popup(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_xdg_popup: crate::wire::ObjectId,
                get_xdg_popup: crate::wire::ObjectId,
                get_xdg_popup: crate::wire::ObjectId,
                get_xdg_popup: crate::wire::ObjectId,
                get_xdg_popup: u32,
                get_xdg_popup: i32,
                get_xdg_popup: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"A client must respond to a ping event with a pong request or"#]
            #[doc = r#"the client may be deemed unresponsive."#]
            async fn pong(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                pong: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"The ping event asks the client if it's still alive. Pass the"#]
            #[doc = r#"serial specified in the event back to the compositor by sending"#]
            #[doc = r#"a "pong" request back with the specified serial."#]
            #[doc = r#""#]
            #[doc = r#"Compositors can use this to determine if the client is still"#]
            #[doc = r#"alive. It's unspecified what will happen if the client doesn't"#]
            #[doc = r#"respond to the ping request, or in what timeframe. Clients should"#]
            #[doc = r#"try to respond in a reasonable amount of time."#]
            #[doc = r#""#]
            #[doc = r#"A compositor is free to ping in any way it wants, but a client must"#]
            #[doc = r#"always respond to any xdg_shell object it created."#]
            async fn ping(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_shell#{}.ping()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod xdg_surface {
        #[doc = r#"These values are used to indicate which edge of a surface"#]
        #[doc = r#"is being dragged in a resize operation."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ResizeEdge {
            None = 0,
            Top = 1,
            Bottom = 2,
            Left = 4,
            TopLeft = 5,
            BottomLeft = 6,
            Right = 8,
            TopRight = 9,
            BottomRight = 10,
        }
        impl TryFrom<u32> for ResizeEdge {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::None),
                    1 => Ok(Self::Top),
                    2 => Ok(Self::Bottom),
                    4 => Ok(Self::Left),
                    5 => Ok(Self::TopLeft),
                    6 => Ok(Self::BottomLeft),
                    8 => Ok(Self::Right),
                    9 => Ok(Self::TopRight),
                    10 => Ok(Self::BottomRight),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"The different state values used on the surface. This is designed for"#]
        #[doc = r#"state values like maximized, fullscreen. It is paired with the"#]
        #[doc = r#"configure event to ensure that both the client and the compositor"#]
        #[doc = r#"setting the state can be synchronized."#]
        #[doc = r#""#]
        #[doc = r#"States set in this way are double-buffered. They will get applied on"#]
        #[doc = r#"the next commit."#]
        #[doc = r#""#]
        #[doc = r#"Desktop environments may extend this enum by taking up a range of"#]
        #[doc = r#"values and documenting the range they chose in this description."#]
        #[doc = r#"They are not required to document the values for the range that they"#]
        #[doc = r#"chose. Ideally, any good extensions from a desktop environment should"#]
        #[doc = r#"make its way into standardization into this enum."#]
        #[doc = r#""#]
        #[doc = r#"The current reserved ranges are:"#]
        #[doc = r#""#]
        #[doc = r#"0x0000 - 0x0FFF: xdg-shell core values, documented below."#]
        #[doc = r#"0x1000 - 0x1FFF: GNOME"#]
        #[doc = r#"0x2000 - 0x2FFF: EFL"#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum State {
            #[doc = r#"The surface is maximized"#]
            Maximized = 1,
            #[doc = r#"The surface is fullscreen"#]
            Fullscreen = 2,
            #[doc = r#"The surface is being resized"#]
            Resizing = 3,
            #[doc = r#"The surface is now activated"#]
            Activated = 4,
        }
        impl TryFrom<u32> for State {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::Maximized),
                    2 => Ok(Self::Fullscreen),
                    3 => Ok(Self::Resizing),
                    4 => Ok(Self::Activated),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"An interface that may be implemented by a wl_surface, for"#]
        #[doc = r#"implementations that provide a desktop-style user interface."#]
        #[doc = r#""#]
        #[doc = r#"It provides requests to treat surfaces like windows, allowing to set"#]
        #[doc = r#"properties like maximized, fullscreen, minimized, and to move and resize"#]
        #[doc = r#"them, and associate metadata like title and app id."#]
        #[doc = r#""#]
        #[doc = r#"The client must call wl_surface.commit on the corresponding wl_surface"#]
        #[doc = r#"for the xdg_surface state to take effect. Prior to committing the new"#]
        #[doc = r#"state, it can set up initial configuration, such as maximizing or setting"#]
        #[doc = r#"a window geometry."#]
        #[doc = r#""#]
        #[doc = r#"Even without attaching a buffer the compositor must respond to initial"#]
        #[doc = r#"committed configuration, for instance sending a configure event with"#]
        #[doc = r#"expected window geometry if the client maximized its surface during"#]
        #[doc = r#"initialization."#]
        #[doc = r#""#]
        #[doc = r#"For a surface to be mapped by the compositor the client must have"#]
        #[doc = r#"committed both an xdg_surface state and a buffer."#]
        pub trait XdgSurface: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_surface";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("xdg_surface#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("xdg_surface#{}.set_parent()", object.id);
                        self.set_parent(object, client, message.object()?).await
                    }
                    2 => {
                        tracing::debug!("xdg_surface#{}.set_title()", object.id);
                        self.set_title(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3 => {
                        tracing::debug!("xdg_surface#{}.set_app_id()", object.id);
                        self.set_app_id(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    4 => {
                        tracing::debug!("xdg_surface#{}.show_window_menu()", object.id);
                        self.show_window_menu(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    5 => {
                        tracing::debug!("xdg_surface#{}.move()", object.id);
                        self.r#move(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    6 => {
                        tracing::debug!("xdg_surface#{}.resize()", object.id);
                        self.resize(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    7 => {
                        tracing::debug!("xdg_surface#{}.ack_configure()", object.id);
                        self.ack_configure(object, client, message.uint()?).await
                    }
                    8 => {
                        tracing::debug!("xdg_surface#{}.set_window_geometry()", object.id);
                        self.set_window_geometry(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    9 => {
                        tracing::debug!("xdg_surface#{}.set_maximized()", object.id);
                        self.set_maximized(object, client).await
                    }
                    10 => {
                        tracing::debug!("xdg_surface#{}.unset_maximized()", object.id);
                        self.unset_maximized(object, client).await
                    }
                    11 => {
                        tracing::debug!("xdg_surface#{}.set_fullscreen()", object.id);
                        self.set_fullscreen(object, client, message.object()?).await
                    }
                    12 => {
                        tracing::debug!("xdg_surface#{}.unset_fullscreen()", object.id);
                        self.unset_fullscreen(object, client).await
                    }
                    13 => {
                        tracing::debug!("xdg_surface#{}.set_minimized()", object.id);
                        self.set_minimized(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Unmap and destroy the window. The window will be effectively"#]
            #[doc = r#"hidden from the user's point of view, and all state like"#]
            #[doc = r#"maximization, fullscreen, and so on, will be lost."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set the "parent" of this surface. This window should be stacked"#]
            #[doc = r#"above a parent. The parent surface must be mapped as long as this"#]
            #[doc = r#"surface is mapped."#]
            #[doc = r#""#]
            #[doc = r#"Parent windows should be set on dialogs, toolboxes, or other"#]
            #[doc = r#""auxiliary" surfaces, so that the parent is raised when the dialog"#]
            #[doc = r#"is raised."#]
            async fn set_parent(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_parent: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set a short title for the surface."#]
            #[doc = r#""#]
            #[doc = r#"This string may be used to identify the surface in a task bar,"#]
            #[doc = r#"window list, or other user interface elements provided by the"#]
            #[doc = r#"compositor."#]
            #[doc = r#""#]
            #[doc = r#"The string must be encoded in UTF-8."#]
            async fn set_title(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_title: String,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set an application identifier for the surface."#]
            #[doc = r#""#]
            #[doc = r#"The app ID identifies the general class of applications to which"#]
            #[doc = r#"the surface belongs. The compositor can use this to group multiple"#]
            #[doc = r#"surfaces together, or to determine how to launch a new application."#]
            #[doc = r#""#]
            #[doc = r#"For D-Bus activatable applications, the app ID is used as the D-Bus"#]
            #[doc = r#"service name."#]
            #[doc = r#""#]
            #[doc = r#"The compositor shell will try to group application surfaces together"#]
            #[doc = r#"by their app ID.  As a best practice, it is suggested to select app"#]
            #[doc = r#"ID's that match the basename of the application's .desktop file."#]
            #[doc = r#"For example, "org.freedesktop.FooViewer" where the .desktop file is"#]
            #[doc = r#""org.freedesktop.FooViewer.desktop"."#]
            #[doc = r#""#]
            #[doc = r#"See the desktop-entry specification [0] for more details on"#]
            #[doc = r#"application identifiers and how they relate to well-known D-Bus"#]
            #[doc = r#"names and .desktop files."#]
            #[doc = r#""#]
            #[doc = r#"[0] http://standards.freedesktop.org/desktop-entry-spec/"#]
            async fn set_app_id(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_app_id: String,
            ) -> crate::server::Result<()>;
            #[doc = r#"Clients implementing client-side decorations might want to show"#]
            #[doc = r#"a context menu when right-clicking on the decorations, giving the"#]
            #[doc = r#"user a menu that they can use to maximize or minimize the window."#]
            #[doc = r#""#]
            #[doc = r#"This request asks the compositor to pop up such a window menu at"#]
            #[doc = r#"the given position, relative to the local surface coordinates of"#]
            #[doc = r#"the parent surface. There are no guarantees as to what menu items"#]
            #[doc = r#"the window menu contains."#]
            #[doc = r#""#]
            #[doc = r#"This request must be used in response to some sort of user action"#]
            #[doc = r#"like a button press, key press, or touch down event."#]
            async fn show_window_menu(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                show_window_menu: crate::wire::ObjectId,
                show_window_menu: u32,
                show_window_menu: i32,
                show_window_menu: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Start an interactive, user-driven move of the surface."#]
            #[doc = r#""#]
            #[doc = r#"This request must be used in response to some sort of user action"#]
            #[doc = r#"like a button press, key press, or touch down event. The passed"#]
            #[doc = r#"serial is used to determine the type of interactive move (touch,"#]
            #[doc = r#"pointer, etc)."#]
            #[doc = r#""#]
            #[doc = r#"The server may ignore move requests depending on the state of"#]
            #[doc = r#"the surface (e.g. fullscreen or maximized), or if the passed serial"#]
            #[doc = r#"is no longer valid."#]
            #[doc = r#""#]
            #[doc = r#"If triggered, the surface will lose the focus of the device"#]
            #[doc = r#"(wl_pointer, wl_touch, etc) used for the move. It is up to the"#]
            #[doc = r#"compositor to visually indicate that the move is taking place, such as"#]
            #[doc = r#"updating a pointer cursor, during the move. There is no guarantee"#]
            #[doc = r#"that the device focus will return when the move is completed."#]
            async fn r#move(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                r#move: crate::wire::ObjectId,
                r#move: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Start a user-driven, interactive resize of the surface."#]
            #[doc = r#""#]
            #[doc = r#"This request must be used in response to some sort of user action"#]
            #[doc = r#"like a button press, key press, or touch down event. The passed"#]
            #[doc = r#"serial is used to determine the type of interactive resize (touch,"#]
            #[doc = r#"pointer, etc)."#]
            #[doc = r#""#]
            #[doc = r#"The server may ignore resize requests depending on the state of"#]
            #[doc = r#"the surface (e.g. fullscreen or maximized)."#]
            #[doc = r#""#]
            #[doc = r#"If triggered, the client will receive configure events with the"#]
            #[doc = r#""resize" state enum value and the expected sizes. See the "resize""#]
            #[doc = r#"enum value for more details about what is required. The client"#]
            #[doc = r#"must also acknowledge configure events using "ack_configure". After"#]
            #[doc = r#"the resize is completed, the client will receive another "configure""#]
            #[doc = r#"event without the resize state."#]
            #[doc = r#""#]
            #[doc = r#"If triggered, the surface also will lose the focus of the device"#]
            #[doc = r#"(wl_pointer, wl_touch, etc) used for the resize. It is up to the"#]
            #[doc = r#"compositor to visually indicate that the resize is taking place,"#]
            #[doc = r#"such as updating a pointer cursor, during the resize. There is no"#]
            #[doc = r#"guarantee that the device focus will return when the resize is"#]
            #[doc = r#"completed."#]
            #[doc = r#""#]
            #[doc = r#"The edges parameter specifies how the surface should be resized,"#]
            #[doc = r#"and is one of the values of the resize_edge enum. The compositor"#]
            #[doc = r#"may use this information to update the surface position for"#]
            #[doc = r#"example when dragging the top left corner. The compositor may also"#]
            #[doc = r#"use this information to adapt its behavior, e.g. choose an"#]
            #[doc = r#"appropriate cursor image."#]
            async fn resize(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                resize: crate::wire::ObjectId,
                resize: u32,
                resize: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"When a configure event is received, if a client commits the"#]
            #[doc = r#"surface in response to the configure event, then the client"#]
            #[doc = r#"must make an ack_configure request sometime before the commit"#]
            #[doc = r#"request, passing along the serial of the configure event."#]
            #[doc = r#""#]
            #[doc = r#"For instance, the compositor might use this information to move"#]
            #[doc = r#"a surface to the top left only when the client has drawn itself"#]
            #[doc = r#"for the maximized or fullscreen state."#]
            #[doc = r#""#]
            #[doc = r#"If the client receives multiple configure events before it"#]
            #[doc = r#"can respond to one, it only has to ack the last configure event."#]
            #[doc = r#""#]
            #[doc = r#"A client is not required to commit immediately after sending"#]
            #[doc = r#"an ack_configure request - it may even ack_configure several times"#]
            #[doc = r#"before its next surface commit."#]
            #[doc = r#""#]
            #[doc = r#"The compositor expects that the most recently received"#]
            #[doc = r#"ack_configure request at the time of a commit indicates which"#]
            #[doc = r#"configure event the client is responding to."#]
            async fn ack_configure(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                ack_configure: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"The window geometry of a window is its "visible bounds" from the"#]
            #[doc = r#"user's perspective. Client-side decorations often have invisible"#]
            #[doc = r#"portions like drop-shadows which should be ignored for the"#]
            #[doc = r#"purposes of aligning, placing and constraining windows."#]
            #[doc = r#""#]
            #[doc = r#"The window geometry is double buffered, and will be applied at the"#]
            #[doc = r#"time wl_surface.commit of the corresponding wl_surface is called."#]
            #[doc = r#""#]
            #[doc = r#"Once the window geometry of the surface is set once, it is not"#]
            #[doc = r#"possible to unset it, and it will remain the same until"#]
            #[doc = r#"set_window_geometry is called again, even if a new subsurface or"#]
            #[doc = r#"buffer is attached."#]
            #[doc = r#""#]
            #[doc = r#"If never set, the value is the full bounds of the surface,"#]
            #[doc = r#"including any subsurfaces. This updates dynamically on every"#]
            #[doc = r#"commit. This unset mode is meant for extremely simple clients."#]
            #[doc = r#""#]
            #[doc = r#"If responding to a configure event, the window geometry in here"#]
            #[doc = r#"must respect the sizing negotiations specified by the states in"#]
            #[doc = r#"the configure event."#]
            #[doc = r#""#]
            #[doc = r#"The arguments are given in the surface local coordinate space of"#]
            #[doc = r#"the wl_surface associated with this xdg_surface."#]
            #[doc = r#""#]
            #[doc = r#"The width and height must be greater than zero."#]
            async fn set_window_geometry(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_window_geometry: i32,
                set_window_geometry: i32,
                set_window_geometry: i32,
                set_window_geometry: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Maximize the surface."#]
            #[doc = r#""#]
            #[doc = r#"After requesting that the surface should be maximized, the compositor"#]
            #[doc = r#"will respond by emitting a configure event with the "maximized" state"#]
            #[doc = r#"and the required window geometry. The client should then update its"#]
            #[doc = r#"content, drawing it in a maximized state, i.e. without shadow or other"#]
            #[doc = r#"decoration outside of the window geometry. The client must also"#]
            #[doc = r#"acknowledge the configure when committing the new content (see"#]
            #[doc = r#"ack_configure)."#]
            #[doc = r#""#]
            #[doc = r#"It is up to the compositor to decide how and where to maximize the"#]
            #[doc = r#"surface, for example which output and what region of the screen should"#]
            #[doc = r#"be used."#]
            #[doc = r#""#]
            #[doc = r#"If the surface was already maximized, the compositor will still emit"#]
            #[doc = r#"a configure event with the "maximized" state."#]
            #[doc = r#""#]
            #[doc = r#"Note that unrelated compositor side state changes may cause"#]
            #[doc = r#"configure events to be emitted at any time, meaning trying to"#]
            #[doc = r#"match this request to a specific future configure event is"#]
            #[doc = r#"futile."#]
            async fn set_maximized(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Unmaximize the surface."#]
            #[doc = r#""#]
            #[doc = r#"After requesting that the surface should be unmaximized, the compositor"#]
            #[doc = r#"will respond by emitting a configure event without the "maximized""#]
            #[doc = r#"state. If available, the compositor will include the window geometry"#]
            #[doc = r#"dimensions the window had prior to being maximized in the configure"#]
            #[doc = r#"request. The client must then update its content, drawing it in a"#]
            #[doc = r#"regular state, i.e. potentially with shadow, etc. The client must also"#]
            #[doc = r#"acknowledge the configure when committing the new content (see"#]
            #[doc = r#"ack_configure)."#]
            #[doc = r#""#]
            #[doc = r#"It is up to the compositor to position the surface after it was"#]
            #[doc = r#"unmaximized; usually the position the surface had before maximizing, if"#]
            #[doc = r#"applicable."#]
            #[doc = r#""#]
            #[doc = r#"If the surface was already not maximized, the compositor will still"#]
            #[doc = r#"emit a configure event without the "maximized" state."#]
            #[doc = r#""#]
            #[doc = r#"Note that unrelated compositor side state changes may cause"#]
            #[doc = r#"configure events to be emitted at any time, meaning trying to"#]
            #[doc = r#"match this request to a specific future configure event is"#]
            #[doc = r#"futile."#]
            async fn unset_maximized(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Make the surface fullscreen."#]
            #[doc = r#""#]
            #[doc = r#"You can specify an output that you would prefer to be fullscreen."#]
            #[doc = r#"If this value is NULL, it's up to the compositor to choose which"#]
            #[doc = r#"display will be used to map this surface."#]
            #[doc = r#""#]
            #[doc = r#"If the surface doesn't cover the whole output, the compositor will"#]
            #[doc = r#"position the surface in the center of the output and compensate with"#]
            #[doc = r#"black borders filling the rest of the output."#]
            async fn set_fullscreen(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_fullscreen: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            async fn unset_fullscreen(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Request that the compositor minimize your surface. There is no"#]
            #[doc = r#"way to know if the surface is currently minimized, nor is there"#]
            #[doc = r#"any way to unset minimization on this surface."#]
            #[doc = r#""#]
            #[doc = r#"If you are looking to throttle redrawing when minimized, please"#]
            #[doc = r#"instead use the wl_surface.frame event for this, as this will"#]
            #[doc = r#"also work with live previews on windows in Alt-Tab, Expose or"#]
            #[doc = r#"similar compositor features."#]
            async fn set_minimized(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"The configure event asks the client to resize its surface or to"#]
            #[doc = r#"change its state."#]
            #[doc = r#""#]
            #[doc = r#"The width and height arguments specify a hint to the window"#]
            #[doc = r#"about how its surface should be resized in window geometry"#]
            #[doc = r#"coordinates. See set_window_geometry."#]
            #[doc = r#""#]
            #[doc = r#"If the width or height arguments are zero, it means the client"#]
            #[doc = r#"should decide its own window dimension. This may happen when the"#]
            #[doc = r#"compositor need to configure the state of the surface but doesn't"#]
            #[doc = r#"have any information about any previous or expected dimension."#]
            #[doc = r#""#]
            #[doc = r#"The states listed in the event specify how the width/height"#]
            #[doc = r#"arguments should be interpreted, and possibly how it should be"#]
            #[doc = r#"drawn."#]
            #[doc = r#""#]
            #[doc = r#"Clients should arrange their surface for the new size and"#]
            #[doc = r#"states, and then send a ack_configure request with the serial"#]
            #[doc = r#"sent in this configure event at some point before committing"#]
            #[doc = r#"the new surface."#]
            #[doc = r#""#]
            #[doc = r#"If the client receives multiple configure events before it"#]
            #[doc = r#"can respond to one, it is free to discard all but the last"#]
            #[doc = r#"event it received."#]
            async fn configure(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
                states: Vec<u8>,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_surface#{}.configure()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(width)
                    .put_int(height)
                    .put_array(states)
                    .put_uint(serial)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The close event is sent by the compositor when the user"#]
            #[doc = r#"wants the surface to be closed. This should be equivalent to"#]
            #[doc = r#"the user clicking the close button in client-side decorations,"#]
            #[doc = r#"if your application has any..."#]
            #[doc = r#""#]
            #[doc = r#"This is only a request that the user intends to close your"#]
            #[doc = r#"window. The client may choose to ignore this request, or show"#]
            #[doc = r#"a dialog to ask the user to save their data..."#]
            async fn close(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_surface#{}.close()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod xdg_popup {
        #[doc = r#"A popup surface is a short-lived, temporary surface that can be"#]
        #[doc = r#"used to implement menus. It takes an explicit grab on the surface"#]
        #[doc = r#"that will be dismissed when the user dismisses the popup. This can"#]
        #[doc = r#"be done by the user clicking outside the surface, using the keyboard,"#]
        #[doc = r#"or even locking the screen through closing the lid or a timeout."#]
        #[doc = r#""#]
        #[doc = r#"When the popup is dismissed, a popup_done event will be sent out,"#]
        #[doc = r#"and at the same time the surface will be unmapped. The xdg_popup"#]
        #[doc = r#"object is now inert and cannot be reactivated, so clients should"#]
        #[doc = r#"destroy it. Explicitly destroying the xdg_popup object will also"#]
        #[doc = r#"dismiss the popup and unmap the surface."#]
        #[doc = r#""#]
        #[doc = r#"Clients will receive events for all their surfaces during this"#]
        #[doc = r#"grab (which is an "owner-events" grab in X11 parlance). This is"#]
        #[doc = r#"done so that users can navigate through submenus and other"#]
        #[doc = r#""nested" popup windows without having to dismiss the topmost"#]
        #[doc = r#"popup."#]
        #[doc = r#""#]
        #[doc = r#"Clients that want to dismiss the popup when another surface of"#]
        #[doc = r#"their own is clicked should dismiss the popup using the destroy"#]
        #[doc = r#"request."#]
        #[doc = r#""#]
        #[doc = r#"The parent surface must have either an xdg_surface or xdg_popup"#]
        #[doc = r#"role."#]
        #[doc = r#""#]
        #[doc = r#"Specifying an xdg_popup for the parent means that the popups are"#]
        #[doc = r#"nested, with this popup now being the topmost popup. Nested"#]
        #[doc = r#"popups must be destroyed in the reverse order they were created"#]
        #[doc = r#"in, e.g. the only popup you are allowed to destroy at all times"#]
        #[doc = r#"is the topmost one."#]
        #[doc = r#""#]
        #[doc = r#"If there is an existing popup when creating a new popup, the"#]
        #[doc = r#"parent must be the current topmost popup."#]
        #[doc = r#""#]
        #[doc = r#"A parent surface must be mapped before the new popup is mapped."#]
        #[doc = r#""#]
        #[doc = r#"When compositors choose to dismiss a popup, they will likely"#]
        #[doc = r#"dismiss every nested popup as well. When a compositor dismisses"#]
        #[doc = r#"popups, it will follow the same dismissing order as required"#]
        #[doc = r#"from the client."#]
        #[doc = r#""#]
        #[doc = r#"The x and y arguments passed when creating the popup object specify"#]
        #[doc = r#"where the top left of the popup should be placed, relative to the"#]
        #[doc = r#"local surface coordinates of the parent surface. See"#]
        #[doc = r#"xdg_shell.get_xdg_popup."#]
        #[doc = r#""#]
        #[doc = r#"The client must call wl_surface.commit on the corresponding wl_surface"#]
        #[doc = r#"for the xdg_popup state to take effect."#]
        #[doc = r#""#]
        #[doc = r#"For a surface to be mapped by the compositor the client must have"#]
        #[doc = r#"committed both the xdg_popup state and a buffer."#]
        pub trait XdgPopup: crate::server::Dispatcher {
            const INTERFACE: &'static str = "xdg_popup";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("xdg_popup#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"This destroys the popup. Explicitly destroying the xdg_popup"#]
            #[doc = r#"object will also dismiss the popup, and unmap the surface."#]
            #[doc = r#""#]
            #[doc = r#"If this xdg_popup is not the "topmost" popup, a protocol error"#]
            #[doc = r#"will be sent."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"The popup_done event is sent out when a popup is dismissed by the"#]
            #[doc = r#"compositor. The client should destroy the xdg_popup object at this"#]
            #[doc = r#"point."#]
            async fn popup_done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> xdg_popup#{}.popup_done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod xdg_shell_unstable_v6 {
    pub mod zxdg_shell_v6 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Given wl_surface has another role"#]
            Role = 0,
            #[doc = r#"Xdg_shell was destroyed before children"#]
            DefunctSurfaces = 1,
            #[doc = r#"The client tried to map or destroy a non-topmost popup"#]
            NotTheTopmostPopup = 2,
            #[doc = r#"The client specified an invalid popup parent surface"#]
            InvalidPopupParent = 3,
            #[doc = r#"The client provided an invalid surface state"#]
            InvalidSurfaceState = 4,
            #[doc = r#"The client provided an invalid positioner"#]
            InvalidPositioner = 5,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Role),
                    1 => Ok(Self::DefunctSurfaces),
                    2 => Ok(Self::NotTheTopmostPopup),
                    3 => Ok(Self::InvalidPopupParent),
                    4 => Ok(Self::InvalidSurfaceState),
                    5 => Ok(Self::InvalidPositioner),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"xdg_shell allows clients to turn a wl_surface into a "real window""#]
        #[doc = r#"which can be dragged, resized, stacked, and moved around by the"#]
        #[doc = r#"user. Everything about this interface is suited towards traditional"#]
        #[doc = r#"desktop environments."#]
        pub trait ZxdgShellV6: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_shell_v6";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zxdg_shell_v6#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("zxdg_shell_v6#{}.create_positioner()", object.id);
                        self.create_positioner(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("zxdg_shell_v6#{}.get_xdg_surface()", object.id);
                        self.get_xdg_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3 => {
                        tracing::debug!("zxdg_shell_v6#{}.pong()", object.id);
                        self.pong(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy this xdg_shell object."#]
            #[doc = r#""#]
            #[doc = r#"Destroying a bound xdg_shell object while there are surfaces"#]
            #[doc = r#"still alive created by this xdg_shell object instance is illegal"#]
            #[doc = r#"and will result in a protocol error."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Create a positioner object. A positioner object is used to position"#]
            #[doc = r#"surfaces relative to some parent surface. See the interface description"#]
            #[doc = r#"and xdg_surface.get_popup for details."#]
            async fn create_positioner(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create_positioner: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"This creates an xdg_surface for the given surface. While xdg_surface"#]
            #[doc = r#"itself is not a role, the corresponding surface may only be assigned"#]
            #[doc = r#"a role extending xdg_surface, such as xdg_toplevel or xdg_popup."#]
            #[doc = r#""#]
            #[doc = r#"This creates an xdg_surface for the given surface. An xdg_surface is"#]
            #[doc = r#"used as basis to define a role to a given surface, such as xdg_toplevel"#]
            #[doc = r#"or xdg_popup. It also manages functionality shared between xdg_surface"#]
            #[doc = r#"based surface roles."#]
            #[doc = r#""#]
            #[doc = r#"See the documentation of xdg_surface for more details about what an"#]
            #[doc = r#"xdg_surface is and how it is used."#]
            async fn get_xdg_surface(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_xdg_surface: crate::wire::ObjectId,
                get_xdg_surface: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"A client must respond to a ping event with a pong request or"#]
            #[doc = r#"the client may be deemed unresponsive. See xdg_shell.ping."#]
            async fn pong(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                pong: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"The ping event asks the client if it's still alive. Pass the"#]
            #[doc = r#"serial specified in the event back to the compositor by sending"#]
            #[doc = r#"a "pong" request back with the specified serial. See xdg_shell.ping."#]
            #[doc = r#""#]
            #[doc = r#"Compositors can use this to determine if the client is still"#]
            #[doc = r#"alive. It's unspecified what will happen if the client doesn't"#]
            #[doc = r#"respond to the ping request, or in what timeframe. Clients should"#]
            #[doc = r#"try to respond in a reasonable amount of time."#]
            #[doc = r#""#]
            #[doc = r#"A compositor is free to ping in any way it wants, but a client must"#]
            #[doc = r#"always respond to any xdg_shell object it created."#]
            async fn ping(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_shell_v6#{}.ping()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zxdg_positioner_v6 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Invalid input provided"#]
            InvalidInput = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::InvalidInput),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! {
                                    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
                                    pub struct Anchor: u32 {#[doc = r#"The center of the anchor rectangle"#]
        const None = 0;#[doc = r#"The top edge of the anchor rectangle"#]
        const Top = 1;#[doc = r#"The bottom edge of the anchor rectangle"#]
        const Bottom = 2;#[doc = r#"The left edge of the anchor rectangle"#]
        const Left = 4;#[doc = r#"The right edge of the anchor rectangle"#]
        const Right = 8;}
                                }
        impl TryFrom<u32> for Anchor {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        bitflags::bitflags! {
                                    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
                                    pub struct Gravity: u32 {#[doc = r#"Center over the anchor edge"#]
        const None = 0;#[doc = r#"Position above the anchor edge"#]
        const Top = 1;#[doc = r#"Position below the anchor edge"#]
        const Bottom = 2;#[doc = r#"Position to the left of the anchor edge"#]
        const Left = 4;#[doc = r#"Position to the right of the anchor edge"#]
        const Right = 8;}
                                }
        impl TryFrom<u32> for Gravity {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = r#"The constraint adjustment value define ways the compositor will adjust"#]
        #[doc = r#"the position of the surface, if the unadjusted position would result"#]
        #[doc = r#"in the surface being partly constrained."#]
        #[doc = r#""#]
        #[doc = r#"Whether a surface is considered 'constrained' is left to the compositor"#]
        #[doc = r#"to determine. For example, the surface may be partly outside the"#]
        #[doc = r#"compositor's defined 'work area', thus necessitating the child surface's"#]
        #[doc = r#"position be adjusted until it is entirely inside the work area."#]
        #[doc = r#""#]
        #[doc = r#"The adjustments can be combined, according to a defined precedence: 1)"#]
        #[doc = r#"Flip, 2) Slide, 3) Resize."#]
        bitflags::bitflags! {
            #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
            pub struct ConstraintAdjustment: u32 {const None = 0;const SlideX = 1;const SlideY = 2;const FlipX = 4;const FlipY = 8;const ResizeX = 16;const ResizeY = 32;}
        }
        impl TryFrom<u32> for ConstraintAdjustment {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = r#"The xdg_positioner provides a collection of rules for the placement of a"#]
        #[doc = r#"child surface relative to a parent surface. Rules can be defined to ensure"#]
        #[doc = r#"the child surface remains within the visible area's borders, and to"#]
        #[doc = r#"specify how the child surface changes its position, such as sliding along"#]
        #[doc = r#"an axis, or flipping around a rectangle. These positioner-created rules are"#]
        #[doc = r#"constrained by the requirement that a child surface must intersect with or"#]
        #[doc = r#"be at least partially adjacent to its parent surface."#]
        #[doc = r#""#]
        #[doc = r#"See the various requests for details about possible rules."#]
        #[doc = r#""#]
        #[doc = r#"At the time of the request, the compositor makes a copy of the rules"#]
        #[doc = r#"specified by the xdg_positioner. Thus, after the request is complete the"#]
        #[doc = r#"xdg_positioner object can be destroyed or reused; further changes to the"#]
        #[doc = r#"object will have no effect on previous usages."#]
        #[doc = r#""#]
        #[doc = r#"For an xdg_positioner object to be considered complete, it must have a"#]
        #[doc = r#"non-zero size set by set_size, and a non-zero anchor rectangle set by"#]
        #[doc = r#"set_anchor_rect. Passing an incomplete xdg_positioner object when"#]
        #[doc = r#"positioning a surface raises an error."#]
        pub trait ZxdgPositionerV6: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_positioner_v6";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zxdg_positioner_v6#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("zxdg_positioner_v6#{}.set_size()", object.id);
                        self.set_size(object, client, message.int()?, message.int()?)
                            .await
                    }
                    2 => {
                        tracing::debug!("zxdg_positioner_v6#{}.set_anchor_rect()", object.id);
                        self.set_anchor_rect(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    3 => {
                        tracing::debug!("zxdg_positioner_v6#{}.set_anchor()", object.id);
                        self.set_anchor(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    4 => {
                        tracing::debug!("zxdg_positioner_v6#{}.set_gravity()", object.id);
                        self.set_gravity(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    5 => {
                        tracing::debug!(
                            "zxdg_positioner_v6#{}.set_constraint_adjustment()",
                            object.id
                        );
                        self.set_constraint_adjustment(object, client, message.uint()?)
                            .await
                    }
                    6 => {
                        tracing::debug!("zxdg_positioner_v6#{}.set_offset()", object.id);
                        self.set_offset(object, client, message.int()?, message.int()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Notify the compositor that the xdg_positioner will no longer be used."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set the size of the surface that is to be positioned with the positioner"#]
            #[doc = r#"object. The size is in surface-local coordinates and corresponds to the"#]
            #[doc = r#"window geometry. See xdg_surface.set_window_geometry."#]
            #[doc = r#""#]
            #[doc = r#"If a zero or negative size is set the invalid_input error is raised."#]
            async fn set_size(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_size: i32,
                set_size: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Specify the anchor rectangle within the parent surface that the child"#]
            #[doc = r#"surface will be placed relative to. The rectangle is relative to the"#]
            #[doc = r#"window geometry as defined by xdg_surface.set_window_geometry of the"#]
            #[doc = r#"parent surface. The rectangle must be at least 1x1 large."#]
            #[doc = r#""#]
            #[doc = r#"When the xdg_positioner object is used to position a child surface, the"#]
            #[doc = r#"anchor rectangle may not extend outside the window geometry of the"#]
            #[doc = r#"positioned child's parent surface."#]
            #[doc = r#""#]
            #[doc = r#"If a zero or negative size is set the invalid_input error is raised."#]
            async fn set_anchor_rect(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_anchor_rect: i32,
                set_anchor_rect: i32,
                set_anchor_rect: i32,
                set_anchor_rect: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Defines a set of edges for the anchor rectangle. These are used to"#]
            #[doc = r#"derive an anchor point that the child surface will be positioned"#]
            #[doc = r#"relative to. If two orthogonal edges are specified (e.g. 'top' and"#]
            #[doc = r#"'left'), then the anchor point will be the intersection of the edges"#]
            #[doc = r#"(e.g. the top left position of the rectangle); otherwise, the derived"#]
            #[doc = r#"anchor point will be centered on the specified edge, or in the center of"#]
            #[doc = r#"the anchor rectangle if no edge is specified."#]
            #[doc = r#""#]
            #[doc = r#"If two parallel anchor edges are specified (e.g. 'left' and 'right'),"#]
            #[doc = r#"the invalid_input error is raised."#]
            async fn set_anchor(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_anchor: Anchor,
            ) -> crate::server::Result<()>;
            #[doc = r#"Defines in what direction a surface should be positioned, relative to"#]
            #[doc = r#"the anchor point of the parent surface. If two orthogonal gravities are"#]
            #[doc = r#"specified (e.g. 'bottom' and 'right'), then the child surface will be"#]
            #[doc = r#"placed in the specified direction; otherwise, the child surface will be"#]
            #[doc = r#"centered over the anchor point on any axis that had no gravity"#]
            #[doc = r#"specified."#]
            #[doc = r#""#]
            #[doc = r#"If two parallel gravities are specified (e.g. 'left' and 'right'), the"#]
            #[doc = r#"invalid_input error is raised."#]
            async fn set_gravity(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_gravity: Gravity,
            ) -> crate::server::Result<()>;
            #[doc = r#"Specify how the window should be positioned if the originally intended"#]
            #[doc = r#"position caused the surface to be constrained, meaning at least"#]
            #[doc = r#"partially outside positioning boundaries set by the compositor. The"#]
            #[doc = r#"adjustment is set by constructing a bitmask describing the adjustment to"#]
            #[doc = r#"be made when the surface is constrained on that axis."#]
            #[doc = r#""#]
            #[doc = r#"If no bit for one axis is set, the compositor will assume that the child"#]
            #[doc = r#"surface should not change its position on that axis when constrained."#]
            #[doc = r#""#]
            #[doc = r#"If more than one bit for one axis is set, the order of how adjustments"#]
            #[doc = r#"are applied is specified in the corresponding adjustment descriptions."#]
            #[doc = r#""#]
            #[doc = r#"The default adjustment is none."#]
            async fn set_constraint_adjustment(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_constraint_adjustment: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Specify the surface position offset relative to the position of the"#]
            #[doc = r#"anchor on the anchor rectangle and the anchor on the surface. For"#]
            #[doc = r#"example if the anchor of the anchor rectangle is at (x, y), the surface"#]
            #[doc = r#"has the gravity bottom|right, and the offset is (ox, oy), the calculated"#]
            #[doc = r#"surface position will be (x + ox, y + oy). The offset position of the"#]
            #[doc = r#"surface is the one used for constraint testing. See"#]
            #[doc = r#"set_constraint_adjustment."#]
            #[doc = r#""#]
            #[doc = r#"An example use case is placing a popup menu on top of a user interface"#]
            #[doc = r#"element, while aligning the user interface element of the parent surface"#]
            #[doc = r#"with some user interface element placed somewhere in the popup surface."#]
            async fn set_offset(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_offset: i32,
                set_offset: i32,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zxdg_surface_v6 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            NotConstructed = 1,
            AlreadyConstructed = 2,
            UnconfiguredBuffer = 3,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::NotConstructed),
                    2 => Ok(Self::AlreadyConstructed),
                    3 => Ok(Self::UnconfiguredBuffer),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"An interface that may be implemented by a wl_surface, for"#]
        #[doc = r#"implementations that provide a desktop-style user interface."#]
        #[doc = r#""#]
        #[doc = r#"It provides a base set of functionality required to construct user"#]
        #[doc = r#"interface elements requiring management by the compositor, such as"#]
        #[doc = r#"toplevel windows, menus, etc. The types of functionality are split into"#]
        #[doc = r#"xdg_surface roles."#]
        #[doc = r#""#]
        #[doc = r#"Creating an xdg_surface does not set the role for a wl_surface. In order"#]
        #[doc = r#"to map an xdg_surface, the client must create a role-specific object"#]
        #[doc = r#"using, e.g., get_toplevel, get_popup. The wl_surface for any given"#]
        #[doc = r#"xdg_surface can have at most one role, and may not be assigned any role"#]
        #[doc = r#"not based on xdg_surface."#]
        #[doc = r#""#]
        #[doc = r#"A role must be assigned before any other requests are made to the"#]
        #[doc = r#"xdg_surface object."#]
        #[doc = r#""#]
        #[doc = r#"The client must call wl_surface.commit on the corresponding wl_surface"#]
        #[doc = r#"for the xdg_surface state to take effect."#]
        #[doc = r#""#]
        #[doc = r#"Creating an xdg_surface from a wl_surface which has a buffer attached or"#]
        #[doc = r#"committed is a client error, and any attempts by a client to attach or"#]
        #[doc = r#"manipulate a buffer prior to the first xdg_surface.configure call must"#]
        #[doc = r#"also be treated as errors."#]
        #[doc = r#""#]
        #[doc = r#"For a surface to be mapped by the compositor, the following conditions"#]
        #[doc = r#"must be met: (1) the client has assigned an xdg_surface based role to the"#]
        #[doc = r#"surface, (2) the client has set and committed the xdg_surface state and"#]
        #[doc = r#"the role dependent state to the surface and (3) the client has committed a"#]
        #[doc = r#"buffer to the surface."#]
        pub trait ZxdgSurfaceV6: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_surface_v6";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zxdg_surface_v6#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("zxdg_surface_v6#{}.get_toplevel()", object.id);
                        self.get_toplevel(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("zxdg_surface_v6#{}.get_popup()", object.id);
                        self.get_popup(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3 => {
                        tracing::debug!("zxdg_surface_v6#{}.set_window_geometry()", object.id);
                        self.set_window_geometry(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    4 => {
                        tracing::debug!("zxdg_surface_v6#{}.ack_configure()", object.id);
                        self.ack_configure(object, client, message.uint()?).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the xdg_surface object. An xdg_surface must only be destroyed"#]
            #[doc = r#"after its role object has been destroyed. If the role object still"#]
            #[doc = r#"exists when this request is issued, the zxdg_shell_v6.defunct_surfaces"#]
            #[doc = r#"is raised."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This creates an xdg_toplevel object for the given xdg_surface and gives"#]
            #[doc = r#"the associated wl_surface the xdg_toplevel role. If the surface already"#]
            #[doc = r#"had a role, the zxdg_shell_v6.role error is raised."#]
            #[doc = r#""#]
            #[doc = r#"See the documentation of xdg_toplevel for more details about what an"#]
            #[doc = r#"xdg_toplevel is and how it is used."#]
            async fn get_toplevel(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_toplevel: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"This creates an xdg_popup object for the given xdg_surface and gives the"#]
            #[doc = r#"associated wl_surface the xdg_popup role. If the surface already"#]
            #[doc = r#"had a role, the zxdg_shell_v6.role error is raised."#]
            #[doc = r#""#]
            #[doc = r#"See the documentation of xdg_popup for more details about what an"#]
            #[doc = r#"xdg_popup is and how it is used."#]
            async fn get_popup(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_popup: crate::wire::ObjectId,
                get_popup: crate::wire::ObjectId,
                get_popup: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"The window geometry of a surface is its "visible bounds" from the"#]
            #[doc = r#"user's perspective. Client-side decorations often have invisible"#]
            #[doc = r#"portions like drop-shadows which should be ignored for the"#]
            #[doc = r#"purposes of aligning, placing and constraining windows."#]
            #[doc = r#""#]
            #[doc = r#"The window geometry is double buffered, and will be applied at the"#]
            #[doc = r#"time wl_surface.commit of the corresponding wl_surface is called."#]
            #[doc = r#""#]
            #[doc = r#"Once the window geometry of the surface is set, it is not possible to"#]
            #[doc = r#"unset it, and it will remain the same until set_window_geometry is"#]
            #[doc = r#"called again, even if a new subsurface or buffer is attached."#]
            #[doc = r#""#]
            #[doc = r#"If never set, the value is the full bounds of the surface,"#]
            #[doc = r#"including any subsurfaces. This updates dynamically on every"#]
            #[doc = r#"commit. This unset is meant for extremely simple clients."#]
            #[doc = r#""#]
            #[doc = r#"The arguments are given in the surface-local coordinate space of"#]
            #[doc = r#"the wl_surface associated with this xdg_surface."#]
            #[doc = r#""#]
            #[doc = r#"The width and height must be greater than zero. Setting an invalid size"#]
            #[doc = r#"will raise an error. When applied, the effective window geometry will be"#]
            #[doc = r#"the set window geometry clamped to the bounding rectangle of the"#]
            #[doc = r#"combined geometry of the surface of the xdg_surface and the associated"#]
            #[doc = r#"subsurfaces."#]
            async fn set_window_geometry(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_window_geometry: i32,
                set_window_geometry: i32,
                set_window_geometry: i32,
                set_window_geometry: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"When a configure event is received, if a client commits the"#]
            #[doc = r#"surface in response to the configure event, then the client"#]
            #[doc = r#"must make an ack_configure request sometime before the commit"#]
            #[doc = r#"request, passing along the serial of the configure event."#]
            #[doc = r#""#]
            #[doc = r#"For instance, for toplevel surfaces the compositor might use this"#]
            #[doc = r#"information to move a surface to the top left only when the client has"#]
            #[doc = r#"drawn itself for the maximized or fullscreen state."#]
            #[doc = r#""#]
            #[doc = r#"If the client receives multiple configure events before it"#]
            #[doc = r#"can respond to one, it only has to ack the last configure event."#]
            #[doc = r#""#]
            #[doc = r#"A client is not required to commit immediately after sending"#]
            #[doc = r#"an ack_configure request - it may even ack_configure several times"#]
            #[doc = r#"before its next surface commit."#]
            #[doc = r#""#]
            #[doc = r#"A client may send multiple ack_configure requests before committing, but"#]
            #[doc = r#"only the last request sent before a commit indicates which configure"#]
            #[doc = r#"event the client really is responding to."#]
            #[doc = r#""#]
            #[doc = r#"If an invalid serial is used, the zxdg_shell_v6.invalid_surface_state"#]
            #[doc = r#"error is raised."#]
            async fn ack_configure(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                ack_configure: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"The configure event marks the end of a configure sequence. A configure"#]
            #[doc = r#"sequence is a set of one or more events configuring the state of the"#]
            #[doc = r#"xdg_surface, including the final xdg_surface.configure event."#]
            #[doc = r#""#]
            #[doc = r#"Where applicable, xdg_surface surface roles will during a configure"#]
            #[doc = r#"sequence extend this event as a latched state sent as events before the"#]
            #[doc = r#"xdg_surface.configure event. Such events should be considered to make up"#]
            #[doc = r#"a set of atomically applied configuration states, where the"#]
            #[doc = r#"xdg_surface.configure commits the accumulated state."#]
            #[doc = r#""#]
            #[doc = r#"Clients should arrange their surface for the new states, and then send"#]
            #[doc = r#"an ack_configure request with the serial sent in this configure event at"#]
            #[doc = r#"some point before committing the new surface."#]
            #[doc = r#""#]
            #[doc = r#"If the client receives multiple configure events before it can respond"#]
            #[doc = r#"to one, it is free to discard all but the last event it received."#]
            async fn configure(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_surface_v6#{}.configure()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zxdg_toplevel_v6 {
        #[doc = r#"These values are used to indicate which edge of a surface"#]
        #[doc = r#"is being dragged in a resize operation."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum ResizeEdge {
            None = 0,
            Top = 1,
            Bottom = 2,
            Left = 4,
            TopLeft = 5,
            BottomLeft = 6,
            Right = 8,
            TopRight = 9,
            BottomRight = 10,
        }
        impl TryFrom<u32> for ResizeEdge {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::None),
                    1 => Ok(Self::Top),
                    2 => Ok(Self::Bottom),
                    4 => Ok(Self::Left),
                    5 => Ok(Self::TopLeft),
                    6 => Ok(Self::BottomLeft),
                    8 => Ok(Self::Right),
                    9 => Ok(Self::TopRight),
                    10 => Ok(Self::BottomRight),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"The different state values used on the surface. This is designed for"#]
        #[doc = r#"state values like maximized, fullscreen. It is paired with the"#]
        #[doc = r#"configure event to ensure that both the client and the compositor"#]
        #[doc = r#"setting the state can be synchronized."#]
        #[doc = r#""#]
        #[doc = r#"States set in this way are double-buffered. They will get applied on"#]
        #[doc = r#"the next commit."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum State {
            #[doc = r#"The surface is maximized"#]
            Maximized = 1,
            #[doc = r#"The surface is fullscreen"#]
            Fullscreen = 2,
            #[doc = r#"The surface is being resized"#]
            Resizing = 3,
            #[doc = r#"The surface is now activated"#]
            Activated = 4,
        }
        impl TryFrom<u32> for State {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::Maximized),
                    2 => Ok(Self::Fullscreen),
                    3 => Ok(Self::Resizing),
                    4 => Ok(Self::Activated),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"This interface defines an xdg_surface role which allows a surface to,"#]
        #[doc = r#"among other things, set window-like properties such as maximize,"#]
        #[doc = r#"fullscreen, and minimize, set application-specific metadata like title and"#]
        #[doc = r#"id, and well as trigger user interactive operations such as interactive"#]
        #[doc = r#"resize and move."#]
        pub trait ZxdgToplevelV6: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_toplevel_v6";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_parent()", object.id);
                        self.set_parent(object, client, message.object()?).await
                    }
                    2 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_title()", object.id);
                        self.set_title(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    3 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_app_id()", object.id);
                        self.set_app_id(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    4 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.show_window_menu()", object.id);
                        self.show_window_menu(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    5 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.move()", object.id);
                        self.r#move(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    6 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.resize()", object.id);
                        self.resize(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    7 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_max_size()", object.id);
                        self.set_max_size(object, client, message.int()?, message.int()?)
                            .await
                    }
                    8 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_min_size()", object.id);
                        self.set_min_size(object, client, message.int()?, message.int()?)
                            .await
                    }
                    9 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_maximized()", object.id);
                        self.set_maximized(object, client).await
                    }
                    10 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.unset_maximized()", object.id);
                        self.unset_maximized(object, client).await
                    }
                    11 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_fullscreen()", object.id);
                        self.set_fullscreen(object, client, message.object()?).await
                    }
                    12 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.unset_fullscreen()", object.id);
                        self.unset_fullscreen(object, client).await
                    }
                    13 => {
                        tracing::debug!("zxdg_toplevel_v6#{}.set_minimized()", object.id);
                        self.set_minimized(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Unmap and destroy the window. The window will be effectively"#]
            #[doc = r#"hidden from the user's point of view, and all state like"#]
            #[doc = r#"maximization, fullscreen, and so on, will be lost."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set the "parent" of this surface. This window should be stacked"#]
            #[doc = r#"above a parent. The parent surface must be mapped as long as this"#]
            #[doc = r#"surface is mapped."#]
            #[doc = r#""#]
            #[doc = r#"Parent windows should be set on dialogs, toolboxes, or other"#]
            #[doc = r#""auxiliary" surfaces, so that the parent is raised when the dialog"#]
            #[doc = r#"is raised."#]
            async fn set_parent(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_parent: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set a short title for the surface."#]
            #[doc = r#""#]
            #[doc = r#"This string may be used to identify the surface in a task bar,"#]
            #[doc = r#"window list, or other user interface elements provided by the"#]
            #[doc = r#"compositor."#]
            #[doc = r#""#]
            #[doc = r#"The string must be encoded in UTF-8."#]
            async fn set_title(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_title: String,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set an application identifier for the surface."#]
            #[doc = r#""#]
            #[doc = r#"The app ID identifies the general class of applications to which"#]
            #[doc = r#"the surface belongs. The compositor can use this to group multiple"#]
            #[doc = r#"surfaces together, or to determine how to launch a new application."#]
            #[doc = r#""#]
            #[doc = r#"For D-Bus activatable applications, the app ID is used as the D-Bus"#]
            #[doc = r#"service name."#]
            #[doc = r#""#]
            #[doc = r#"The compositor shell will try to group application surfaces together"#]
            #[doc = r#"by their app ID. As a best practice, it is suggested to select app"#]
            #[doc = r#"ID's that match the basename of the application's .desktop file."#]
            #[doc = r#"For example, "org.freedesktop.FooViewer" where the .desktop file is"#]
            #[doc = r#""org.freedesktop.FooViewer.desktop"."#]
            #[doc = r#""#]
            #[doc = r#"See the desktop-entry specification [0] for more details on"#]
            #[doc = r#"application identifiers and how they relate to well-known D-Bus"#]
            #[doc = r#"names and .desktop files."#]
            #[doc = r#""#]
            #[doc = r#"[0] http://standards.freedesktop.org/desktop-entry-spec/"#]
            async fn set_app_id(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_app_id: String,
            ) -> crate::server::Result<()>;
            #[doc = r#"Clients implementing client-side decorations might want to show"#]
            #[doc = r#"a context menu when right-clicking on the decorations, giving the"#]
            #[doc = r#"user a menu that they can use to maximize or minimize the window."#]
            #[doc = r#""#]
            #[doc = r#"This request asks the compositor to pop up such a window menu at"#]
            #[doc = r#"the given position, relative to the local surface coordinates of"#]
            #[doc = r#"the parent surface. There are no guarantees as to what menu items"#]
            #[doc = r#"the window menu contains."#]
            #[doc = r#""#]
            #[doc = r#"This request must be used in response to some sort of user action"#]
            #[doc = r#"like a button press, key press, or touch down event."#]
            async fn show_window_menu(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                show_window_menu: crate::wire::ObjectId,
                show_window_menu: u32,
                show_window_menu: i32,
                show_window_menu: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Start an interactive, user-driven move of the surface."#]
            #[doc = r#""#]
            #[doc = r#"This request must be used in response to some sort of user action"#]
            #[doc = r#"like a button press, key press, or touch down event. The passed"#]
            #[doc = r#"serial is used to determine the type of interactive move (touch,"#]
            #[doc = r#"pointer, etc)."#]
            #[doc = r#""#]
            #[doc = r#"The server may ignore move requests depending on the state of"#]
            #[doc = r#"the surface (e.g. fullscreen or maximized), or if the passed serial"#]
            #[doc = r#"is no longer valid."#]
            #[doc = r#""#]
            #[doc = r#"If triggered, the surface will lose the focus of the device"#]
            #[doc = r#"(wl_pointer, wl_touch, etc) used for the move. It is up to the"#]
            #[doc = r#"compositor to visually indicate that the move is taking place, such as"#]
            #[doc = r#"updating a pointer cursor, during the move. There is no guarantee"#]
            #[doc = r#"that the device focus will return when the move is completed."#]
            async fn r#move(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                r#move: crate::wire::ObjectId,
                r#move: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Start a user-driven, interactive resize of the surface."#]
            #[doc = r#""#]
            #[doc = r#"This request must be used in response to some sort of user action"#]
            #[doc = r#"like a button press, key press, or touch down event. The passed"#]
            #[doc = r#"serial is used to determine the type of interactive resize (touch,"#]
            #[doc = r#"pointer, etc)."#]
            #[doc = r#""#]
            #[doc = r#"The server may ignore resize requests depending on the state of"#]
            #[doc = r#"the surface (e.g. fullscreen or maximized)."#]
            #[doc = r#""#]
            #[doc = r#"If triggered, the client will receive configure events with the"#]
            #[doc = r#""resize" state enum value and the expected sizes. See the "resize""#]
            #[doc = r#"enum value for more details about what is required. The client"#]
            #[doc = r#"must also acknowledge configure events using "ack_configure". After"#]
            #[doc = r#"the resize is completed, the client will receive another "configure""#]
            #[doc = r#"event without the resize state."#]
            #[doc = r#""#]
            #[doc = r#"If triggered, the surface also will lose the focus of the device"#]
            #[doc = r#"(wl_pointer, wl_touch, etc) used for the resize. It is up to the"#]
            #[doc = r#"compositor to visually indicate that the resize is taking place,"#]
            #[doc = r#"such as updating a pointer cursor, during the resize. There is no"#]
            #[doc = r#"guarantee that the device focus will return when the resize is"#]
            #[doc = r#"completed."#]
            #[doc = r#""#]
            #[doc = r#"The edges parameter specifies how the surface should be resized,"#]
            #[doc = r#"and is one of the values of the resize_edge enum. The compositor"#]
            #[doc = r#"may use this information to update the surface position for"#]
            #[doc = r#"example when dragging the top left corner. The compositor may also"#]
            #[doc = r#"use this information to adapt its behavior, e.g. choose an"#]
            #[doc = r#"appropriate cursor image."#]
            async fn resize(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                resize: crate::wire::ObjectId,
                resize: u32,
                resize: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set a maximum size for the window."#]
            #[doc = r#""#]
            #[doc = r#"The client can specify a maximum size so that the compositor does"#]
            #[doc = r#"not try to configure the window beyond this size."#]
            #[doc = r#""#]
            #[doc = r#"The width and height arguments are in window geometry coordinates."#]
            #[doc = r#"See xdg_surface.set_window_geometry."#]
            #[doc = r#""#]
            #[doc = r#"Values set in this way are double-buffered. They will get applied"#]
            #[doc = r#"on the next commit."#]
            #[doc = r#""#]
            #[doc = r#"The compositor can use this information to allow or disallow"#]
            #[doc = r#"different states like maximize or fullscreen and draw accurate"#]
            #[doc = r#"animations."#]
            #[doc = r#""#]
            #[doc = r#"Similarly, a tiling window manager may use this information to"#]
            #[doc = r#"place and resize client windows in a more effective way."#]
            #[doc = r#""#]
            #[doc = r#"The client should not rely on the compositor to obey the maximum"#]
            #[doc = r#"size. The compositor may decide to ignore the values set by the"#]
            #[doc = r#"client and request a larger size."#]
            #[doc = r#""#]
            #[doc = r#"If never set, or a value of zero in the request, means that the"#]
            #[doc = r#"client has no expected maximum size in the given dimension."#]
            #[doc = r#"As a result, a client wishing to reset the maximum size"#]
            #[doc = r#"to an unspecified state can use zero for width and height in the"#]
            #[doc = r#"request."#]
            #[doc = r#""#]
            #[doc = r#"Requesting a maximum size to be smaller than the minimum size of"#]
            #[doc = r#"a surface is illegal and will result in a protocol error."#]
            #[doc = r#""#]
            #[doc = r#"The width and height must be greater than or equal to zero. Using"#]
            #[doc = r#"strictly negative values for width and height will result in the"#]
            #[doc = r#"zxdg_shell_v6.invalid_surface_state error being raised."#]
            async fn set_max_size(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_max_size: i32,
                set_max_size: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set a minimum size for the window."#]
            #[doc = r#""#]
            #[doc = r#"The client can specify a minimum size so that the compositor does"#]
            #[doc = r#"not try to configure the window below this size."#]
            #[doc = r#""#]
            #[doc = r#"The width and height arguments are in window geometry coordinates."#]
            #[doc = r#"See xdg_surface.set_window_geometry."#]
            #[doc = r#""#]
            #[doc = r#"Values set in this way are double-buffered. They will get applied"#]
            #[doc = r#"on the next commit."#]
            #[doc = r#""#]
            #[doc = r#"The compositor can use this information to allow or disallow"#]
            #[doc = r#"different states like maximize or fullscreen and draw accurate"#]
            #[doc = r#"animations."#]
            #[doc = r#""#]
            #[doc = r#"Similarly, a tiling window manager may use this information to"#]
            #[doc = r#"place and resize client windows in a more effective way."#]
            #[doc = r#""#]
            #[doc = r#"The client should not rely on the compositor to obey the minimum"#]
            #[doc = r#"size. The compositor may decide to ignore the values set by the"#]
            #[doc = r#"client and request a smaller size."#]
            #[doc = r#""#]
            #[doc = r#"If never set, or a value of zero in the request, means that the"#]
            #[doc = r#"client has no expected minimum size in the given dimension."#]
            #[doc = r#"As a result, a client wishing to reset the minimum size"#]
            #[doc = r#"to an unspecified state can use zero for width and height in the"#]
            #[doc = r#"request."#]
            #[doc = r#""#]
            #[doc = r#"Requesting a minimum size to be larger than the maximum size of"#]
            #[doc = r#"a surface is illegal and will result in a protocol error."#]
            #[doc = r#""#]
            #[doc = r#"The width and height must be greater than or equal to zero. Using"#]
            #[doc = r#"strictly negative values for width and height will result in the"#]
            #[doc = r#"zxdg_shell_v6.invalid_surface_state error being raised."#]
            async fn set_min_size(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_min_size: i32,
                set_min_size: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Maximize the surface."#]
            #[doc = r#""#]
            #[doc = r#"After requesting that the surface should be maximized, the compositor"#]
            #[doc = r#"will respond by emitting a configure event with the "maximized" state"#]
            #[doc = r#"and the required window geometry. The client should then update its"#]
            #[doc = r#"content, drawing it in a maximized state, i.e. without shadow or other"#]
            #[doc = r#"decoration outside of the window geometry. The client must also"#]
            #[doc = r#"acknowledge the configure when committing the new content (see"#]
            #[doc = r#"ack_configure)."#]
            #[doc = r#""#]
            #[doc = r#"It is up to the compositor to decide how and where to maximize the"#]
            #[doc = r#"surface, for example which output and what region of the screen should"#]
            #[doc = r#"be used."#]
            #[doc = r#""#]
            #[doc = r#"If the surface was already maximized, the compositor will still emit"#]
            #[doc = r#"a configure event with the "maximized" state."#]
            #[doc = r#""#]
            #[doc = r#"Note that unrelated compositor side state changes may cause"#]
            #[doc = r#"configure events to be emitted at any time, meaning trying to"#]
            #[doc = r#"match this request to a specific future configure event is"#]
            #[doc = r#"futile."#]
            async fn set_maximized(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Unmaximize the surface."#]
            #[doc = r#""#]
            #[doc = r#"After requesting that the surface should be unmaximized, the compositor"#]
            #[doc = r#"will respond by emitting a configure event without the "maximized""#]
            #[doc = r#"state. If available, the compositor will include the window geometry"#]
            #[doc = r#"dimensions the window had prior to being maximized in the configure"#]
            #[doc = r#"request. The client must then update its content, drawing it in a"#]
            #[doc = r#"regular state, i.e. potentially with shadow, etc. The client must also"#]
            #[doc = r#"acknowledge the configure when committing the new content (see"#]
            #[doc = r#"ack_configure)."#]
            #[doc = r#""#]
            #[doc = r#"It is up to the compositor to position the surface after it was"#]
            #[doc = r#"unmaximized; usually the position the surface had before maximizing, if"#]
            #[doc = r#"applicable."#]
            #[doc = r#""#]
            #[doc = r#"If the surface was already not maximized, the compositor will still"#]
            #[doc = r#"emit a configure event without the "maximized" state."#]
            #[doc = r#""#]
            #[doc = r#"Note that unrelated changes in the state of compositor may cause"#]
            #[doc = r#"configure events to be emitted by the compositor between processing"#]
            #[doc = r#"this request and emitting corresponding configure event, so trying"#]
            #[doc = r#"to match the request with the event is futile."#]
            async fn unset_maximized(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Make the surface fullscreen."#]
            #[doc = r#""#]
            #[doc = r#"You can specify an output that you would prefer to be fullscreen."#]
            #[doc = r#"If this value is NULL, it's up to the compositor to choose which"#]
            #[doc = r#"display will be used to map this surface."#]
            #[doc = r#""#]
            #[doc = r#"If the surface doesn't cover the whole output, the compositor will"#]
            #[doc = r#"position the surface in the center of the output and compensate with"#]
            #[doc = r#"black borders filling the rest of the output."#]
            async fn set_fullscreen(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_fullscreen: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            async fn unset_fullscreen(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Request that the compositor minimize your surface. There is no"#]
            #[doc = r#"way to know if the surface is currently minimized, nor is there"#]
            #[doc = r#"any way to unset minimization on this surface."#]
            #[doc = r#""#]
            #[doc = r#"If you are looking to throttle redrawing when minimized, please"#]
            #[doc = r#"instead use the wl_surface.frame event for this, as this will"#]
            #[doc = r#"also work with live previews on windows in Alt-Tab, Expose or"#]
            #[doc = r#"similar compositor features."#]
            async fn set_minimized(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This configure event asks the client to resize its toplevel surface or"#]
            #[doc = r#"to change its state. The configured state should not be applied"#]
            #[doc = r#"immediately. See xdg_surface.configure for details."#]
            #[doc = r#""#]
            #[doc = r#"The width and height arguments specify a hint to the window"#]
            #[doc = r#"about how its surface should be resized in window geometry"#]
            #[doc = r#"coordinates. See set_window_geometry."#]
            #[doc = r#""#]
            #[doc = r#"If the width or height arguments are zero, it means the client"#]
            #[doc = r#"should decide its own window dimension. This may happen when the"#]
            #[doc = r#"compositor needs to configure the state of the surface but doesn't"#]
            #[doc = r#"have any information about any previous or expected dimension."#]
            #[doc = r#""#]
            #[doc = r#"The states listed in the event specify how the width/height"#]
            #[doc = r#"arguments should be interpreted, and possibly how it should be"#]
            #[doc = r#"drawn."#]
            #[doc = r#""#]
            #[doc = r#"Clients must send an ack_configure in response to this event. See"#]
            #[doc = r#"xdg_surface.configure and xdg_surface.ack_configure for details."#]
            async fn configure(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
                states: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_toplevel_v6#{}.configure()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(width)
                    .put_int(height)
                    .put_array(states)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The close event is sent by the compositor when the user"#]
            #[doc = r#"wants the surface to be closed. This should be equivalent to"#]
            #[doc = r#"the user clicking the close button in client-side decorations,"#]
            #[doc = r#"if your application has any."#]
            #[doc = r#""#]
            #[doc = r#"This is only a request that the user intends to close the"#]
            #[doc = r#"window. The client may choose to ignore this request, or show"#]
            #[doc = r#"a dialog to ask the user to save their data, etc."#]
            async fn close(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_toplevel_v6#{}.close()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zxdg_popup_v6 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Tried to grab after being mapped"#]
            InvalidGrab = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::InvalidGrab),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"A popup surface is a short-lived, temporary surface. It can be used to"#]
        #[doc = r#"implement for example menus, popovers, tooltips and other similar user"#]
        #[doc = r#"interface concepts."#]
        #[doc = r#""#]
        #[doc = r#"A popup can be made to take an explicit grab. See xdg_popup.grab for"#]
        #[doc = r#"details."#]
        #[doc = r#""#]
        #[doc = r#"When the popup is dismissed, a popup_done event will be sent out, and at"#]
        #[doc = r#"the same time the surface will be unmapped. See the xdg_popup.popup_done"#]
        #[doc = r#"event for details."#]
        #[doc = r#""#]
        #[doc = r#"Explicitly destroying the xdg_popup object will also dismiss the popup and"#]
        #[doc = r#"unmap the surface. Clients that want to dismiss the popup when another"#]
        #[doc = r#"surface of their own is clicked should dismiss the popup using the destroy"#]
        #[doc = r#"request."#]
        #[doc = r#""#]
        #[doc = r#"The parent surface must have either the xdg_toplevel or xdg_popup surface"#]
        #[doc = r#"role."#]
        #[doc = r#""#]
        #[doc = r#"A newly created xdg_popup will be stacked on top of all previously created"#]
        #[doc = r#"xdg_popup surfaces associated with the same xdg_toplevel."#]
        #[doc = r#""#]
        #[doc = r#"The parent of an xdg_popup must be mapped (see the xdg_surface"#]
        #[doc = r#"description) before the xdg_popup itself."#]
        #[doc = r#""#]
        #[doc = r#"The x and y arguments passed when creating the popup object specify"#]
        #[doc = r#"where the top left of the popup should be placed, relative to the"#]
        #[doc = r#"local surface coordinates of the parent surface. See"#]
        #[doc = r#"xdg_surface.get_popup. An xdg_popup must intersect with or be at least"#]
        #[doc = r#"partially adjacent to its parent surface."#]
        #[doc = r#""#]
        #[doc = r#"The client must call wl_surface.commit on the corresponding wl_surface"#]
        #[doc = r#"for the xdg_popup state to take effect."#]
        pub trait ZxdgPopupV6: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zxdg_popup_v6";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zxdg_popup_v6#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    1 => {
                        tracing::debug!("zxdg_popup_v6#{}.grab()", object.id);
                        self.grab(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"This destroys the popup. Explicitly destroying the xdg_popup"#]
            #[doc = r#"object will also dismiss the popup, and unmap the surface."#]
            #[doc = r#""#]
            #[doc = r#"If this xdg_popup is not the "topmost" popup, a protocol error"#]
            #[doc = r#"will be sent."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request makes the created popup take an explicit grab. An explicit"#]
            #[doc = r#"grab will be dismissed when the user dismisses the popup, or when the"#]
            #[doc = r#"client destroys the xdg_popup. This can be done by the user clicking"#]
            #[doc = r#"outside the surface, using the keyboard, or even locking the screen"#]
            #[doc = r#"through closing the lid or a timeout."#]
            #[doc = r#""#]
            #[doc = r#"If the compositor denies the grab, the popup will be immediately"#]
            #[doc = r#"dismissed."#]
            #[doc = r#""#]
            #[doc = r#"This request must be used in response to some sort of user action like a"#]
            #[doc = r#"button press, key press, or touch down event. The serial number of the"#]
            #[doc = r#"event should be passed as 'serial'."#]
            #[doc = r#""#]
            #[doc = r#"The parent of a grabbing popup must either be an xdg_toplevel surface or"#]
            #[doc = r#"another xdg_popup with an explicit grab. If the parent is another"#]
            #[doc = r#"xdg_popup it means that the popups are nested, with this popup now being"#]
            #[doc = r#"the topmost popup."#]
            #[doc = r#""#]
            #[doc = r#"Nested popups must be destroyed in the reverse order they were created"#]
            #[doc = r#"in, e.g. the only popup you are allowed to destroy at all times is the"#]
            #[doc = r#"topmost one."#]
            #[doc = r#""#]
            #[doc = r#"When compositors choose to dismiss a popup, they may dismiss every"#]
            #[doc = r#"nested grabbing popup as well. When a compositor dismisses popups, it"#]
            #[doc = r#"will follow the same dismissing order as required from the client."#]
            #[doc = r#""#]
            #[doc = r#"The parent of a grabbing popup must either be another xdg_popup with an"#]
            #[doc = r#"active explicit grab, or an xdg_popup or xdg_toplevel, if there are no"#]
            #[doc = r#"explicit grabs already taken."#]
            #[doc = r#""#]
            #[doc = r#"If the topmost grabbing popup is destroyed, the grab will be returned to"#]
            #[doc = r#"the parent of the popup, if that parent previously had an explicit grab."#]
            #[doc = r#""#]
            #[doc = r#"If the parent is a grabbing popup which has already been dismissed, this"#]
            #[doc = r#"popup will be immediately dismissed. If the parent is a popup that did"#]
            #[doc = r#"not take an explicit grab, an error will be raised."#]
            #[doc = r#""#]
            #[doc = r#"During a popup grab, the client owning the grab will receive pointer"#]
            #[doc = r#"and touch events for all their surfaces as normal (similar to an"#]
            #[doc = r#""owner-events" grab in X11 parlance), while the top most grabbing popup"#]
            #[doc = r#"will always have keyboard focus."#]
            async fn grab(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                grab: crate::wire::ObjectId,
                grab: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event asks the popup surface to configure itself given the"#]
            #[doc = r#"configuration. The configured state should not be applied immediately."#]
            #[doc = r#"See xdg_surface.configure for details."#]
            #[doc = r#""#]
            #[doc = r#"The x and y arguments represent the position the popup was placed at"#]
            #[doc = r#"given the xdg_positioner rule, relative to the upper left corner of the"#]
            #[doc = r#"window geometry of the parent surface."#]
            async fn configure(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_popup_v6#{}.configure()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(x)
                    .put_int(y)
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The popup_done event is sent out when a popup is dismissed by the"#]
            #[doc = r#"compositor. The client should destroy the xdg_popup object at this"#]
            #[doc = r#"point."#]
            async fn popup_done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zxdg_popup_v6#{}.popup_done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = r#"This protocol allows a privileged client to control data devices. In"#]
#[doc = r#"particular, the client will be able to manage the current selection and take"#]
#[doc = r#"the role of a clipboard manager."#]
#[doc = r#""#]
#[doc = r#"Warning! The protocol described in this file is experimental and"#]
#[doc = r#"backward incompatible changes may be made. Backward compatible changes"#]
#[doc = r#"may be added together with the corresponding interface version bump."#]
#[doc = r#"Backward incompatible changes are done by bumping the version number in"#]
#[doc = r#"the protocol and interface names and resetting the interface version."#]
#[doc = r#"Once the protocol is to be declared stable, the 'z' prefix and the"#]
#[doc = r#"version number in the protocol and interface names are removed and the"#]
#[doc = r#"interface version number is reset."#]
pub mod wlr_data_control_unstable_v1 {
    pub mod zwlr_data_control_manager_v1 {
        #[doc = r#"This interface is a manager that allows creating per-seat data device"#]
        #[doc = r#"controls."#]
        pub trait ZwlrDataControlManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_data_control_manager_v1";
            const VERSION: u32 = 2;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "zwlr_data_control_manager_v1#{}.create_data_source()",
                            object.id
                        );
                        self.create_data_source(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!(
                            "zwlr_data_control_manager_v1#{}.get_data_device()",
                            object.id
                        );
                        self.get_data_device(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("zwlr_data_control_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Create a new data source."#]
            async fn create_data_source(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create_data_source: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Create a data device that can be used to manage a seat's selection."#]
            async fn get_data_device(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_data_device: crate::wire::ObjectId,
                get_data_device: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"All objects created by the manager will still remain valid, until their"#]
            #[doc = r#"appropriate destroy request has been called."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwlr_data_control_device_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Source given to set_selection or set_primary_selection was already used before"#]
            UsedSource = 1,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::UsedSource),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"This interface allows a client to manage a seat's selection."#]
        #[doc = r#""#]
        #[doc = r#"When the seat is destroyed, this object becomes inert."#]
        pub trait ZwlrDataControlDeviceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_data_control_device_v1";
            const VERSION: u32 = 2;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "zwlr_data_control_device_v1#{}.set_selection()",
                            object.id
                        );
                        self.set_selection(object, client, message.object()?).await
                    }
                    1 => {
                        tracing::debug!("zwlr_data_control_device_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    2 => {
                        tracing::debug!(
                            "zwlr_data_control_device_v1#{}.set_primary_selection()",
                            object.id
                        );
                        self.set_primary_selection(object, client, message.object()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"This request asks the compositor to set the selection to the data from"#]
            #[doc = r#"the source on behalf of the client."#]
            #[doc = r#""#]
            #[doc = r#"The given source may not be used in any further set_selection or"#]
            #[doc = r#"set_primary_selection requests. Attempting to use a previously used"#]
            #[doc = r#"source is a protocol error."#]
            #[doc = r#""#]
            #[doc = r#"To unset the selection, set the source to NULL."#]
            async fn set_selection(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_selection: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = r#"Destroys the data device object."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request asks the compositor to set the primary selection to the"#]
            #[doc = r#"data from the source on behalf of the client."#]
            #[doc = r#""#]
            #[doc = r#"The given source may not be used in any further set_selection or"#]
            #[doc = r#"set_primary_selection requests. Attempting to use a previously used"#]
            #[doc = r#"source is a protocol error."#]
            #[doc = r#""#]
            #[doc = r#"To unset the primary selection, set the source to NULL."#]
            #[doc = r#""#]
            #[doc = r#"The compositor will ignore this request if it does not support primary"#]
            #[doc = r#"selection."#]
            async fn set_primary_selection(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_primary_selection: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = r#"The data_offer event introduces a new wlr_data_control_offer object,"#]
            #[doc = r#"which will subsequently be used in either the"#]
            #[doc = r#"wlr_data_control_device.selection event (for the regular clipboard"#]
            #[doc = r#"selections) or the wlr_data_control_device.primary_selection event (for"#]
            #[doc = r#"the primary clipboard selections). Immediately following the"#]
            #[doc = r#"wlr_data_control_device.data_offer event, the new data_offer object"#]
            #[doc = r#"will send out wlr_data_control_offer.offer events to describe the MIME"#]
            #[doc = r#"types it offers."#]
            async fn data_offer(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_data_control_device_v1#{}.data_offer()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The selection event is sent out to notify the client of a new"#]
            #[doc = r#"wlr_data_control_offer for the selection for this device. The"#]
            #[doc = r#"wlr_data_control_device.data_offer and the wlr_data_control_offer.offer"#]
            #[doc = r#"events are sent out immediately before this event to introduce the data"#]
            #[doc = r#"offer object. The selection event is sent to a client when a new"#]
            #[doc = r#"selection is set. The wlr_data_control_offer is valid until a new"#]
            #[doc = r#"wlr_data_control_offer or NULL is received. The client must destroy the"#]
            #[doc = r#"previous selection wlr_data_control_offer, if any, upon receiving this"#]
            #[doc = r#"event."#]
            #[doc = r#""#]
            #[doc = r#"The first selection event is sent upon binding the"#]
            #[doc = r#"wlr_data_control_device object."#]
            async fn selection(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_data_control_device_v1#{}.selection()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_object(id).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This data control object is no longer valid and should be destroyed by"#]
            #[doc = r#"the client."#]
            async fn finished(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_data_control_device_v1#{}.finished()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The primary_selection event is sent out to notify the client of a new"#]
            #[doc = r#"wlr_data_control_offer for the primary selection for this device. The"#]
            #[doc = r#"wlr_data_control_device.data_offer and the wlr_data_control_offer.offer"#]
            #[doc = r#"events are sent out immediately before this event to introduce the data"#]
            #[doc = r#"offer object. The primary_selection event is sent to a client when a"#]
            #[doc = r#"new primary selection is set. The wlr_data_control_offer is valid until"#]
            #[doc = r#"a new wlr_data_control_offer or NULL is received. The client must"#]
            #[doc = r#"destroy the previous primary selection wlr_data_control_offer, if any,"#]
            #[doc = r#"upon receiving this event."#]
            #[doc = r#""#]
            #[doc = r#"If the compositor supports primary selection, the first"#]
            #[doc = r#"primary_selection event is sent upon binding the"#]
            #[doc = r#"wlr_data_control_device object."#]
            async fn primary_selection(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                id: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwlr_data_control_device_v1#{}.primary_selection()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_object(id).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwlr_data_control_source_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Offer sent after wlr_data_control_device.set_selection"#]
            InvalidOffer = 1,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::InvalidOffer),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"The wlr_data_control_source object is the source side of a"#]
        #[doc = r#"wlr_data_control_offer. It is created by the source client in a data"#]
        #[doc = r#"transfer and provides a way to describe the offered data and a way to"#]
        #[doc = r#"respond to requests to transfer the data."#]
        pub trait ZwlrDataControlSourceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_data_control_source_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwlr_data_control_source_v1#{}.offer()", object.id);
                        self.offer(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwlr_data_control_source_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"This request adds a MIME type to the set of MIME types advertised to"#]
            #[doc = r#"targets. Can be called several times to offer multiple types."#]
            #[doc = r#""#]
            #[doc = r#"Calling this after wlr_data_control_device.set_selection is a protocol"#]
            #[doc = r#"error."#]
            async fn offer(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                offer: String,
            ) -> crate::server::Result<()>;
            #[doc = r#"Destroys the data source object."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Request for data from the client. Send the data as the specified MIME"#]
            #[doc = r#"type over the passed file descriptor, then close it."#]
            async fn send(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
                fd: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_data_control_source_v1#{}.send()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(mime_type))
                    .put_fd(fd)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This data source is no longer valid. The data source has been replaced"#]
            #[doc = r#"by another data source."#]
            #[doc = r#""#]
            #[doc = r#"The client should clean up and destroy this data source."#]
            async fn cancelled(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_data_control_source_v1#{}.cancelled()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwlr_data_control_offer_v1 {
        #[doc = r#"A wlr_data_control_offer represents a piece of data offered for transfer"#]
        #[doc = r#"by another client (the source client). The offer describes the different"#]
        #[doc = r#"MIME types that the data can be converted to and provides the mechanism"#]
        #[doc = r#"for transferring the data directly from the source client."#]
        pub trait ZwlrDataControlOfferV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_data_control_offer_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwlr_data_control_offer_v1#{}.receive()", object.id);
                        self.receive(
                            object,
                            client,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.fd()?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwlr_data_control_offer_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"To transfer the offered data, the client issues this request and"#]
            #[doc = r#"indicates the MIME type it wants to receive. The transfer happens"#]
            #[doc = r#"through the passed file descriptor (typically created with the pipe"#]
            #[doc = r#"system call). The source client writes the data in the MIME type"#]
            #[doc = r#"representation requested and then closes the file descriptor."#]
            #[doc = r#""#]
            #[doc = r#"The receiving client reads from the read end of the pipe until EOF and"#]
            #[doc = r#"then closes its end, at which point the transfer is complete."#]
            #[doc = r#""#]
            #[doc = r#"This request may happen multiple times for different MIME types."#]
            async fn receive(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                receive: String,
                receive: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()>;
            #[doc = r#"Destroys the data offer object."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Sent immediately after creating the wlr_data_control_offer object."#]
            #[doc = r#"One event per offered MIME type."#]
            async fn offer(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                mime_type: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_data_control_offer_v1#{}.offer()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(mime_type))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = r#"An interface to capture surfaces in an efficient way by exporting DMA-BUFs."#]
#[doc = r#""#]
#[doc = r#"Warning! The protocol described in this file is experimental and"#]
#[doc = r#"backward incompatible changes may be made. Backward compatible changes"#]
#[doc = r#"may be added together with the corresponding interface version bump."#]
#[doc = r#"Backward incompatible changes are done by bumping the version number in"#]
#[doc = r#"the protocol and interface names and resetting the interface version."#]
#[doc = r#"Once the protocol is to be declared stable, the 'z' prefix and the"#]
#[doc = r#"version number in the protocol and interface names are removed and the"#]
#[doc = r#"interface version number is reset."#]
pub mod wlr_export_dmabuf_unstable_v1 {
    pub mod zwlr_export_dmabuf_manager_v1 {
        #[doc = r#"This object is a manager with which to start capturing from sources."#]
        pub trait ZwlrExportDmabufManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_export_dmabuf_manager_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "zwlr_export_dmabuf_manager_v1#{}.capture_output()",
                            object.id
                        );
                        self.capture_output(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwlr_export_dmabuf_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Capture the next frame of an entire output."#]
            async fn capture_output(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                capture_output: crate::wire::ObjectId,
                capture_output: i32,
                capture_output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"All objects created by the manager will still remain valid, until their"#]
            #[doc = r#"appropriate destroy request has been called."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwlr_export_dmabuf_frame_v1 {
        #[doc = r#"Special flags that should be respected by the client."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Flags {
            #[doc = r#"Clients should copy frame before processing"#]
            Transient = 0x1,
        }
        impl TryFrom<u32> for Flags {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0x1 => Ok(Self::Transient),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"Indicates reason for cancelling the frame."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum CancelReason {
            #[doc = r#"Temporary error, source will produce more frames"#]
            Temporary = 0,
            #[doc = r#"Fatal error, source will not produce frames"#]
            Permanent = 1,
            #[doc = r#"Temporary error, source will produce more frames"#]
            Resizing = 2,
        }
        impl TryFrom<u32> for CancelReason {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Temporary),
                    1 => Ok(Self::Permanent),
                    2 => Ok(Self::Resizing),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"This object represents a single DMA-BUF frame."#]
        #[doc = r#""#]
        #[doc = r#"If the capture is successful, the compositor will first send a "frame""#]
        #[doc = r#"event, followed by one or several "object". When the frame is available"#]
        #[doc = r#"for readout, the "ready" event is sent."#]
        #[doc = r#""#]
        #[doc = r#"If the capture failed, the "cancel" event is sent. This can happen anytime"#]
        #[doc = r#"before the "ready" event."#]
        #[doc = r#""#]
        #[doc = r#"Once either a "ready" or a "cancel" event is received, the client should"#]
        #[doc = r#"destroy the frame. Once an "object" event is received, the client is"#]
        #[doc = r#"responsible for closing the associated file descriptor."#]
        #[doc = r#""#]
        #[doc = r#"All frames are read-only and may not be written into or altered."#]
        pub trait ZwlrExportDmabufFrameV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_export_dmabuf_frame_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwlr_export_dmabuf_frame_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Unreferences the frame. This request must be called as soon as its no"#]
            #[doc = r#"longer used."#]
            #[doc = r#""#]
            #[doc = r#"It can be called at any time by the client. The client will still have"#]
            #[doc = r#"to close any FDs it has been given."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Main event supplying the client with information about the frame. If the"#]
            #[doc = r#"capture didn't fail, this event is always emitted first before any other"#]
            #[doc = r#"events."#]
            #[doc = r#""#]
            #[doc = r#"This event is followed by a number of "object" as specified by the"#]
            #[doc = r#""num_objects" argument."#]
            async fn frame(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: u32,
                height: u32,
                offset_x: u32,
                offset_y: u32,
                buffer_flags: u32,
                flags: Flags,
                format: u32,
                mod_high: u32,
                mod_low: u32,
                num_objects: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_export_dmabuf_frame_v1#{}.frame()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(width)
                    .put_uint(height)
                    .put_uint(offset_x)
                    .put_uint(offset_y)
                    .put_uint(buffer_flags)
                    .put_uint(flags as u32)
                    .put_uint(format)
                    .put_uint(mod_high)
                    .put_uint(mod_low)
                    .put_uint(num_objects)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Event which serves to supply the client with the file descriptors"#]
            #[doc = r#"containing the data for each object."#]
            #[doc = r#""#]
            #[doc = r#"After receiving this event, the client must always close the file"#]
            #[doc = r#"descriptor as soon as they're done with it and even if the frame fails."#]
            async fn object(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                index: u32,
                fd: rustix::fd::OwnedFd,
                size: u32,
                offset: u32,
                stride: u32,
                plane_index: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_export_dmabuf_frame_v1#{}.object()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(index)
                    .put_fd(fd)
                    .put_uint(size)
                    .put_uint(offset)
                    .put_uint(stride)
                    .put_uint(plane_index)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent as soon as the frame is presented, indicating it is"#]
            #[doc = r#"available for reading. This event includes the time at which"#]
            #[doc = r#"presentation happened at."#]
            #[doc = r#""#]
            #[doc = r#"The timestamp is expressed as tv_sec_hi, tv_sec_lo, tv_nsec triples,"#]
            #[doc = r#"each component being an unsigned 32-bit value. Whole seconds are in"#]
            #[doc = r#"tv_sec which is a 64-bit value combined from tv_sec_hi and tv_sec_lo,"#]
            #[doc = r#"and the additional fractional part in tv_nsec as nanoseconds. Hence,"#]
            #[doc = r#"for valid timestamps tv_nsec must be in [0, 999999999]. The seconds part"#]
            #[doc = r#"may have an arbitrary offset at start."#]
            #[doc = r#""#]
            #[doc = r#"After receiving this event, the client should destroy this object."#]
            async fn ready(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                tv_sec_hi: u32,
                tv_sec_lo: u32,
                tv_nsec: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_export_dmabuf_frame_v1#{}.ready()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(tv_sec_hi)
                    .put_uint(tv_sec_lo)
                    .put_uint(tv_nsec)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"If the capture failed or if the frame is no longer valid after the"#]
            #[doc = r#""frame" event has been emitted, this event will be used to inform the"#]
            #[doc = r#"client to scrap the frame."#]
            #[doc = r#""#]
            #[doc = r#"If the failure is temporary, the client may capture again the same"#]
            #[doc = r#"source. If the failure is permanent, any further attempts to capture the"#]
            #[doc = r#"same source will fail again."#]
            #[doc = r#""#]
            #[doc = r#"After receiving this event, the client should destroy this object."#]
            async fn cancel(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                reason: CancelReason,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_export_dmabuf_frame_v1#{}.cancel()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(reason as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod wlr_foreign_toplevel_management_unstable_v1 {
    pub mod zwlr_foreign_toplevel_manager_v1 {
        #[doc = r#"The purpose of this protocol is to enable the creation of taskbars"#]
        #[doc = r#"and docks by providing them with a list of opened applications and"#]
        #[doc = r#"letting them request certain actions on them, like maximizing, etc."#]
        #[doc = r#""#]
        #[doc = r#"After a client binds the zwlr_foreign_toplevel_manager_v1, each opened"#]
        #[doc = r#"toplevel window will be sent via the toplevel event"#]
        pub trait ZwlrForeignToplevelManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_foreign_toplevel_manager_v1";
            const VERSION: u32 = 3;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwlr_foreign_toplevel_manager_v1#{}.stop()", object.id);
                        self.stop(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Indicates the client no longer wishes to receive events for new toplevels."#]
            #[doc = r#"However the compositor may emit further toplevel_created events, until"#]
            #[doc = r#"the finished event is emitted."#]
            #[doc = r#""#]
            #[doc = r#"The client must not send any more requests after this one."#]
            async fn stop(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event is emitted whenever a new toplevel window is created. It"#]
            #[doc = r#"is emitted for all toplevels, regardless of the app that has created"#]
            #[doc = r#"them."#]
            #[doc = r#""#]
            #[doc = r#"All initial details of the toplevel(title, app_id, states, etc.) will"#]
            #[doc = r#"be sent immediately after this event via the corresponding events in"#]
            #[doc = r#"zwlr_foreign_toplevel_handle_v1."#]
            async fn toplevel(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                toplevel: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwlr_foreign_toplevel_manager_v1#{}.toplevel()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(toplevel))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event indicates that the compositor is done sending events to the"#]
            #[doc = r#"zwlr_foreign_toplevel_manager_v1. The server will destroy the object"#]
            #[doc = r#"immediately after sending this request, so it will become invalid and"#]
            #[doc = r#"the client should free any resources associated with it."#]
            async fn finished(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwlr_foreign_toplevel_manager_v1#{}.finished()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwlr_foreign_toplevel_handle_v1 {
        #[doc = r#"The different states that a toplevel can have. These have the same meaning"#]
        #[doc = r#"as the states with the same names defined in xdg-toplevel"#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum State {
            #[doc = r#"The toplevel is maximized"#]
            Maximized = 0,
            #[doc = r#"The toplevel is minimized"#]
            Minimized = 1,
            #[doc = r#"The toplevel is active"#]
            Activated = 2,
            #[doc = r#"The toplevel is fullscreen"#]
            Fullscreen = 3,
        }
        impl TryFrom<u32> for State {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Maximized),
                    1 => Ok(Self::Minimized),
                    2 => Ok(Self::Activated),
                    3 => Ok(Self::Fullscreen),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"The provided rectangle is invalid"#]
            InvalidRectangle = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::InvalidRectangle),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"A zwlr_foreign_toplevel_handle_v1 object represents an opened toplevel"#]
        #[doc = r#"window. Each app may have multiple opened toplevels."#]
        #[doc = r#""#]
        #[doc = r#"Each toplevel has a list of outputs it is visible on, conveyed to the"#]
        #[doc = r#"client with the output_enter and output_leave events."#]
        pub trait ZwlrForeignToplevelHandleV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_foreign_toplevel_handle_v1";
            const VERSION: u32 = 3;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "zwlr_foreign_toplevel_handle_v1#{}.set_maximized()",
                            object.id
                        );
                        self.set_maximized(object, client).await
                    }
                    1 => {
                        tracing::debug!(
                            "zwlr_foreign_toplevel_handle_v1#{}.unset_maximized()",
                            object.id
                        );
                        self.unset_maximized(object, client).await
                    }
                    2 => {
                        tracing::debug!(
                            "zwlr_foreign_toplevel_handle_v1#{}.set_minimized()",
                            object.id
                        );
                        self.set_minimized(object, client).await
                    }
                    3 => {
                        tracing::debug!(
                            "zwlr_foreign_toplevel_handle_v1#{}.unset_minimized()",
                            object.id
                        );
                        self.unset_minimized(object, client).await
                    }
                    4 => {
                        tracing::debug!("zwlr_foreign_toplevel_handle_v1#{}.activate()", object.id);
                        self.activate(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    5 => {
                        tracing::debug!("zwlr_foreign_toplevel_handle_v1#{}.close()", object.id);
                        self.close(object, client).await
                    }
                    6 => {
                        tracing::debug!(
                            "zwlr_foreign_toplevel_handle_v1#{}.set_rectangle()",
                            object.id
                        );
                        self.set_rectangle(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    7 => {
                        tracing::debug!("zwlr_foreign_toplevel_handle_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    8 => {
                        tracing::debug!(
                            "zwlr_foreign_toplevel_handle_v1#{}.set_fullscreen()",
                            object.id
                        );
                        self.set_fullscreen(object, client, message.object()?).await
                    }
                    9 => {
                        tracing::debug!(
                            "zwlr_foreign_toplevel_handle_v1#{}.unset_fullscreen()",
                            object.id
                        );
                        self.unset_fullscreen(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Requests that the toplevel be maximized. If the maximized state actually"#]
            #[doc = r#"changes, this will be indicated by the state event."#]
            async fn set_maximized(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Requests that the toplevel be unmaximized. If the maximized state actually"#]
            #[doc = r#"changes, this will be indicated by the state event."#]
            async fn unset_maximized(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Requests that the toplevel be minimized. If the minimized state actually"#]
            #[doc = r#"changes, this will be indicated by the state event."#]
            async fn set_minimized(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Requests that the toplevel be unminimized. If the minimized state actually"#]
            #[doc = r#"changes, this will be indicated by the state event."#]
            async fn unset_minimized(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Request that this toplevel be activated on the given seat."#]
            #[doc = r#"There is no guarantee the toplevel will be actually activated."#]
            async fn activate(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                activate: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Send a request to the toplevel to close itself. The compositor would"#]
            #[doc = r#"typically use a shell-specific method to carry out this request, for"#]
            #[doc = r#"example by sending the xdg_toplevel.close event. However, this gives"#]
            #[doc = r#"no guarantees the toplevel will actually be destroyed. If and when"#]
            #[doc = r#"this happens, the zwlr_foreign_toplevel_handle_v1.closed event will"#]
            #[doc = r#"be emitted."#]
            async fn close(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"The rectangle of the surface specified in this request corresponds to"#]
            #[doc = r#"the place where the app using this protocol represents the given toplevel."#]
            #[doc = r#"It can be used by the compositor as a hint for some operations, e.g"#]
            #[doc = r#"minimizing. The client is however not required to set this, in which"#]
            #[doc = r#"case the compositor is free to decide some default value."#]
            #[doc = r#""#]
            #[doc = r#"If the client specifies more than one rectangle, only the last one is"#]
            #[doc = r#"considered."#]
            #[doc = r#""#]
            #[doc = r#"The dimensions are given in surface-local coordinates."#]
            #[doc = r#"Setting width=height=0 removes the already-set rectangle."#]
            async fn set_rectangle(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_rectangle: crate::wire::ObjectId,
                set_rectangle: i32,
                set_rectangle: i32,
                set_rectangle: i32,
                set_rectangle: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Destroys the zwlr_foreign_toplevel_handle_v1 object."#]
            #[doc = r#""#]
            #[doc = r#"This request should be called either when the client does not want to"#]
            #[doc = r#"use the toplevel anymore or after the closed event to finalize the"#]
            #[doc = r#"destruction of the object."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Requests that the toplevel be fullscreened on the given output. If the"#]
            #[doc = r#"fullscreen state and/or the outputs the toplevel is visible on actually"#]
            #[doc = r#"change, this will be indicated by the state and output_enter/leave"#]
            #[doc = r#"events."#]
            #[doc = r#""#]
            #[doc = r#"The output parameter is only a hint to the compositor. Also, if output"#]
            #[doc = r#"is NULL, the compositor should decide which output the toplevel will be"#]
            #[doc = r#"fullscreened on, if at all."#]
            async fn set_fullscreen(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_fullscreen: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()>;
            #[doc = r#"Requests that the toplevel be unfullscreened. If the fullscreen state"#]
            #[doc = r#"actually changes, this will be indicated by the state event."#]
            async fn unset_fullscreen(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event is emitted whenever the title of the toplevel changes."#]
            async fn title(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                title: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_foreign_toplevel_handle_v1#{}.title()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(title))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is emitted whenever the app-id of the toplevel changes."#]
            async fn app_id(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                app_id: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_foreign_toplevel_handle_v1#{}.app_id()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(app_id))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is emitted whenever the toplevel becomes visible on"#]
            #[doc = r#"the given output. A toplevel may be visible on multiple outputs."#]
            async fn output_enter(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwlr_foreign_toplevel_handle_v1#{}.output_enter()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(output))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is emitted whenever the toplevel stops being visible on"#]
            #[doc = r#"the given output. It is guaranteed that an entered-output event"#]
            #[doc = r#"with the same output has been emitted before this event."#]
            async fn output_leave(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                output: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!(
                    "-> zwlr_foreign_toplevel_handle_v1#{}.output_leave()",
                    _object.id
                );
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(output))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is emitted immediately after the zlw_foreign_toplevel_handle_v1"#]
            #[doc = r#"is created and each time the toplevel state changes, either because of a"#]
            #[doc = r#"compositor action or because of a request in this protocol."#]
            async fn state(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                state: Vec<u8>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_foreign_toplevel_handle_v1#{}.state()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_array(state).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent after all changes in the toplevel state have been"#]
            #[doc = r#"sent."#]
            #[doc = r#""#]
            #[doc = r#"This allows changes to the zwlr_foreign_toplevel_handle_v1 properties"#]
            #[doc = r#"to be seen as atomic, even if they happen via multiple events."#]
            async fn done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_foreign_toplevel_handle_v1#{}.done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 5, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event means the toplevel has been destroyed. It is guaranteed there"#]
            #[doc = r#"won't be any more events for this zwlr_foreign_toplevel_handle_v1. The"#]
            #[doc = r#"toplevel itself becomes inert so any requests will be ignored except the"#]
            #[doc = r#"destroy request."#]
            async fn closed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_foreign_toplevel_handle_v1#{}.closed()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 6, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is emitted whenever the parent of the toplevel changes."#]
            #[doc = r#""#]
            #[doc = r#"No event is emitted when the parent handle is destroyed by the client."#]
            async fn parent(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                parent: Option<crate::wire::ObjectId>,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_foreign_toplevel_handle_v1#{}.parent()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(parent)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 7, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = r#"This protocol allows a privileged client to set the gamma tables for"#]
#[doc = r#"outputs."#]
#[doc = r#""#]
#[doc = r#"Warning! The protocol described in this file is experimental and"#]
#[doc = r#"backward incompatible changes may be made. Backward compatible changes"#]
#[doc = r#"may be added together with the corresponding interface version bump."#]
#[doc = r#"Backward incompatible changes are done by bumping the version number in"#]
#[doc = r#"the protocol and interface names and resetting the interface version."#]
#[doc = r#"Once the protocol is to be declared stable, the 'z' prefix and the"#]
#[doc = r#"version number in the protocol and interface names are removed and the"#]
#[doc = r#"interface version number is reset."#]
pub mod wlr_gamma_control_unstable_v1 {
    pub mod zwlr_gamma_control_manager_v1 {
        #[doc = r#"This interface is a manager that allows creating per-output gamma"#]
        #[doc = r#"controls."#]
        pub trait ZwlrGammaControlManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_gamma_control_manager_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "zwlr_gamma_control_manager_v1#{}.get_gamma_control()",
                            object.id
                        );
                        self.get_gamma_control(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwlr_gamma_control_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Create a gamma control that can be used to adjust gamma tables for the"#]
            #[doc = r#"provided output."#]
            async fn get_gamma_control(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_gamma_control: crate::wire::ObjectId,
                get_gamma_control: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"All objects created by the manager will still remain valid, until their"#]
            #[doc = r#"appropriate destroy request has been called."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwlr_gamma_control_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Invalid gamma tables"#]
            InvalidGamma = 1,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::InvalidGamma),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"This interface allows a client to adjust gamma tables for a particular"#]
        #[doc = r#"output."#]
        #[doc = r#""#]
        #[doc = r#"The client will receive the gamma size, and will then be able to set gamma"#]
        #[doc = r#"tables. At any time the compositor can send a failed event indicating that"#]
        #[doc = r#"this object is no longer valid."#]
        #[doc = r#""#]
        #[doc = r#"There can only be at most one gamma control object per output, which"#]
        #[doc = r#"has exclusive access to this particular output. When the gamma control"#]
        #[doc = r#"object is destroyed, the gamma table is restored to its original value."#]
        pub trait ZwlrGammaControlV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_gamma_control_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwlr_gamma_control_v1#{}.set_gamma()", object.id);
                        self.set_gamma(object, client, message.fd()?).await
                    }
                    1 => {
                        tracing::debug!("zwlr_gamma_control_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Set the gamma table. The file descriptor can be memory-mapped to provide"#]
            #[doc = r#"the raw gamma table, which contains successive gamma ramps for the red,"#]
            #[doc = r#"green and blue channels. Each gamma ramp is an array of 16-byte unsigned"#]
            #[doc = r#"integers which has the same length as the gamma size."#]
            #[doc = r#""#]
            #[doc = r#"The file descriptor data must have the same length as three times the"#]
            #[doc = r#"gamma size."#]
            async fn set_gamma(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_gamma: rustix::fd::OwnedFd,
            ) -> crate::server::Result<()>;
            #[doc = r#"Destroys the gamma control object. If the object is still valid, this"#]
            #[doc = r#"restores the original gamma tables."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Advertise the size of each gamma ramp."#]
            #[doc = r#""#]
            #[doc = r#"This event is sent immediately when the gamma control object is created."#]
            async fn gamma_size(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                size: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_gamma_control_v1#{}.gamma_size()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(size).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event indicates that the gamma control is no longer valid. This"#]
            #[doc = r#"can happen for a number of reasons, including:"#]
            #[doc = r#"- The output doesn't support gamma tables"#]
            #[doc = r#"- Setting the gamma tables failed"#]
            #[doc = r#"- Another client already has exclusive gamma control for this output"#]
            #[doc = r#"- The compositor has transferred gamma control to another client"#]
            #[doc = r#""#]
            #[doc = r#"Upon receiving this event, the client should destroy this object."#]
            async fn failed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_gamma_control_v1#{}.failed()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod wlr_input_inhibit_unstable_v1 {
    pub mod zwlr_input_inhibit_manager_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"An input inhibitor is already in use on the compositor"#]
            AlreadyInhibited = 0,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::AlreadyInhibited),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"Clients can use this interface to prevent input events from being sent to"#]
        #[doc = r#"any surfaces but its own, which is useful for example in lock screen"#]
        #[doc = r#"software. It is assumed that access to this interface will be locked down"#]
        #[doc = r#"to whitelisted clients by the compositor."#]
        #[doc = r#""#]
        #[doc = r#"Note! This protocol is deprecated and not intended for production use."#]
        #[doc = r#"For screen lockers, use the ext-session-lock-v1 protocol."#]
        pub trait ZwlrInputInhibitManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_input_inhibit_manager_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "zwlr_input_inhibit_manager_v1#{}.get_inhibitor()",
                            object.id
                        );
                        self.get_inhibitor(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Activates the input inhibitor. As long as the inhibitor is active, the"#]
            #[doc = r#"compositor will not send input events to other clients."#]
            async fn get_inhibitor(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_inhibitor: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwlr_input_inhibitor_v1 {
        #[doc = r#"While this resource exists, input to clients other than the owner of the"#]
        #[doc = r#"inhibitor resource will not receive input events. Any client which"#]
        #[doc = r#"previously had focus will receive a leave event and will not be given"#]
        #[doc = r#"focus again. The client that owns this resource will receive all input"#]
        #[doc = r#"events normally. The compositor will also disable all of its own input"#]
        #[doc = r#"processing (such as keyboard shortcuts) while the inhibitor is active."#]
        #[doc = r#""#]
        #[doc = r#"The compositor may continue to send input events to selected clients,"#]
        #[doc = r#"such as an on-screen keyboard (via the input-method protocol)."#]
        pub trait ZwlrInputInhibitorV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_input_inhibitor_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwlr_input_inhibitor_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Destroy the inhibitor and allow other clients to receive input."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
}
pub mod wlr_layer_shell_unstable_v1 {
    pub mod zwlr_layer_shell_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Wl_surface has another role"#]
            Role = 0,
            #[doc = r#"Layer value is invalid"#]
            InvalidLayer = 1,
            #[doc = r#"Wl_surface has a buffer attached or committed"#]
            AlreadyConstructed = 2,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Role),
                    1 => Ok(Self::InvalidLayer),
                    2 => Ok(Self::AlreadyConstructed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"These values indicate which layers a surface can be rendered in. They"#]
        #[doc = r#"are ordered by z depth, bottom-most first. Traditional shell surfaces"#]
        #[doc = r#"will typically be rendered between the bottom and top layers."#]
        #[doc = r#"Fullscreen shell surfaces are typically rendered at the top layer."#]
        #[doc = r#"Multiple surfaces can share a single layer, and ordering within a"#]
        #[doc = r#"single layer is undefined."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Layer {
            Background = 0,
            Bottom = 1,
            Top = 2,
            Overlay = 3,
        }
        impl TryFrom<u32> for Layer {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Background),
                    1 => Ok(Self::Bottom),
                    2 => Ok(Self::Top),
                    3 => Ok(Self::Overlay),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"Clients can use this interface to assign the surface_layer role to"#]
        #[doc = r#"wl_surfaces. Such surfaces are assigned to a "layer" of the output and"#]
        #[doc = r#"rendered with a defined z-depth respective to each other. They may also be"#]
        #[doc = r#"anchored to the edges and corners of a screen and specify input handling"#]
        #[doc = r#"semantics. This interface should be suitable for the implementation of"#]
        #[doc = r#"many desktop shell components, and a broad number of other applications"#]
        #[doc = r#"that interact with the desktop."#]
        pub trait ZwlrLayerShellV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_layer_shell_v1";
            const VERSION: u32 = 5;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwlr_layer_shell_v1#{}.get_layer_surface()", object.id);
                        self.get_layer_surface(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.object()?,
                            message.uint()?.try_into()?,
                            message
                                .string()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwlr_layer_shell_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Create a layer surface for an existing surface. This assigns the role of"#]
            #[doc = r#"layer_surface, or raises a protocol error if another role is already"#]
            #[doc = r#"assigned."#]
            #[doc = r#""#]
            #[doc = r#"Creating a layer surface from a wl_surface which has a buffer attached"#]
            #[doc = r#"or committed is a client error, and any attempts by a client to attach"#]
            #[doc = r#"or manipulate a buffer prior to the first layer_surface.configure call"#]
            #[doc = r#"must also be treated as errors."#]
            #[doc = r#""#]
            #[doc = r#"After creating a layer_surface object and setting it up, the client"#]
            #[doc = r#"must perform an initial commit without any buffer attached."#]
            #[doc = r#"The compositor will reply with a layer_surface.configure event."#]
            #[doc = r#"The client must acknowledge it and is then allowed to attach a buffer"#]
            #[doc = r#"to map the surface."#]
            #[doc = r#""#]
            #[doc = r#"You may pass NULL for output to allow the compositor to decide which"#]
            #[doc = r#"output to use. Generally this will be the one that the user most"#]
            #[doc = r#"recently interacted with."#]
            #[doc = r#""#]
            #[doc = r#"Clients can specify a namespace that defines the purpose of the layer"#]
            #[doc = r#"surface."#]
            async fn get_layer_surface(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_layer_surface: crate::wire::ObjectId,
                get_layer_surface: crate::wire::ObjectId,
                get_layer_surface: Option<crate::wire::ObjectId>,
                get_layer_surface: Layer,
                get_layer_surface: String,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request indicates that the client will not use the layer_shell"#]
            #[doc = r#"object any more. Objects that have been created through this instance"#]
            #[doc = r#"are not affected."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwlr_layer_surface_v1 {
        #[doc = r#"Types of keyboard interaction possible for layer shell surfaces. The"#]
        #[doc = r#"rationale for this is twofold: (1) some applications are not interested"#]
        #[doc = r#"in keyboard events and not allowing them to be focused can improve the"#]
        #[doc = r#"desktop experience; (2) some applications will want to take exclusive"#]
        #[doc = r#"keyboard focus."#]
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum KeyboardInteractivity {
            None = 0,
            Exclusive = 1,
            OnDemand = 2,
        }
        impl TryFrom<u32> for KeyboardInteractivity {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::None),
                    1 => Ok(Self::Exclusive),
                    2 => Ok(Self::OnDemand),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Provided surface state is invalid"#]
            InvalidSurfaceState = 0,
            #[doc = r#"Size is invalid"#]
            InvalidSize = 1,
            #[doc = r#"Anchor bitfield is invalid"#]
            InvalidAnchor = 2,
            #[doc = r#"Keyboard interactivity is invalid"#]
            InvalidKeyboardInteractivity = 3,
            #[doc = r#"Exclusive edge is invalid given the surface anchors"#]
            InvalidExclusiveEdge = 4,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::InvalidSurfaceState),
                    1 => Ok(Self::InvalidSize),
                    2 => Ok(Self::InvalidAnchor),
                    3 => Ok(Self::InvalidKeyboardInteractivity),
                    4 => Ok(Self::InvalidExclusiveEdge),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! {
                                    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
                                    pub struct Anchor: u32 {#[doc = r#"The top edge of the anchor rectangle"#]
        const Top = 1;#[doc = r#"The bottom edge of the anchor rectangle"#]
        const Bottom = 2;#[doc = r#"The left edge of the anchor rectangle"#]
        const Left = 4;#[doc = r#"The right edge of the anchor rectangle"#]
        const Right = 8;}
                                }
        impl TryFrom<u32> for Anchor {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = r#"An interface that may be implemented by a wl_surface, for surfaces that"#]
        #[doc = r#"are designed to be rendered as a layer of a stacked desktop-like"#]
        #[doc = r#"environment."#]
        #[doc = r#""#]
        #[doc = r#"Layer surface state (layer, size, anchor, exclusive zone,"#]
        #[doc = r#"margin, interactivity) is double-buffered, and will be applied at the"#]
        #[doc = r#"time wl_surface.commit of the corresponding wl_surface is called."#]
        #[doc = r#""#]
        #[doc = r#"Attaching a null buffer to a layer surface unmaps it."#]
        #[doc = r#""#]
        #[doc = r#"Unmapping a layer_surface means that the surface cannot be shown by the"#]
        #[doc = r#"compositor until it is explicitly mapped again. The layer_surface"#]
        #[doc = r#"returns to the state it had right after layer_shell.get_layer_surface."#]
        #[doc = r#"The client can re-map the surface by performing a commit without any"#]
        #[doc = r#"buffer attached, waiting for a configure event and handling it as usual."#]
        pub trait ZwlrLayerSurfaceV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_layer_surface_v1";
            const VERSION: u32 = 5;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.set_size()", object.id);
                        self.set_size(object, client, message.uint()?, message.uint()?)
                            .await
                    }
                    1 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.set_anchor()", object.id);
                        self.set_anchor(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    2 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.set_exclusive_zone()", object.id);
                        self.set_exclusive_zone(object, client, message.int()?)
                            .await
                    }
                    3 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.set_margin()", object.id);
                        self.set_margin(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    4 => {
                        tracing::debug!(
                            "zwlr_layer_surface_v1#{}.set_keyboard_interactivity()",
                            object.id
                        );
                        self.set_keyboard_interactivity(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    5 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.get_popup()", object.id);
                        self.get_popup(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    6 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.ack_configure()", object.id);
                        self.ack_configure(object, client, message.uint()?).await
                    }
                    7 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    8 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.set_layer()", object.id);
                        self.set_layer(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    9 => {
                        tracing::debug!("zwlr_layer_surface_v1#{}.set_exclusive_edge()", object.id);
                        self.set_exclusive_edge(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Sets the size of the surface in surface-local coordinates. The"#]
            #[doc = r#"compositor will display the surface centered with respect to its"#]
            #[doc = r#"anchors."#]
            #[doc = r#""#]
            #[doc = r#"If you pass 0 for either value, the compositor will assign it and"#]
            #[doc = r#"inform you of the assignment in the configure event. You must set your"#]
            #[doc = r#"anchor to opposite edges in the dimensions you omit; not doing so is a"#]
            #[doc = r#"protocol error. Both values are 0 by default."#]
            #[doc = r#""#]
            #[doc = r#"Size is double-buffered, see wl_surface.commit."#]
            async fn set_size(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_size: u32,
                set_size: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Requests that the compositor anchor the surface to the specified edges"#]
            #[doc = r#"and corners. If two orthogonal edges are specified (e.g. 'top' and"#]
            #[doc = r#"'left'), then the anchor point will be the intersection of the edges"#]
            #[doc = r#"(e.g. the top left corner of the output); otherwise the anchor point"#]
            #[doc = r#"will be centered on that edge, or in the center if none is specified."#]
            #[doc = r#""#]
            #[doc = r#"Anchor is double-buffered, see wl_surface.commit."#]
            async fn set_anchor(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_anchor: Anchor,
            ) -> crate::server::Result<()>;
            #[doc = r#"Requests that the compositor avoids occluding an area with other"#]
            #[doc = r#"surfaces. The compositor's use of this information is"#]
            #[doc = r#"implementation-dependent - do not assume that this region will not"#]
            #[doc = r#"actually be occluded."#]
            #[doc = r#""#]
            #[doc = r#"A positive value is only meaningful if the surface is anchored to one"#]
            #[doc = r#"edge or an edge and both perpendicular edges. If the surface is not"#]
            #[doc = r#"anchored, anchored to only two perpendicular edges (a corner), anchored"#]
            #[doc = r#"to only two parallel edges or anchored to all edges, a positive value"#]
            #[doc = r#"will be treated the same as zero."#]
            #[doc = r#""#]
            #[doc = r#"A positive zone is the distance from the edge in surface-local"#]
            #[doc = r#"coordinates to consider exclusive."#]
            #[doc = r#""#]
            #[doc = r#"Surfaces that do not wish to have an exclusive zone may instead specify"#]
            #[doc = r#"how they should interact with surfaces that do. If set to zero, the"#]
            #[doc = r#"surface indicates that it would like to be moved to avoid occluding"#]
            #[doc = r#"surfaces with a positive exclusive zone. If set to -1, the surface"#]
            #[doc = r#"indicates that it would not like to be moved to accommodate for other"#]
            #[doc = r#"surfaces, and the compositor should extend it all the way to the edges"#]
            #[doc = r#"it is anchored to."#]
            #[doc = r#""#]
            #[doc = r#"For example, a panel might set its exclusive zone to 10, so that"#]
            #[doc = r#"maximized shell surfaces are not shown on top of it. A notification"#]
            #[doc = r#"might set its exclusive zone to 0, so that it is moved to avoid"#]
            #[doc = r#"occluding the panel, but shell surfaces are shown underneath it. A"#]
            #[doc = r#"wallpaper or lock screen might set their exclusive zone to -1, so that"#]
            #[doc = r#"they stretch below or over the panel."#]
            #[doc = r#""#]
            #[doc = r#"The default value is 0."#]
            #[doc = r#""#]
            #[doc = r#"Exclusive zone is double-buffered, see wl_surface.commit."#]
            async fn set_exclusive_zone(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_exclusive_zone: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Requests that the surface be placed some distance away from the anchor"#]
            #[doc = r#"point on the output, in surface-local coordinates. Setting this value"#]
            #[doc = r#"for edges you are not anchored to has no effect."#]
            #[doc = r#""#]
            #[doc = r#"The exclusive zone includes the margin."#]
            #[doc = r#""#]
            #[doc = r#"Margin is double-buffered, see wl_surface.commit."#]
            async fn set_margin(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_margin: i32,
                set_margin: i32,
                set_margin: i32,
                set_margin: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Set how keyboard events are delivered to this surface. By default,"#]
            #[doc = r#"layer shell surfaces do not receive keyboard events; this request can"#]
            #[doc = r#"be used to change this."#]
            #[doc = r#""#]
            #[doc = r#"This setting is inherited by child surfaces set by the get_popup"#]
            #[doc = r#"request."#]
            #[doc = r#""#]
            #[doc = r#"Layer surfaces receive pointer, touch, and tablet events normally. If"#]
            #[doc = r#"you do not want to receive them, set the input region on your surface"#]
            #[doc = r#"to an empty region."#]
            #[doc = r#""#]
            #[doc = r#"Keyboard interactivity is double-buffered, see wl_surface.commit."#]
            async fn set_keyboard_interactivity(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_keyboard_interactivity: KeyboardInteractivity,
            ) -> crate::server::Result<()>;
            #[doc = r#"This assigns an xdg_popup's parent to this layer_surface.  This popup"#]
            #[doc = r#"should have been created via xdg_surface::get_popup with the parent set"#]
            #[doc = r#"to NULL, and this request must be invoked before committing the popup's"#]
            #[doc = r#"initial state."#]
            #[doc = r#""#]
            #[doc = r#"See the documentation of xdg_popup for more details about what an"#]
            #[doc = r#"xdg_popup is and how it is used."#]
            async fn get_popup(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_popup: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"When a configure event is received, if a client commits the"#]
            #[doc = r#"surface in response to the configure event, then the client"#]
            #[doc = r#"must make an ack_configure request sometime before the commit"#]
            #[doc = r#"request, passing along the serial of the configure event."#]
            #[doc = r#""#]
            #[doc = r#"If the client receives multiple configure events before it"#]
            #[doc = r#"can respond to one, it only has to ack the last configure event."#]
            #[doc = r#""#]
            #[doc = r#"A client is not required to commit immediately after sending"#]
            #[doc = r#"an ack_configure request - it may even ack_configure several times"#]
            #[doc = r#"before its next surface commit."#]
            #[doc = r#""#]
            #[doc = r#"A client may send multiple ack_configure requests before committing, but"#]
            #[doc = r#"only the last request sent before a commit indicates which configure"#]
            #[doc = r#"event the client really is responding to."#]
            async fn ack_configure(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                ack_configure: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request destroys the layer surface."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Change the layer that the surface is rendered on."#]
            #[doc = r#""#]
            #[doc = r#"Layer is double-buffered, see wl_surface.commit."#]
            async fn set_layer(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_layer: super::super::wlr_layer_shell_unstable_v1::zwlr_layer_shell_v1::Layer,
            ) -> crate::server::Result<()>;
            #[doc = r#"Requests an edge for the exclusive zone to apply. The exclusive"#]
            #[doc = r#"edge will be automatically deduced from anchor points when possible,"#]
            #[doc = r#"but when the surface is anchored to a corner, it will be necessary"#]
            #[doc = r#"to set it explicitly to disambiguate, as it is not possible to deduce"#]
            #[doc = r#"which one of the two corner edges should be used."#]
            #[doc = r#""#]
            #[doc = r#"The edge must be one the surface is anchored to, otherwise the"#]
            #[doc = r#"invalid_exclusive_edge protocol error will be raised."#]
            async fn set_exclusive_edge(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_exclusive_edge: Anchor,
            ) -> crate::server::Result<()>;
            #[doc = r#"The configure event asks the client to resize its surface."#]
            #[doc = r#""#]
            #[doc = r#"Clients should arrange their surface for the new states, and then send"#]
            #[doc = r#"an ack_configure request with the serial sent in this configure event at"#]
            #[doc = r#"some point before committing the new surface."#]
            #[doc = r#""#]
            #[doc = r#"The client is free to dismiss all but the last configure event it"#]
            #[doc = r#"received."#]
            #[doc = r#""#]
            #[doc = r#"The width and height arguments specify the size of the window in"#]
            #[doc = r#"surface-local coordinates."#]
            #[doc = r#""#]
            #[doc = r#"The size is a hint, in the sense that the client is free to ignore it if"#]
            #[doc = r#"it doesn't resize, pick a smaller size (to satisfy aspect ratio or"#]
            #[doc = r#"resize in steps of NxM pixels). If the client picks a smaller size and"#]
            #[doc = r#"is anchored to two opposite anchors (e.g. 'top' and 'bottom'), the"#]
            #[doc = r#"surface will be centered on this axis."#]
            #[doc = r#""#]
            #[doc = r#"If the width or height arguments are zero, it means the client should"#]
            #[doc = r#"decide its own window dimension."#]
            async fn configure(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
                width: u32,
                height: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_layer_surface_v1#{}.configure()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(serial)
                    .put_uint(width)
                    .put_uint(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"The closed event is sent by the compositor when the surface will no"#]
            #[doc = r#"longer be shown. The output may have been destroyed or the user may"#]
            #[doc = r#"have asked for it to be removed. Further changes to the surface will be"#]
            #[doc = r#"ignored. The client should destroy the resource after receiving this"#]
            #[doc = r#"event, and create a new surface if they so choose."#]
            async fn closed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_layer_surface_v1#{}.closed()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = r#"This protocol exposes interfaces to obtain and modify output device"#]
#[doc = r#"configuration."#]
#[doc = r#""#]
#[doc = r#"Warning! The protocol described in this file is experimental and"#]
#[doc = r#"backward incompatible changes may be made. Backward compatible changes"#]
#[doc = r#"may be added together with the corresponding interface version bump."#]
#[doc = r#"Backward incompatible changes are done by bumping the version number in"#]
#[doc = r#"the protocol and interface names and resetting the interface version."#]
#[doc = r#"Once the protocol is to be declared stable, the 'z' prefix and the"#]
#[doc = r#"version number in the protocol and interface names are removed and the"#]
#[doc = r#"interface version number is reset."#]
pub mod wlr_output_management_unstable_v1 {
    pub mod zwlr_output_manager_v1 {
        #[doc = r#"This interface is a manager that allows reading and writing the current"#]
        #[doc = r#"output device configuration."#]
        #[doc = r#""#]
        #[doc = r#"Output devices that display pixels (e.g. a physical monitor or a virtual"#]
        #[doc = r#"output in a window) are represented as heads. Heads cannot be created nor"#]
        #[doc = r#"destroyed by the client, but they can be enabled or disabled and their"#]
        #[doc = r#"properties can be changed. Each head may have one or more available modes."#]
        #[doc = r#""#]
        #[doc = r#"Whenever a head appears (e.g. a monitor is plugged in), it will be"#]
        #[doc = r#"advertised via the head event. Immediately after the output manager is"#]
        #[doc = r#"bound, all current heads are advertised."#]
        #[doc = r#""#]
        #[doc = r#"Whenever a head's properties change, the relevant wlr_output_head events"#]
        #[doc = r#"will be sent. Not all head properties will be sent: only properties that"#]
        #[doc = r#"have changed need to."#]
        #[doc = r#""#]
        #[doc = r#"Whenever a head disappears (e.g. a monitor is unplugged), a"#]
        #[doc = r#"wlr_output_head.finished event will be sent."#]
        #[doc = r#""#]
        #[doc = r#"After one or more heads appear, change or disappear, the done event will"#]
        #[doc = r#"be sent. It carries a serial which can be used in a create_configuration"#]
        #[doc = r#"request to update heads properties."#]
        #[doc = r#""#]
        #[doc = r#"The information obtained from this protocol should only be used for output"#]
        #[doc = r#"configuration purposes. This protocol is not designed to be a generic"#]
        #[doc = r#"output property advertisement protocol for regular clients. Instead,"#]
        #[doc = r#"protocols such as xdg-output should be used."#]
        pub trait ZwlrOutputManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_output_manager_v1";
            const VERSION: u32 = 4;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "zwlr_output_manager_v1#{}.create_configuration()",
                            object.id
                        );
                        self.create_configuration(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.uint()?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwlr_output_manager_v1#{}.stop()", object.id);
                        self.stop(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Create a new output configuration object. This allows to update head"#]
            #[doc = r#"properties."#]
            async fn create_configuration(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create_configuration: crate::wire::ObjectId,
                create_configuration: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"Indicates the client no longer wishes to receive events for output"#]
            #[doc = r#"configuration changes. However the compositor may emit further events,"#]
            #[doc = r#"until the finished event is emitted."#]
            #[doc = r#""#]
            #[doc = r#"The client must not send any more requests after this one."#]
            async fn stop(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event introduces a new head. This happens whenever a new head"#]
            #[doc = r#"appears (e.g. a monitor is plugged in) or after the output manager is"#]
            #[doc = r#"bound."#]
            async fn head(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                head: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_manager_v1#{}.head()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(head))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent after all information has been sent after binding to"#]
            #[doc = r#"the output manager object and after any subsequent changes. This applies"#]
            #[doc = r#"to child head and mode objects as well. In other words, this event is"#]
            #[doc = r#"sent whenever a head or mode is created or destroyed and whenever one of"#]
            #[doc = r#"their properties has been changed. Not all state is re-sent each time"#]
            #[doc = r#"the current configuration changes: only the actual changes are sent."#]
            #[doc = r#""#]
            #[doc = r#"This allows changes to the output configuration to be seen as atomic,"#]
            #[doc = r#"even if they happen via multiple events."#]
            #[doc = r#""#]
            #[doc = r#"A serial is sent to be used in a future create_configuration request."#]
            async fn done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_manager_v1#{}.done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_uint(serial).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event indicates that the compositor is done sending manager events."#]
            #[doc = r#"The compositor will destroy the object immediately after sending this"#]
            #[doc = r#"event, so it will become invalid and the client should release any"#]
            #[doc = r#"resources associated with it."#]
            async fn finished(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_manager_v1#{}.finished()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwlr_output_head_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum AdaptiveSyncState {
            #[doc = r#"Adaptive sync is disabled"#]
            Disabled = 0,
            #[doc = r#"Adaptive sync is enabled"#]
            Enabled = 1,
        }
        impl TryFrom<u32> for AdaptiveSyncState {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Disabled),
                    1 => Ok(Self::Enabled),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"A head is an output device. The difference between a wl_output object and"#]
        #[doc = r#"a head is that heads are advertised even if they are turned off. A head"#]
        #[doc = r#"object only advertises properties and cannot be used directly to change"#]
        #[doc = r#"them."#]
        #[doc = r#""#]
        #[doc = r#"A head has some read-only properties: modes, name, description and"#]
        #[doc = r#"physical_size. These cannot be changed by clients."#]
        #[doc = r#""#]
        #[doc = r#"Other properties can be updated via a wlr_output_configuration object."#]
        #[doc = r#""#]
        #[doc = r#"Properties sent via this interface are applied atomically via the"#]
        #[doc = r#"wlr_output_manager.done event. No guarantees are made regarding the order"#]
        #[doc = r#"in which properties are sent."#]
        pub trait ZwlrOutputHeadV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_output_head_v1";
            const VERSION: u32 = 4;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwlr_output_head_v1#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"This request indicates that the client will no longer use this head"#]
            #[doc = r#"object."#]
            async fn release(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event describes the head name."#]
            #[doc = r#""#]
            #[doc = r#"The naming convention is compositor defined, but limited to alphanumeric"#]
            #[doc = r#"characters and dashes (-). Each name is unique among all wlr_output_head"#]
            #[doc = r#"objects, but if a wlr_output_head object is destroyed the same name may"#]
            #[doc = r#"be reused later. The names will also remain consistent across sessions"#]
            #[doc = r#"with the same hardware and software configuration."#]
            #[doc = r#""#]
            #[doc = r#"Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do"#]
            #[doc = r#"not assume that the name is a reflection of an underlying DRM"#]
            #[doc = r#"connector, X11 connection, etc."#]
            #[doc = r#""#]
            #[doc = r#"If the compositor implements the xdg-output protocol and this head is"#]
            #[doc = r#"enabled, the xdg_output.name event must report the same name."#]
            #[doc = r#""#]
            #[doc = r#"The name event is sent after a wlr_output_head object is created. This"#]
            #[doc = r#"event is only sent once per object, and the name does not change over"#]
            #[doc = r#"the lifetime of the wlr_output_head object."#]
            async fn name(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                name: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.name()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(name))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event describes a human-readable description of the head."#]
            #[doc = r#""#]
            #[doc = r#"The description is a UTF-8 string with no convention defined for its"#]
            #[doc = r#"contents. Examples might include 'Foocorp 11" Display' or 'Virtual X11"#]
            #[doc = r#"output via :1'. However, do not assume that the name is a reflection of"#]
            #[doc = r#"the make, model, serial of the underlying DRM connector or the display"#]
            #[doc = r#"name of the underlying X11 connection, etc."#]
            #[doc = r#""#]
            #[doc = r#"If the compositor implements xdg-output and this head is enabled,"#]
            #[doc = r#"the xdg_output.description must report the same description."#]
            #[doc = r#""#]
            #[doc = r#"The description event is sent after a wlr_output_head object is created."#]
            #[doc = r#"This event is only sent once per object, and the description does not"#]
            #[doc = r#"change over the lifetime of the wlr_output_head object."#]
            async fn description(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                description: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.description()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(description))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event describes the physical size of the head. This event is only"#]
            #[doc = r#"sent if the head has a physical size (e.g. is not a projector or a"#]
            #[doc = r#"virtual device)."#]
            async fn physical_size(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.physical_size()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event introduces a mode for this head. It is sent once per"#]
            #[doc = r#"supported mode."#]
            async fn mode(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                mode: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.mode()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(mode))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event describes whether the head is enabled. A disabled head is not"#]
            #[doc = r#"mapped to a region of the global compositor space."#]
            #[doc = r#""#]
            #[doc = r#"When a head is disabled, some properties (current_mode, position,"#]
            #[doc = r#"transform and scale) are irrelevant."#]
            async fn enabled(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                enabled: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.enabled()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(enabled).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event describes the mode currently in use for this head. It is only"#]
            #[doc = r#"sent if the output is enabled."#]
            async fn current_mode(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                mode: crate::wire::ObjectId,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.current_mode()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_object(Some(mode))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 5, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This events describes the position of the head in the global compositor"#]
            #[doc = r#"space. It is only sent if the output is enabled."#]
            async fn position(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: i32,
                y: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.position()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(x)
                    .put_int(y)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 6, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event describes the transformation currently applied to the head."#]
            #[doc = r#"It is only sent if the output is enabled."#]
            async fn transform(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                transform: super::super::wayland::wl_output::Transform,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.transform()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(transform as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 7, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This events describes the scale of the head in the global compositor"#]
            #[doc = r#"space. It is only sent if the output is enabled."#]
            async fn scale(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                scale: crate::wire::Fixed,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.scale()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_fixed(scale).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 8, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event indicates that the head is no longer available. The head"#]
            #[doc = r#"object becomes inert. Clients should send a destroy request and release"#]
            #[doc = r#"any resources associated with it."#]
            async fn finished(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.finished()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 9, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event describes the manufacturer of the head."#]
            #[doc = r#""#]
            #[doc = r#"This must report the same make as the wl_output interface does in its"#]
            #[doc = r#"geometry event."#]
            #[doc = r#""#]
            #[doc = r#"Together with the model and serial_number events the purpose is to"#]
            #[doc = r#"allow clients to recognize heads from previous sessions and for example"#]
            #[doc = r#"load head-specific configurations back."#]
            #[doc = r#""#]
            #[doc = r#"It is not guaranteed this event will be ever sent. A reason for that"#]
            #[doc = r#"can be that the compositor does not have information about the make of"#]
            #[doc = r#"the head or the definition of a make is not sensible in the current"#]
            #[doc = r#"setup, for example in a virtual session. Clients can still try to"#]
            #[doc = r#"identify the head by available information from other events but should"#]
            #[doc = r#"be aware that there is an increased risk of false positives."#]
            #[doc = r#""#]
            #[doc = r#"It is not recommended to display the make string in UI to users. For"#]
            #[doc = r#"that the string provided by the description event should be preferred."#]
            async fn make(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                make: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.make()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(make))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 10, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event describes the model of the head."#]
            #[doc = r#""#]
            #[doc = r#"This must report the same model as the wl_output interface does in its"#]
            #[doc = r#"geometry event."#]
            #[doc = r#""#]
            #[doc = r#"Together with the make and serial_number events the purpose is to"#]
            #[doc = r#"allow clients to recognize heads from previous sessions and for example"#]
            #[doc = r#"load head-specific configurations back."#]
            #[doc = r#""#]
            #[doc = r#"It is not guaranteed this event will be ever sent. A reason for that"#]
            #[doc = r#"can be that the compositor does not have information about the model of"#]
            #[doc = r#"the head or the definition of a model is not sensible in the current"#]
            #[doc = r#"setup, for example in a virtual session. Clients can still try to"#]
            #[doc = r#"identify the head by available information from other events but should"#]
            #[doc = r#"be aware that there is an increased risk of false positives."#]
            #[doc = r#""#]
            #[doc = r#"It is not recommended to display the model string in UI to users. For"#]
            #[doc = r#"that the string provided by the description event should be preferred."#]
            async fn model(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                model: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.model()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(model))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 11, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event describes the serial number of the head."#]
            #[doc = r#""#]
            #[doc = r#"Together with the make and model events the purpose is to allow clients"#]
            #[doc = r#"to recognize heads from previous sessions and for example load head-"#]
            #[doc = r#"specific configurations back."#]
            #[doc = r#""#]
            #[doc = r#"It is not guaranteed this event will be ever sent. A reason for that"#]
            #[doc = r#"can be that the compositor does not have information about the serial"#]
            #[doc = r#"number of the head or the definition of a serial number is not sensible"#]
            #[doc = r#"in the current setup. Clients can still try to identify the head by"#]
            #[doc = r#"available information from other events but should be aware that there"#]
            #[doc = r#"is an increased risk of false positives."#]
            #[doc = r#""#]
            #[doc = r#"It is not recommended to display the serial_number string in UI to"#]
            #[doc = r#"users. For that the string provided by the description event should be"#]
            #[doc = r#"preferred."#]
            async fn serial_number(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                serial_number: String,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.serial_number()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_string(Some(serial_number))
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 12, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event describes whether adaptive sync is currently enabled for"#]
            #[doc = r#"the head or not. Adaptive sync is also known as Variable Refresh"#]
            #[doc = r#"Rate or VRR."#]
            async fn adaptive_sync(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                state: AdaptiveSyncState,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_head_v1#{}.adaptive_sync()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(state as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 13, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwlr_output_mode_v1 {
        #[doc = r#"This object describes an output mode."#]
        #[doc = r#""#]
        #[doc = r#"Some heads don't support output modes, in which case modes won't be"#]
        #[doc = r#"advertised."#]
        #[doc = r#""#]
        #[doc = r#"Properties sent via this interface are applied atomically via the"#]
        #[doc = r#"wlr_output_manager.done event. No guarantees are made regarding the order"#]
        #[doc = r#"in which properties are sent."#]
        pub trait ZwlrOutputModeV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_output_mode_v1";
            const VERSION: u32 = 3;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwlr_output_mode_v1#{}.release()", object.id);
                        self.release(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"This request indicates that the client will no longer use this mode"#]
            #[doc = r#"object."#]
            async fn release(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"This event describes the mode size. The size is given in physical"#]
            #[doc = r#"hardware units of the output device. This is not necessarily the same as"#]
            #[doc = r#"the output size in the global compositor space. For instance, the output"#]
            #[doc = r#"may be scaled or transformed."#]
            async fn size(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                width: i32,
                height: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_mode_v1#{}.size()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_int(width)
                    .put_int(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event describes the mode's fixed vertical refresh rate. It is only"#]
            #[doc = r#"sent if the mode has a fixed refresh rate."#]
            async fn refresh(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                refresh: i32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_mode_v1#{}.refresh()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().put_int(refresh).build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event advertises this mode as preferred."#]
            async fn preferred(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_mode_v1#{}.preferred()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event indicates that the mode is no longer available. The mode"#]
            #[doc = r#"object becomes inert. Clients should send a destroy request and release"#]
            #[doc = r#"any resources associated with it."#]
            async fn finished(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_mode_v1#{}.finished()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwlr_output_configuration_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Head has been configured twice"#]
            AlreadyConfiguredHead = 1,
            #[doc = r#"Head has not been configured"#]
            UnconfiguredHead = 2,
            #[doc = r#"Request sent after configuration has been applied or tested"#]
            AlreadyUsed = 3,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::AlreadyConfiguredHead),
                    2 => Ok(Self::UnconfiguredHead),
                    3 => Ok(Self::AlreadyUsed),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"This object is used by the client to describe a full output configuration."#]
        #[doc = r#""#]
        #[doc = r#"First, the client needs to setup the output configuration. Each head can"#]
        #[doc = r#"be either enabled (and configured) or disabled. It is a protocol error to"#]
        #[doc = r#"send two enable_head or disable_head requests with the same head. It is a"#]
        #[doc = r#"protocol error to omit a head in a configuration."#]
        #[doc = r#""#]
        #[doc = r#"Then, the client can apply or test the configuration. The compositor will"#]
        #[doc = r#"then reply with a succeeded, failed or cancelled event. Finally the client"#]
        #[doc = r#"should destroy the configuration object."#]
        pub trait ZwlrOutputConfigurationV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_output_configuration_v1";
            const VERSION: u32 = 4;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwlr_output_configuration_v1#{}.enable_head()", object.id);
                        self.enable_head(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!(
                            "zwlr_output_configuration_v1#{}.disable_head()",
                            object.id
                        );
                        self.disable_head(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("zwlr_output_configuration_v1#{}.apply()", object.id);
                        self.apply(object, client).await
                    }
                    3 => {
                        tracing::debug!("zwlr_output_configuration_v1#{}.test()", object.id);
                        self.test(object, client).await
                    }
                    4 => {
                        tracing::debug!("zwlr_output_configuration_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Enable a head. This request creates a head configuration object that can"#]
            #[doc = r#"be used to change the head's properties."#]
            async fn enable_head(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                enable_head: crate::wire::ObjectId,
                enable_head: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Disable a head."#]
            async fn disable_head(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                disable_head: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Apply the new output configuration."#]
            #[doc = r#""#]
            #[doc = r#"In case the configuration is successfully applied, there is no guarantee"#]
            #[doc = r#"that the new output state matches completely the requested"#]
            #[doc = r#"configuration. For instance, a compositor might round the scale if it"#]
            #[doc = r#"doesn't support fractional scaling."#]
            #[doc = r#""#]
            #[doc = r#"After this request has been sent, the compositor must respond with an"#]
            #[doc = r#"succeeded, failed or cancelled event. Sending a request that isn't the"#]
            #[doc = r#"destructor is a protocol error."#]
            async fn apply(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Test the new output configuration. The configuration won't be applied,"#]
            #[doc = r#"but will only be validated."#]
            #[doc = r#""#]
            #[doc = r#"Even if the compositor succeeds to test a configuration, applying it may"#]
            #[doc = r#"fail."#]
            #[doc = r#""#]
            #[doc = r#"After this request has been sent, the compositor must respond with an"#]
            #[doc = r#"succeeded, failed or cancelled event. Sending a request that isn't the"#]
            #[doc = r#"destructor is a protocol error."#]
            async fn test(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Using this request a client can tell the compositor that it is not going"#]
            #[doc = r#"to use the configuration object anymore. Any changes to the outputs"#]
            #[doc = r#"that have not been applied will be discarded."#]
            #[doc = r#""#]
            #[doc = r#"This request also destroys wlr_output_configuration_head objects created"#]
            #[doc = r#"via this object."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Sent after the compositor has successfully applied the changes or"#]
            #[doc = r#"tested them."#]
            #[doc = r#""#]
            #[doc = r#"Upon receiving this event, the client should destroy this object."#]
            #[doc = r#""#]
            #[doc = r#"If the current configuration has changed, events to describe the changes"#]
            #[doc = r#"will be sent followed by a wlr_output_manager.done event."#]
            async fn succeeded(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_configuration_v1#{}.succeeded()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent if the compositor rejects the changes or failed to apply them. The"#]
            #[doc = r#"compositor should revert any changes made by the apply request that"#]
            #[doc = r#"triggered this event."#]
            #[doc = r#""#]
            #[doc = r#"Upon receiving this event, the client should destroy this object."#]
            async fn failed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_configuration_v1#{}.failed()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Sent if the compositor cancels the configuration because the state of an"#]
            #[doc = r#"output changed and the client has outdated information (e.g. after an"#]
            #[doc = r#"output has been hotplugged)."#]
            #[doc = r#""#]
            #[doc = r#"The client can create a new configuration with a newer serial and try"#]
            #[doc = r#"again."#]
            #[doc = r#""#]
            #[doc = r#"Upon receiving this event, the client should destroy this object."#]
            async fn cancelled(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_configuration_v1#{}.cancelled()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
    pub mod zwlr_output_configuration_head_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Property has already been set"#]
            AlreadySet = 1,
            #[doc = r#"Mode doesn't belong to head"#]
            InvalidMode = 2,
            #[doc = r#"Mode is invalid"#]
            InvalidCustomMode = 3,
            #[doc = r#"Transform value outside enum"#]
            InvalidTransform = 4,
            #[doc = r#"Scale negative or zero"#]
            InvalidScale = 5,
            #[doc = r#"Invalid enum value used in the set_adaptive_sync request"#]
            InvalidAdaptiveSyncState = 6,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::AlreadySet),
                    2 => Ok(Self::InvalidMode),
                    3 => Ok(Self::InvalidCustomMode),
                    4 => Ok(Self::InvalidTransform),
                    5 => Ok(Self::InvalidScale),
                    6 => Ok(Self::InvalidAdaptiveSyncState),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"This object is used by the client to update a single head's configuration."#]
        #[doc = r#""#]
        #[doc = r#"It is a protocol error to set the same property twice."#]
        pub trait ZwlrOutputConfigurationHeadV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_output_configuration_head_v1";
            const VERSION: u32 = 4;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "zwlr_output_configuration_head_v1#{}.set_mode()",
                            object.id
                        );
                        self.set_mode(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!(
                            "zwlr_output_configuration_head_v1#{}.set_custom_mode()",
                            object.id
                        );
                        self.set_custom_mode(
                            object,
                            client,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!(
                            "zwlr_output_configuration_head_v1#{}.set_position()",
                            object.id
                        );
                        self.set_position(object, client, message.int()?, message.int()?)
                            .await
                    }
                    3 => {
                        tracing::debug!(
                            "zwlr_output_configuration_head_v1#{}.set_transform()",
                            object.id
                        );
                        self.set_transform(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    4 => {
                        tracing::debug!(
                            "zwlr_output_configuration_head_v1#{}.set_scale()",
                            object.id
                        );
                        self.set_scale(object, client, message.fixed()?).await
                    }
                    5 => {
                        tracing::debug!(
                            "zwlr_output_configuration_head_v1#{}.set_adaptive_sync()",
                            object.id
                        );
                        self.set_adaptive_sync(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"This request sets the head's mode."#]
            async fn set_mode(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_mode: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request assigns a custom mode to the head. The size is given in"#]
            #[doc = r#"physical hardware units of the output device. If set to zero, the"#]
            #[doc = r#"refresh rate is unspecified."#]
            #[doc = r#""#]
            #[doc = r#"It is a protocol error to set both a mode and a custom mode."#]
            async fn set_custom_mode(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_custom_mode: i32,
                set_custom_mode: i32,
                set_custom_mode: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request sets the head's position in the global compositor space."#]
            async fn set_position(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_position: i32,
                set_position: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request sets the head's transform."#]
            async fn set_transform(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_transform: super::super::wayland::wl_output::Transform,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request sets the head's scale."#]
            async fn set_scale(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_scale: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            #[doc = r#"This request enables/disables adaptive sync. Adaptive sync is also"#]
            #[doc = r#"known as Variable Refresh Rate or VRR."#]
            async fn set_adaptive_sync(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_adaptive_sync: super::super::wlr_output_management_unstable_v1::zwlr_output_head_v1::AdaptiveSyncState,
            ) -> crate::server::Result<()>;
        }
    }
}
#[doc = r#"This protocol allows clients to control power management modes"#]
#[doc = r#"of outputs that are currently part of the compositor space. The"#]
#[doc = r#"intent is to allow special clients like desktop shells to power"#]
#[doc = r#"down outputs when the system is idle."#]
#[doc = r#""#]
#[doc = r#"To modify outputs not currently part of the compositor space see"#]
#[doc = r#"wlr-output-management."#]
#[doc = r#""#]
#[doc = r#"Warning! The protocol described in this file is experimental and"#]
#[doc = r#"backward incompatible changes may be made. Backward compatible changes"#]
#[doc = r#"may be added together with the corresponding interface version bump."#]
#[doc = r#"Backward incompatible changes are done by bumping the version number in"#]
#[doc = r#"the protocol and interface names and resetting the interface version."#]
#[doc = r#"Once the protocol is to be declared stable, the 'z' prefix and the"#]
#[doc = r#"version number in the protocol and interface names are removed and the"#]
#[doc = r#"interface version number is reset."#]
pub mod wlr_output_power_management_unstable_v1 {
    pub mod zwlr_output_power_manager_v1 {
        #[doc = r#"This interface is a manager that allows creating per-output power"#]
        #[doc = r#"management mode controls."#]
        pub trait ZwlrOutputPowerManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_output_power_manager_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "zwlr_output_power_manager_v1#{}.get_output_power()",
                            object.id
                        );
                        self.get_output_power(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwlr_output_power_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Create an output power management mode control that can be used to"#]
            #[doc = r#"adjust the power management mode for a given output."#]
            async fn get_output_power(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                get_output_power: crate::wire::ObjectId,
                get_output_power: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"All objects created by the manager will still remain valid, until their"#]
            #[doc = r#"appropriate destroy request has been called."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwlr_output_power_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Mode {
            #[doc = r#"Output is turned off."#]
            Off = 0,
            #[doc = r#"Output is turned on, no power saving"#]
            On = 1,
        }
        impl TryFrom<u32> for Mode {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::Off),
                    1 => Ok(Self::On),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Nonexistent power save mode"#]
            InvalidMode = 1,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    1 => Ok(Self::InvalidMode),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"This object offers requests to set the power management mode of"#]
        #[doc = r#"an output."#]
        pub trait ZwlrOutputPowerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_output_power_v1";
            const VERSION: u32 = 1;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwlr_output_power_v1#{}.set_mode()", object.id);
                        self.set_mode(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    1 => {
                        tracing::debug!("zwlr_output_power_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Set an output's power save mode to the given mode. The mode change"#]
            #[doc = r#"is effective immediately. If the output does not support the given"#]
            #[doc = r#"mode a failed event is sent."#]
            async fn set_mode(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                set_mode: Mode,
            ) -> crate::server::Result<()>;
            #[doc = r#"Destroys the output power management mode control object."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Report the power management mode change of an output."#]
            #[doc = r#""#]
            #[doc = r#"The mode event is sent after an output changed its power"#]
            #[doc = r#"management mode. The reason can be a client using set_mode or the"#]
            #[doc = r#"compositor deciding to change an output's mode."#]
            #[doc = r#"This event is also sent immediately when the object is created"#]
            #[doc = r#"so the client is informed about the current power management mode."#]
            async fn mode(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                mode: Mode,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_power_v1#{}.mode()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(mode as u32)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event indicates that the output power management mode control"#]
            #[doc = r#"is no longer valid. This can happen for a number of reasons,"#]
            #[doc = r#"including:"#]
            #[doc = r#"- The output doesn't support power management"#]
            #[doc = r#"- Another client already has exclusive power management mode control"#]
            #[doc = r#"for this output"#]
            #[doc = r#"- The output disappeared"#]
            #[doc = r#""#]
            #[doc = r#"Upon receiving this event, the client should destroy this object."#]
            async fn failed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_output_power_v1#{}.failed()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
#[doc = r#"This protocol allows clients to ask the compositor to copy part of the"#]
#[doc = r#"screen content to a client buffer."#]
#[doc = r#""#]
#[doc = r#"Warning! The protocol described in this file is experimental and"#]
#[doc = r#"backward incompatible changes may be made. Backward compatible changes"#]
#[doc = r#"may be added together with the corresponding interface version bump."#]
#[doc = r#"Backward incompatible changes are done by bumping the version number in"#]
#[doc = r#"the protocol and interface names and resetting the interface version."#]
#[doc = r#"Once the protocol is to be declared stable, the 'z' prefix and the"#]
#[doc = r#"version number in the protocol and interface names are removed and the"#]
#[doc = r#"interface version number is reset."#]
pub mod wlr_screencopy_unstable_v1 {
    pub mod zwlr_screencopy_manager_v1 {
        #[doc = r#"This object is a manager which offers requests to start capturing from a"#]
        #[doc = r#"source."#]
        pub trait ZwlrScreencopyManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_screencopy_manager_v1";
            const VERSION: u32 = 3;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "zwlr_screencopy_manager_v1#{}.capture_output()",
                            object.id
                        );
                        self.capture_output(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!(
                            "zwlr_screencopy_manager_v1#{}.capture_output_region()",
                            object.id
                        );
                        self.capture_output_region(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                            message.int()?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("zwlr_screencopy_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Capture the next frame of an entire output."#]
            async fn capture_output(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                capture_output: crate::wire::ObjectId,
                capture_output: i32,
                capture_output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Capture the next frame of an output's region."#]
            #[doc = r#""#]
            #[doc = r#"The region is given in output logical coordinates, see"#]
            #[doc = r#"xdg_output.logical_size. The region will be clipped to the output's"#]
            #[doc = r#"extents."#]
            async fn capture_output_region(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                capture_output_region: crate::wire::ObjectId,
                capture_output_region: i32,
                capture_output_region: crate::wire::ObjectId,
                capture_output_region: i32,
                capture_output_region: i32,
                capture_output_region: i32,
                capture_output_region: i32,
            ) -> crate::server::Result<()>;
            #[doc = r#"All objects created by the manager will still remain valid, until their"#]
            #[doc = r#"appropriate destroy request has been called."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwlr_screencopy_frame_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"The object has already been used to copy a wl_buffer"#]
            AlreadyUsed = 0,
            #[doc = r#"Buffer attributes are invalid"#]
            InvalidBuffer = 1,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::AlreadyUsed),
                    1 => Ok(Self::InvalidBuffer),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        bitflags::bitflags! {
                                    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
                                    pub struct Flags: u32 {#[doc = r#"Contents are y-inverted"#]
        const YInvert = 1;}
                                }
        impl TryFrom<u32> for Flags {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                Self::from_bits(v).ok_or(crate::wire::DecodeError::MalformedPayload)
            }
        }
        #[doc = r#"This object represents a single frame."#]
        #[doc = r#""#]
        #[doc = r#"When created, a series of buffer events will be sent, each representing a"#]
        #[doc = r#"supported buffer type. The "buffer_done" event is sent afterwards to"#]
        #[doc = r#"indicate that all supported buffer types have been enumerated. The client"#]
        #[doc = r#"will then be able to send a "copy" request. If the capture is successful,"#]
        #[doc = r#"the compositor will send a "flags" followed by a "ready" event."#]
        #[doc = r#""#]
        #[doc = r#"For objects version 2 or lower, wl_shm buffers are always supported, ie."#]
        #[doc = r#"the "buffer" event is guaranteed to be sent."#]
        #[doc = r#""#]
        #[doc = r#"If the capture failed, the "failed" event is sent. This can happen anytime"#]
        #[doc = r#"before the "ready" event."#]
        #[doc = r#""#]
        #[doc = r#"Once either a "ready" or a "failed" event is received, the client should"#]
        #[doc = r#"destroy the frame."#]
        pub trait ZwlrScreencopyFrameV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_screencopy_frame_v1";
            const VERSION: u32 = 3;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwlr_screencopy_frame_v1#{}.copy()", object.id);
                        self.copy(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwlr_screencopy_frame_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    2 => {
                        tracing::debug!(
                            "zwlr_screencopy_frame_v1#{}.copy_with_damage()",
                            object.id
                        );
                        self.copy_with_damage(
                            object,
                            client,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Copy the frame to the supplied buffer. The buffer must have a the"#]
            #[doc = r#"correct size, see zwlr_screencopy_frame_v1.buffer and"#]
            #[doc = r#"zwlr_screencopy_frame_v1.linux_dmabuf. The buffer needs to have a"#]
            #[doc = r#"supported format."#]
            #[doc = r#""#]
            #[doc = r#"If the frame is successfully copied, a "flags" and a "ready" events are"#]
            #[doc = r#"sent. Otherwise, a "failed" event is sent."#]
            async fn copy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                copy: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Destroys the frame. This request can be sent at any time by the client."#]
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Same as copy, except it waits until there is damage to copy."#]
            async fn copy_with_damage(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                copy_with_damage: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            #[doc = r#"Provides information about wl_shm buffer parameters that need to be"#]
            #[doc = r#"used for this frame. This event is sent once after the frame is created"#]
            #[doc = r#"if wl_shm buffers are supported."#]
            async fn buffer(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                format: super::super::wayland::wl_shm::Format,
                width: u32,
                height: u32,
                stride: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_screencopy_frame_v1#{}.buffer()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(format as u32)
                    .put_uint(width)
                    .put_uint(height)
                    .put_uint(stride)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 0, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Provides flags about the frame. This event is sent once before the"#]
            #[doc = r#""ready" event."#]
            async fn flags(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                flags: Flags,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_screencopy_frame_v1#{}.flags()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(flags.bits())
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 1, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Called as soon as the frame is copied, indicating it is available"#]
            #[doc = r#"for reading. This event includes the time at which presentation happened"#]
            #[doc = r#"at."#]
            #[doc = r#""#]
            #[doc = r#"The timestamp is expressed as tv_sec_hi, tv_sec_lo, tv_nsec triples,"#]
            #[doc = r#"each component being an unsigned 32-bit value. Whole seconds are in"#]
            #[doc = r#"tv_sec which is a 64-bit value combined from tv_sec_hi and tv_sec_lo,"#]
            #[doc = r#"and the additional fractional part in tv_nsec as nanoseconds. Hence,"#]
            #[doc = r#"for valid timestamps tv_nsec must be in [0, 999999999]. The seconds part"#]
            #[doc = r#"may have an arbitrary offset at start."#]
            #[doc = r#""#]
            #[doc = r#"After receiving this event, the client should destroy the object."#]
            async fn ready(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                tv_sec_hi: u32,
                tv_sec_lo: u32,
                tv_nsec: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_screencopy_frame_v1#{}.ready()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(tv_sec_hi)
                    .put_uint(tv_sec_lo)
                    .put_uint(tv_nsec)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 2, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event indicates that the attempted frame copy has failed."#]
            #[doc = r#""#]
            #[doc = r#"After receiving this event, the client should destroy the object."#]
            async fn failed(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_screencopy_frame_v1#{}.failed()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 3, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent right before the ready event when copy_with_damage is"#]
            #[doc = r#"requested. It may be generated multiple times for each copy_with_damage"#]
            #[doc = r#"request."#]
            #[doc = r#""#]
            #[doc = r#"The arguments describe a box around an area that has changed since the"#]
            #[doc = r#"last copy request that was derived from the current screencopy manager"#]
            #[doc = r#"instance."#]
            #[doc = r#""#]
            #[doc = r#"The union of all regions received between the call to copy_with_damage"#]
            #[doc = r#"and a ready event is the total damage since the prior ready event."#]
            async fn damage(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                x: u32,
                y: u32,
                width: u32,
                height: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_screencopy_frame_v1#{}.damage()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(x)
                    .put_uint(y)
                    .put_uint(width)
                    .put_uint(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 4, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"Provides information about linux-dmabuf buffer parameters that need to"#]
            #[doc = r#"be used for this frame. This event is sent once after the frame is"#]
            #[doc = r#"created if linux-dmabuf buffers are supported."#]
            async fn linux_dmabuf(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                format: u32,
                width: u32,
                height: u32,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_screencopy_frame_v1#{}.linux_dmabuf()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new()
                    .put_uint(format)
                    .put_uint(width)
                    .put_uint(height)
                    .build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 5, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
            #[doc = r#"This event is sent once after all buffer events have been sent."#]
            #[doc = r#""#]
            #[doc = r#"The client should proceed to create a buffer of one of the supported"#]
            #[doc = r#"types, and send a "copy" request."#]
            async fn buffer_done(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()> {
                tracing::debug!("-> zwlr_screencopy_frame_v1#{}.buffer_done()", _object.id);
                let (payload, fds) = crate::wire::PayloadBuilder::new().build();
                client
                    .send_message(crate::wire::Message::new(_object.id, 6, payload, fds))
                    .await
                    .map_err(crate::server::error::Error::IoError)
            }
        }
    }
}
pub mod wlr_virtual_pointer_unstable_v1 {
    pub mod zwlr_virtual_pointer_v1 {
        #[repr(u32)]
        #[non_exhaustive]
        #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
        pub enum Error {
            #[doc = r#"Client sent invalid axis enumeration value"#]
            InvalidAxis = 0,
            #[doc = r#"Client sent invalid axis source enumeration value"#]
            InvalidAxisSource = 1,
        }
        impl TryFrom<u32> for Error {
            type Error = crate::wire::DecodeError;

            fn try_from(v: u32) -> Result<Self, Self::Error> {
                match v {
                    0 => Ok(Self::InvalidAxis),
                    1 => Ok(Self::InvalidAxisSource),
                    _ => Err(crate::wire::DecodeError::MalformedPayload),
                }
            }
        }
        #[doc = r#"This protocol allows clients to emulate a physical pointer device. The"#]
        #[doc = r#"requests are mostly mirror opposites of those specified in wl_pointer."#]
        pub trait ZwlrVirtualPointerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_virtual_pointer_v1";
            const VERSION: u32 = 2;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.motion()", object.id);
                        self.motion(
                            object,
                            client,
                            message.uint()?,
                            message.fixed()?,
                            message.fixed()?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.motion_absolute()", object.id);
                        self.motion_absolute(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?,
                        )
                        .await
                    }
                    2 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.button()", object.id);
                        self.button(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?,
                            message.uint()?.try_into()?,
                        )
                        .await
                    }
                    3 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.axis()", object.id);
                        self.axis(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?.try_into()?,
                            message.fixed()?,
                        )
                        .await
                    }
                    4 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.frame()", object.id);
                        self.frame(object, client).await
                    }
                    5 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.axis_source()", object.id);
                        self.axis_source(object, client, message.uint()?.try_into()?)
                            .await
                    }
                    6 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.axis_stop()", object.id);
                        self.axis_stop(object, client, message.uint()?, message.uint()?.try_into()?)
                            .await
                    }
                    7 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.axis_discrete()", object.id);
                        self.axis_discrete(
                            object,
                            client,
                            message.uint()?,
                            message.uint()?.try_into()?,
                            message.fixed()?,
                            message.int()?,
                        )
                        .await
                    }
                    8 => {
                        tracing::debug!("zwlr_virtual_pointer_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"The pointer has moved by a relative amount to the previous request."#]
            #[doc = r#""#]
            #[doc = r#"Values are in the global compositor space."#]
            async fn motion(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                motion: u32,
                motion: crate::wire::Fixed,
                motion: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            #[doc = r#"The pointer has moved in an absolute coordinate frame."#]
            #[doc = r#""#]
            #[doc = r#"Value of x can range from 0 to x_extent, value of y can range from 0"#]
            #[doc = r#"to y_extent."#]
            async fn motion_absolute(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                motion_absolute: u32,
                motion_absolute: u32,
                motion_absolute: u32,
                motion_absolute: u32,
                motion_absolute: u32,
            ) -> crate::server::Result<()>;
            #[doc = r#"A button was pressed or released."#]
            async fn button(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                button: u32,
                button: u32,
                button: super::super::wayland::wl_pointer::ButtonState,
            ) -> crate::server::Result<()>;
            #[doc = r#"Scroll and other axis requests."#]
            async fn axis(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                axis: u32,
                axis: super::super::wayland::wl_pointer::Axis,
                axis: crate::wire::Fixed,
            ) -> crate::server::Result<()>;
            #[doc = r#"Indicates the set of events that logically belong together."#]
            async fn frame(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Source information for scroll and other axis."#]
            async fn axis_source(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                axis_source: super::super::wayland::wl_pointer::AxisSource,
            ) -> crate::server::Result<()>;
            #[doc = r#"Stop notification for scroll and other axes."#]
            async fn axis_stop(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                axis_stop: u32,
                axis_stop: super::super::wayland::wl_pointer::Axis,
            ) -> crate::server::Result<()>;
            #[doc = r#"Discrete step information for scroll and other axes."#]
            #[doc = r#""#]
            #[doc = r#"This event allows the client to extend data normally sent using the axis"#]
            #[doc = r#"event with discrete value."#]
            async fn axis_discrete(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                axis_discrete: u32,
                axis_discrete: super::super::wayland::wl_pointer::Axis,
                axis_discrete: crate::wire::Fixed,
                axis_discrete: i32,
            ) -> crate::server::Result<()>;
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
        }
    }
    pub mod zwlr_virtual_pointer_manager_v1 {
        #[doc = r#"This object allows clients to create individual virtual pointer objects."#]
        pub trait ZwlrVirtualPointerManagerV1: crate::server::Dispatcher {
            const INTERFACE: &'static str = "zwlr_virtual_pointer_manager_v1";
            const VERSION: u32 = 2;

            fn into_object(self, id: crate::wire::ObjectId) -> crate::server::Object
            where
                Self: Sized,
            {
                crate::server::Object::new(id, self)
            }

            async fn handle_request(
                &self,
                object: &crate::server::Object,
                client: &mut crate::server::Client,
                message: &mut crate::wire::Message,
            ) -> crate::server::Result<()> {
                match message.opcode {
                    0 => {
                        tracing::debug!(
                            "zwlr_virtual_pointer_manager_v1#{}.create_virtual_pointer()",
                            object.id
                        );
                        self.create_virtual_pointer(
                            object,
                            client,
                            message.object()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    1 => {
                        tracing::debug!("zwlr_virtual_pointer_manager_v1#{}.destroy()", object.id);
                        self.destroy(object, client).await
                    }
                    2 => {
                        tracing::debug!("zwlr_virtual_pointer_manager_v1#{}.create_virtual_pointer_with_output()", object.id);
                        self.create_virtual_pointer_with_output(
                            object,
                            client,
                            message.object()?,
                            message.object()?,
                            message
                                .object()?
                                .ok_or(crate::wire::DecodeError::MalformedPayload)?,
                        )
                        .await
                    }
                    _ => Err(crate::server::error::Error::UnknownOpcode),
                }
            }
            #[doc = r#"Creates a new virtual pointer. The optional seat is a suggestion to the"#]
            #[doc = r#"compositor."#]
            async fn create_virtual_pointer(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create_virtual_pointer: Option<crate::wire::ObjectId>,
                create_virtual_pointer: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
            async fn destroy(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
            ) -> crate::server::Result<()>;
            #[doc = r#"Creates a new virtual pointer. The seat and the output arguments are"#]
            #[doc = r#"optional. If the seat argument is set, the compositor should assign the"#]
            #[doc = r#"input device to the requested seat. If the output argument is set, the"#]
            #[doc = r#"compositor should map the input device to the requested output."#]
            async fn create_virtual_pointer_with_output(
                &self,
                _object: &crate::server::Object,
                client: &mut crate::server::Client,
                create_virtual_pointer_with_output: Option<crate::wire::ObjectId>,
                create_virtual_pointer_with_output: Option<crate::wire::ObjectId>,
                create_virtual_pointer_with_output: crate::wire::ObjectId,
            ) -> crate::server::Result<()>;
        }
    }
}
